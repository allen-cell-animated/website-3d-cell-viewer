/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@aics/volume-viewer/es/workers/FetchZarrWorker.js":
/*!************************************************************************!*\
  !*** ./node_modules/@aics/volume-viewer/es/workers/FetchZarrWorker.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var zarr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zarr */ \"./node_modules/zarr/zarr.mjs\");\n\n\nfunction convertChannel(channelData, nx, ny, nz, dtype, downsampleZ) {\n  var nresultpixels = nx * ny * Math.ceil(nz / downsampleZ);\n  var u8 = new Uint8Array(nresultpixels);\n  var xy = nx * ny;\n\n  if (dtype === \"|u1\") {\n    // flatten the 3d array and convert to uint8\n    // todo test perf with a loop over x,y,z instead\n    for (var z = 0, slice = 0; z < nz; z += downsampleZ, ++slice) {\n      for (var j = 0; j < xy; ++j) {\n        var yrow = Math.floor(j / nx);\n        var xcol = j % nx;\n        u8[j + slice * xy] = channelData[z][yrow][xcol];\n      }\n    }\n  } else {\n    var chmin = channelData[0][0][0];\n    var chmax = channelData[0][0][0]; // find min and max (only of data we are sampling?)\n\n    for (var _z = 0; _z < nz; _z += downsampleZ) {\n      for (var _j = 0; _j < xy; ++_j) {\n        var _yrow = Math.floor(_j / nx);\n\n        var _xcol = _j % nx;\n\n        var val = channelData[_z][_yrow][_xcol];\n\n        if (val < chmin) {\n          chmin = val;\n        }\n\n        if (val > chmax) {\n          chmax = val;\n        }\n      }\n    } // flatten the 3d array and convert to uint8\n\n\n    for (var _z2 = 0, _slice = 0; _z2 < nz; _z2 += downsampleZ, ++_slice) {\n      for (var _j2 = 0; _j2 < xy; ++_j2) {\n        var _yrow2 = Math.floor(_j2 / nx);\n\n        var _xcol2 = _j2 % nx;\n\n        u8[_j2 + _slice * xy] = (channelData[_z2][_yrow2][_xcol2] - chmin) / (chmax - chmin) * 255;\n      }\n    }\n  }\n\n  return u8;\n}\n\nself.onmessage = function (e) {\n  var time = e.data.time;\n  var channelIndex = e.data.channel;\n  var downsampleZ = e.data.downsampleZ;\n  var store = new zarr__WEBPACK_IMPORTED_MODULE_0__.HTTPStore(e.data.urlStore);\n  (0,zarr__WEBPACK_IMPORTED_MODULE_0__.openArray)({\n    store: store,\n    path: e.data.path,\n    mode: \"r\"\n  }).then(function (level) {\n    // build slice spec\n    // assuming ZYX are the last three dimensions:\n    var sliceSpec = [null, null, null];\n\n    if (channelIndex > -1) {\n      sliceSpec.unshift(channelIndex);\n    }\n\n    if (time > -1) {\n      sliceSpec.unshift(time);\n    }\n\n    return level.get(sliceSpec);\n  }).then(function (channel) {\n    channel = channel;\n    var nz = channel.shape[0];\n    var ny = channel.shape[1];\n    var nx = channel.shape[2];\n    var u8 = convertChannel(channel.data, nx, ny, nz, channel.dtype, downsampleZ);\n    var results = {\n      data: u8,\n      channel: channelIndex === -1 ? 0 : channelIndex\n    };\n    postMessage(results, [results.data.buffer]);\n  });\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFpY3Mvdm9sdW1lLXZpZXdlci9lcy93b3JrZXJzL0ZldGNoWmFycldvcmtlci5qcy5qcyIsIm1hcHBpbmdzIjoiOztBQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkMsc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHNDQUFzQzs7QUFFdEMscUJBQXFCLFNBQVM7QUFDOUIsdUJBQXVCLFNBQVM7QUFDaEM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR04sa0NBQWtDLFVBQVU7QUFDNUMsd0JBQXdCLFVBQVU7QUFDbEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBUztBQUMzQixFQUFFLCtDQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFpY3Mvd2ViLTNkLXZpZXdlci8uL25vZGVfbW9kdWxlcy9AYWljcy92b2x1bWUtdmlld2VyL2VzL3dvcmtlcnMvRmV0Y2haYXJyV29ya2VyLmpzP2VkNDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSFRUUFN0b3JlLCBvcGVuQXJyYXkgfSBmcm9tIFwiemFyclwiO1xuXG5mdW5jdGlvbiBjb252ZXJ0Q2hhbm5lbChjaGFubmVsRGF0YSwgbngsIG55LCBueiwgZHR5cGUsIGRvd25zYW1wbGVaKSB7XG4gIHZhciBucmVzdWx0cGl4ZWxzID0gbnggKiBueSAqIE1hdGguY2VpbChueiAvIGRvd25zYW1wbGVaKTtcbiAgdmFyIHU4ID0gbmV3IFVpbnQ4QXJyYXkobnJlc3VsdHBpeGVscyk7XG4gIHZhciB4eSA9IG54ICogbnk7XG5cbiAgaWYgKGR0eXBlID09PSBcInx1MVwiKSB7XG4gICAgLy8gZmxhdHRlbiB0aGUgM2QgYXJyYXkgYW5kIGNvbnZlcnQgdG8gdWludDhcbiAgICAvLyB0b2RvIHRlc3QgcGVyZiB3aXRoIGEgbG9vcCBvdmVyIHgseSx6IGluc3RlYWRcbiAgICBmb3IgKHZhciB6ID0gMCwgc2xpY2UgPSAwOyB6IDwgbno7IHogKz0gZG93bnNhbXBsZVosICsrc2xpY2UpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgeHk7ICsraikge1xuICAgICAgICB2YXIgeXJvdyA9IE1hdGguZmxvb3IoaiAvIG54KTtcbiAgICAgICAgdmFyIHhjb2wgPSBqICUgbng7XG4gICAgICAgIHU4W2ogKyBzbGljZSAqIHh5XSA9IGNoYW5uZWxEYXRhW3pdW3lyb3ddW3hjb2xdO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY2htaW4gPSBjaGFubmVsRGF0YVswXVswXVswXTtcbiAgICB2YXIgY2htYXggPSBjaGFubmVsRGF0YVswXVswXVswXTsgLy8gZmluZCBtaW4gYW5kIG1heCAob25seSBvZiBkYXRhIHdlIGFyZSBzYW1wbGluZz8pXG5cbiAgICBmb3IgKHZhciBfeiA9IDA7IF96IDwgbno7IF96ICs9IGRvd25zYW1wbGVaKSB7XG4gICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgeHk7ICsrX2opIHtcbiAgICAgICAgdmFyIF95cm93ID0gTWF0aC5mbG9vcihfaiAvIG54KTtcblxuICAgICAgICB2YXIgX3hjb2wgPSBfaiAlIG54O1xuXG4gICAgICAgIHZhciB2YWwgPSBjaGFubmVsRGF0YVtfel1bX3lyb3ddW194Y29sXTtcblxuICAgICAgICBpZiAodmFsIDwgY2htaW4pIHtcbiAgICAgICAgICBjaG1pbiA9IHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgPiBjaG1heCkge1xuICAgICAgICAgIGNobWF4ID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBmbGF0dGVuIHRoZSAzZCBhcnJheSBhbmQgY29udmVydCB0byB1aW50OFxuXG5cbiAgICBmb3IgKHZhciBfejIgPSAwLCBfc2xpY2UgPSAwOyBfejIgPCBuejsgX3oyICs9IGRvd25zYW1wbGVaLCArK19zbGljZSkge1xuICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgeHk7ICsrX2oyKSB7XG4gICAgICAgIHZhciBfeXJvdzIgPSBNYXRoLmZsb29yKF9qMiAvIG54KTtcblxuICAgICAgICB2YXIgX3hjb2wyID0gX2oyICUgbng7XG5cbiAgICAgICAgdThbX2oyICsgX3NsaWNlICogeHldID0gKGNoYW5uZWxEYXRhW196Ml1bX3lyb3cyXVtfeGNvbDJdIC0gY2htaW4pIC8gKGNobWF4IC0gY2htaW4pICogMjU1O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1ODtcbn1cblxuc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICB2YXIgdGltZSA9IGUuZGF0YS50aW1lO1xuICB2YXIgY2hhbm5lbEluZGV4ID0gZS5kYXRhLmNoYW5uZWw7XG4gIHZhciBkb3duc2FtcGxlWiA9IGUuZGF0YS5kb3duc2FtcGxlWjtcbiAgdmFyIHN0b3JlID0gbmV3IEhUVFBTdG9yZShlLmRhdGEudXJsU3RvcmUpO1xuICBvcGVuQXJyYXkoe1xuICAgIHN0b3JlOiBzdG9yZSxcbiAgICBwYXRoOiBlLmRhdGEucGF0aCxcbiAgICBtb2RlOiBcInJcIlxuICB9KS50aGVuKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgIC8vIGJ1aWxkIHNsaWNlIHNwZWNcbiAgICAvLyBhc3N1bWluZyBaWVggYXJlIHRoZSBsYXN0IHRocmVlIGRpbWVuc2lvbnM6XG4gICAgdmFyIHNsaWNlU3BlYyA9IFtudWxsLCBudWxsLCBudWxsXTtcblxuICAgIGlmIChjaGFubmVsSW5kZXggPiAtMSkge1xuICAgICAgc2xpY2VTcGVjLnVuc2hpZnQoY2hhbm5lbEluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAodGltZSA+IC0xKSB7XG4gICAgICBzbGljZVNwZWMudW5zaGlmdCh0aW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGV2ZWwuZ2V0KHNsaWNlU3BlYyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICBjaGFubmVsID0gY2hhbm5lbDtcbiAgICB2YXIgbnogPSBjaGFubmVsLnNoYXBlWzBdO1xuICAgIHZhciBueSA9IGNoYW5uZWwuc2hhcGVbMV07XG4gICAgdmFyIG54ID0gY2hhbm5lbC5zaGFwZVsyXTtcbiAgICB2YXIgdTggPSBjb252ZXJ0Q2hhbm5lbChjaGFubmVsLmRhdGEsIG54LCBueSwgbnosIGNoYW5uZWwuZHR5cGUsIGRvd25zYW1wbGVaKTtcbiAgICB2YXIgcmVzdWx0cyA9IHtcbiAgICAgIGRhdGE6IHU4LFxuICAgICAgY2hhbm5lbDogY2hhbm5lbEluZGV4ID09PSAtMSA/IDAgOiBjaGFubmVsSW5kZXhcbiAgICB9O1xuICAgIHBvc3RNZXNzYWdlKHJlc3VsdHMsIFtyZXN1bHRzLmRhdGEuYnVmZmVyXSk7XG4gIH0pO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@aics/volume-viewer/es/workers/FetchZarrWorker.js\n");

/***/ }),

/***/ "./node_modules/zarr/core.mjs":
/*!************************************!*\
  !*** ./node_modules/zarr/core.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ArrayNotFoundError\": () => (/* binding */ ArrayNotFoundError),\n/* harmony export */   \"BoundsCheckError\": () => (/* binding */ BoundsCheckError),\n/* harmony export */   \"ContainsArrayError\": () => (/* binding */ ContainsArrayError),\n/* harmony export */   \"ContainsGroupError\": () => (/* binding */ ContainsGroupError),\n/* harmony export */   \"Group\": () => (/* binding */ Group),\n/* harmony export */   \"GroupNotFoundError\": () => (/* binding */ GroupNotFoundError),\n/* harmony export */   \"HTTPError\": () => (/* binding */ HTTPError),\n/* harmony export */   \"HTTPStore\": () => (/* binding */ HTTPStore),\n/* harmony export */   \"InvalidSliceError\": () => (/* binding */ InvalidSliceError),\n/* harmony export */   \"KeyError\": () => (/* binding */ KeyError),\n/* harmony export */   \"MemoryStore\": () => (/* binding */ MemoryStore),\n/* harmony export */   \"NegativeStepError\": () => (/* binding */ NegativeStepError),\n/* harmony export */   \"NestedArray\": () => (/* binding */ NestedArray),\n/* harmony export */   \"ObjectStore\": () => (/* binding */ ObjectStore),\n/* harmony export */   \"PathNotFoundError\": () => (/* binding */ PathNotFoundError),\n/* harmony export */   \"PermissionError\": () => (/* binding */ PermissionError),\n/* harmony export */   \"TooManyIndicesError\": () => (/* binding */ TooManyIndicesError),\n/* harmony export */   \"ValueError\": () => (/* binding */ ValueError),\n/* harmony export */   \"ZarrArray\": () => (/* binding */ ZarrArray),\n/* harmony export */   \"addCodec\": () => (/* binding */ addCodec),\n/* harmony export */   \"array\": () => (/* binding */ array),\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"createProxy\": () => (/* binding */ createProxy),\n/* harmony export */   \"empty\": () => (/* binding */ empty),\n/* harmony export */   \"full\": () => (/* binding */ full),\n/* harmony export */   \"getCodec\": () => (/* binding */ getCodec),\n/* harmony export */   \"getTypedArrayCtr\": () => (/* binding */ getTypedArrayCtr),\n/* harmony export */   \"getTypedArrayDtypeString\": () => (/* binding */ getTypedArrayDtypeString),\n/* harmony export */   \"group\": () => (/* binding */ group),\n/* harmony export */   \"isKeyError\": () => (/* binding */ isKeyError),\n/* harmony export */   \"normalizeStoreArgument\": () => (/* binding */ normalizeStoreArgument),\n/* harmony export */   \"ones\": () => (/* binding */ ones),\n/* harmony export */   \"openArray\": () => (/* binding */ openArray),\n/* harmony export */   \"openGroup\": () => (/* binding */ openGroup),\n/* harmony export */   \"rangeTypedArray\": () => (/* binding */ rangeTypedArray),\n/* harmony export */   \"slice\": () => (/* binding */ slice),\n/* harmony export */   \"sliceIndices\": () => (/* binding */ sliceIndices),\n/* harmony export */   \"zeros\": () => (/* binding */ zeros)\n/* harmony export */ });\nconst registry = new Map();\r\nfunction addCodec(id, importFn) {\r\n    registry.set(id, importFn);\r\n}\r\nasync function getCodec(config) {\r\n    if (!registry.has(config.id)) {\r\n        throw new Error(`Compression codec ${config.id} is not supported by Zarr.js yet.`);\r\n    }\r\n    /* eslint-disable @typescript-eslint/no-non-null-assertion */\r\n    const codec = await registry.get(config.id)();\r\n    return codec.fromConfig(config);\r\n}\n\nfunction createProxy(mapping) {\r\n    return new Proxy(mapping, {\r\n        set(target, key, value, _receiver) {\r\n            return target.setItem(key, value);\r\n        },\r\n        get(target, key, _receiver) {\r\n            return target.getItem(key);\r\n        },\r\n        deleteProperty(target, key) {\r\n            return target.deleteItem(key);\r\n        },\r\n        has(target, key) {\r\n            return target.containsItem(key);\r\n        }\r\n    });\r\n}\n\nfunction isZarrError(err) {\r\n    return typeof err === 'object' && err !== null && '__zarr__' in err;\r\n}\r\nfunction isKeyError(o) {\r\n    return isZarrError(o) && o.__zarr__ === 'KeyError';\r\n}\r\n// Custom error messages, note we have to patch the prototype of the\r\n// errors to fix `instanceof` calls, see:\r\n// https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\nclass ContainsArrayError extends Error {\r\n    constructor(path) {\r\n        super(`path ${path} contains an array`);\r\n        this.__zarr__ = 'ContainsArrayError';\r\n        Object.setPrototypeOf(this, ContainsArrayError.prototype);\r\n    }\r\n}\r\nclass ContainsGroupError extends Error {\r\n    constructor(path) {\r\n        super(`path ${path} contains a group`);\r\n        this.__zarr__ = 'ContainsGroupError';\r\n        Object.setPrototypeOf(this, ContainsGroupError.prototype);\r\n    }\r\n}\r\nclass ArrayNotFoundError extends Error {\r\n    constructor(path) {\r\n        super(`array not found at path ${path}`);\r\n        this.__zarr__ = 'ArrayNotFoundError';\r\n        Object.setPrototypeOf(this, ArrayNotFoundError.prototype);\r\n    }\r\n}\r\nclass GroupNotFoundError extends Error {\r\n    constructor(path) {\r\n        super(`ground not found at path ${path}`);\r\n        this.__zarr__ = 'GroupNotFoundError';\r\n        Object.setPrototypeOf(this, GroupNotFoundError.prototype);\r\n    }\r\n}\r\nclass PathNotFoundError extends Error {\r\n    constructor(path) {\r\n        super(`nothing not found at path ${path}`);\r\n        this.__zarr__ = 'PathNotFoundError';\r\n        Object.setPrototypeOf(this, PathNotFoundError.prototype);\r\n    }\r\n}\r\nclass PermissionError extends Error {\r\n    constructor(message) {\r\n        super(message);\r\n        this.__zarr__ = 'PermissionError';\r\n        Object.setPrototypeOf(this, PermissionError.prototype);\r\n    }\r\n}\r\nclass KeyError extends Error {\r\n    constructor(key) {\r\n        super(`key ${key} not present`);\r\n        this.__zarr__ = 'KeyError';\r\n        Object.setPrototypeOf(this, KeyError.prototype);\r\n    }\r\n}\r\nclass TooManyIndicesError extends RangeError {\r\n    constructor(selection, shape) {\r\n        super(`too many indices for array; expected ${shape.length}, got ${selection.length}`);\r\n        this.__zarr__ = 'TooManyIndicesError';\r\n        Object.setPrototypeOf(this, TooManyIndicesError.prototype);\r\n    }\r\n}\r\nclass BoundsCheckError extends RangeError {\r\n    constructor(message) {\r\n        super(message);\r\n        this.__zarr__ = 'BoundsCheckError';\r\n        Object.setPrototypeOf(this, BoundsCheckError.prototype);\r\n    }\r\n}\r\nclass InvalidSliceError extends RangeError {\r\n    constructor(from, to, stepSize, reason) {\r\n        super(`slice arguments slice(${from}, ${to}, ${stepSize}) invalid: ${reason}`);\r\n        this.__zarr__ = 'InvalidSliceError';\r\n        Object.setPrototypeOf(this, InvalidSliceError.prototype);\r\n    }\r\n}\r\nclass NegativeStepError extends Error {\r\n    constructor() {\r\n        super(`Negative step size is not supported when indexing.`);\r\n        this.__zarr__ = 'NegativeStepError';\r\n        Object.setPrototypeOf(this, NegativeStepError.prototype);\r\n    }\r\n}\r\nclass ValueError extends Error {\r\n    constructor(message) {\r\n        super(message);\r\n        this.__zarr__ = 'ValueError';\r\n        Object.setPrototypeOf(this, ValueError.prototype);\r\n    }\r\n}\r\nclass HTTPError extends Error {\r\n    constructor(code) {\r\n        super(code);\r\n        this.__zarr__ = 'HTTPError';\r\n        Object.setPrototypeOf(this, HTTPError.prototype);\r\n    }\r\n}\n\nfunction slice(start, stop = undefined, step = null) {\r\n    // tslint:disable-next-line: strict-type-predicates\r\n    if (start === undefined) { // Not possible in typescript\r\n        throw new InvalidSliceError(start, stop, step, \"The first argument must not be undefined\");\r\n    }\r\n    if ((typeof start === \"string\" && start !== \":\") || (typeof stop === \"string\" && stop !== \":\")) { // Note in typescript this will never happen with type checking.\r\n        throw new InvalidSliceError(start, stop, step, \"Arguments can only be integers, \\\":\\\" or null\");\r\n    }\r\n    // slice(5) === slice(null, 5)\r\n    if (stop === undefined) {\r\n        stop = start;\r\n        start = null;\r\n    }\r\n    // if (start !== null && stop !== null && start > stop) {\r\n    //     throw new InvalidSliceError(start, stop, step, \"to is higher than from\");\r\n    // }\r\n    return {\r\n        start: start === \":\" ? null : start,\r\n        stop: stop === \":\" ? null : stop,\r\n        step,\r\n        _slice: true,\r\n    };\r\n}\r\n/**\r\n * Port of adjustIndices\r\n * https://github.com/python/cpython/blob/master/Objects/sliceobject.c#L243\r\n */\r\nfunction adjustIndices(start, stop, step, length) {\r\n    if (start < 0) {\r\n        start += length;\r\n        if (start < 0) {\r\n            start = (step < 0) ? -1 : 0;\r\n        }\r\n    }\r\n    else if (start >= length) {\r\n        start = (step < 0) ? length - 1 : length;\r\n    }\r\n    if (stop < 0) {\r\n        stop += length;\r\n        if (stop < 0) {\r\n            stop = (step < 0) ? -1 : 0;\r\n        }\r\n    }\r\n    else if (stop >= length) {\r\n        stop = (step < 0) ? length - 1 : length;\r\n    }\r\n    if (step < 0) {\r\n        if (stop < start) {\r\n            const length = Math.floor((start - stop - 1) / (-step) + 1);\r\n            return [start, stop, step, length];\r\n        }\r\n    }\r\n    else {\r\n        if (start < stop) {\r\n            const length = Math.floor((stop - start - 1) / step + 1);\r\n            return [start, stop, step, length];\r\n        }\r\n    }\r\n    return [start, stop, step, 0];\r\n}\r\n/**\r\n * Port of slice.indices(n) and PySlice_Unpack\r\n * https://github.com/python/cpython/blob/master/Objects/sliceobject.c#L166\r\n *  https://github.com/python/cpython/blob/master/Objects/sliceobject.c#L198\r\n *\r\n * Behaviour might be slightly different as it's a weird hybrid implementation.\r\n */\r\nfunction sliceIndices(slice, length) {\r\n    let start;\r\n    let stop;\r\n    let step;\r\n    if (slice.step === null) {\r\n        step = 1;\r\n    }\r\n    else {\r\n        step = slice.step;\r\n    }\r\n    if (slice.start === null) {\r\n        start = step < 0 ? Number.MAX_SAFE_INTEGER : 0;\r\n    }\r\n    else {\r\n        start = slice.start;\r\n        if (start < 0) {\r\n            start += length;\r\n        }\r\n    }\r\n    if (slice.stop === null) {\r\n        stop = step < 0 ? -Number.MAX_SAFE_INTEGER : Number.MAX_SAFE_INTEGER;\r\n    }\r\n    else {\r\n        stop = slice.stop;\r\n        if (stop < 0) {\r\n            stop += length;\r\n        }\r\n    }\r\n    // This clips out of bounds slices\r\n    const s = adjustIndices(start, stop, step, length);\r\n    start = s[0];\r\n    stop = s[1];\r\n    step = s[2];\r\n    // The output length\r\n    length = s[3];\r\n    // With out of bounds slicing these two assertions are not useful.\r\n    // if (stop > length) throw new Error(\"Stop greater than length\");\r\n    // if (start >= length) throw new Error(\"Start greater than or equal to length\");\r\n    if (step === 0)\r\n        throw new Error(\"Step size 0 is invalid\");\r\n    return [start, stop, step, length];\r\n}\n\nfunction ensureArray(selection) {\r\n    if (!Array.isArray(selection)) {\r\n        return [selection];\r\n    }\r\n    return selection;\r\n}\r\nfunction checkSelectionLength(selection, shape) {\r\n    if (selection.length > shape.length) {\r\n        throw new TooManyIndicesError(selection, shape);\r\n    }\r\n}\r\n/**\r\n * Returns both the sliceIndices per dimension and the output shape after slicing.\r\n */\r\nfunction selectionToSliceIndices(selection, shape) {\r\n    const sliceIndicesResult = [];\r\n    const outShape = [];\r\n    for (let i = 0; i < selection.length; i++) {\r\n        const s = selection[i];\r\n        if (typeof s === \"number\") {\r\n            sliceIndicesResult.push(s);\r\n        }\r\n        else {\r\n            const x = sliceIndices(s, shape[i]);\r\n            const dimLength = x[3];\r\n            outShape.push(dimLength);\r\n            sliceIndicesResult.push(x);\r\n        }\r\n    }\r\n    return [sliceIndicesResult, outShape];\r\n}\r\n/**\r\n * This translates \"...\", \":\", null into a list of slices or non-negative integer selections of length shape\r\n */\r\nfunction normalizeArraySelection(selection, shape, convertIntegerSelectionToSlices = false) {\r\n    selection = replaceEllipsis(selection, shape);\r\n    for (let i = 0; i < selection.length; i++) {\r\n        const dimSelection = selection[i];\r\n        if (typeof dimSelection === \"number\") {\r\n            if (convertIntegerSelectionToSlices) {\r\n                selection[i] = slice(dimSelection, dimSelection + 1, 1);\r\n            }\r\n            else {\r\n                selection[i] = normalizeIntegerSelection(dimSelection, shape[i]);\r\n            }\r\n        }\r\n        else if (isIntegerArray(dimSelection)) {\r\n            throw new TypeError(\"Integer array selections are not supported (yet)\");\r\n        }\r\n        else if (dimSelection === \":\" || dimSelection === null) {\r\n            selection[i] = slice(null, null, 1);\r\n        }\r\n    }\r\n    return selection;\r\n}\r\nfunction replaceEllipsis(selection, shape) {\r\n    selection = ensureArray(selection);\r\n    let ellipsisIndex = -1;\r\n    let numEllipsis = 0;\r\n    for (let i = 0; i < selection.length; i++) {\r\n        if (selection[i] === \"...\") {\r\n            ellipsisIndex = i;\r\n            numEllipsis += 1;\r\n        }\r\n    }\r\n    if (numEllipsis > 1) {\r\n        throw new RangeError(\"an index can only have a single ellipsis ('...')\");\r\n    }\r\n    if (numEllipsis === 1) {\r\n        // count how many items to left and right of ellipsis\r\n        const numItemsLeft = ellipsisIndex;\r\n        const numItemsRight = selection.length - (numItemsLeft + 1);\r\n        const numItems = selection.length - 1; // All non-ellipsis items\r\n        if (numItems >= shape.length) {\r\n            // Ellipsis does nothing, just remove it\r\n            selection = selection.filter((x) => x !== \"...\");\r\n        }\r\n        else {\r\n            // Replace ellipsis with as many slices are needed for number of dims\r\n            const numNewItems = shape.length - numItems;\r\n            let newItem = selection.slice(0, numItemsLeft).concat(new Array(numNewItems).fill(null));\r\n            if (numItemsRight > 0) {\r\n                newItem = newItem.concat(selection.slice(selection.length - numItemsRight));\r\n            }\r\n            selection = newItem;\r\n        }\r\n    }\r\n    // Fill out selection if not completely specified\r\n    if (selection.length < shape.length) {\r\n        const numMissing = shape.length - selection.length;\r\n        selection = selection.concat(new Array(numMissing).fill(null));\r\n    }\r\n    checkSelectionLength(selection, shape);\r\n    return selection;\r\n}\r\nfunction normalizeIntegerSelection(dimSelection, dimLength) {\r\n    // Note: Maybe we should convert to integer or warn if dimSelection is not an integer\r\n    // handle wraparound\r\n    if (dimSelection < 0) {\r\n        dimSelection = dimLength + dimSelection;\r\n    }\r\n    // handle out of bounds\r\n    if (dimSelection >= dimLength || dimSelection < 0) {\r\n        throw new BoundsCheckError(`index out of bounds for dimension with length ${dimLength}`);\r\n    }\r\n    return dimSelection;\r\n}\r\nfunction isInteger(s) {\r\n    return typeof s === \"number\";\r\n}\r\nfunction isIntegerArray(s) {\r\n    if (!Array.isArray(s)) {\r\n        return false;\r\n    }\r\n    for (const e of s) {\r\n        if (typeof e !== \"number\") {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction isSlice(s) {\r\n    if (s !== null && s[\"_slice\"] === true) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfunction isContiguousSlice(s) {\r\n    return isSlice(s) && (s.step === null || s.step === 1);\r\n}\r\nfunction isContiguousSelection(selection) {\r\n    selection = ensureArray(selection);\r\n    for (let i = 0; i < selection.length; i++) {\r\n        const s = selection[i];\r\n        if (!(isIntegerArray(s) || isContiguousSlice(s) || s === \"...\")) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction* product(...iterables) {\r\n    if (iterables.length === 0) {\r\n        return;\r\n    }\r\n    // make a list of iterators from the iterables\r\n    const iterators = iterables.map(it => it());\r\n    const results = iterators.map(it => it.next());\r\n    // Disabled to allow empty inputs\r\n    // if (results.some(r => r.done)) {\r\n    //     throw new Error(\"Input contains an empty iterator.\");\r\n    // }\r\n    for (let i = 0;;) {\r\n        if (results[i].done) {\r\n            // reset the current iterator\r\n            iterators[i] = iterables[i]();\r\n            results[i] = iterators[i].next();\r\n            // advance, and exit if we've reached the end\r\n            if (++i >= iterators.length) {\r\n                return;\r\n            }\r\n        }\r\n        else {\r\n            yield results.map(({ value }) => value);\r\n            i = 0;\r\n        }\r\n        results[i] = iterators[i].next();\r\n    }\r\n}\r\nclass BasicIndexer {\r\n    constructor(selection, array) {\r\n        selection = normalizeArraySelection(selection, array.shape);\r\n        // Setup per-dimension indexers\r\n        this.dimIndexers = [];\r\n        const arrayShape = array.shape;\r\n        for (let i = 0; i < arrayShape.length; i++) {\r\n            let dimSelection = selection[i];\r\n            const dimLength = arrayShape[i];\r\n            const dimChunkLength = array.chunks[i];\r\n            if (dimSelection === null) {\r\n                dimSelection = slice(null);\r\n            }\r\n            if (isInteger(dimSelection)) {\r\n                this.dimIndexers.push(new IntDimIndexer(dimSelection, dimLength, dimChunkLength));\r\n            }\r\n            else if (isSlice(dimSelection)) {\r\n                this.dimIndexers.push(new SliceDimIndexer(dimSelection, dimLength, dimChunkLength));\r\n            }\r\n            else {\r\n                throw new RangeError(`Unspported selection item for basic indexing; expected integer or slice, got ${dimSelection}`);\r\n            }\r\n        }\r\n        this.shape = [];\r\n        for (const d of this.dimIndexers) {\r\n            if (d instanceof SliceDimIndexer) {\r\n                this.shape.push(d.numItems);\r\n            }\r\n        }\r\n        this.dropAxes = null;\r\n    }\r\n    *iter() {\r\n        const dimIndexerIterables = this.dimIndexers.map(x => (() => x.iter()));\r\n        const dimIndexerProduct = product(...dimIndexerIterables);\r\n        for (const dimProjections of dimIndexerProduct) {\r\n            // TODO fix this, I think the product outputs too many combinations\r\n            const chunkCoords = [];\r\n            const chunkSelection = [];\r\n            const outSelection = [];\r\n            for (const p of dimProjections) {\r\n                chunkCoords.push((p).dimChunkIndex);\r\n                chunkSelection.push((p).dimChunkSelection);\r\n                if ((p).dimOutSelection !== null) {\r\n                    outSelection.push((p).dimOutSelection);\r\n                }\r\n            }\r\n            yield {\r\n                chunkCoords,\r\n                chunkSelection,\r\n                outSelection,\r\n            };\r\n        }\r\n    }\r\n}\r\nclass IntDimIndexer {\r\n    constructor(dimSelection, dimLength, dimChunkLength) {\r\n        dimSelection = normalizeIntegerSelection(dimSelection, dimLength);\r\n        this.dimSelection = dimSelection;\r\n        this.dimLength = dimLength;\r\n        this.dimChunkLength = dimChunkLength;\r\n        this.numItems = 1;\r\n    }\r\n    *iter() {\r\n        const dimChunkIndex = Math.floor(this.dimSelection / this.dimChunkLength);\r\n        const dimOffset = dimChunkIndex * this.dimChunkLength;\r\n        const dimChunkSelection = this.dimSelection - dimOffset;\r\n        const dimOutSelection = null;\r\n        yield {\r\n            dimChunkIndex,\r\n            dimChunkSelection,\r\n            dimOutSelection,\r\n        };\r\n    }\r\n}\r\nclass SliceDimIndexer {\r\n    constructor(dimSelection, dimLength, dimChunkLength) {\r\n        // Normalize\r\n        const [start, stop, step] = sliceIndices(dimSelection, dimLength);\r\n        this.start = start;\r\n        this.stop = stop;\r\n        this.step = step;\r\n        if (this.step < 1) {\r\n            throw new NegativeStepError();\r\n        }\r\n        this.dimLength = dimLength;\r\n        this.dimChunkLength = dimChunkLength;\r\n        this.numItems = Math.max(0, Math.ceil((this.stop - this.start) / this.step));\r\n        this.numChunks = Math.ceil(this.dimLength / this.dimChunkLength);\r\n    }\r\n    *iter() {\r\n        const dimChunkIndexFrom = Math.floor(this.start / this.dimChunkLength);\r\n        const dimChunkIndexTo = Math.ceil(this.stop / this.dimChunkLength);\r\n        // Iterate over chunks in range\r\n        for (let dimChunkIndex = dimChunkIndexFrom; dimChunkIndex < dimChunkIndexTo; dimChunkIndex++) {\r\n            // Compute offsets for chunk within overall array\r\n            const dimOffset = dimChunkIndex * this.dimChunkLength;\r\n            const dimLimit = Math.min(this.dimLength, (dimChunkIndex + 1) * this.dimChunkLength);\r\n            // Determine chunk length, accounting for trailing chunk\r\n            const dimChunkLength = dimLimit - dimOffset;\r\n            let dimChunkSelStart;\r\n            let dimChunkSelStop;\r\n            let dimOutOffset;\r\n            if (this.start < dimOffset) {\r\n                // Selection starts before current chunk\r\n                dimChunkSelStart = 0;\r\n                const remainder = (dimOffset - this.start) % this.step;\r\n                if (remainder > 0) {\r\n                    dimChunkSelStart += this.step - remainder;\r\n                }\r\n                // Compute number of previous items, provides offset into output array\r\n                dimOutOffset = Math.ceil((dimOffset - this.start) / this.step);\r\n            }\r\n            else {\r\n                // Selection starts within current chunk\r\n                dimChunkSelStart = this.start - dimOffset;\r\n                dimOutOffset = 0;\r\n            }\r\n            if (this.stop > dimLimit) {\r\n                // Selection ends after current chunk\r\n                dimChunkSelStop = dimChunkLength;\r\n            }\r\n            else {\r\n                // Selection ends within current chunk\r\n                dimChunkSelStop = this.stop - dimOffset;\r\n            }\r\n            const dimChunkSelection = slice(dimChunkSelStart, dimChunkSelStop, this.step);\r\n            const dimChunkNumItems = Math.ceil((dimChunkSelStop - dimChunkSelStart) / this.step);\r\n            const dimOutSelection = slice(dimOutOffset, dimOutOffset + dimChunkNumItems);\r\n            yield {\r\n                dimChunkIndex,\r\n                dimChunkSelection,\r\n                dimOutSelection,\r\n            };\r\n        }\r\n    }\r\n}\n\n/**\r\n * This should be true only if this javascript is getting executed in Node.\r\n */\r\nconst IS_NODE = typeof process !== \"undefined\" && process.versions && process.versions.node;\r\n// eslint-disable-next-line @typescript-eslint/no-empty-function\r\nfunction noop() { }\r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\nfunction normalizeStoragePath(path) {\r\n    if (path === null) {\r\n        return \"\";\r\n    }\r\n    if (path instanceof String) {\r\n        path = path.valueOf();\r\n    }\r\n    // convert backslash to forward slash\r\n    path = path.replace(/\\\\/g, \"/\");\r\n    // ensure no leading slash\r\n    while (path.length > 0 && path[0] === '/') {\r\n        path = path.slice(1);\r\n    }\r\n    // ensure no trailing slash\r\n    while (path.length > 0 && path[path.length - 1] === '/') {\r\n        path = path.slice(0, path.length - 1);\r\n    }\r\n    // collapse any repeated slashes\r\n    path = path.replace(/\\/\\/+/g, \"/\");\r\n    // don't allow path segments with just '.' or '..'\r\n    const segments = path.split('/');\r\n    for (const s of segments) {\r\n        if (s === \".\" || s === \"..\") {\r\n            throw Error(\"path containing '.' or '..' segment not allowed\");\r\n        }\r\n    }\r\n    return path;\r\n}\r\nfunction normalizeShape(shape) {\r\n    if (typeof shape === \"number\") {\r\n        shape = [shape];\r\n    }\r\n    return shape.map(x => Math.floor(x));\r\n}\r\nfunction normalizeChunks(chunks, shape) {\r\n    // Assume shape is already normalized\r\n    if (chunks === null || chunks === true) {\r\n        throw new Error(\"Chunk guessing is not supported yet\");\r\n    }\r\n    if (chunks === false) {\r\n        return shape;\r\n    }\r\n    if (typeof chunks === \"number\") {\r\n        chunks = [chunks];\r\n    }\r\n    // handle underspecified chunks\r\n    if (chunks.length < shape.length) {\r\n        // assume chunks across remaining dimensions\r\n        chunks = chunks.concat(shape.slice(chunks.length));\r\n    }\r\n    return chunks.map((x, idx) => {\r\n        // handle null or -1 in chunks\r\n        if (x === -1 || x === null) {\r\n            return shape[idx];\r\n        }\r\n        else {\r\n            return Math.floor(x);\r\n        }\r\n    });\r\n}\r\nfunction normalizeOrder(order) {\r\n    order = order.toUpperCase();\r\n    return order;\r\n}\r\nfunction normalizeDtype(dtype) {\r\n    return dtype;\r\n}\r\nfunction normalizeFillValue(fillValue) {\r\n    return fillValue;\r\n}\r\n/**\r\n * Determine whether `item` specifies a complete slice of array with the\r\n *  given `shape`. Used to optimize __setitem__ operations on chunks\r\n * @param item\r\n * @param shape\r\n */\r\nfunction isTotalSlice(item, shape) {\r\n    if (item === null) {\r\n        return true;\r\n    }\r\n    if (!Array.isArray(item)) {\r\n        item = [item];\r\n    }\r\n    for (let i = 0; i < Math.min(item.length, shape.length); i++) {\r\n        const it = item[i];\r\n        if (it === null)\r\n            continue;\r\n        if (isSlice(it)) {\r\n            const s = it;\r\n            const isStepOne = s.step === 1 || s.step === null;\r\n            if (s.start === null && s.stop === null && isStepOne) {\r\n                continue;\r\n            }\r\n            if ((s.stop - s.start) === shape[i] && isStepOne) {\r\n                continue;\r\n            }\r\n            return false;\r\n        }\r\n        return false;\r\n        // } else {\r\n        //     console.error(`isTotalSlice unexpected non-slice, got ${it}`);\r\n        //     return false;\r\n        // }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Checks for === equality of all elements.\r\n */\r\nfunction arrayEquals1D(a, b) {\r\n    if (a.length !== b.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < a.length; i++) {\r\n        if (a[i] !== b[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/*\r\n * Determines \"C\" order strides for a given shape array.\r\n * Strides provide integer steps in each dimention to traverse an ndarray.\r\n *\r\n * NOTE: - These strides here are distinct from numpy.ndarray.strides, which describe actual byte steps.\r\n *       - Strides are assumed to be contiguous, so initial step is 1. Thus, output will always be [XX, XX, 1].\r\n */\r\nfunction getStrides(shape) {\r\n    // adapted from https://github.com/scijs/ndarray/blob/master/ndarray.js#L326-L330\r\n    const ndim = shape.length;\r\n    const strides = Array(ndim);\r\n    let step = 1; // init step\r\n    for (let i = ndim - 1; i >= 0; i--) {\r\n        strides[i] = step;\r\n        step *= shape[i];\r\n    }\r\n    return strides;\r\n}\r\nfunction resolveUrl(root, path) {\r\n    const base = typeof root === 'string' ? new URL(root) : root;\r\n    if (!base.pathname.endsWith('/')) {\r\n        // ensure trailing slash so that base is resolved as _directory_\r\n        base.pathname += '/';\r\n    }\r\n    const resolved = new URL(path, base);\r\n    // copy search params to new URL\r\n    resolved.search = base.search;\r\n    return resolved.href;\r\n}\r\n/**\r\n * Swaps byte order in-place for a given TypedArray.\r\n * Used to flip endian-ness when getting/setting chunks from/to zarr store.\r\n * @param src TypedArray\r\n */\r\nfunction byteSwapInplace(src) {\r\n    const b = src.BYTES_PER_ELEMENT;\r\n    if (b === 1)\r\n        return; // no swapping needed\r\n    if (IS_NODE) {\r\n        // Use builtin methods for swapping if in Node environment\r\n        const bytes = Buffer.from(src.buffer, src.byteOffset, src.length * b);\r\n        if (b === 2)\r\n            bytes.swap16();\r\n        if (b === 4)\r\n            bytes.swap32();\r\n        if (b === 8)\r\n            bytes.swap64();\r\n        return;\r\n    }\r\n    // In browser, need to flip manually\r\n    // Adapted from https://github.com/zbjornson/node-bswap/blob/master/bswap.js\r\n    const flipper = new Uint8Array(src.buffer, src.byteOffset, src.length * b);\r\n    const numFlips = b / 2;\r\n    const endByteIndex = b - 1;\r\n    let t;\r\n    for (let i = 0; i < flipper.length; i += b) {\r\n        for (let j = 0; j < numFlips; j++) {\r\n            t = flipper[i + j];\r\n            flipper[i + j] = flipper[i + endByteIndex - j];\r\n            flipper[i + endByteIndex - j] = t;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Creates a copy of a TypedArray and swaps bytes.\r\n * Used to flip endian-ness when getting/setting chunks from/to zarr store.\r\n * @param src TypedArray\r\n */\r\nfunction byteSwap(src) {\r\n    const copy = src.slice();\r\n    byteSwapInplace(copy);\r\n    return copy;\r\n}\r\nfunction convertColMajorToRowMajor2D(src, out, shape) {\r\n    let idx = 0;\r\n    const shape0 = shape[0];\r\n    const shape1 = shape[1];\r\n    const stride0 = shape1;\r\n    for (let i1 = 0; i1 < shape1; i1++) {\r\n        for (let i0 = 0; i0 < shape0; i0++) {\r\n            out[i0 * stride0 + i1] = src[idx++];\r\n        }\r\n    }\r\n}\r\nfunction convertColMajorToRowMajor3D(src, out, shape) {\r\n    let idx = 0;\r\n    const shape0 = shape[0];\r\n    const shape1 = shape[1];\r\n    const shape2 = shape[2];\r\n    const stride0 = shape2 * shape1;\r\n    const stride1 = shape2;\r\n    for (let i2 = 0; i2 < shape2; i2++) {\r\n        for (let i1 = 0; i1 < shape1; i1++) {\r\n            for (let i0 = 0; i0 < shape0; i0++) {\r\n                out[i0 * stride0 + i1 * stride1 + i2] = src[idx++];\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction convertColMajorToRowMajor4D(src, out, shape) {\r\n    let idx = 0;\r\n    const shape0 = shape[0];\r\n    const shape1 = shape[1];\r\n    const shape2 = shape[2];\r\n    const shape3 = shape[3];\r\n    const stride0 = shape3 * shape2 * shape1;\r\n    const stride1 = shape3 * shape2;\r\n    const stride2 = shape3;\r\n    for (let i3 = 0; i3 < shape3; i3++) {\r\n        for (let i2 = 0; i2 < shape2; i2++) {\r\n            for (let i1 = 0; i1 < shape1; i1++) {\r\n                for (let i0 = 0; i0 < shape0; i0++) {\r\n                    out[i0 * stride0 + i1 * stride1 + i2 * stride2 + i3] = src[idx++];\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction convertColMajorToRowMajorGeneric(src, out, shape) {\r\n    const nDims = shape.length;\r\n    const size = shape.reduce((r, a) => r * a);\r\n    const rowMajorStrides = shape.map((_, i) => i + 1 === nDims ? 1 : shape.slice(i + 1).reduce((r, a) => r * a, 1));\r\n    const index = Array(nDims).fill(0);\r\n    for (let colMajorIdx = 0; colMajorIdx < size; colMajorIdx++) {\r\n        let rowMajorIdx = 0;\r\n        for (let dim = 0; dim < nDims; dim++) {\r\n            rowMajorIdx += index[dim] * rowMajorStrides[dim];\r\n        }\r\n        out[rowMajorIdx] = src[colMajorIdx];\r\n        index[0] += 1;\r\n        // Handle carry-over\r\n        for (let dim = 0; dim < nDims; dim++) {\r\n            if (index[dim] === shape[dim]) {\r\n                if (dim + 1 === nDims) {\r\n                    return;\r\n                }\r\n                index[dim] = 0;\r\n                index[dim + 1] += 1;\r\n            }\r\n        }\r\n    }\r\n}\r\nconst colMajorToRowMajorConverters = {\r\n    [0]: noop,\r\n    [1]: noop,\r\n    [2]: convertColMajorToRowMajor2D,\r\n    [3]: convertColMajorToRowMajor3D,\r\n    [4]: convertColMajorToRowMajor4D,\r\n};\r\n/**\r\n * Rewrites a copy of a TypedArray while converting it from column-major (F-order) to row-major (C-order).\r\n * @param src TypedArray\r\n * @param out TypedArray\r\n * @param shape number[]\r\n */\r\nfunction convertColMajorToRowMajor(src, out, shape) {\r\n    return (colMajorToRowMajorConverters[shape.length] || convertColMajorToRowMajorGeneric)(src, out, shape);\r\n}\r\nfunction isArrayBufferLike(obj) {\r\n    if (obj === null) {\r\n        return false;\r\n    }\r\n    if (obj instanceof ArrayBuffer) {\r\n        return true;\r\n    }\r\n    if (typeof SharedArrayBuffer === \"function\" && obj instanceof SharedArrayBuffer) {\r\n        return true;\r\n    }\r\n    if (IS_NODE) { // Necessary for Node.js for some reason..\r\n        return obj.toString().startsWith(\"[object ArrayBuffer]\")\r\n            || obj.toString().startsWith(\"[object SharedArrayBuffer]\");\r\n    }\r\n    return false;\r\n}\n\nconst ARRAY_META_KEY = \".zarray\";\r\nconst GROUP_META_KEY = \".zgroup\";\r\nconst ATTRS_META_KEY = \".zattrs\";\n\n/**\r\n * Return true if the store contains an array at the given logical path.\r\n */\r\nasync function containsArray(store, path = null) {\r\n    path = normalizeStoragePath(path);\r\n    const prefix = pathToPrefix(path);\r\n    const key = prefix + ARRAY_META_KEY;\r\n    return store.containsItem(key);\r\n}\r\n/**\r\n * Return true if the store contains a group at the given logical path.\r\n */\r\nasync function containsGroup(store, path = null) {\r\n    path = normalizeStoragePath(path);\r\n    const prefix = pathToPrefix(path);\r\n    const key = prefix + GROUP_META_KEY;\r\n    return store.containsItem(key);\r\n}\r\nfunction pathToPrefix(path) {\r\n    // assume path already normalized\r\n    if (path.length > 0) {\r\n        return path + '/';\r\n    }\r\n    return '';\r\n}\r\nasync function requireParentGroup(store, path, chunkStore, overwrite) {\r\n    // Assume path is normalized\r\n    if (path.length === 0) {\r\n        return;\r\n    }\r\n    const segments = path.split(\"/\");\r\n    let p = \"\";\r\n    for (const s of segments.slice(0, segments.length - 1)) {\r\n        p += s;\r\n        if (await containsArray(store, p)) {\r\n            await initGroupMetadata(store, p, overwrite);\r\n        }\r\n        else if (!await containsGroup(store, p)) {\r\n            await initGroupMetadata(store, p);\r\n        }\r\n        p += \"/\";\r\n    }\r\n}\r\nasync function initGroupMetadata(store, path = null, overwrite = false) {\r\n    path = normalizeStoragePath(path);\r\n    // Guard conditions\r\n    if (overwrite) {\r\n        throw Error(\"Group overwriting not implemented yet :(\");\r\n    }\r\n    else if (await containsArray(store, path)) {\r\n        throw new ContainsArrayError(path);\r\n    }\r\n    else if (await containsGroup(store, path)) {\r\n        throw new ContainsGroupError(path);\r\n    }\r\n    const metadata = { zarr_format: 2 };\r\n    const key = pathToPrefix(path) + GROUP_META_KEY;\r\n    await store.setItem(key, JSON.stringify(metadata));\r\n}\r\n/**\r\n *  Initialize a group store. Note that this is a low-level function and there should be no\r\n *  need to call this directly from user code.\r\n */\r\nasync function initGroup(store, path = null, chunkStore = null, overwrite = false) {\r\n    path = normalizeStoragePath(path);\r\n    await requireParentGroup(store, path, chunkStore, overwrite);\r\n    await initGroupMetadata(store, path, overwrite);\r\n}\r\nasync function initArrayMetadata(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters, dimensionSeparator) {\r\n    // Guard conditions\r\n    if (overwrite) {\r\n        throw Error(\"Array overwriting not implemented yet :(\");\r\n    }\r\n    else if (await containsArray(store, path)) {\r\n        throw new ContainsArrayError(path);\r\n    }\r\n    else if (await containsGroup(store, path)) {\r\n        throw new ContainsGroupError(path);\r\n    }\r\n    // Normalize metadata,  does type checking too.\r\n    dtype = normalizeDtype(dtype);\r\n    shape = normalizeShape(shape);\r\n    chunks = normalizeChunks(chunks, shape);\r\n    order = normalizeOrder(order);\r\n    fillValue = normalizeFillValue(fillValue);\r\n    if (filters !== null && filters.length > 0) {\r\n        throw Error(\"Filters are not supported yet\");\r\n    }\r\n    let serializedFillValue = fillValue;\r\n    if (typeof fillValue === \"number\") {\r\n        if (Number.isNaN(fillValue))\r\n            serializedFillValue = \"NaN\";\r\n        if (Number.POSITIVE_INFINITY === fillValue)\r\n            serializedFillValue = \"Infinity\";\r\n        if (Number.NEGATIVE_INFINITY === fillValue)\r\n            serializedFillValue = \"-Infinity\";\r\n    }\r\n    filters = null;\r\n    const metadata = {\r\n        zarr_format: 2,\r\n        shape: shape,\r\n        chunks: chunks,\r\n        dtype: dtype,\r\n        fill_value: serializedFillValue,\r\n        order: order,\r\n        compressor: compressor,\r\n        filters: filters,\r\n    };\r\n    if (dimensionSeparator) {\r\n        metadata.dimension_separator = dimensionSeparator;\r\n    }\r\n    const metaKey = pathToPrefix(path) + ARRAY_META_KEY;\r\n    await store.setItem(metaKey, JSON.stringify(metadata));\r\n}\r\n/**\r\n *\r\n * Initialize an array store with the given configuration. Note that this is a low-level\r\n * function and there should be no need to call this directly from user code\r\n */\r\nasync function initArray(store, shape, chunks, dtype, path = null, compressor = null, fillValue = null, order = \"C\", overwrite = false, chunkStore = null, filters = null, dimensionSeparator) {\r\n    path = normalizeStoragePath(path);\r\n    await requireParentGroup(store, path, chunkStore, overwrite);\r\n    await initArrayMetadata(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters, dimensionSeparator);\r\n}\n\nfunction parseMetadata(s) {\r\n    // Here we allow that a store may return an already-parsed metadata object,\r\n    // or a string of JSON that we will parse here. We allow for an already-parsed\r\n    // object to accommodate a consolidated metadata store, where all the metadata for\r\n    // all groups and arrays will already have been parsed from JSON.\r\n    if (typeof s !== 'string') {\r\n        // tslint:disable-next-line: strict-type-predicates\r\n        if (IS_NODE && Buffer.isBuffer(s)) {\r\n            return JSON.parse(s.toString());\r\n        }\r\n        else if (isArrayBufferLike(s)) {\r\n            const utf8Decoder = new TextDecoder();\r\n            const bytes = new Uint8Array(s);\r\n            return JSON.parse(utf8Decoder.decode(bytes));\r\n        }\r\n        else {\r\n            return s;\r\n        }\r\n    }\r\n    return JSON.parse(s);\r\n}\n\n/**\r\n * Class providing access to user attributes on an array or group. Should not be\r\n * instantiated directly, will be available via the `.attrs` property of an array or\r\n * group.\r\n */\r\nclass Attributes {\r\n    constructor(store, key, readOnly, cache = true) {\r\n        this.store = store;\r\n        this.key = key;\r\n        this.readOnly = readOnly;\r\n        this.cache = cache;\r\n        this.cachedValue = null;\r\n    }\r\n    /**\r\n     * Retrieve all attributes as a JSON object.\r\n     */\r\n    async asObject() {\r\n        if (this.cache && this.cachedValue !== null) {\r\n            return this.cachedValue;\r\n        }\r\n        const o = await this.getNoSync();\r\n        if (this.cache) {\r\n            this.cachedValue = o;\r\n        }\r\n        return o;\r\n    }\r\n    async getNoSync() {\r\n        try {\r\n            const data = await this.store.getItem(this.key);\r\n            // TODO fix typing?\r\n            return parseMetadata(data);\r\n        }\r\n        catch (error) {\r\n            return {};\r\n        }\r\n    }\r\n    async setNoSync(key, value) {\r\n        const d = await this.getNoSync();\r\n        d[key] = value;\r\n        await this.putNoSync(d);\r\n        return true;\r\n    }\r\n    async putNoSync(m) {\r\n        await this.store.setItem(this.key, JSON.stringify(m));\r\n        if (this.cache) {\r\n            this.cachedValue = m;\r\n        }\r\n    }\r\n    async delNoSync(key) {\r\n        const d = await this.getNoSync();\r\n        delete d[key];\r\n        await this.putNoSync(d);\r\n        return true;\r\n    }\r\n    /**\r\n     * Overwrite all attributes with the provided object in a single operation\r\n     */\r\n    async put(d) {\r\n        if (this.readOnly) {\r\n            throw new PermissionError(\"attributes are read-only\");\r\n        }\r\n        return this.putNoSync(d);\r\n    }\r\n    async setItem(key, value) {\r\n        if (this.readOnly) {\r\n            throw new PermissionError(\"attributes are read-only\");\r\n        }\r\n        return this.setNoSync(key, value);\r\n    }\r\n    async getItem(key) {\r\n        return (await this.asObject())[key];\r\n    }\r\n    async deleteItem(key) {\r\n        if (this.readOnly) {\r\n            throw new PermissionError(\"attributes are read-only\");\r\n        }\r\n        return this.delNoSync(key);\r\n    }\r\n    async containsItem(key) {\r\n        return (await this.asObject())[key] !== undefined;\r\n    }\r\n    proxy() {\r\n        return createProxy(this);\r\n    }\r\n}\n\nconst DTYPE_TYPEDARRAY_MAPPING = {\r\n    '|b': Int8Array,\r\n    '|B': Uint8Array,\r\n    '|u1': Uint8Array,\r\n    '|i1': Int8Array,\r\n    '<b': Int8Array,\r\n    '<B': Uint8Array,\r\n    '<u1': Uint8Array,\r\n    '<i1': Int8Array,\r\n    '<u2': Uint16Array,\r\n    '<i2': Int16Array,\r\n    '<u4': Uint32Array,\r\n    '<i4': Int32Array,\r\n    '<f4': Float32Array,\r\n    '<f8': Float64Array,\r\n    '>b': Int8Array,\r\n    '>B': Uint8Array,\r\n    '>u1': Uint8Array,\r\n    '>i1': Int8Array,\r\n    '>u2': Uint16Array,\r\n    '>i2': Int16Array,\r\n    '>u4': Uint32Array,\r\n    '>i4': Int32Array,\r\n    '>f4': Float32Array,\r\n    '>f8': Float64Array\r\n};\r\nfunction getTypedArrayCtr(dtype) {\r\n    const ctr = DTYPE_TYPEDARRAY_MAPPING[dtype];\r\n    if (!ctr) {\r\n        throw Error(`Dtype not recognized or not supported in zarr.js, got ${dtype}.`);\r\n    }\r\n    return ctr;\r\n}\r\n/*\r\n * Called by NestedArray and RawArray constructors only.\r\n * We byte-swap the buffer of a store after decoding\r\n * since TypedArray views are little endian only.\r\n *\r\n * This means NestedArrays and RawArrays will always be little endian,\r\n * unless a numpy-like library comes around and can handle endianess\r\n * for buffer views.\r\n */\r\nfunction getTypedArrayDtypeString(t) {\r\n    // Favour the types below instead of small and big B\r\n    if (t instanceof Uint8Array)\r\n        return '|u1';\r\n    if (t instanceof Int8Array)\r\n        return '|i1';\r\n    if (t instanceof Uint16Array)\r\n        return '<u2';\r\n    if (t instanceof Int16Array)\r\n        return '<i2';\r\n    if (t instanceof Uint32Array)\r\n        return '<u4';\r\n    if (t instanceof Int32Array)\r\n        return '<i4';\r\n    if (t instanceof Float32Array)\r\n        return '<f4';\r\n    if (t instanceof Float64Array)\r\n        return '<f8';\r\n    throw new ValueError('Mapping for TypedArray to Dtypestring not known');\r\n}\n\n/**\r\n * Digs down into the dimensions of given array to find the TypedArray and returns its constructor.\r\n * Better to use sparingly.\r\n */\r\nfunction getNestedArrayConstructor(arr) {\r\n    // TODO fix typing\r\n    // tslint:disable-next-line: strict-type-predicates\r\n    if (arr.byteLength !== undefined) {\r\n        return (arr).constructor;\r\n    }\r\n    return getNestedArrayConstructor(arr[0]);\r\n}\r\n/**\r\n * Returns both the slice result and new output shape\r\n * @param arr NestedArray to slice\r\n * @param shape The shape of the NestedArray\r\n * @param selection\r\n */\r\nfunction sliceNestedArray(arr, shape, selection) {\r\n    // This translates \"...\", \":\", null into a list of slices or integer selections\r\n    const normalizedSelection = normalizeArraySelection(selection, shape);\r\n    const [sliceIndices, outShape] = selectionToSliceIndices(normalizedSelection, shape);\r\n    const outArray = _sliceNestedArray(arr, shape, sliceIndices);\r\n    return [outArray, outShape];\r\n}\r\nfunction _sliceNestedArray(arr, shape, selection) {\r\n    const currentSlice = selection[0];\r\n    // Is this necessary?\r\n    // // This is possible when a slice list is passed shorter than the amount of dimensions\r\n    // // tslint:disable-next-line: strict-type-predicates\r\n    // if (currentSlice === undefined) {\r\n    //     return arr.slice();\r\n    // }\r\n    // When a number is passed that dimension is squeezed\r\n    if (typeof currentSlice === \"number\") {\r\n        // Assume already normalized integer selection here.\r\n        if (shape.length === 1) {\r\n            return arr[currentSlice];\r\n        }\r\n        else {\r\n            return _sliceNestedArray(arr[currentSlice], shape.slice(1), selection.slice(1));\r\n        }\r\n    }\r\n    const [from, to, step, outputSize] = currentSlice;\r\n    if (outputSize === 0) {\r\n        return new (getNestedArrayConstructor(arr))(0);\r\n    }\r\n    if (shape.length === 1) {\r\n        if (step === 1) {\r\n            return arr.slice(from, to);\r\n        }\r\n        const newArrData = new arr.constructor(outputSize);\r\n        for (let i = 0; i < outputSize; i++) {\r\n            newArrData[i] = arr[from + i * step];\r\n        }\r\n        return newArrData;\r\n    }\r\n    let newArr = new Array(outputSize);\r\n    for (let i = 0; i < outputSize; i++) {\r\n        newArr[i] = _sliceNestedArray(arr[from + i * step], shape.slice(1), selection.slice(1));\r\n    }\r\n    // This is necessary to ensure that the return value is a NestedArray if the last dimension is squeezed\r\n    // e.g. shape [2,1] with slice [:, 0] would otherwise result in a list of numbers instead of a valid NestedArray\r\n    if (outputSize > 0 && typeof newArr[0] === \"number\") {\r\n        const typedArrayConstructor = arr[0].constructor;\r\n        newArr = typedArrayConstructor.from(newArr);\r\n    }\r\n    return newArr;\r\n}\r\nfunction setNestedArrayToScalar(dstArr, value, destShape, selection) {\r\n    // This translates \"...\", \":\", null, etc into a list of slices.\r\n    const normalizedSelection = normalizeArraySelection(selection, destShape, true);\r\n    // Above we force the results to be SliceIndicesIndices only, without integer selections making this cast is safe.\r\n    const [sliceIndices, _outShape] = selectionToSliceIndices(normalizedSelection, destShape);\r\n    _setNestedArrayToScalar(dstArr, value, destShape, sliceIndices);\r\n}\r\nfunction setNestedArray(dstArr, sourceArr, destShape, sourceShape, selection) {\r\n    // This translates \"...\", \":\", null, etc into a list of slices.\r\n    const normalizedSelection = normalizeArraySelection(selection, destShape, false);\r\n    const [sliceIndices, outShape] = selectionToSliceIndices(normalizedSelection, destShape);\r\n    // TODO: replace with non stringify equality check\r\n    if (JSON.stringify(outShape) !== JSON.stringify(sourceShape)) {\r\n        throw new ValueError(`Shape mismatch in target and source NestedArray: ${outShape} and ${sourceShape}`);\r\n    }\r\n    _setNestedArray(dstArr, sourceArr, destShape, sliceIndices);\r\n}\r\nfunction _setNestedArray(dstArr, sourceArr, shape, selection) {\r\n    const currentSlice = selection[0];\r\n    if (typeof sourceArr === \"number\") {\r\n        _setNestedArrayToScalar(dstArr, sourceArr, shape, selection.map(x => typeof x === \"number\" ? [x, x + 1, 1, 1] : x));\r\n        return;\r\n    }\r\n    // This dimension is squeezed.\r\n    if (typeof currentSlice === \"number\") {\r\n        _setNestedArray(dstArr[currentSlice], sourceArr, shape.slice(1), selection.slice(1));\r\n        return;\r\n    }\r\n    const [from, _to, step, outputSize] = currentSlice;\r\n    if (shape.length === 1) {\r\n        if (step === 1) {\r\n            dstArr.set(sourceArr, from);\r\n        }\r\n        else {\r\n            for (let i = 0; i < outputSize; i++) {\r\n                dstArr[from + i * step] = (sourceArr)[i];\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    for (let i = 0; i < outputSize; i++) {\r\n        _setNestedArray(dstArr[from + i * step], sourceArr[i], shape.slice(1), selection.slice(1));\r\n    }\r\n}\r\nfunction _setNestedArrayToScalar(dstArr, value, shape, selection) {\r\n    const currentSlice = selection[0];\r\n    const [from, to, step, outputSize] = currentSlice;\r\n    if (shape.length === 1) {\r\n        if (step === 1) {\r\n            dstArr.fill(value, from, to);\r\n        }\r\n        else {\r\n            for (let i = 0; i < outputSize; i++) {\r\n                dstArr[from + i * step] = value;\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    for (let i = 0; i < outputSize; i++) {\r\n        _setNestedArrayToScalar(dstArr[from + i * step], value, shape.slice(1), selection.slice(1));\r\n    }\r\n}\r\nfunction flattenNestedArray(arr, shape, constr) {\r\n    if (constr === undefined) {\r\n        constr = getNestedArrayConstructor(arr);\r\n    }\r\n    const size = shape.reduce((x, y) => x * y, 1);\r\n    const outArr = new constr(size);\r\n    _flattenNestedArray(arr, shape, outArr, 0);\r\n    return outArr;\r\n}\r\nfunction _flattenNestedArray(arr, shape, outArr, offset) {\r\n    if (shape.length === 1) {\r\n        // This is only ever reached if called with rank 1 shape, never reached through recursion.\r\n        // We just slice set the array directly from one level above to save some function calls.\r\n        outArr.set(arr, offset);\r\n        return;\r\n    }\r\n    if (shape.length === 2) {\r\n        for (let i = 0; i < shape[0]; i++) {\r\n            outArr.set(arr[i], offset + shape[1] * i);\r\n        }\r\n        return arr;\r\n    }\r\n    const nextShape = shape.slice(1);\r\n    // Small optimization possible here: this can be precomputed for different levels of depth and passed on.\r\n    const mult = nextShape.reduce((x, y) => x * y, 1);\r\n    for (let i = 0; i < shape[0]; i++) {\r\n        _flattenNestedArray(arr[i], nextShape, outArr, offset + mult * i);\r\n    }\r\n    return arr;\r\n}\n\nclass NestedArray {\r\n    constructor(data, shape, dtype) {\r\n        const dataIsTypedArray = data !== null && !!data.BYTES_PER_ELEMENT;\r\n        if (shape === undefined) {\r\n            if (!dataIsTypedArray) {\r\n                throw new ValueError(\"Shape argument is required unless you pass in a TypedArray\");\r\n            }\r\n            shape = [data.length];\r\n        }\r\n        if (dtype === undefined) {\r\n            if (!dataIsTypedArray) {\r\n                throw new ValueError(\"Dtype argument is required unless you pass in a TypedArray\");\r\n            }\r\n            dtype = getTypedArrayDtypeString(data);\r\n        }\r\n        shape = normalizeShape(shape);\r\n        this.shape = shape;\r\n        this.dtype = dtype;\r\n        if (dataIsTypedArray && shape.length !== 1) {\r\n            data = data.buffer;\r\n        }\r\n        // Zero dimension array.. they are a bit weirdly represented now, they will only ever occur internally\r\n        if (this.shape.length === 0) {\r\n            this.data = new (getTypedArrayCtr(dtype))(1);\r\n        }\r\n        else if (\r\n        // tslint:disable-next-line: strict-type-predicates\r\n        (IS_NODE && Buffer.isBuffer(data))\r\n            || isArrayBufferLike(data)\r\n            || data === null) {\r\n            // Create from ArrayBuffer or Buffer\r\n            const numShapeElements = shape.reduce((x, y) => x * y, 1);\r\n            if (data === null) {\r\n                data = new ArrayBuffer(numShapeElements * parseInt(dtype[dtype.length - 1], 10));\r\n            }\r\n            const numDataElements = data.byteLength / parseInt(dtype[dtype.length - 1], 10);\r\n            if (numShapeElements !== numDataElements) {\r\n                throw new Error(`Buffer has ${numDataElements} of dtype ${dtype}, shape is too large or small ${shape} (flat=${numShapeElements})`);\r\n            }\r\n            const typeConstructor = getTypedArrayCtr(dtype);\r\n            this.data = createNestedArray(data, typeConstructor, shape);\r\n        }\r\n        else {\r\n            this.data = data;\r\n        }\r\n    }\r\n    get(selection) {\r\n        const [sliceResult, outShape] = sliceNestedArray(this.data, this.shape, selection);\r\n        if (outShape.length === 0) {\r\n            return sliceResult;\r\n        }\r\n        else {\r\n            return new NestedArray(sliceResult, outShape, this.dtype);\r\n        }\r\n    }\r\n    set(selection = null, value) {\r\n        if (selection === null) {\r\n            selection = [slice(null)];\r\n        }\r\n        if (typeof value === \"number\") {\r\n            if (this.shape.length === 0) {\r\n                // Zero dimension array..\r\n                this.data[0] = value;\r\n            }\r\n            else {\r\n                setNestedArrayToScalar(this.data, value, this.shape, selection);\r\n            }\r\n        }\r\n        else {\r\n            setNestedArray(this.data, value.data, this.shape, value.shape, selection);\r\n        }\r\n    }\r\n    flatten() {\r\n        if (this.shape.length === 1) {\r\n            return this.data;\r\n        }\r\n        return flattenNestedArray(this.data, this.shape, getTypedArrayCtr(this.dtype));\r\n    }\r\n    /**\r\n     * Currently only supports a single integer as the size, TODO: support start, stop, step.\r\n     */\r\n    static arange(size, dtype = \"<i4\") {\r\n        const constr = getTypedArrayCtr(dtype);\r\n        const data = rangeTypedArray([size], constr);\r\n        return new NestedArray(data, [size], dtype);\r\n    }\r\n}\r\n/**\r\n * Creates a TypedArray with values 0 through N where N is the product of the shape.\r\n */\r\nfunction rangeTypedArray(shape, tContructor) {\r\n    const size = shape.reduce((x, y) => x * y, 1);\r\n    const data = new tContructor(size);\r\n    data.set([...Array(size).keys()]); // Sets range 0,1,2,3,4,5\r\n    return data;\r\n}\r\n/**\r\n * Creates multi-dimensional (rank > 1) array given input data and shape recursively.\r\n * What it does is create a Array<Array<...<Array<Uint8Array>>> or some other typed array.\r\n * This is for internal use, there should be no need to call this from user code.\r\n * @param data a buffer containing the data for this array.\r\n * @param t constructor for the datatype of choice\r\n * @param shape list of numbers describing the size in each dimension\r\n * @param offset in bytes for this dimension\r\n */\r\nfunction createNestedArray(data, t, shape, offset = 0) {\r\n    if (shape.length === 1) {\r\n        // This is only ever reached if called with rank 1 shape, never reached through recursion.\r\n        // We just slice set the array directly from one level above to save some function calls.\r\n        return new t(data.slice(offset, offset + shape[0] * t.BYTES_PER_ELEMENT));\r\n    }\r\n    const arr = new Array(shape[0]);\r\n    if (shape.length === 2) {\r\n        for (let i = 0; i < shape[0]; i++) {\r\n            arr[i] = new t(data.slice(offset + shape[1] * i * t.BYTES_PER_ELEMENT, offset + shape[1] * (i + 1) * t.BYTES_PER_ELEMENT));\r\n        }\r\n        return arr;\r\n    }\r\n    const nextShape = shape.slice(1);\r\n    // Small optimization possible here: this can be precomputed for different levels of depth and passed on.\r\n    const mult = nextShape.reduce((x, y) => x * y, 1);\r\n    for (let i = 0; i < shape[0]; i++) {\r\n        arr[i] = createNestedArray(data, t, nextShape, offset + mult * i * t.BYTES_PER_ELEMENT);\r\n    }\r\n    return arr;\r\n}\n\nfunction setRawArrayToScalar(dstArr, dstStrides, dstShape, dstSelection, value) {\r\n    // This translates \"...\", \":\", null, etc into a list of slices.\r\n    const normalizedSelection = normalizeArraySelection(dstSelection, dstShape, true);\r\n    const [sliceIndices] = selectionToSliceIndices(normalizedSelection, dstShape);\r\n    // Above we force the results to be SliceIndicesIndices only, without integer selections making this cast is safe.\r\n    _setRawArrayToScalar(value, dstArr, dstStrides, sliceIndices);\r\n}\r\nfunction setRawArray(dstArr, dstStrides, dstShape, dstSelection, sourceArr, sourceStrides, sourceShape) {\r\n    // This translates \"...\", \":\", null, etc into a list of slices.\r\n    const normalizedDstSelection = normalizeArraySelection(dstSelection, dstShape, false);\r\n    const [dstSliceIndices, outShape] = selectionToSliceIndices(normalizedDstSelection, dstShape);\r\n    // TODO: replace with non stringify equality check\r\n    if (JSON.stringify(outShape) !== JSON.stringify(sourceShape)) {\r\n        throw new ValueError(`Shape mismatch in target and source RawArray: ${outShape} and ${sourceShape}`);\r\n    }\r\n    _setRawArray(dstArr, dstStrides, dstSliceIndices, sourceArr, sourceStrides);\r\n}\r\nfunction setRawArrayFromChunkItem(dstArr, dstStrides, dstShape, dstSelection, sourceArr, sourceStrides, sourceShape, sourceSelection) {\r\n    // This translates \"...\", \":\", null, etc into a list of slices.\r\n    const normalizedDstSelection = normalizeArraySelection(dstSelection, dstShape, true);\r\n    // Above we force the results to be dstSliceIndices only, without integer selections making this cast is safe.\r\n    const [dstSliceIndices] = selectionToSliceIndices(normalizedDstSelection, dstShape);\r\n    const normalizedSourceSelection = normalizeArraySelection(sourceSelection, sourceShape, false);\r\n    const [sourceSliceIndicies] = selectionToSliceIndices(normalizedSourceSelection, sourceShape);\r\n    // TODO check to ensure chunk and dest selection are same shape?\r\n    // As is, this only gets called in ZarrArray.getRaw where this condition should be ensured, and check might hinder performance.\r\n    _setRawArrayFromChunkItem(dstArr, dstStrides, dstSliceIndices, sourceArr, sourceStrides, sourceSliceIndicies);\r\n}\r\nfunction _setRawArrayToScalar(value, dstArr, dstStrides, dstSliceIndices) {\r\n    const [currentDstSlice, ...nextDstSliceIndices] = dstSliceIndices;\r\n    const [currentDstStride, ...nextDstStrides] = dstStrides;\r\n    const [from, _to, step, outputSize] = currentDstSlice;\r\n    if (dstStrides.length === 1) {\r\n        if (step === 1 && currentDstStride === 1) {\r\n            dstArr.fill(value, from, from + outputSize);\r\n        }\r\n        else {\r\n            for (let i = 0; i < outputSize; i++) {\r\n                dstArr[currentDstStride * (from + (step * i))] = value;\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    for (let i = 0; i < outputSize; i++) {\r\n        _setRawArrayToScalar(value, dstArr.subarray(currentDstStride * (from + (step * i))), nextDstStrides, nextDstSliceIndices);\r\n    }\r\n}\r\nfunction _setRawArray(dstArr, dstStrides, dstSliceIndices, sourceArr, sourceStrides) {\r\n    if (dstSliceIndices.length === 0) {\r\n        dstArr.set(sourceArr);\r\n        return;\r\n    }\r\n    const [currentDstSlice, ...nextDstSliceIndices] = dstSliceIndices;\r\n    const [currentDstStride, ...nextDstStrides] = dstStrides;\r\n    // This dimension is squeezed.\r\n    if (typeof currentDstSlice === \"number\") {\r\n        _setRawArray(dstArr.subarray(currentDstSlice * currentDstStride), nextDstStrides, nextDstSliceIndices, sourceArr, sourceStrides);\r\n        return;\r\n    }\r\n    const [currentSourceStride, ...nextSourceStrides] = sourceStrides;\r\n    const [from, _to, step, outputSize] = currentDstSlice;\r\n    if (dstStrides.length === 1) {\r\n        if (step === 1 && currentDstStride === 1 && currentSourceStride === 1) {\r\n            dstArr.set(sourceArr.subarray(0, outputSize), from);\r\n        }\r\n        else {\r\n            for (let i = 0; i < outputSize; i++) {\r\n                dstArr[currentDstStride * (from + (step * i))] = sourceArr[currentSourceStride * i];\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    for (let i = 0; i < outputSize; i++) {\r\n        // Apply strides as above, using both destination and source-specific strides.\r\n        _setRawArray(dstArr.subarray(currentDstStride * (from + (i * step))), nextDstStrides, nextDstSliceIndices, sourceArr.subarray(currentSourceStride * i), nextSourceStrides);\r\n    }\r\n}\r\nfunction _setRawArrayFromChunkItem(dstArr, dstStrides, dstSliceIndices, sourceArr, sourceStrides, sourceSliceIndices) {\r\n    if (sourceSliceIndices.length === 0) {\r\n        // Case when last source dimension is squeezed\r\n        dstArr.set(sourceArr.subarray(0, dstArr.length));\r\n        return;\r\n    }\r\n    // Get current indicies and strides for both destination and source arrays\r\n    const [currentDstSlice, ...nextDstSliceIndices] = dstSliceIndices;\r\n    const [currentSourceSlice, ...nextSourceSliceIndices] = sourceSliceIndices;\r\n    const [currentDstStride, ...nextDstStrides] = dstStrides;\r\n    const [currentSourceStride, ...nextSourceStrides] = sourceStrides;\r\n    // This source dimension is squeezed\r\n    if (typeof currentSourceSlice === \"number\") {\r\n        /*\r\n        Sets dimension offset for squeezed dimension.\r\n\n        Ex. if 0th dimension is squeezed to 2nd index (numpy : arr[2,i])\r\n\n            sourceArr[stride[0]* 2 + i] --> sourceArr.subarray(stride[0] * 2)[i] (sourceArr[i] in next call)\r\n\n        Thus, subsequent squeezed dims are appended to the source offset.\r\n        */\r\n        _setRawArrayFromChunkItem(\r\n        // Don't update destination offset/slices, just source\r\n        dstArr, dstStrides, dstSliceIndices, sourceArr.subarray(currentSourceStride * currentSourceSlice), nextSourceStrides, nextSourceSliceIndices);\r\n        return;\r\n    }\r\n    const [from, _to, step, outputSize] = currentDstSlice; // just need start and size\r\n    const [sfrom, _sto, sstep, _soutputSize] = currentSourceSlice; // Will always be subset of dst, so don't need output size just start\r\n    if (dstStrides.length === 1 && sourceStrides.length === 1) {\r\n        if (step === 1 && currentDstStride === 1 && sstep === 1 && currentSourceStride === 1) {\r\n            dstArr.set(sourceArr.subarray(sfrom, sfrom + outputSize), from);\r\n        }\r\n        else {\r\n            for (let i = 0; i < outputSize; i++) {\r\n                dstArr[currentDstStride * (from + (step * i))] = sourceArr[currentSourceStride * (sfrom + (sstep * i))];\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    for (let i = 0; i < outputSize; i++) {\r\n        // Apply strides as above, using both destination and source-specific strides.\r\n        _setRawArrayFromChunkItem(dstArr.subarray(currentDstStride * (from + (i * step))), nextDstStrides, nextDstSliceIndices, sourceArr.subarray(currentSourceStride * (sfrom + (i * sstep))), nextSourceStrides, nextSourceSliceIndices);\r\n    }\r\n}\n\nclass RawArray {\r\n    constructor(data, shape, dtype, strides) {\r\n        const dataIsTypedArray = data !== null && !!data.BYTES_PER_ELEMENT;\r\n        if (shape === undefined) {\r\n            if (!dataIsTypedArray) {\r\n                throw new ValueError(\"Shape argument is required unless you pass in a TypedArray\");\r\n            }\r\n            shape = [data.length];\r\n        }\r\n        shape = normalizeShape(shape);\r\n        if (dtype === undefined) {\r\n            if (!dataIsTypedArray) {\r\n                throw new ValueError(\"Dtype argument is required unless you pass in a TypedArray\");\r\n            }\r\n            dtype = getTypedArrayDtypeString(data);\r\n        }\r\n        if (strides === undefined) {\r\n            strides = getStrides(shape);\r\n        }\r\n        this.shape = shape;\r\n        this.dtype = dtype;\r\n        this.strides = strides;\r\n        if (dataIsTypedArray && shape.length !== 1) {\r\n            data = data.buffer;\r\n        }\r\n        // Zero dimension array.. they are a bit weirdly represented now, they will only ever occur internally\r\n        if (this.shape.length === 0) {\r\n            this.data = new (getTypedArrayCtr(dtype))(1);\r\n        }\r\n        else if (\r\n        // tslint:disable-next-line: strict-type-predicates\r\n        (IS_NODE && Buffer.isBuffer(data))\r\n            || isArrayBufferLike(data)\r\n            || data === null) {\r\n            // Create from ArrayBuffer or Buffer\r\n            const numShapeElements = shape.reduce((x, y) => x * y, 1);\r\n            if (data === null) {\r\n                data = new ArrayBuffer(numShapeElements * parseInt(dtype[dtype.length - 1], 10));\r\n            }\r\n            const numDataElements = data.byteLength / parseInt(dtype[dtype.length - 1], 10);\r\n            if (numShapeElements !== numDataElements) {\r\n                throw new Error(`Buffer has ${numDataElements} of dtype ${dtype}, shape is too large or small ${shape} (flat=${numShapeElements})`);\r\n            }\r\n            const typeConstructor = getTypedArrayCtr(dtype);\r\n            this.data = new typeConstructor(data);\r\n        }\r\n        else {\r\n            this.data = data;\r\n        }\r\n    }\r\n    set(selection = null, value, chunkSelection) {\r\n        if (selection === null) {\r\n            selection = [slice(null)];\r\n        }\r\n        if (typeof value === \"number\") {\r\n            if (this.shape.length === 0) {\r\n                // Zero dimension array..\r\n                this.data[0] = value;\r\n            }\r\n            else {\r\n                setRawArrayToScalar(this.data, this.strides, this.shape, selection, value);\r\n            }\r\n        }\r\n        else if (value instanceof RawArray && chunkSelection) {\r\n            // Copy directly from decoded chunk to destination array\r\n            setRawArrayFromChunkItem(this.data, this.strides, this.shape, selection, value.data, value.strides, value.shape, chunkSelection);\r\n        }\r\n        else {\r\n            setRawArray(this.data, this.strides, this.shape, selection, value.data, value.strides, value.shape);\r\n        }\r\n    }\r\n}\n\nvar eventemitter3 = {exports: {}};\n\n(function (module) {\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\n{\n  module.exports = EventEmitter;\n}\n}(eventemitter3));\n\nvar EventEmitter = eventemitter3.exports;\n\nclass TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\nfunction pTimeout(promise, milliseconds, fallback, options) {\n\tlet timer;\n\tconst cancelablePromise = new Promise((resolve, reject) => {\n\t\tif (typeof milliseconds !== 'number' || milliseconds < 0) {\n\t\t\tthrow new TypeError('Expected `milliseconds` to be a positive number');\n\t\t}\n\n\t\tif (milliseconds === Number.POSITIVE_INFINITY) {\n\t\t\tresolve(promise);\n\t\t\treturn;\n\t\t}\n\n\t\toptions = {\n\t\t\tcustomTimers: {setTimeout, clearTimeout},\n\t\t\t...options\n\t\t};\n\n\t\ttimer = options.customTimers.setTimeout.call(undefined, () => {\n\t\t\tif (typeof fallback === 'function') {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(fallback());\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst message = typeof fallback === 'string' ? fallback : `Promise timed out after ${milliseconds} milliseconds`;\n\t\t\tconst timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);\n\n\t\t\tif (typeof promise.cancel === 'function') {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\n\t\t\treject(timeoutError);\n\t\t}, milliseconds);\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tresolve(await promise);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t} finally {\n\t\t\t\toptions.customTimers.clearTimeout.call(undefined, timer);\n\t\t\t}\n\t\t})();\n\t});\n\n\tcancelablePromise.clear = () => {\n\t\tclearTimeout(timer);\n\t\ttimer = undefined;\n\t};\n\n\treturn cancelablePromise;\n}\n\n// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nfunction lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while (count > 0) {\n        const step = Math.trunc(count / 2);\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        }\n        else {\n            count = step;\n        }\n    }\n    return first;\n}\n\nclass PriorityQueue {\n    constructor() {\n        Object.defineProperty(this, \"_queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    enqueue(run, options) {\n        var _a;\n        options = {\n            priority: 0,\n            ...options\n        };\n        const element = {\n            priority: options.priority,\n            run\n        };\n        if (this.size && ((_a = this._queue[this.size - 1]) === null || _a === void 0 ? void 0 : _a.priority) >= options.priority) {\n            this._queue.push(element);\n            return;\n        }\n        const index = lowerBound(this._queue, element, (a, b) => b.priority - a.priority);\n        this._queue.splice(index, 0, element);\n    }\n    dequeue() {\n        const item = this._queue.shift();\n        return item === null || item === void 0 ? void 0 : item.run;\n    }\n    filter(options) {\n        return this._queue.filter((element) => element.priority === options.priority).map((element) => element.run);\n    }\n    get size() {\n        return this._queue.length;\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst empty$1 = () => { };\nconst timeoutError = new TimeoutError();\n/**\nPromise queue with concurrency control.\n*/\nclass PQueue extends EventEmitter {\n    constructor(options) {\n        var _a, _b, _c, _d;\n        super();\n        Object.defineProperty(this, \"_carryoverConcurrencyCount\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_isIntervalIgnored\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_intervalCount\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"_intervalCap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_interval\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_intervalEnd\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"_intervalId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_timeoutId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_queueClass\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_pendingCount\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n        Object.defineProperty(this, \"_concurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_isPaused\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_resolveEmpty\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: empty$1\n        });\n        Object.defineProperty(this, \"_resolveIdle\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: empty$1\n        });\n        Object.defineProperty(this, \"_timeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_throwOnTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = {\n            carryoverConcurrencyCount: false,\n            intervalCap: Number.POSITIVE_INFINITY,\n            interval: 0,\n            concurrency: Number.POSITIVE_INFINITY,\n            autoStart: true,\n            queueClass: PriorityQueue,\n            ...options\n        };\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''}\\` (${typeof options.interval})`);\n        }\n        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n        this._isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;\n        this._intervalCap = options.intervalCap;\n        this._interval = options.interval;\n        this._queue = new options.queueClass();\n        this._queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        this._timeout = options.timeout;\n        this._throwOnTimeout = options.throwOnTimeout === true;\n        this._isPaused = options.autoStart === false;\n    }\n    get _doesIntervalAllowAnother() {\n        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;\n    }\n    get _doesConcurrentAllowAnother() {\n        return this._pendingCount < this._concurrency;\n    }\n    _next() {\n        this._pendingCount--;\n        this._tryToStartAnother();\n        this.emit('next');\n    }\n    _resolvePromises() {\n        this._resolveEmpty();\n        this._resolveEmpty = empty$1;\n        if (this._pendingCount === 0) {\n            this._resolveIdle();\n            this._resolveIdle = empty$1;\n            this.emit('idle');\n        }\n    }\n    _onResumeInterval() {\n        this._onInterval();\n        this._initializeIntervalIfNeeded();\n        this._timeoutId = undefined;\n    }\n    _isIntervalPaused() {\n        const now = Date.now();\n        if (this._intervalId === undefined) {\n            const delay = this._intervalEnd - now;\n            if (delay < 0) {\n                // Act as the interval was done\n                // We don't need to resume it here because it will be resumed on line 160\n                this._intervalCount = (this._carryoverConcurrencyCount) ? this._pendingCount : 0;\n            }\n            else {\n                // Act as the interval is pending\n                if (this._timeoutId === undefined) {\n                    this._timeoutId = setTimeout(() => {\n                        this._onResumeInterval();\n                    }, delay);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _tryToStartAnother() {\n        if (this._queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            if (this._intervalId) {\n                clearInterval(this._intervalId);\n            }\n            this._intervalId = undefined;\n            this._resolvePromises();\n            return false;\n        }\n        if (!this._isPaused) {\n            const canInitializeInterval = !this._isIntervalPaused();\n            if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {\n                const job = this._queue.dequeue();\n                if (!job) {\n                    return false;\n                }\n                this.emit('active');\n                job();\n                if (canInitializeInterval) {\n                    this._initializeIntervalIfNeeded();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _initializeIntervalIfNeeded() {\n        if (this._isIntervalIgnored || this._intervalId !== undefined) {\n            return;\n        }\n        this._intervalId = setInterval(() => {\n            this._onInterval();\n        }, this._interval);\n        this._intervalEnd = Date.now() + this._interval;\n    }\n    _onInterval() {\n        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {\n            clearInterval(this._intervalId);\n            this._intervalId = undefined;\n        }\n        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n        this._processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n    _processQueue() {\n        // eslint-disable-next-line no-empty\n        while (this._tryToStartAnother()) { }\n    }\n    get concurrency() {\n        return this._concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this._concurrency = newConcurrency;\n        this._processQueue();\n    }\n    /**\n    Adds a sync or async task to the queue. Always returns a promise.\n    */\n    async add(fn, options = {}) {\n        return new Promise((resolve, reject) => {\n            const run = async () => {\n                this._pendingCount++;\n                this._intervalCount++;\n                try {\n                    const operation = (this._timeout === undefined && options.timeout === undefined) ? fn() : pTimeout(Promise.resolve(fn()), (options.timeout === undefined ? this._timeout : options.timeout), () => {\n                        if (options.throwOnTimeout === undefined ? this._throwOnTimeout : options.throwOnTimeout) {\n                            reject(timeoutError);\n                        }\n                        return undefined;\n                    });\n                    const result = await operation;\n                    resolve(result);\n                    this.emit('completed', result);\n                }\n                catch (error) {\n                    reject(error);\n                    this.emit('error', error);\n                }\n                this._next();\n            };\n            this._queue.enqueue(run, options);\n            this._tryToStartAnother();\n            this.emit('add');\n        });\n    }\n    /**\n    Same as `.add()`, but accepts an array of sync or async functions.\n\n    @returns A promise that resolves when all functions are resolved.\n    */\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!this._isPaused) {\n            return this;\n        }\n        this._isPaused = false;\n        this._processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        this._isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        this._queue = new this._queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this._queue.size === 0) {\n            return;\n        }\n        return new Promise(resolve => {\n            const existingResolve = this._resolveEmpty;\n            this._resolveEmpty = () => {\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n\n    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n\n    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n    */\n    async onSizeLessThan(limit) {\n        // Instantly resolve if the queue is empty.\n        if (this._queue.size < limit) {\n            return;\n        }\n        return new Promise(resolve => {\n            const listener = () => {\n                if (this._queue.size < limit) {\n                    this.removeListener('next', listener);\n                    resolve();\n                }\n            };\n            this.on('next', listener);\n        });\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this._pendingCount === 0 && this._queue.size === 0) {\n            return;\n        }\n        return new Promise(resolve => {\n            const existingResolve = this._resolveIdle;\n            this._resolveIdle = () => {\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    Size of the queue, the number of queued items waiting to run.\n    */\n    get size() {\n        return this._queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-array-callback-reference\n        return this._queue.filter(options).length;\n    }\n    /**\n    Number of running items (no longer in the queue).\n    */\n    get pending() {\n        return this._pendingCount;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return this._isPaused;\n    }\n    get timeout() {\n        return this._timeout;\n    }\n    /**\n    Set the timeout for future operations.\n    */\n    set timeout(milliseconds) {\n        this._timeout = milliseconds;\n    }\n}\n\nclass ZarrArray {\r\n    /**\r\n     * Instantiate an array from an initialized store.\r\n     * @param store Array store, already initialized.\r\n     * @param path Storage path.\r\n     * @param metadata The initial value for the metadata\r\n     * @param readOnly True if array should be protected against modification.\r\n     * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.\r\n     * @param cacheMetadata If true (default), array configuration metadata will be cached for the lifetime of the object.\r\n     * If false, array metadata will be reloaded prior to all data access and modification operations (may incur overhead depending on storage and data access pattern).\r\n     * @param cacheAttrs If true (default), user attributes will be cached for attribute read operations.\r\n     * If false, user attributes are reloaded from the store prior to all attribute read operations.\r\n     */\r\n    constructor(store, path = null, metadata, readOnly = false, chunkStore = null, cacheMetadata = true, cacheAttrs = true) {\r\n        // N.B., expect at this point store is fully initialized with all\r\n        // configuration metadata fully specified and normalized\r\n        this.store = store;\r\n        this._chunkStore = chunkStore;\r\n        this.path = normalizeStoragePath(path);\r\n        this.keyPrefix = pathToPrefix(this.path);\r\n        this.readOnly = readOnly;\r\n        this.cacheMetadata = cacheMetadata;\r\n        this.cacheAttrs = cacheAttrs;\r\n        this.meta = metadata;\r\n        if (this.meta.compressor !== null) {\r\n            this.compressor = getCodec(this.meta.compressor);\r\n        }\r\n        else {\r\n            this.compressor = null;\r\n        }\r\n        const attrKey = this.keyPrefix + ATTRS_META_KEY;\r\n        this.attrs = new Attributes(this.store, attrKey, this.readOnly, cacheAttrs);\r\n    }\r\n    /**\r\n     * A `Store` providing the underlying storage for array chunks.\r\n     */\r\n    get chunkStore() {\r\n        if (this._chunkStore) {\r\n            return this._chunkStore;\r\n        }\r\n        return this.store;\r\n    }\r\n    /**\r\n     * Array name following h5py convention.\r\n     */\r\n    get name() {\r\n        if (this.path.length > 0) {\r\n            if (this.path[0] !== \"/\") {\r\n                return \"/\" + this.path;\r\n            }\r\n            return this.path;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Final component of name.\r\n     */\r\n    get basename() {\r\n        const name = this.name;\r\n        if (name === null) {\r\n            return null;\r\n        }\r\n        const parts = name.split(\"/\");\r\n        return parts[parts.length - 1];\r\n    }\r\n    /**\r\n     * \"A list of integers describing the length of each dimension of the array.\r\n     */\r\n    get shape() {\r\n        // this.refreshMetadata();\r\n        return this.meta.shape;\r\n    }\r\n    /**\r\n     * A list of integers describing the length of each dimension of a chunk of the array.\r\n     */\r\n    get chunks() {\r\n        return this.meta.chunks;\r\n    }\r\n    /**\r\n     * Integer describing how many element a chunk contains\r\n     */\r\n    get chunkSize() {\r\n        return this.chunks.reduce((x, y) => x * y, 1);\r\n    }\r\n    /**\r\n     *  The NumPy data type.\r\n     */\r\n    get dtype() {\r\n        return this.meta.dtype;\r\n    }\r\n    /**\r\n     *  A value used for uninitialized portions of the array.\r\n     */\r\n    get fillValue() {\r\n        const fillTypeValue = this.meta.fill_value;\r\n        // TODO extract into function\r\n        if (fillTypeValue === \"NaN\") {\r\n            return NaN;\r\n        }\r\n        else if (fillTypeValue === \"Infinity\") {\r\n            return Infinity;\r\n        }\r\n        else if (fillTypeValue === \"-Infinity\") {\r\n            return -Infinity;\r\n        }\r\n        return this.meta.fill_value;\r\n    }\r\n    /**\r\n     *  Number of dimensions.\r\n     */\r\n    get nDims() {\r\n        return this.meta.shape.length;\r\n    }\r\n    /**\r\n     *  The total number of elements in the array.\r\n     */\r\n    get size() {\r\n        // this.refreshMetadata()\r\n        return this.meta.shape.reduce((x, y) => x * y, 1);\r\n    }\r\n    get length() {\r\n        return this.shape[0];\r\n    }\r\n    get _chunkDataShape() {\r\n        if (this.shape.length === 0) {\r\n            return [1];\r\n        }\r\n        else {\r\n            const s = [];\r\n            for (let i = 0; i < this.shape.length; i++) {\r\n                s[i] = Math.ceil(this.shape[i] / this.chunks[i]);\r\n            }\r\n            return s;\r\n        }\r\n    }\r\n    /**\r\n     * A tuple of integers describing the number of chunks along each\r\n     * dimension of the array.\r\n     */\r\n    get chunkDataShape() {\r\n        // this.refreshMetadata();\r\n        return this._chunkDataShape;\r\n    }\r\n    /**\r\n     * Total number of chunks.\r\n     */\r\n    get numChunks() {\r\n        // this.refreshMetadata();\r\n        return this.chunkDataShape.reduce((x, y) => x * y, 1);\r\n    }\r\n    /**\r\n     * Instantiate an array from an initialized store.\r\n     * @param store Array store, already initialized.\r\n     * @param path Storage path.\r\n     * @param readOnly True if array should be protected against modification.\r\n     * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.\r\n     * @param cacheMetadata If true (default), array configuration metadata will be cached for the lifetime of the object.\r\n     * If false, array metadata will be reloaded prior to all data access and modification operations (may incur overhead depending on storage and data access pattern).\r\n     * @param cacheAttrs If true (default), user attributes will be cached for attribute read operations.\r\n     * If false, user attributes are reloaded from the store prior to all attribute read operations.\r\n     */\r\n    static async create(store, path = null, readOnly = false, chunkStore = null, cacheMetadata = true, cacheAttrs = true) {\r\n        const metadata = await this.loadMetadataForConstructor(store, path);\r\n        return new ZarrArray(store, path, metadata, readOnly, chunkStore, cacheMetadata, cacheAttrs);\r\n    }\r\n    static async loadMetadataForConstructor(store, path) {\r\n        try {\r\n            path = normalizeStoragePath(path);\r\n            const keyPrefix = pathToPrefix(path);\r\n            const metaStoreValue = await store.getItem(keyPrefix + ARRAY_META_KEY);\r\n            return parseMetadata(metaStoreValue);\r\n        }\r\n        catch (error) {\r\n            if (await containsGroup(store, path)) {\r\n                throw new ContainsGroupError(path !== null && path !== void 0 ? path : '');\r\n            }\r\n            throw new Error(\"Failed to load metadata for ZarrArray:\" + error.toString());\r\n        }\r\n    }\r\n    /**\r\n     * (Re)load metadata from store\r\n     */\r\n    async reloadMetadata() {\r\n        const metaKey = this.keyPrefix + ARRAY_META_KEY;\r\n        const metaStoreValue = this.store.getItem(metaKey);\r\n        this.meta = parseMetadata(await metaStoreValue);\r\n        return this.meta;\r\n    }\r\n    async refreshMetadata() {\r\n        if (!this.cacheMetadata) {\r\n            await this.reloadMetadata();\r\n        }\r\n    }\r\n    get(selection = null, opts = {}) {\r\n        return this.getBasicSelection(selection, false, opts);\r\n    }\r\n    getRaw(selection = null, opts = {}) {\r\n        return this.getBasicSelection(selection, true, opts);\r\n    }\r\n    async getBasicSelection(selection, asRaw = false, { concurrencyLimit = 10, progressCallback } = {}) {\r\n        // Refresh metadata\r\n        if (!this.cacheMetadata) {\r\n            await this.reloadMetadata();\r\n        }\r\n        // Check fields (TODO?)\r\n        if (this.shape.length === 0) {\r\n            throw new Error(\"Shape [] indexing is not supported yet\");\r\n        }\r\n        else {\r\n            return this.getBasicSelectionND(selection, asRaw, concurrencyLimit, progressCallback);\r\n        }\r\n    }\r\n    getBasicSelectionND(selection, asRaw, concurrencyLimit, progressCallback) {\r\n        const indexer = new BasicIndexer(selection, this);\r\n        return this.getSelection(indexer, asRaw, concurrencyLimit, progressCallback);\r\n    }\r\n    async getSelection(indexer, asRaw, concurrencyLimit, progressCallback) {\r\n        // We iterate over all chunks which overlap the selection and thus contain data\r\n        // that needs to be extracted. Each chunk is processed in turn, extracting the\r\n        // necessary data and storing into the correct location in the output array.\r\n        // N.B., it is an important optimisation that we only visit chunks which overlap\r\n        // the selection. This minimises the number of iterations in the main for loop.\r\n        // check fields are sensible (TODO?)\r\n        const outDtype = this.dtype;\r\n        const outShape = indexer.shape;\r\n        const outSize = indexer.shape.reduce((x, y) => x * y, 1);\r\n        if (asRaw && (outSize === this.chunkSize)) {\r\n            // Optimization: if output strided array _is_ chunk exactly,\r\n            // decode directly as new TypedArray and return\r\n            const itr = indexer.iter();\r\n            const proj = itr.next(); // ensure there is only one projection\r\n            if (proj.done === false && itr.next().done === true) {\r\n                const chunkProjection = proj.value;\r\n                const out = await this.decodeDirectToRawArray(chunkProjection, outShape, outSize);\r\n                return out;\r\n            }\r\n        }\r\n        const out = asRaw\r\n            ? new RawArray(null, outShape, outDtype)\r\n            : new NestedArray(null, outShape, outDtype);\r\n        if (outSize === 0) {\r\n            return out;\r\n        }\r\n        // create promise queue with concurrency control\r\n        const queue = new PQueue({ concurrency: concurrencyLimit });\r\n        if (progressCallback) {\r\n            let progress = 0;\r\n            let queueSize = 0;\r\n            for (const _ of indexer.iter())\r\n                queueSize += 1;\r\n            progressCallback({ progress: 0, queueSize: queueSize });\r\n            for (const proj of indexer.iter()) {\r\n                (async () => {\r\n                    await queue.add(() => this.chunkGetItem(proj.chunkCoords, proj.chunkSelection, out, proj.outSelection, indexer.dropAxes));\r\n                    progress += 1;\r\n                    progressCallback({ progress: progress, queueSize: queueSize });\r\n                })();\r\n            }\r\n        }\r\n        else {\r\n            for (const proj of indexer.iter()) {\r\n                queue.add(() => this.chunkGetItem(proj.chunkCoords, proj.chunkSelection, out, proj.outSelection, indexer.dropAxes));\r\n            }\r\n        }\r\n        // guarantees that all work on queue has finished\r\n        await queue.onIdle();\r\n        // Return scalar instead of zero-dimensional array.\r\n        if (out.shape.length === 0) {\r\n            return out.data[0];\r\n        }\r\n        return out;\r\n    }\r\n    /**\r\n     * Obtain part or whole of a chunk.\r\n     * @param chunkCoords Indices of the chunk.\r\n     * @param chunkSelection Location of region within the chunk to extract.\r\n     * @param out Array to store result in.\r\n     * @param outSelection Location of region within output array to store results in.\r\n     * @param dropAxes Axes to squeeze out of the chunk.\r\n     */\r\n    async chunkGetItem(chunkCoords, chunkSelection, out, outSelection, dropAxes) {\r\n        if (chunkCoords.length !== this._chunkDataShape.length) {\r\n            throw new ValueError(`Inconsistent shapes: chunkCoordsLength: ${chunkCoords.length}, cDataShapeLength: ${this.chunkDataShape.length}`);\r\n        }\r\n        const cKey = this.chunkKey(chunkCoords);\r\n        try {\r\n            const cdata = await this.chunkStore.getItem(cKey);\r\n            const decodedChunk = await this.decodeChunk(cdata);\r\n            if (out instanceof NestedArray) {\r\n                if (isContiguousSelection(outSelection) && isTotalSlice(chunkSelection, this.chunks) && !this.meta.filters) {\r\n                    // Optimization: we want the whole chunk, and the destination is\r\n                    // contiguous, so we can decompress directly from the chunk\r\n                    // into the destination array\r\n                    // TODO check order\r\n                    // TODO filters..\r\n                    out.set(outSelection, this.toNestedArray(decodedChunk));\r\n                    return;\r\n                }\r\n                // Decode chunk\r\n                const chunk = this.toNestedArray(decodedChunk);\r\n                const tmp = chunk.get(chunkSelection);\r\n                if (dropAxes !== null) {\r\n                    throw new Error(\"Drop axes is not supported yet\");\r\n                }\r\n                out.set(outSelection, tmp);\r\n            }\r\n            else {\r\n                /* RawArray\r\n                Copies chunk by index directly into output. Doesn't matter if selection is contiguous\r\n                since store/output are different shapes/strides.\r\n                */\r\n                out.set(outSelection, this.chunkBufferToRawArray(decodedChunk), chunkSelection);\r\n            }\r\n        }\r\n        catch (error) {\r\n            if (isKeyError(error)) {\r\n                // fill with scalar if cKey doesn't exist in store\r\n                if (this.fillValue !== null) {\r\n                    out.set(outSelection, this.fillValue);\r\n                }\r\n            }\r\n            else {\r\n                // Different type of error - rethrow\r\n                throw error;\r\n            }\r\n        }\r\n    }\r\n    async getRawChunk(chunkCoords, opts) {\r\n        if (chunkCoords.length !== this.shape.length) {\r\n            throw new Error(`Chunk coordinates ${chunkCoords.join(\".\")} do not correspond to shape ${this.shape}.`);\r\n        }\r\n        try {\r\n            for (let i = 0; i < chunkCoords.length; i++) {\r\n                const dimLength = Math.ceil(this.shape[i] / this.chunks[i]);\r\n                chunkCoords[i] = normalizeIntegerSelection(chunkCoords[i], dimLength);\r\n            }\r\n        }\r\n        catch (error) {\r\n            if (error instanceof BoundsCheckError) {\r\n                throw new BoundsCheckError(`index ${chunkCoords.join(\".\")} is out of bounds for shape: ${this.shape} and chunks ${this.chunks}`);\r\n            }\r\n            else {\r\n                throw error;\r\n            }\r\n        }\r\n        const cKey = this.chunkKey(chunkCoords);\r\n        const cdata = this.chunkStore.getItem(cKey, opts === null || opts === void 0 ? void 0 : opts.storeOptions);\r\n        const buffer = await this.decodeChunk(await cdata);\r\n        const outShape = this.chunks.filter(d => d !== 1); // squeeze chunk dim if 1\r\n        return new RawArray(buffer, outShape, this.dtype);\r\n    }\r\n    chunkKey(chunkCoords) {\r\n        var _a;\r\n        const sep = (_a = this.meta.dimension_separator) !== null && _a !== void 0 ? _a : \".\";\r\n        return this.keyPrefix + chunkCoords.join(sep);\r\n    }\r\n    ensureByteArray(chunkData) {\r\n        if (typeof chunkData === \"string\") {\r\n            return new Uint8Array(Buffer.from(chunkData).buffer);\r\n        }\r\n        return new Uint8Array(chunkData);\r\n    }\r\n    toTypedArray(buffer) {\r\n        return new (getTypedArrayCtr(this.dtype))(buffer);\r\n    }\r\n    toNestedArray(data) {\r\n        const buffer = this.ensureByteArray(data).buffer;\r\n        return new NestedArray(buffer, this.chunks, this.dtype);\r\n    }\r\n    async decodeChunk(chunkData) {\r\n        let bytes = this.ensureByteArray(chunkData);\r\n        if (this.compressor !== null) {\r\n            bytes = await (await this.compressor).decode(bytes);\r\n        }\r\n        if (this.dtype.includes('>')) {\r\n            // Need to flip bytes for Javascript TypedArrays\r\n            // We flip bytes in-place to avoid creating an extra copy of the decoded buffer.\r\n            byteSwapInplace(this.toTypedArray(bytes.buffer));\r\n        }\r\n        if (this.meta.order === \"F\" && this.nDims > 1) {\r\n            // We need to transpose the array, because this library only support C-order.\r\n            const src = this.toTypedArray(bytes.buffer);\r\n            const out = new (getTypedArrayCtr(this.dtype))(src.length);\r\n            convertColMajorToRowMajor(src, out, this.chunks);\r\n            return out.buffer;\r\n        }\r\n        // TODO filtering etc\r\n        return bytes.buffer;\r\n    }\r\n    chunkBufferToRawArray(buffer) {\r\n        return new RawArray(buffer, this.chunks, this.dtype);\r\n    }\r\n    async decodeDirectToRawArray({ chunkCoords }, outShape, outSize) {\r\n        const cKey = this.chunkKey(chunkCoords);\r\n        try {\r\n            const cdata = await this.chunkStore.getItem(cKey);\r\n            return new RawArray(await this.decodeChunk(cdata), outShape, this.dtype);\r\n        }\r\n        catch (error) {\r\n            if (isKeyError(error)) {\r\n                // fill with scalar if item doesn't exist\r\n                const data = new (getTypedArrayCtr(this.dtype))(outSize);\r\n                return new RawArray(data.fill(this.fillValue), outShape);\r\n            }\r\n            else {\r\n                // Different type of error - rethrow\r\n                throw error;\r\n            }\r\n        }\r\n    }\r\n    async set(selection = null, value, opts = {}) {\r\n        await this.setBasicSelection(selection, value, opts);\r\n    }\r\n    async setBasicSelection(selection, value, { concurrencyLimit = 10, progressCallback } = {}) {\r\n        if (this.readOnly) {\r\n            throw new PermissionError(\"Object is read only\");\r\n        }\r\n        if (!this.cacheMetadata) {\r\n            await this.reloadMetadata();\r\n        }\r\n        if (this.shape.length === 0) {\r\n            throw new Error(\"Shape [] indexing is not supported yet\");\r\n        }\r\n        else {\r\n            await this.setBasicSelectionND(selection, value, concurrencyLimit, progressCallback);\r\n        }\r\n    }\r\n    async setBasicSelectionND(selection, value, concurrencyLimit, progressCallback) {\r\n        const indexer = new BasicIndexer(selection, this);\r\n        await this.setSelection(indexer, value, concurrencyLimit, progressCallback);\r\n    }\r\n    getChunkValue(proj, indexer, value, selectionShape) {\r\n        let chunkValue;\r\n        if (selectionShape.length === 0) {\r\n            chunkValue = value;\r\n        }\r\n        else if (typeof value === \"number\") {\r\n            chunkValue = value;\r\n        }\r\n        else {\r\n            chunkValue = value.get(proj.outSelection);\r\n            // tslint:disable-next-line: strict-type-predicates\r\n            if (indexer.dropAxes !== null) {\r\n                throw new Error(\"Handling drop axes not supported yet\");\r\n            }\r\n        }\r\n        return chunkValue;\r\n    }\r\n    async setSelection(indexer, value, concurrencyLimit, progressCallback) {\r\n        // We iterate over all chunks which overlap the selection and thus contain data\r\n        // that needs to be replaced. Each chunk is processed in turn, extracting the\r\n        // necessary data from the value array and storing into the chunk array.\r\n        // N.B., it is an important optimisation that we only visit chunks which overlap\r\n        // the selection. This minimises the number of iterations in the main for loop.\r\n        // TODO? check fields are sensible\r\n        // Determine indices of chunks overlapping the selection\r\n        const selectionShape = indexer.shape;\r\n        // Check value shape\r\n        if (selectionShape.length === 0) ;\r\n        else if (typeof value === \"number\") ;\r\n        else if (value instanceof NestedArray) {\r\n            // TODO: non stringify equality check\r\n            if (!arrayEquals1D(value.shape, selectionShape)) {\r\n                throw new ValueError(`Shape mismatch in source NestedArray and set selection: ${value.shape} and ${selectionShape}`);\r\n            }\r\n        }\r\n        else {\r\n            // TODO support TypedArrays, buffers, etc\r\n            throw new Error(\"Unknown data type for setting :(\");\r\n        }\r\n        const queue = new PQueue({ concurrency: concurrencyLimit });\r\n        if (progressCallback) {\r\n            let queueSize = 0;\r\n            for (const _ of indexer.iter())\r\n                queueSize += 1;\r\n            let progress = 0;\r\n            progressCallback({ progress: 0, queueSize: queueSize });\r\n            for (const proj of indexer.iter()) {\r\n                const chunkValue = this.getChunkValue(proj, indexer, value, selectionShape);\r\n                (async () => {\r\n                    await queue.add(() => this.chunkSetItem(proj.chunkCoords, proj.chunkSelection, chunkValue));\r\n                    progress += 1;\r\n                    progressCallback({ progress: progress, queueSize: queueSize });\r\n                })();\r\n            }\r\n        }\r\n        else {\r\n            for (const proj of indexer.iter()) {\r\n                const chunkValue = this.getChunkValue(proj, indexer, value, selectionShape);\r\n                queue.add(() => this.chunkSetItem(proj.chunkCoords, proj.chunkSelection, chunkValue));\r\n            }\r\n        }\r\n        // guarantees that all work on queue has finished\r\n        await queue.onIdle();\r\n    }\r\n    async chunkSetItem(chunkCoords, chunkSelection, value) {\r\n        if (this.meta.order === \"F\" && this.nDims > 1) {\r\n            throw new Error(\"Setting content for arrays in F-order is not supported.\");\r\n        }\r\n        // Obtain key for chunk storage\r\n        const chunkKey = this.chunkKey(chunkCoords);\r\n        let chunk = null;\r\n        const dtypeConstr = getTypedArrayCtr(this.dtype);\r\n        const chunkSize = this.chunkSize;\r\n        if (isTotalSlice(chunkSelection, this.chunks)) {\r\n            // Totally replace chunk\r\n            // Optimization: we are completely replacing the chunk, so no need\r\n            // to access the existing chunk data\r\n            if (typeof value === \"number\") {\r\n                // TODO get the right type here\r\n                chunk = new dtypeConstr(chunkSize);\r\n                chunk.fill(value);\r\n            }\r\n            else {\r\n                chunk = value.flatten();\r\n            }\r\n        }\r\n        else {\r\n            // partially replace the contents of this chunk\r\n            // Existing chunk data\r\n            let chunkData;\r\n            try {\r\n                // Chunk is initialized if this does not error\r\n                const chunkStoreData = await this.chunkStore.getItem(chunkKey);\r\n                const dBytes = await this.decodeChunk(chunkStoreData);\r\n                chunkData = this.toTypedArray(dBytes);\r\n            }\r\n            catch (error) {\r\n                if (isKeyError(error)) {\r\n                    // Chunk is not initialized\r\n                    chunkData = new dtypeConstr(chunkSize);\r\n                    if (this.fillValue !== null) {\r\n                        chunkData.fill(this.fillValue);\r\n                    }\r\n                }\r\n                else {\r\n                    // Different type of error - rethrow\r\n                    throw error;\r\n                }\r\n            }\r\n            const chunkNestedArray = new NestedArray(chunkData, this.chunks, this.dtype);\r\n            chunkNestedArray.set(chunkSelection, value);\r\n            chunk = chunkNestedArray.flatten();\r\n        }\r\n        const chunkData = await this.encodeChunk(chunk);\r\n        this.chunkStore.setItem(chunkKey, chunkData);\r\n    }\r\n    async encodeChunk(chunk) {\r\n        if (this.dtype.includes('>')) {\r\n            /*\r\n             * If big endian, flip bytes before applying compression and setting store.\r\n             *\r\n             * Here we create a copy (not in-place byteswapping) to avoid flipping the\r\n             * bytes in the buffers of user-created Raw- and NestedArrays.\r\n            */\r\n            chunk = byteSwap(chunk);\r\n        }\r\n        if (this.compressor !== null) {\r\n            const bytes = new Uint8Array(chunk.buffer);\r\n            const cbytes = await (await this.compressor).encode(bytes);\r\n            return cbytes.buffer;\r\n        }\r\n        // TODO: filters, etc\r\n        return chunk.buffer;\r\n    }\r\n}\n\nclass MemoryStore {\r\n    constructor(root = {}) {\r\n        this.root = root;\r\n    }\r\n    proxy() {\r\n        return createProxy(this);\r\n    }\r\n    getParent(item) {\r\n        let parent = this.root;\r\n        const segments = item.split('/');\r\n        // find the parent container\r\n        for (const k of segments.slice(0, segments.length - 1)) {\r\n            parent = parent[k];\r\n            if (!parent) {\r\n                throw Error(item);\r\n            }\r\n            // if not isinstance(parent, self.cls):\r\n            //     raise KeyError(item)\r\n        }\r\n        return [parent, segments[segments.length - 1]];\r\n    }\r\n    requireParent(item) {\r\n        let parent = this.root;\r\n        const segments = item.split('/');\r\n        // require the parent container\r\n        for (const k of segments.slice(0, segments.length - 1)) {\r\n            // TODO: verify correct implementation\r\n            if (parent[k] === undefined) {\r\n                parent[k] = {};\r\n            }\r\n            parent = parent[k];\r\n        }\r\n        return [parent, segments[segments.length - 1]];\r\n    }\r\n    getItem(item) {\r\n        const [parent, key] = this.getParent(item);\r\n        const value = parent[key];\r\n        if (value === undefined) {\r\n            throw new KeyError(item);\r\n        }\r\n        return value;\r\n    }\r\n    setItem(item, value) {\r\n        const [parent, key] = this.requireParent(item);\r\n        parent[key] = value;\r\n        return true;\r\n    }\r\n    deleteItem(item) {\r\n        const [parent, key] = this.getParent(item);\r\n        return delete parent[key];\r\n    }\r\n    containsItem(item) {\r\n        // TODO: more sane implementation\r\n        try {\r\n            return this.getItem(item) !== undefined;\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n    keys() {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n}\n\nvar HTTPMethod;\r\n(function (HTTPMethod) {\r\n    HTTPMethod[\"HEAD\"] = \"HEAD\";\r\n    HTTPMethod[\"GET\"] = \"GET\";\r\n    HTTPMethod[\"PUT\"] = \"PUT\";\r\n})(HTTPMethod || (HTTPMethod = {}));\r\nconst DEFAULT_METHODS = [HTTPMethod.HEAD, HTTPMethod.GET, HTTPMethod.PUT];\r\nclass HTTPStore {\r\n    constructor(url, options = {}) {\r\n        this.url = url;\r\n        const { fetchOptions = {}, supportedMethods = DEFAULT_METHODS } = options;\r\n        this.fetchOptions = fetchOptions;\r\n        this.supportedMethods = new Set(supportedMethods);\r\n    }\r\n    keys() {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n    async getItem(item, opts) {\r\n        const url = resolveUrl(this.url, item);\r\n        const value = await fetch(url, { ...this.fetchOptions, ...opts });\r\n        if (value.status === 404) {\r\n            // Item is not found\r\n            throw new KeyError(item);\r\n        }\r\n        else if (value.status !== 200) {\r\n            throw new HTTPError(String(value.status));\r\n        }\r\n        // only decode if 200\r\n        if (IS_NODE) {\r\n            return Buffer.from(await value.arrayBuffer());\r\n        }\r\n        else {\r\n            return value.arrayBuffer(); // Browser\r\n        }\r\n    }\r\n    async setItem(item, value) {\r\n        if (!this.supportedMethods.has(HTTPMethod.PUT)) {\r\n            throw new Error('HTTP PUT no a supported method for store.');\r\n        }\r\n        const url = resolveUrl(this.url, item);\r\n        if (typeof value === 'string') {\r\n            value = new TextEncoder().encode(value).buffer;\r\n        }\r\n        const set = await fetch(url, { ...this.fetchOptions, method: HTTPMethod.PUT, body: value });\r\n        return set.status.toString()[0] === '2';\r\n    }\r\n    deleteItem(_item) {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n    async containsItem(item) {\r\n        const url = resolveUrl(this.url, item);\r\n        // Just check headers if HEAD method supported\r\n        const method = this.supportedMethods.has(HTTPMethod.HEAD) ? HTTPMethod.HEAD : HTTPMethod.GET;\r\n        const value = await fetch(url, { ...this.fetchOptions, method });\r\n        return value.status === 200;\r\n    }\r\n}\n\n/**\r\n *\r\n * @param shape Array shape.\r\n * @param chunks  Chunk shape. If `true`, will be guessed from `shape` and `dtype`. If\r\n *      `false`, will be set to `shape`, i.e., single chunk for the whole array.\r\n *      If an int, the chunk size in each dimension will be given by the value\r\n *      of `chunks`. Default is `true`.\r\n * @param dtype NumPy dtype.\r\n * @param compressor Primary compressor.\r\n * @param fillValue Default value to use for uninitialized portions of the array.\r\n * @param order Memory layout to be used within each chunk.\r\n * @param store Store or path to directory in file system or name of zip file.\r\n * @param overwrite  If True, delete all pre-existing data in `store` at `path` before creating the array.\r\n * @param path Path under which array is stored.\r\n * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.\r\n * @param filters Sequence of filters to use to encode chunk data prior to compression.\r\n * @param cacheMetadata If `true` (default), array configuration metadata will be cached for the\r\n *      lifetime of the object. If `false`, array metadata will be reloaded\r\n *      prior to all data access and modification operations (may incur\r\n *      overhead depending on storage and data access pattern).\r\n * @param cacheAttrs If `true` (default), user attributes will be cached for attribute read\r\n *      operations. If `false`, user attributes are reloaded from the store prior\r\n *      to all attribute read operations.\r\n * @param readOnly `true` if array should be protected against modification, defaults to `false`.\r\n * @param dimensionSeparator if specified, defines an alternate string separator placed between the dimension chunks.\r\n */\r\nasync function create({ shape, chunks = true, dtype = \"<i4\", compressor = null, fillValue = null, order = \"C\", store, overwrite = false, path, chunkStore, filters, cacheMetadata = true, cacheAttrs = true, readOnly = false, dimensionSeparator }) {\r\n    store = normalizeStoreArgument(store);\r\n    await initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters, dimensionSeparator);\r\n    const z = await ZarrArray.create(store, path, readOnly, chunkStore, cacheMetadata, cacheAttrs);\r\n    return z;\r\n}\r\n/**\r\n * Create an empty array.\r\n */\r\nasync function empty(shape, opts = {}) {\r\n    opts.fillValue = null;\r\n    return create({ shape, ...opts });\r\n}\r\n/**\r\n * Create an array, with zero being used as the default value for\r\n * uninitialized portions of the array.\r\n */\r\nasync function zeros(shape, opts = {}) {\r\n    opts.fillValue = 0;\r\n    return create({ shape, ...opts });\r\n}\r\n/**\r\n * Create an array, with one being used as the default value for\r\n * uninitialized portions of the array.\r\n */\r\nasync function ones(shape, opts = {}) {\r\n    opts.fillValue = 1;\r\n    return create({ shape, ...opts });\r\n}\r\n/**\r\n * Create an array, with `fill_value` being used as the default value for\r\n * uninitialized portions of the array\r\n */\r\nasync function full(shape, fillValue, opts = {}) {\r\n    opts.fillValue = fillValue;\r\n    return create({ shape, ...opts });\r\n}\r\nasync function array(data, opts = {}) {\r\n    // TODO: infer chunks?\r\n    let shape = null;\r\n    if (data instanceof NestedArray) {\r\n        shape = data.shape;\r\n        opts.dtype = opts.dtype === undefined ? data.dtype : opts.dtype;\r\n    }\r\n    else {\r\n        shape = data.byteLength;\r\n        // TODO: infer datatype\r\n    }\r\n    // TODO: support TypedArray\r\n    const wasReadOnly = opts.readOnly === undefined ? false : opts.readOnly;\r\n    opts.readOnly = false;\r\n    const z = await create({ shape, ...opts });\r\n    await z.set(null, data);\r\n    z.readOnly = wasReadOnly;\r\n    return z;\r\n}\r\nasync function openArray({ shape, mode = \"a\", chunks = true, dtype = \"<i4\", compressor = null, fillValue = null, order = \"C\", store, overwrite = false, path = null, chunkStore, filters, cacheMetadata = true, cacheAttrs = true, dimensionSeparator } = {}) {\r\n    store = normalizeStoreArgument(store);\r\n    if (chunkStore === undefined) {\r\n        chunkStore = normalizeStoreArgument(store);\r\n    }\r\n    path = normalizeStoragePath(path);\r\n    if (mode === \"r\" || mode === \"r+\") {\r\n        if (!await containsArray(store, path)) {\r\n            if (await containsGroup(store, path)) {\r\n                throw new ContainsGroupError(path);\r\n            }\r\n            throw new ArrayNotFoundError(path);\r\n        }\r\n    }\r\n    else if (mode === \"w\") {\r\n        if (shape === undefined) {\r\n            throw new ValueError(\"Shape can not be undefined when creating a new array\");\r\n        }\r\n        await initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters, dimensionSeparator);\r\n    }\r\n    else if (mode === \"a\") {\r\n        if (!await containsArray(store, path)) {\r\n            if (await containsGroup(store, path)) {\r\n                throw new ContainsGroupError(path);\r\n            }\r\n            if (shape === undefined) {\r\n                throw new ValueError(\"Shape can not be undefined when creating a new array\");\r\n            }\r\n            await initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters, dimensionSeparator);\r\n        }\r\n    }\r\n    else if (mode === \"w-\" || mode === \"x\") {\r\n        if (await containsArray(store, path)) {\r\n            throw new ContainsArrayError(path);\r\n        }\r\n        else if (await containsGroup(store, path)) {\r\n            throw new ContainsGroupError(path);\r\n        }\r\n        else {\r\n            if (shape === undefined) {\r\n                throw new ValueError(\"Shape can not be undefined when creating a new array\");\r\n            }\r\n            await initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters, dimensionSeparator);\r\n        }\r\n    }\r\n    else {\r\n        throw new ValueError(`Invalid mode argument: ${mode}`);\r\n    }\r\n    const readOnly = mode === \"r\";\r\n    return ZarrArray.create(store, path, readOnly, chunkStore, cacheMetadata, cacheAttrs);\r\n}\r\nfunction normalizeStoreArgument(store) {\r\n    if (store === undefined) {\r\n        return new MemoryStore();\r\n    }\r\n    else if (typeof store === \"string\") {\r\n        return new HTTPStore(store);\r\n    }\r\n    return store;\r\n}\n\nclass Group {\r\n    constructor(store, path = null, metadata, readOnly = false, chunkStore = null, cacheAttrs = true) {\r\n        this.store = store;\r\n        this._chunkStore = chunkStore;\r\n        this.path = normalizeStoragePath(path);\r\n        this.keyPrefix = pathToPrefix(this.path);\r\n        this.readOnly = readOnly;\r\n        this.meta = metadata;\r\n        // Initialize attributes\r\n        const attrKey = this.keyPrefix + ATTRS_META_KEY;\r\n        this.attrs = new Attributes(this.store, attrKey, this.readOnly, cacheAttrs);\r\n    }\r\n    /**\r\n     * Group name following h5py convention.\r\n     */\r\n    get name() {\r\n        if (this.path.length > 0) {\r\n            if (this.path[0] !== \"/\") {\r\n                return \"/\" + this.path;\r\n            }\r\n            return this.path;\r\n        }\r\n        return \"/\";\r\n    }\r\n    /**\r\n     * Final component of name.\r\n     */\r\n    get basename() {\r\n        const parts = this.name.split(\"/\");\r\n        return parts[parts.length - 1];\r\n    }\r\n    /**\r\n     * A `Store` providing the underlying storage for array chunks.\r\n     */\r\n    get chunkStore() {\r\n        if (this._chunkStore) {\r\n            return this._chunkStore;\r\n        }\r\n        return this.store;\r\n    }\r\n    static async create(store, path = null, readOnly = false, chunkStore = null, cacheAttrs = true) {\r\n        const metadata = await this.loadMetadataForConstructor(store, path);\r\n        return new Group(store, path, metadata, readOnly, chunkStore, cacheAttrs);\r\n    }\r\n    static async loadMetadataForConstructor(store, path) {\r\n        path = normalizeStoragePath(path);\r\n        const keyPrefix = pathToPrefix(path);\r\n        try {\r\n            const metaStoreValue = await store.getItem(keyPrefix + GROUP_META_KEY);\r\n            return parseMetadata(metaStoreValue);\r\n        }\r\n        catch (error) {\r\n            if (await containsArray(store, path)) {\r\n                throw new ContainsArrayError(path);\r\n            }\r\n            throw new GroupNotFoundError(path);\r\n        }\r\n    }\r\n    itemPath(item) {\r\n        const absolute = typeof item === \"string\" && item.length > 0 && item[0] === '/';\r\n        const path = normalizeStoragePath(item);\r\n        // Absolute path\r\n        if (!absolute && this.path.length > 0) {\r\n            return this.keyPrefix + path;\r\n        }\r\n        return path;\r\n    }\r\n    /**\r\n     * Create a sub-group.\r\n     */\r\n    async createGroup(name, overwrite = false) {\r\n        if (this.readOnly) {\r\n            throw new PermissionError(\"group is read only\");\r\n        }\r\n        const path = this.itemPath(name);\r\n        await initGroup(this.store, path, this._chunkStore, overwrite);\r\n        return Group.create(this.store, path, this.readOnly, this._chunkStore, this.attrs.cache);\r\n    }\r\n    /**\r\n     * Obtain a sub-group, creating one if it doesn't exist.\r\n     */\r\n    async requireGroup(name, overwrite = false) {\r\n        if (this.readOnly) {\r\n            throw new PermissionError(\"group is read only\");\r\n        }\r\n        const path = this.itemPath(name);\r\n        if (!await containsGroup(this.store, path)) {\r\n            await initGroup(this.store, path, this._chunkStore, overwrite);\r\n        }\r\n        return Group.create(this.store, path, this.readOnly, this._chunkStore, this.attrs.cache);\r\n    }\r\n    getOptsForArrayCreation(name, opts = {}) {\r\n        const path = this.itemPath(name);\r\n        opts.path = path;\r\n        if (opts.cacheAttrs === undefined) {\r\n            opts.cacheAttrs = this.attrs.cache;\r\n        }\r\n        opts.store = this.store;\r\n        opts.chunkStore = this.chunkStore;\r\n        return opts;\r\n    }\r\n    /**\r\n     * Creates an array\r\n     */\r\n    array(name, data, opts, overwrite) {\r\n        if (this.readOnly) {\r\n            throw new PermissionError(\"group is read only\");\r\n        }\r\n        opts = this.getOptsForArrayCreation(name, opts);\r\n        opts.overwrite = overwrite === undefined ? opts.overwrite : overwrite;\r\n        return array(data, opts);\r\n    }\r\n    empty(name, shape, opts = {}) {\r\n        if (this.readOnly) {\r\n            throw new PermissionError(\"group is read only\");\r\n        }\r\n        opts = this.getOptsForArrayCreation(name, opts);\r\n        return empty(shape, opts);\r\n    }\r\n    zeros(name, shape, opts = {}) {\r\n        if (this.readOnly) {\r\n            throw new PermissionError(\"group is read only\");\r\n        }\r\n        opts = this.getOptsForArrayCreation(name, opts);\r\n        return zeros(shape, opts);\r\n    }\r\n    ones(name, shape, opts = {}) {\r\n        if (this.readOnly) {\r\n            throw new PermissionError(\"group is read only\");\r\n        }\r\n        opts = this.getOptsForArrayCreation(name, opts);\r\n        return ones(shape, opts);\r\n    }\r\n    full(name, shape, fillValue, opts = {}) {\r\n        if (this.readOnly) {\r\n            throw new PermissionError(\"group is read only\");\r\n        }\r\n        opts = this.getOptsForArrayCreation(name, opts);\r\n        return full(shape, fillValue, opts);\r\n    }\r\n    createDataset(name, shape, data, opts) {\r\n        if (this.readOnly) {\r\n            throw new PermissionError(\"group is read only\");\r\n        }\r\n        opts = this.getOptsForArrayCreation(name, opts);\r\n        let z;\r\n        if (data === undefined) {\r\n            if (shape === undefined) {\r\n                throw new ValueError(\"Shape must be set if no data is passed to CreateDataset\");\r\n            }\r\n            z = create({ shape, ...opts });\r\n        }\r\n        else {\r\n            z = array(data, opts);\r\n        }\r\n        return z;\r\n    }\r\n    async getItem(item) {\r\n        const path = this.itemPath(item);\r\n        if (await containsArray(this.store, path)) {\r\n            return ZarrArray.create(this.store, path, this.readOnly, this.chunkStore, undefined, this.attrs.cache);\r\n        }\r\n        else if (await containsGroup(this.store, path)) {\r\n            return Group.create(this.store, path, this.readOnly, this._chunkStore, this.attrs.cache);\r\n        }\r\n        throw new KeyError(item);\r\n    }\r\n    async setItem(item, value) {\r\n        await this.array(item, value, {}, true);\r\n        return true;\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    async deleteItem(_item) {\r\n        if (this.readOnly) {\r\n            throw new PermissionError(\"group is read only\");\r\n        }\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    async containsItem(item) {\r\n        const path = this.itemPath(item);\r\n        return await containsArray(this.store, path) || containsGroup(this.store, path);\r\n    }\r\n    proxy() {\r\n        return createProxy(this);\r\n    }\r\n}\r\n/**\r\n * Create a group.\r\n * @param store Store or path to directory in file system.\r\n * @param path Group path within store.\r\n * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.\r\n * @param overwrite If `true`, delete any pre-existing data in `store` at `path` before creating the group.\r\n * @param cacheAttrs If `true` (default), user attributes will be cached for attribute read operations.\r\n *   If `false`, user attributes are reloaded from the store prior to all attribute read operations.\r\n */\r\nasync function group(store, path = null, chunkStore, overwrite = false, cacheAttrs = true) {\r\n    store = normalizeStoreArgument(store);\r\n    path = normalizeStoragePath(path);\r\n    if (overwrite || await containsGroup(store)) {\r\n        await initGroup(store, path, chunkStore, overwrite);\r\n    }\r\n    return Group.create(store, path, false, chunkStore, cacheAttrs);\r\n}\r\n/**\r\n * Open a group using file-mode-like semantics.\r\n * @param store Store or path to directory in file system or name of zip file.\r\n * @param path Group path within store.\r\n * @param mode Persistence mode, see `PersistenceMode` type.\r\n * @param chunkStore Store or path to directory in file system or name of zip file.\r\n * @param cacheAttrs If `true` (default), user attributes will be cached for attribute read operations\r\n *   If False, user attributes are reloaded from the store prior to all attribute read operations.\r\n *\r\n */\r\nasync function openGroup(store, path = null, mode = \"a\", chunkStore, cacheAttrs = true) {\r\n    store = normalizeStoreArgument(store);\r\n    if (chunkStore !== undefined) {\r\n        chunkStore = normalizeStoreArgument(store);\r\n    }\r\n    path = normalizeStoragePath(path);\r\n    if (mode === \"r\" || mode === \"r+\") {\r\n        if (!await containsGroup(store, path)) {\r\n            if (await containsArray(store, path)) {\r\n                throw new ContainsArrayError(path);\r\n            }\r\n            throw new GroupNotFoundError(path);\r\n        }\r\n    }\r\n    else if (mode === \"w\") {\r\n        await initGroup(store, path, chunkStore, true);\r\n    }\r\n    else if (mode === \"a\") {\r\n        if (!await containsGroup(store, path)) {\r\n            if (await containsArray(store, path)) {\r\n                throw new ContainsArrayError(path);\r\n            }\r\n            await initGroup(store, path, chunkStore);\r\n        }\r\n    }\r\n    else if (mode === \"w-\" || mode === \"x\") {\r\n        if (await containsArray(store, path)) {\r\n            throw new ContainsArrayError(path);\r\n        }\r\n        else if (await containsGroup(store, path)) {\r\n            throw new ContainsGroupError(path);\r\n        }\r\n        else {\r\n            await initGroup(store, path, chunkStore);\r\n        }\r\n    }\r\n    else {\r\n        throw new ValueError(`Invalid mode argument: ${mode}`);\r\n    }\r\n    const readOnly = mode === \"r\";\r\n    return Group.create(store, path, readOnly, chunkStore, cacheAttrs);\r\n}\n\nclass ObjectStore {\r\n    constructor() {\r\n        this.object = {};\r\n    }\r\n    getItem(item) {\r\n        if (!Object.prototype.hasOwnProperty.call(this.object, item)) {\r\n            throw new KeyError(item);\r\n        }\r\n        return this.object[item];\r\n    }\r\n    setItem(item, value) {\r\n        this.object[item] = value;\r\n        return true;\r\n    }\r\n    deleteItem(item) {\r\n        return delete this.object[item];\r\n    }\r\n    containsItem(item) {\r\n        return Object.prototype.hasOwnProperty.call(this.object, item);\r\n    }\r\n    proxy() {\r\n        return createProxy(this);\r\n    }\r\n    keys() {\r\n        return Object.getOwnPropertyNames(this.object);\r\n    }\r\n}\n\n\n//# sourceMappingURL=core.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvemFyci9jb3JlLm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxXQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEtBQUs7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLEtBQUs7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsS0FBSztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVyxhQUFhLFFBQVEsaUJBQWlCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEtBQUssSUFBSSxHQUFHLElBQUksU0FBUyxhQUFhLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsVUFBVTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsaUNBQWlDLGFBQWE7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGlDQUFpQztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLE1BQU07QUFDbkY7QUFDQTtB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Q0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLHlIQUF5SCxNQUFNLDJCQUEyQjtBQUMxUDtBQUNBO0FBQ0EsMkZBQTJGLHNIQUFzSCxNQUFNLHdCQUF3QjtBQUMvTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csZUFBZSxNQUFNLHNCQUFzQjtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLHdEQUF3RCwwQ0FBMEMsSUFBSTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELEtBQUs7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU2Z0I7QUFDN2dCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFpY3Mvd2ViLTNkLXZpZXdlci8uL25vZGVfbW9kdWxlcy96YXJyL2NvcmUubWpzPzNmMzYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcmVnaXN0cnkgPSBuZXcgTWFwKCk7XHJcbmZ1bmN0aW9uIGFkZENvZGVjKGlkLCBpbXBvcnRGbikge1xyXG4gICAgcmVnaXN0cnkuc2V0KGlkLCBpbXBvcnRGbik7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gZ2V0Q29kZWMoY29uZmlnKSB7XHJcbiAgICBpZiAoIXJlZ2lzdHJ5Lmhhcyhjb25maWcuaWQpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wcmVzc2lvbiBjb2RlYyAke2NvbmZpZy5pZH0gaXMgbm90IHN1cHBvcnRlZCBieSBaYXJyLmpzIHlldC5gKTtcclxuICAgIH1cclxuICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb24gKi9cclxuICAgIGNvbnN0IGNvZGVjID0gYXdhaXQgcmVnaXN0cnkuZ2V0KGNvbmZpZy5pZCkoKTtcclxuICAgIHJldHVybiBjb2RlYy5mcm9tQ29uZmlnKGNvbmZpZyk7XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJveHkobWFwcGluZykge1xyXG4gICAgcmV0dXJuIG5ldyBQcm94eShtYXBwaW5nLCB7XHJcbiAgICAgICAgc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgX3JlY2VpdmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuc2V0SXRlbShrZXksIHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCh0YXJnZXQsIGtleSwgX3JlY2VpdmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuZ2V0SXRlbShrZXkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5kZWxldGVJdGVtKGtleSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYXModGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5jb250YWluc0l0ZW0oa2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxuXG5mdW5jdGlvbiBpc1phcnJFcnJvcihlcnIpIHtcclxuICAgIHJldHVybiB0eXBlb2YgZXJyID09PSAnb2JqZWN0JyAmJiBlcnIgIT09IG51bGwgJiYgJ19femFycl9fJyBpbiBlcnI7XHJcbn1cclxuZnVuY3Rpb24gaXNLZXlFcnJvcihvKSB7XHJcbiAgICByZXR1cm4gaXNaYXJyRXJyb3IobykgJiYgby5fX3phcnJfXyA9PT0gJ0tleUVycm9yJztcclxufVxyXG4vLyBDdXN0b20gZXJyb3IgbWVzc2FnZXMsIG5vdGUgd2UgaGF2ZSB0byBwYXRjaCB0aGUgcHJvdG90eXBlIG9mIHRoZVxyXG4vLyBlcnJvcnMgdG8gZml4IGBpbnN0YW5jZW9mYCBjYWxscywgc2VlOlxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvd2lraS9CcmVha2luZy1DaGFuZ2VzI2V4dGVuZGluZy1idWlsdC1pbnMtbGlrZS1lcnJvci1hcnJheS1hbmQtbWFwLW1heS1uby1sb25nZXItd29ya1xyXG5jbGFzcyBDb250YWluc0FycmF5RXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXRoKSB7XHJcbiAgICAgICAgc3VwZXIoYHBhdGggJHtwYXRofSBjb250YWlucyBhbiBhcnJheWApO1xyXG4gICAgICAgIHRoaXMuX196YXJyX18gPSAnQ29udGFpbnNBcnJheUVycm9yJztcclxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQ29udGFpbnNBcnJheUVycm9yLnByb3RvdHlwZSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgQ29udGFpbnNHcm91cEVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IocGF0aCkge1xyXG4gICAgICAgIHN1cGVyKGBwYXRoICR7cGF0aH0gY29udGFpbnMgYSBncm91cGApO1xyXG4gICAgICAgIHRoaXMuX196YXJyX18gPSAnQ29udGFpbnNHcm91cEVycm9yJztcclxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQ29udGFpbnNHcm91cEVycm9yLnByb3RvdHlwZSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgQXJyYXlOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IocGF0aCkge1xyXG4gICAgICAgIHN1cGVyKGBhcnJheSBub3QgZm91bmQgYXQgcGF0aCAke3BhdGh9YCk7XHJcbiAgICAgICAgdGhpcy5fX3phcnJfXyA9ICdBcnJheU5vdEZvdW5kRXJyb3InO1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBBcnJheU5vdEZvdW5kRXJyb3IucHJvdG90eXBlKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBHcm91cE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXRoKSB7XHJcbiAgICAgICAgc3VwZXIoYGdyb3VuZCBub3QgZm91bmQgYXQgcGF0aCAke3BhdGh9YCk7XHJcbiAgICAgICAgdGhpcy5fX3phcnJfXyA9ICdHcm91cE5vdEZvdW5kRXJyb3InO1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBHcm91cE5vdEZvdW5kRXJyb3IucHJvdG90eXBlKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBQYXRoTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhdGgpIHtcclxuICAgICAgICBzdXBlcihgbm90aGluZyBub3QgZm91bmQgYXQgcGF0aCAke3BhdGh9YCk7XHJcbiAgICAgICAgdGhpcy5fX3phcnJfXyA9ICdQYXRoTm90Rm91bmRFcnJvcic7XHJcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFBhdGhOb3RGb3VuZEVycm9yLnByb3RvdHlwZSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgUGVybWlzc2lvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xyXG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMuX196YXJyX18gPSAnUGVybWlzc2lvbkVycm9yJztcclxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgUGVybWlzc2lvbkVycm9yLnByb3RvdHlwZSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgS2V5RXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcclxuICAgICAgICBzdXBlcihga2V5ICR7a2V5fSBub3QgcHJlc2VudGApO1xyXG4gICAgICAgIHRoaXMuX196YXJyX18gPSAnS2V5RXJyb3InO1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBLZXlFcnJvci5wcm90b3R5cGUpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFRvb01hbnlJbmRpY2VzRXJyb3IgZXh0ZW5kcyBSYW5nZUVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHNlbGVjdGlvbiwgc2hhcGUpIHtcclxuICAgICAgICBzdXBlcihgdG9vIG1hbnkgaW5kaWNlcyBmb3IgYXJyYXk7IGV4cGVjdGVkICR7c2hhcGUubGVuZ3RofSwgZ290ICR7c2VsZWN0aW9uLmxlbmd0aH1gKTtcclxuICAgICAgICB0aGlzLl9femFycl9fID0gJ1Rvb01hbnlJbmRpY2VzRXJyb3InO1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBUb29NYW55SW5kaWNlc0Vycm9yLnByb3RvdHlwZSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgQm91bmRzQ2hlY2tFcnJvciBleHRlbmRzIFJhbmdlRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xyXG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMuX196YXJyX18gPSAnQm91bmRzQ2hlY2tFcnJvcic7XHJcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEJvdW5kc0NoZWNrRXJyb3IucHJvdG90eXBlKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBJbnZhbGlkU2xpY2VFcnJvciBleHRlbmRzIFJhbmdlRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIHN0ZXBTaXplLCByZWFzb24pIHtcclxuICAgICAgICBzdXBlcihgc2xpY2UgYXJndW1lbnRzIHNsaWNlKCR7ZnJvbX0sICR7dG99LCAke3N0ZXBTaXplfSkgaW52YWxpZDogJHtyZWFzb259YCk7XHJcbiAgICAgICAgdGhpcy5fX3phcnJfXyA9ICdJbnZhbGlkU2xpY2VFcnJvcic7XHJcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEludmFsaWRTbGljZUVycm9yLnByb3RvdHlwZSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgTmVnYXRpdmVTdGVwRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihgTmVnYXRpdmUgc3RlcCBzaXplIGlzIG5vdCBzdXBwb3J0ZWQgd2hlbiBpbmRleGluZy5gKTtcclxuICAgICAgICB0aGlzLl9femFycl9fID0gJ05lZ2F0aXZlU3RlcEVycm9yJztcclxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgTmVnYXRpdmVTdGVwRXJyb3IucHJvdG90eXBlKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xyXG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMuX196YXJyX18gPSAnVmFsdWVFcnJvcic7XHJcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFZhbHVlRXJyb3IucHJvdG90eXBlKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBIVFRQRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb2RlKSB7XHJcbiAgICAgICAgc3VwZXIoY29kZSk7XHJcbiAgICAgICAgdGhpcy5fX3phcnJfXyA9ICdIVFRQRXJyb3InO1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBIVFRQRXJyb3IucHJvdG90eXBlKTtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBzbGljZShzdGFydCwgc3RvcCA9IHVuZGVmaW5lZCwgc3RlcCA9IG51bGwpIHtcclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogc3RyaWN0LXR5cGUtcHJlZGljYXRlc1xyXG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHsgLy8gTm90IHBvc3NpYmxlIGluIHR5cGVzY3JpcHRcclxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFNsaWNlRXJyb3Ioc3RhcnQsIHN0b3AsIHN0ZXAsIFwiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3Qgbm90IGJlIHVuZGVmaW5lZFwiKTtcclxuICAgIH1cclxuICAgIGlmICgodHlwZW9mIHN0YXJ0ID09PSBcInN0cmluZ1wiICYmIHN0YXJ0ICE9PSBcIjpcIikgfHwgKHR5cGVvZiBzdG9wID09PSBcInN0cmluZ1wiICYmIHN0b3AgIT09IFwiOlwiKSkgeyAvLyBOb3RlIGluIHR5cGVzY3JpcHQgdGhpcyB3aWxsIG5ldmVyIGhhcHBlbiB3aXRoIHR5cGUgY2hlY2tpbmcuXHJcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTbGljZUVycm9yKHN0YXJ0LCBzdG9wLCBzdGVwLCBcIkFyZ3VtZW50cyBjYW4gb25seSBiZSBpbnRlZ2VycywgXFxcIjpcXFwiIG9yIG51bGxcIik7XHJcbiAgICB9XHJcbiAgICAvLyBzbGljZSg1KSA9PT0gc2xpY2UobnVsbCwgNSlcclxuICAgIGlmIChzdG9wID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBzdG9wID0gc3RhcnQ7XHJcbiAgICAgICAgc3RhcnQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gaWYgKHN0YXJ0ICE9PSBudWxsICYmIHN0b3AgIT09IG51bGwgJiYgc3RhcnQgPiBzdG9wKSB7XHJcbiAgICAvLyAgICAgdGhyb3cgbmV3IEludmFsaWRTbGljZUVycm9yKHN0YXJ0LCBzdG9wLCBzdGVwLCBcInRvIGlzIGhpZ2hlciB0aGFuIGZyb21cIik7XHJcbiAgICAvLyB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0YXJ0OiBzdGFydCA9PT0gXCI6XCIgPyBudWxsIDogc3RhcnQsXHJcbiAgICAgICAgc3RvcDogc3RvcCA9PT0gXCI6XCIgPyBudWxsIDogc3RvcCxcclxuICAgICAgICBzdGVwLFxyXG4gICAgICAgIF9zbGljZTogdHJ1ZSxcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIFBvcnQgb2YgYWRqdXN0SW5kaWNlc1xyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcHl0aG9uL2NweXRob24vYmxvYi9tYXN0ZXIvT2JqZWN0cy9zbGljZW9iamVjdC5jI0wyNDNcclxuICovXHJcbmZ1bmN0aW9uIGFkanVzdEluZGljZXMoc3RhcnQsIHN0b3AsIHN0ZXAsIGxlbmd0aCkge1xyXG4gICAgaWYgKHN0YXJ0IDwgMCkge1xyXG4gICAgICAgIHN0YXJ0ICs9IGxlbmd0aDtcclxuICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gKHN0ZXAgPCAwKSA/IC0xIDogMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzdGFydCA+PSBsZW5ndGgpIHtcclxuICAgICAgICBzdGFydCA9IChzdGVwIDwgMCkgPyBsZW5ndGggLSAxIDogbGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0b3AgPCAwKSB7XHJcbiAgICAgICAgc3RvcCArPSBsZW5ndGg7XHJcbiAgICAgICAgaWYgKHN0b3AgPCAwKSB7XHJcbiAgICAgICAgICAgIHN0b3AgPSAoc3RlcCA8IDApID8gLTEgOiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHN0b3AgPj0gbGVuZ3RoKSB7XHJcbiAgICAgICAgc3RvcCA9IChzdGVwIDwgMCkgPyBsZW5ndGggLSAxIDogbGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0ZXAgPCAwKSB7XHJcbiAgICAgICAgaWYgKHN0b3AgPCBzdGFydCkge1xyXG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLmZsb29yKChzdGFydCAtIHN0b3AgLSAxKSAvICgtc3RlcCkgKyAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIFtzdGFydCwgc3RvcCwgc3RlcCwgbGVuZ3RoXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoc3RhcnQgPCBzdG9wKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGguZmxvb3IoKHN0b3AgLSBzdGFydCAtIDEpIC8gc3RlcCArIDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gW3N0YXJ0LCBzdG9wLCBzdGVwLCBsZW5ndGhdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBbc3RhcnQsIHN0b3AsIHN0ZXAsIDBdO1xyXG59XHJcbi8qKlxyXG4gKiBQb3J0IG9mIHNsaWNlLmluZGljZXMobikgYW5kIFB5U2xpY2VfVW5wYWNrXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9weXRob24vY3B5dGhvbi9ibG9iL21hc3Rlci9PYmplY3RzL3NsaWNlb2JqZWN0LmMjTDE2NlxyXG4gKiAgaHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvbWFzdGVyL09iamVjdHMvc2xpY2VvYmplY3QuYyNMMTk4XHJcbiAqXHJcbiAqIEJlaGF2aW91ciBtaWdodCBiZSBzbGlnaHRseSBkaWZmZXJlbnQgYXMgaXQncyBhIHdlaXJkIGh5YnJpZCBpbXBsZW1lbnRhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIHNsaWNlSW5kaWNlcyhzbGljZSwgbGVuZ3RoKSB7XHJcbiAgICBsZXQgc3RhcnQ7XHJcbiAgICBsZXQgc3RvcDtcclxuICAgIGxldCBzdGVwO1xyXG4gICAgaWYgKHNsaWNlLnN0ZXAgPT09IG51bGwpIHtcclxuICAgICAgICBzdGVwID0gMTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHN0ZXAgPSBzbGljZS5zdGVwO1xyXG4gICAgfVxyXG4gICAgaWYgKHNsaWNlLnN0YXJ0ID09PSBudWxsKSB7XHJcbiAgICAgICAgc3RhcnQgPSBzdGVwIDwgMCA/IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIDogMDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHN0YXJ0ID0gc2xpY2Uuc3RhcnQ7XHJcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xyXG4gICAgICAgICAgICBzdGFydCArPSBsZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHNsaWNlLnN0b3AgPT09IG51bGwpIHtcclxuICAgICAgICBzdG9wID0gc3RlcCA8IDAgPyAtTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHN0b3AgPSBzbGljZS5zdG9wO1xyXG4gICAgICAgIGlmIChzdG9wIDwgMCkge1xyXG4gICAgICAgICAgICBzdG9wICs9IGxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBUaGlzIGNsaXBzIG91dCBvZiBib3VuZHMgc2xpY2VzXHJcbiAgICBjb25zdCBzID0gYWRqdXN0SW5kaWNlcyhzdGFydCwgc3RvcCwgc3RlcCwgbGVuZ3RoKTtcclxuICAgIHN0YXJ0ID0gc1swXTtcclxuICAgIHN0b3AgPSBzWzFdO1xyXG4gICAgc3RlcCA9IHNbMl07XHJcbiAgICAvLyBUaGUgb3V0cHV0IGxlbmd0aFxyXG4gICAgbGVuZ3RoID0gc1szXTtcclxuICAgIC8vIFdpdGggb3V0IG9mIGJvdW5kcyBzbGljaW5nIHRoZXNlIHR3byBhc3NlcnRpb25zIGFyZSBub3QgdXNlZnVsLlxyXG4gICAgLy8gaWYgKHN0b3AgPiBsZW5ndGgpIHRocm93IG5ldyBFcnJvcihcIlN0b3AgZ3JlYXRlciB0aGFuIGxlbmd0aFwiKTtcclxuICAgIC8vIGlmIChzdGFydCA+PSBsZW5ndGgpIHRocm93IG5ldyBFcnJvcihcIlN0YXJ0IGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBsZW5ndGhcIik7XHJcbiAgICBpZiAoc3RlcCA9PT0gMClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGVwIHNpemUgMCBpcyBpbnZhbGlkXCIpO1xyXG4gICAgcmV0dXJuIFtzdGFydCwgc3RvcCwgc3RlcCwgbGVuZ3RoXTtcclxufVxuXG5mdW5jdGlvbiBlbnN1cmVBcnJheShzZWxlY3Rpb24pIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShzZWxlY3Rpb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIFtzZWxlY3Rpb25dO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNlbGVjdGlvbjtcclxufVxyXG5mdW5jdGlvbiBjaGVja1NlbGVjdGlvbkxlbmd0aChzZWxlY3Rpb24sIHNoYXBlKSB7XHJcbiAgICBpZiAoc2VsZWN0aW9uLmxlbmd0aCA+IHNoYXBlLmxlbmd0aCkge1xyXG4gICAgICAgIHRocm93IG5ldyBUb29NYW55SW5kaWNlc0Vycm9yKHNlbGVjdGlvbiwgc2hhcGUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGJvdGggdGhlIHNsaWNlSW5kaWNlcyBwZXIgZGltZW5zaW9uIGFuZCB0aGUgb3V0cHV0IHNoYXBlIGFmdGVyIHNsaWNpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZWxlY3Rpb25Ub1NsaWNlSW5kaWNlcyhzZWxlY3Rpb24sIHNoYXBlKSB7XHJcbiAgICBjb25zdCBzbGljZUluZGljZXNSZXN1bHQgPSBbXTtcclxuICAgIGNvbnN0IG91dFNoYXBlID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdGlvbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHMgPSBzZWxlY3Rpb25baV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIHNsaWNlSW5kaWNlc1Jlc3VsdC5wdXNoKHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgeCA9IHNsaWNlSW5kaWNlcyhzLCBzaGFwZVtpXSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpbUxlbmd0aCA9IHhbM107XHJcbiAgICAgICAgICAgIG91dFNoYXBlLnB1c2goZGltTGVuZ3RoKTtcclxuICAgICAgICAgICAgc2xpY2VJbmRpY2VzUmVzdWx0LnB1c2goeCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtzbGljZUluZGljZXNSZXN1bHQsIG91dFNoYXBlXTtcclxufVxyXG4vKipcclxuICogVGhpcyB0cmFuc2xhdGVzIFwiLi4uXCIsIFwiOlwiLCBudWxsIGludG8gYSBsaXN0IG9mIHNsaWNlcyBvciBub24tbmVnYXRpdmUgaW50ZWdlciBzZWxlY3Rpb25zIG9mIGxlbmd0aCBzaGFwZVxyXG4gKi9cclxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlTZWxlY3Rpb24oc2VsZWN0aW9uLCBzaGFwZSwgY29udmVydEludGVnZXJTZWxlY3Rpb25Ub1NsaWNlcyA9IGZhbHNlKSB7XHJcbiAgICBzZWxlY3Rpb24gPSByZXBsYWNlRWxsaXBzaXMoc2VsZWN0aW9uLCBzaGFwZSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdGlvbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGRpbVNlbGVjdGlvbiA9IHNlbGVjdGlvbltpXTtcclxuICAgICAgICBpZiAodHlwZW9mIGRpbVNlbGVjdGlvbiA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICBpZiAoY29udmVydEludGVnZXJTZWxlY3Rpb25Ub1NsaWNlcykge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uW2ldID0gc2xpY2UoZGltU2VsZWN0aW9uLCBkaW1TZWxlY3Rpb24gKyAxLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbltpXSA9IG5vcm1hbGl6ZUludGVnZXJTZWxlY3Rpb24oZGltU2VsZWN0aW9uLCBzaGFwZVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNJbnRlZ2VyQXJyYXkoZGltU2VsZWN0aW9uKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW50ZWdlciBhcnJheSBzZWxlY3Rpb25zIGFyZSBub3Qgc3VwcG9ydGVkICh5ZXQpXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkaW1TZWxlY3Rpb24gPT09IFwiOlwiIHx8IGRpbVNlbGVjdGlvbiA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZWxlY3Rpb25baV0gPSBzbGljZShudWxsLCBudWxsLCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2VsZWN0aW9uO1xyXG59XHJcbmZ1bmN0aW9uIHJlcGxhY2VFbGxpcHNpcyhzZWxlY3Rpb24sIHNoYXBlKSB7XHJcbiAgICBzZWxlY3Rpb24gPSBlbnN1cmVBcnJheShzZWxlY3Rpb24pO1xyXG4gICAgbGV0IGVsbGlwc2lzSW5kZXggPSAtMTtcclxuICAgIGxldCBudW1FbGxpcHNpcyA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdGlvbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChzZWxlY3Rpb25baV0gPT09IFwiLi4uXCIpIHtcclxuICAgICAgICAgICAgZWxsaXBzaXNJbmRleCA9IGk7XHJcbiAgICAgICAgICAgIG51bUVsbGlwc2lzICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG51bUVsbGlwc2lzID4gMSkge1xyXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiYW4gaW5kZXggY2FuIG9ubHkgaGF2ZSBhIHNpbmdsZSBlbGxpcHNpcyAoJy4uLicpXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKG51bUVsbGlwc2lzID09PSAxKSB7XHJcbiAgICAgICAgLy8gY291bnQgaG93IG1hbnkgaXRlbXMgdG8gbGVmdCBhbmQgcmlnaHQgb2YgZWxsaXBzaXNcclxuICAgICAgICBjb25zdCBudW1JdGVtc0xlZnQgPSBlbGxpcHNpc0luZGV4O1xyXG4gICAgICAgIGNvbnN0IG51bUl0ZW1zUmlnaHQgPSBzZWxlY3Rpb24ubGVuZ3RoIC0gKG51bUl0ZW1zTGVmdCArIDEpO1xyXG4gICAgICAgIGNvbnN0IG51bUl0ZW1zID0gc2VsZWN0aW9uLmxlbmd0aCAtIDE7IC8vIEFsbCBub24tZWxsaXBzaXMgaXRlbXNcclxuICAgICAgICBpZiAobnVtSXRlbXMgPj0gc2hhcGUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIEVsbGlwc2lzIGRvZXMgbm90aGluZywganVzdCByZW1vdmUgaXRcclxuICAgICAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uLmZpbHRlcigoeCkgPT4geCAhPT0gXCIuLi5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBSZXBsYWNlIGVsbGlwc2lzIHdpdGggYXMgbWFueSBzbGljZXMgYXJlIG5lZWRlZCBmb3IgbnVtYmVyIG9mIGRpbXNcclxuICAgICAgICAgICAgY29uc3QgbnVtTmV3SXRlbXMgPSBzaGFwZS5sZW5ndGggLSBudW1JdGVtcztcclxuICAgICAgICAgICAgbGV0IG5ld0l0ZW0gPSBzZWxlY3Rpb24uc2xpY2UoMCwgbnVtSXRlbXNMZWZ0KS5jb25jYXQobmV3IEFycmF5KG51bU5ld0l0ZW1zKS5maWxsKG51bGwpKTtcclxuICAgICAgICAgICAgaWYgKG51bUl0ZW1zUmlnaHQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdJdGVtID0gbmV3SXRlbS5jb25jYXQoc2VsZWN0aW9uLnNsaWNlKHNlbGVjdGlvbi5sZW5ndGggLSBudW1JdGVtc1JpZ2h0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZWN0aW9uID0gbmV3SXRlbTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBGaWxsIG91dCBzZWxlY3Rpb24gaWYgbm90IGNvbXBsZXRlbHkgc3BlY2lmaWVkXHJcbiAgICBpZiAoc2VsZWN0aW9uLmxlbmd0aCA8IHNoYXBlLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IG51bU1pc3NpbmcgPSBzaGFwZS5sZW5ndGggLSBzZWxlY3Rpb24ubGVuZ3RoO1xyXG4gICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5jb25jYXQobmV3IEFycmF5KG51bU1pc3NpbmcpLmZpbGwobnVsbCkpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tTZWxlY3Rpb25MZW5ndGgoc2VsZWN0aW9uLCBzaGFwZSk7XHJcbiAgICByZXR1cm4gc2VsZWN0aW9uO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUludGVnZXJTZWxlY3Rpb24oZGltU2VsZWN0aW9uLCBkaW1MZW5ndGgpIHtcclxuICAgIC8vIE5vdGU6IE1heWJlIHdlIHNob3VsZCBjb252ZXJ0IHRvIGludGVnZXIgb3Igd2FybiBpZiBkaW1TZWxlY3Rpb24gaXMgbm90IGFuIGludGVnZXJcclxuICAgIC8vIGhhbmRsZSB3cmFwYXJvdW5kXHJcbiAgICBpZiAoZGltU2VsZWN0aW9uIDwgMCkge1xyXG4gICAgICAgIGRpbVNlbGVjdGlvbiA9IGRpbUxlbmd0aCArIGRpbVNlbGVjdGlvbjtcclxuICAgIH1cclxuICAgIC8vIGhhbmRsZSBvdXQgb2YgYm91bmRzXHJcbiAgICBpZiAoZGltU2VsZWN0aW9uID49IGRpbUxlbmd0aCB8fCBkaW1TZWxlY3Rpb24gPCAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEJvdW5kc0NoZWNrRXJyb3IoYGluZGV4IG91dCBvZiBib3VuZHMgZm9yIGRpbWVuc2lvbiB3aXRoIGxlbmd0aCAke2RpbUxlbmd0aH1gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkaW1TZWxlY3Rpb247XHJcbn1cclxuZnVuY3Rpb24gaXNJbnRlZ2VyKHMpIHtcclxuICAgIHJldHVybiB0eXBlb2YgcyA9PT0gXCJudW1iZXJcIjtcclxufVxyXG5mdW5jdGlvbiBpc0ludGVnZXJBcnJheShzKSB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocykpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGUgb2Ygcykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZSAhPT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gaXNTbGljZShzKSB7XHJcbiAgICBpZiAocyAhPT0gbnVsbCAmJiBzW1wiX3NsaWNlXCJdID09PSB0cnVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaXNDb250aWd1b3VzU2xpY2Uocykge1xyXG4gICAgcmV0dXJuIGlzU2xpY2UocykgJiYgKHMuc3RlcCA9PT0gbnVsbCB8fCBzLnN0ZXAgPT09IDEpO1xyXG59XHJcbmZ1bmN0aW9uIGlzQ29udGlndW91c1NlbGVjdGlvbihzZWxlY3Rpb24pIHtcclxuICAgIHNlbGVjdGlvbiA9IGVuc3VyZUFycmF5KHNlbGVjdGlvbik7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdGlvbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHMgPSBzZWxlY3Rpb25baV07XHJcbiAgICAgICAgaWYgKCEoaXNJbnRlZ2VyQXJyYXkocykgfHwgaXNDb250aWd1b3VzU2xpY2UocykgfHwgcyA9PT0gXCIuLi5cIikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uKiBwcm9kdWN0KC4uLml0ZXJhYmxlcykge1xyXG4gICAgaWYgKGl0ZXJhYmxlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBtYWtlIGEgbGlzdCBvZiBpdGVyYXRvcnMgZnJvbSB0aGUgaXRlcmFibGVzXHJcbiAgICBjb25zdCBpdGVyYXRvcnMgPSBpdGVyYWJsZXMubWFwKGl0ID0+IGl0KCkpO1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IGl0ZXJhdG9ycy5tYXAoaXQgPT4gaXQubmV4dCgpKTtcclxuICAgIC8vIERpc2FibGVkIHRvIGFsbG93IGVtcHR5IGlucHV0c1xyXG4gICAgLy8gaWYgKHJlc3VsdHMuc29tZShyID0+IHIuZG9uZSkpIHtcclxuICAgIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBjb250YWlucyBhbiBlbXB0eSBpdGVyYXRvci5cIik7XHJcbiAgICAvLyB9XHJcbiAgICBmb3IgKGxldCBpID0gMDs7KSB7XHJcbiAgICAgICAgaWYgKHJlc3VsdHNbaV0uZG9uZSkge1xyXG4gICAgICAgICAgICAvLyByZXNldCB0aGUgY3VycmVudCBpdGVyYXRvclxyXG4gICAgICAgICAgICBpdGVyYXRvcnNbaV0gPSBpdGVyYWJsZXNbaV0oKTtcclxuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IGl0ZXJhdG9yc1tpXS5uZXh0KCk7XHJcbiAgICAgICAgICAgIC8vIGFkdmFuY2UsIGFuZCBleGl0IGlmIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZFxyXG4gICAgICAgICAgICBpZiAoKytpID49IGl0ZXJhdG9ycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgeWllbGQgcmVzdWx0cy5tYXAoKHsgdmFsdWUgfSkgPT4gdmFsdWUpO1xyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0c1tpXSA9IGl0ZXJhdG9yc1tpXS5uZXh0KCk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgQmFzaWNJbmRleGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHNlbGVjdGlvbiwgYXJyYXkpIHtcclxuICAgICAgICBzZWxlY3Rpb24gPSBub3JtYWxpemVBcnJheVNlbGVjdGlvbihzZWxlY3Rpb24sIGFycmF5LnNoYXBlKTtcclxuICAgICAgICAvLyBTZXR1cCBwZXItZGltZW5zaW9uIGluZGV4ZXJzXHJcbiAgICAgICAgdGhpcy5kaW1JbmRleGVycyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGFycmF5U2hhcGUgPSBhcnJheS5zaGFwZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5U2hhcGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGRpbVNlbGVjdGlvbiA9IHNlbGVjdGlvbltpXTtcclxuICAgICAgICAgICAgY29uc3QgZGltTGVuZ3RoID0gYXJyYXlTaGFwZVtpXTtcclxuICAgICAgICAgICAgY29uc3QgZGltQ2h1bmtMZW5ndGggPSBhcnJheS5jaHVua3NbaV07XHJcbiAgICAgICAgICAgIGlmIChkaW1TZWxlY3Rpb24gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGRpbVNlbGVjdGlvbiA9IHNsaWNlKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc0ludGVnZXIoZGltU2VsZWN0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaW1JbmRleGVycy5wdXNoKG5ldyBJbnREaW1JbmRleGVyKGRpbVNlbGVjdGlvbiwgZGltTGVuZ3RoLCBkaW1DaHVua0xlbmd0aCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzU2xpY2UoZGltU2VsZWN0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaW1JbmRleGVycy5wdXNoKG5ldyBTbGljZURpbUluZGV4ZXIoZGltU2VsZWN0aW9uLCBkaW1MZW5ndGgsIGRpbUNodW5rTGVuZ3RoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5zcHBvcnRlZCBzZWxlY3Rpb24gaXRlbSBmb3IgYmFzaWMgaW5kZXhpbmc7IGV4cGVjdGVkIGludGVnZXIgb3Igc2xpY2UsIGdvdCAke2RpbVNlbGVjdGlvbn1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNoYXBlID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIHRoaXMuZGltSW5kZXhlcnMpIHtcclxuICAgICAgICAgICAgaWYgKGQgaW5zdGFuY2VvZiBTbGljZURpbUluZGV4ZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hhcGUucHVzaChkLm51bUl0ZW1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRyb3BBeGVzID0gbnVsbDtcclxuICAgIH1cclxuICAgICppdGVyKCkge1xyXG4gICAgICAgIGNvbnN0IGRpbUluZGV4ZXJJdGVyYWJsZXMgPSB0aGlzLmRpbUluZGV4ZXJzLm1hcCh4ID0+ICgoKSA9PiB4Lml0ZXIoKSkpO1xyXG4gICAgICAgIGNvbnN0IGRpbUluZGV4ZXJQcm9kdWN0ID0gcHJvZHVjdCguLi5kaW1JbmRleGVySXRlcmFibGVzKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGRpbVByb2plY3Rpb25zIG9mIGRpbUluZGV4ZXJQcm9kdWN0KSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gZml4IHRoaXMsIEkgdGhpbmsgdGhlIHByb2R1Y3Qgb3V0cHV0cyB0b28gbWFueSBjb21iaW5hdGlvbnNcclxuICAgICAgICAgICAgY29uc3QgY2h1bmtDb29yZHMgPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgY2h1bmtTZWxlY3Rpb24gPSBbXTtcclxuICAgICAgICAgICAgY29uc3Qgb3V0U2VsZWN0aW9uID0gW107XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiBkaW1Qcm9qZWN0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgY2h1bmtDb29yZHMucHVzaCgocCkuZGltQ2h1bmtJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBjaHVua1NlbGVjdGlvbi5wdXNoKChwKS5kaW1DaHVua1NlbGVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHApLmRpbU91dFNlbGVjdGlvbiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dFNlbGVjdGlvbi5wdXNoKChwKS5kaW1PdXRTZWxlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHlpZWxkIHtcclxuICAgICAgICAgICAgICAgIGNodW5rQ29vcmRzLFxyXG4gICAgICAgICAgICAgICAgY2h1bmtTZWxlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBvdXRTZWxlY3Rpb24sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNsYXNzIEludERpbUluZGV4ZXIge1xyXG4gICAgY29uc3RydWN0b3IoZGltU2VsZWN0aW9uLCBkaW1MZW5ndGgsIGRpbUNodW5rTGVuZ3RoKSB7XHJcbiAgICAgICAgZGltU2VsZWN0aW9uID0gbm9ybWFsaXplSW50ZWdlclNlbGVjdGlvbihkaW1TZWxlY3Rpb24sIGRpbUxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5kaW1TZWxlY3Rpb24gPSBkaW1TZWxlY3Rpb247XHJcbiAgICAgICAgdGhpcy5kaW1MZW5ndGggPSBkaW1MZW5ndGg7XHJcbiAgICAgICAgdGhpcy5kaW1DaHVua0xlbmd0aCA9IGRpbUNodW5rTGVuZ3RoO1xyXG4gICAgICAgIHRoaXMubnVtSXRlbXMgPSAxO1xyXG4gICAgfVxyXG4gICAgKml0ZXIoKSB7XHJcbiAgICAgICAgY29uc3QgZGltQ2h1bmtJbmRleCA9IE1hdGguZmxvb3IodGhpcy5kaW1TZWxlY3Rpb24gLyB0aGlzLmRpbUNodW5rTGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBkaW1PZmZzZXQgPSBkaW1DaHVua0luZGV4ICogdGhpcy5kaW1DaHVua0xlbmd0aDtcclxuICAgICAgICBjb25zdCBkaW1DaHVua1NlbGVjdGlvbiA9IHRoaXMuZGltU2VsZWN0aW9uIC0gZGltT2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IGRpbU91dFNlbGVjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgeWllbGQge1xyXG4gICAgICAgICAgICBkaW1DaHVua0luZGV4LFxyXG4gICAgICAgICAgICBkaW1DaHVua1NlbGVjdGlvbixcclxuICAgICAgICAgICAgZGltT3V0U2VsZWN0aW9uLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgU2xpY2VEaW1JbmRleGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGRpbVNlbGVjdGlvbiwgZGltTGVuZ3RoLCBkaW1DaHVua0xlbmd0aCkge1xyXG4gICAgICAgIC8vIE5vcm1hbGl6ZVxyXG4gICAgICAgIGNvbnN0IFtzdGFydCwgc3RvcCwgc3RlcF0gPSBzbGljZUluZGljZXMoZGltU2VsZWN0aW9uLCBkaW1MZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcclxuICAgICAgICB0aGlzLnN0b3AgPSBzdG9wO1xyXG4gICAgICAgIHRoaXMuc3RlcCA9IHN0ZXA7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RlcCA8IDEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5lZ2F0aXZlU3RlcEVycm9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGltTGVuZ3RoID0gZGltTGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuZGltQ2h1bmtMZW5ndGggPSBkaW1DaHVua0xlbmd0aDtcclxuICAgICAgICB0aGlzLm51bUl0ZW1zID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKCh0aGlzLnN0b3AgLSB0aGlzLnN0YXJ0KSAvIHRoaXMuc3RlcCkpO1xyXG4gICAgICAgIHRoaXMubnVtQ2h1bmtzID0gTWF0aC5jZWlsKHRoaXMuZGltTGVuZ3RoIC8gdGhpcy5kaW1DaHVua0xlbmd0aCk7XHJcbiAgICB9XHJcbiAgICAqaXRlcigpIHtcclxuICAgICAgICBjb25zdCBkaW1DaHVua0luZGV4RnJvbSA9IE1hdGguZmxvb3IodGhpcy5zdGFydCAvIHRoaXMuZGltQ2h1bmtMZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IGRpbUNodW5rSW5kZXhUbyA9IE1hdGguY2VpbCh0aGlzLnN0b3AgLyB0aGlzLmRpbUNodW5rTGVuZ3RoKTtcclxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgY2h1bmtzIGluIHJhbmdlXHJcbiAgICAgICAgZm9yIChsZXQgZGltQ2h1bmtJbmRleCA9IGRpbUNodW5rSW5kZXhGcm9tOyBkaW1DaHVua0luZGV4IDwgZGltQ2h1bmtJbmRleFRvOyBkaW1DaHVua0luZGV4KyspIHtcclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBvZmZzZXRzIGZvciBjaHVuayB3aXRoaW4gb3ZlcmFsbCBhcnJheVxyXG4gICAgICAgICAgICBjb25zdCBkaW1PZmZzZXQgPSBkaW1DaHVua0luZGV4ICogdGhpcy5kaW1DaHVua0xlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgZGltTGltaXQgPSBNYXRoLm1pbih0aGlzLmRpbUxlbmd0aCwgKGRpbUNodW5rSW5kZXggKyAxKSAqIHRoaXMuZGltQ2h1bmtMZW5ndGgpO1xyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgY2h1bmsgbGVuZ3RoLCBhY2NvdW50aW5nIGZvciB0cmFpbGluZyBjaHVua1xyXG4gICAgICAgICAgICBjb25zdCBkaW1DaHVua0xlbmd0aCA9IGRpbUxpbWl0IC0gZGltT2Zmc2V0O1xyXG4gICAgICAgICAgICBsZXQgZGltQ2h1bmtTZWxTdGFydDtcclxuICAgICAgICAgICAgbGV0IGRpbUNodW5rU2VsU3RvcDtcclxuICAgICAgICAgICAgbGV0IGRpbU91dE9mZnNldDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnQgPCBkaW1PZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNlbGVjdGlvbiBzdGFydHMgYmVmb3JlIGN1cnJlbnQgY2h1bmtcclxuICAgICAgICAgICAgICAgIGRpbUNodW5rU2VsU3RhcnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluZGVyID0gKGRpbU9mZnNldCAtIHRoaXMuc3RhcnQpICUgdGhpcy5zdGVwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlbWFpbmRlciA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBkaW1DaHVua1NlbFN0YXJ0ICs9IHRoaXMuc3RlcCAtIHJlbWFpbmRlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgbnVtYmVyIG9mIHByZXZpb3VzIGl0ZW1zLCBwcm92aWRlcyBvZmZzZXQgaW50byBvdXRwdXQgYXJyYXlcclxuICAgICAgICAgICAgICAgIGRpbU91dE9mZnNldCA9IE1hdGguY2VpbCgoZGltT2Zmc2V0IC0gdGhpcy5zdGFydCkgLyB0aGlzLnN0ZXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gU2VsZWN0aW9uIHN0YXJ0cyB3aXRoaW4gY3VycmVudCBjaHVua1xyXG4gICAgICAgICAgICAgICAgZGltQ2h1bmtTZWxTdGFydCA9IHRoaXMuc3RhcnQgLSBkaW1PZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBkaW1PdXRPZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3AgPiBkaW1MaW1pdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gU2VsZWN0aW9uIGVuZHMgYWZ0ZXIgY3VycmVudCBjaHVua1xyXG4gICAgICAgICAgICAgICAgZGltQ2h1bmtTZWxTdG9wID0gZGltQ2h1bmtMZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZWxlY3Rpb24gZW5kcyB3aXRoaW4gY3VycmVudCBjaHVua1xyXG4gICAgICAgICAgICAgICAgZGltQ2h1bmtTZWxTdG9wID0gdGhpcy5zdG9wIC0gZGltT2Zmc2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGRpbUNodW5rU2VsZWN0aW9uID0gc2xpY2UoZGltQ2h1bmtTZWxTdGFydCwgZGltQ2h1bmtTZWxTdG9wLCB0aGlzLnN0ZXApO1xyXG4gICAgICAgICAgICBjb25zdCBkaW1DaHVua051bUl0ZW1zID0gTWF0aC5jZWlsKChkaW1DaHVua1NlbFN0b3AgLSBkaW1DaHVua1NlbFN0YXJ0KSAvIHRoaXMuc3RlcCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpbU91dFNlbGVjdGlvbiA9IHNsaWNlKGRpbU91dE9mZnNldCwgZGltT3V0T2Zmc2V0ICsgZGltQ2h1bmtOdW1JdGVtcyk7XHJcbiAgICAgICAgICAgIHlpZWxkIHtcclxuICAgICAgICAgICAgICAgIGRpbUNodW5rSW5kZXgsXHJcbiAgICAgICAgICAgICAgICBkaW1DaHVua1NlbGVjdGlvbixcclxuICAgICAgICAgICAgICAgIGRpbU91dFNlbGVjdGlvbixcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIFRoaXMgc2hvdWxkIGJlIHRydWUgb25seSBpZiB0aGlzIGphdmFzY3JpcHQgaXMgZ2V0dGluZyBleGVjdXRlZCBpbiBOb2RlLlxyXG4gKi9cclxuY29uc3QgSVNfTk9ERSA9IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlO1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXHJcbmZ1bmN0aW9uIG5vb3AoKSB7IH1cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcclxuZnVuY3Rpb24gbm9ybWFsaXplU3RvcmFnZVBhdGgocGF0aCkge1xyXG4gICAgaWYgKHBhdGggPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIH1cclxuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgU3RyaW5nKSB7XHJcbiAgICAgICAgcGF0aCA9IHBhdGgudmFsdWVPZigpO1xyXG4gICAgfVxyXG4gICAgLy8gY29udmVydCBiYWNrc2xhc2ggdG8gZm9yd2FyZCBzbGFzaFxyXG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFxcXC9nLCBcIi9cIik7XHJcbiAgICAvLyBlbnN1cmUgbm8gbGVhZGluZyBzbGFzaFxyXG4gICAgd2hpbGUgKHBhdGgubGVuZ3RoID4gMCAmJiBwYXRoWzBdID09PSAnLycpIHtcclxuICAgICAgICBwYXRoID0gcGF0aC5zbGljZSgxKTtcclxuICAgIH1cclxuICAgIC8vIGVuc3VyZSBubyB0cmFpbGluZyBzbGFzaFxyXG4gICAgd2hpbGUgKHBhdGgubGVuZ3RoID4gMCAmJiBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICcvJykge1xyXG4gICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIHBhdGgubGVuZ3RoIC0gMSk7XHJcbiAgICB9XHJcbiAgICAvLyBjb2xsYXBzZSBhbnkgcmVwZWF0ZWQgc2xhc2hlc1xyXG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwvXFwvKy9nLCBcIi9cIik7XHJcbiAgICAvLyBkb24ndCBhbGxvdyBwYXRoIHNlZ21lbnRzIHdpdGgganVzdCAnLicgb3IgJy4uJ1xyXG4gICAgY29uc3Qgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcvJyk7XHJcbiAgICBmb3IgKGNvbnN0IHMgb2Ygc2VnbWVudHMpIHtcclxuICAgICAgICBpZiAocyA9PT0gXCIuXCIgfHwgcyA9PT0gXCIuLlwiKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwicGF0aCBjb250YWluaW5nICcuJyBvciAnLi4nIHNlZ21lbnQgbm90IGFsbG93ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhdGg7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplU2hhcGUoc2hhcGUpIHtcclxuICAgIGlmICh0eXBlb2Ygc2hhcGUgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICBzaGFwZSA9IFtzaGFwZV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2hhcGUubWFwKHggPT4gTWF0aC5mbG9vcih4KSk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplQ2h1bmtzKGNodW5rcywgc2hhcGUpIHtcclxuICAgIC8vIEFzc3VtZSBzaGFwZSBpcyBhbHJlYWR5IG5vcm1hbGl6ZWRcclxuICAgIGlmIChjaHVua3MgPT09IG51bGwgfHwgY2h1bmtzID09PSB0cnVlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2h1bmsgZ3Vlc3NpbmcgaXMgbm90IHN1cHBvcnRlZCB5ZXRcIik7XHJcbiAgICB9XHJcbiAgICBpZiAoY2h1bmtzID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiBzaGFwZTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgY2h1bmtzID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgY2h1bmtzID0gW2NodW5rc107XHJcbiAgICB9XHJcbiAgICAvLyBoYW5kbGUgdW5kZXJzcGVjaWZpZWQgY2h1bmtzXHJcbiAgICBpZiAoY2h1bmtzLmxlbmd0aCA8IHNoYXBlLmxlbmd0aCkge1xyXG4gICAgICAgIC8vIGFzc3VtZSBjaHVua3MgYWNyb3NzIHJlbWFpbmluZyBkaW1lbnNpb25zXHJcbiAgICAgICAgY2h1bmtzID0gY2h1bmtzLmNvbmNhdChzaGFwZS5zbGljZShjaHVua3MubGVuZ3RoKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2h1bmtzLm1hcCgoeCwgaWR4KSA9PiB7XHJcbiAgICAgICAgLy8gaGFuZGxlIG51bGwgb3IgLTEgaW4gY2h1bmtzXHJcbiAgICAgICAgaWYgKHggPT09IC0xIHx8IHggPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNoYXBlW2lkeF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih4KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVPcmRlcihvcmRlcikge1xyXG4gICAgb3JkZXIgPSBvcmRlci50b1VwcGVyQ2FzZSgpO1xyXG4gICAgcmV0dXJuIG9yZGVyO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUR0eXBlKGR0eXBlKSB7XHJcbiAgICByZXR1cm4gZHR5cGU7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplRmlsbFZhbHVlKGZpbGxWYWx1ZSkge1xyXG4gICAgcmV0dXJuIGZpbGxWYWx1ZTtcclxufVxyXG4vKipcclxuICogRGV0ZXJtaW5lIHdoZXRoZXIgYGl0ZW1gIHNwZWNpZmllcyBhIGNvbXBsZXRlIHNsaWNlIG9mIGFycmF5IHdpdGggdGhlXHJcbiAqICBnaXZlbiBgc2hhcGVgLiBVc2VkIHRvIG9wdGltaXplIF9fc2V0aXRlbV9fIG9wZXJhdGlvbnMgb24gY2h1bmtzXHJcbiAqIEBwYXJhbSBpdGVtXHJcbiAqIEBwYXJhbSBzaGFwZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNUb3RhbFNsaWNlKGl0ZW0sIHNoYXBlKSB7XHJcbiAgICBpZiAoaXRlbSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW0pKSB7XHJcbiAgICAgICAgaXRlbSA9IFtpdGVtXTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4oaXRlbS5sZW5ndGgsIHNoYXBlLmxlbmd0aCk7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGl0ID0gaXRlbVtpXTtcclxuICAgICAgICBpZiAoaXQgPT09IG51bGwpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGlmIChpc1NsaWNlKGl0KSkge1xyXG4gICAgICAgICAgICBjb25zdCBzID0gaXQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzU3RlcE9uZSA9IHMuc3RlcCA9PT0gMSB8fCBzLnN0ZXAgPT09IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChzLnN0YXJ0ID09PSBudWxsICYmIHMuc3RvcCA9PT0gbnVsbCAmJiBpc1N0ZXBPbmUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgocy5zdG9wIC0gcy5zdGFydCkgPT09IHNoYXBlW2ldICYmIGlzU3RlcE9uZSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgLy8gfSBlbHNlIHtcclxuICAgICAgICAvLyAgICAgY29uc29sZS5lcnJvcihgaXNUb3RhbFNsaWNlIHVuZXhwZWN0ZWQgbm9uLXNsaWNlLCBnb3QgJHtpdH1gKTtcclxuICAgICAgICAvLyAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIC8vIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgZm9yID09PSBlcXVhbGl0eSBvZiBhbGwgZWxlbWVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcnJheUVxdWFsczFEKGEsIGIpIHtcclxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLypcclxuICogRGV0ZXJtaW5lcyBcIkNcIiBvcmRlciBzdHJpZGVzIGZvciBhIGdpdmVuIHNoYXBlIGFycmF5LlxyXG4gKiBTdHJpZGVzIHByb3ZpZGUgaW50ZWdlciBzdGVwcyBpbiBlYWNoIGRpbWVudGlvbiB0byB0cmF2ZXJzZSBhbiBuZGFycmF5LlxyXG4gKlxyXG4gKiBOT1RFOiAtIFRoZXNlIHN0cmlkZXMgaGVyZSBhcmUgZGlzdGluY3QgZnJvbSBudW1weS5uZGFycmF5LnN0cmlkZXMsIHdoaWNoIGRlc2NyaWJlIGFjdHVhbCBieXRlIHN0ZXBzLlxyXG4gKiAgICAgICAtIFN0cmlkZXMgYXJlIGFzc3VtZWQgdG8gYmUgY29udGlndW91cywgc28gaW5pdGlhbCBzdGVwIGlzIDEuIFRodXMsIG91dHB1dCB3aWxsIGFsd2F5cyBiZSBbWFgsIFhYLCAxXS5cclxuICovXHJcbmZ1bmN0aW9uIGdldFN0cmlkZXMoc2hhcGUpIHtcclxuICAgIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc2NpanMvbmRhcnJheS9ibG9iL21hc3Rlci9uZGFycmF5LmpzI0wzMjYtTDMzMFxyXG4gICAgY29uc3QgbmRpbSA9IHNoYXBlLmxlbmd0aDtcclxuICAgIGNvbnN0IHN0cmlkZXMgPSBBcnJheShuZGltKTtcclxuICAgIGxldCBzdGVwID0gMTsgLy8gaW5pdCBzdGVwXHJcbiAgICBmb3IgKGxldCBpID0gbmRpbSAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgc3RyaWRlc1tpXSA9IHN0ZXA7XHJcbiAgICAgICAgc3RlcCAqPSBzaGFwZVtpXTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdHJpZGVzO1xyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmVVcmwocm9vdCwgcGF0aCkge1xyXG4gICAgY29uc3QgYmFzZSA9IHR5cGVvZiByb290ID09PSAnc3RyaW5nJyA/IG5ldyBVUkwocm9vdCkgOiByb290O1xyXG4gICAgaWYgKCFiYXNlLnBhdGhuYW1lLmVuZHNXaXRoKCcvJykpIHtcclxuICAgICAgICAvLyBlbnN1cmUgdHJhaWxpbmcgc2xhc2ggc28gdGhhdCBiYXNlIGlzIHJlc29sdmVkIGFzIF9kaXJlY3RvcnlfXHJcbiAgICAgICAgYmFzZS5wYXRobmFtZSArPSAnLyc7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXNvbHZlZCA9IG5ldyBVUkwocGF0aCwgYmFzZSk7XHJcbiAgICAvLyBjb3B5IHNlYXJjaCBwYXJhbXMgdG8gbmV3IFVSTFxyXG4gICAgcmVzb2x2ZWQuc2VhcmNoID0gYmFzZS5zZWFyY2g7XHJcbiAgICByZXR1cm4gcmVzb2x2ZWQuaHJlZjtcclxufVxyXG4vKipcclxuICogU3dhcHMgYnl0ZSBvcmRlciBpbi1wbGFjZSBmb3IgYSBnaXZlbiBUeXBlZEFycmF5LlxyXG4gKiBVc2VkIHRvIGZsaXAgZW5kaWFuLW5lc3Mgd2hlbiBnZXR0aW5nL3NldHRpbmcgY2h1bmtzIGZyb20vdG8gemFyciBzdG9yZS5cclxuICogQHBhcmFtIHNyYyBUeXBlZEFycmF5XHJcbiAqL1xyXG5mdW5jdGlvbiBieXRlU3dhcElucGxhY2Uoc3JjKSB7XHJcbiAgICBjb25zdCBiID0gc3JjLkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgaWYgKGIgPT09IDEpXHJcbiAgICAgICAgcmV0dXJuOyAvLyBubyBzd2FwcGluZyBuZWVkZWRcclxuICAgIGlmIChJU19OT0RFKSB7XHJcbiAgICAgICAgLy8gVXNlIGJ1aWx0aW4gbWV0aG9kcyBmb3Igc3dhcHBpbmcgaWYgaW4gTm9kZSBlbnZpcm9ubWVudFxyXG4gICAgICAgIGNvbnN0IGJ5dGVzID0gQnVmZmVyLmZyb20oc3JjLmJ1ZmZlciwgc3JjLmJ5dGVPZmZzZXQsIHNyYy5sZW5ndGggKiBiKTtcclxuICAgICAgICBpZiAoYiA9PT0gMilcclxuICAgICAgICAgICAgYnl0ZXMuc3dhcDE2KCk7XHJcbiAgICAgICAgaWYgKGIgPT09IDQpXHJcbiAgICAgICAgICAgIGJ5dGVzLnN3YXAzMigpO1xyXG4gICAgICAgIGlmIChiID09PSA4KVxyXG4gICAgICAgICAgICBieXRlcy5zd2FwNjQoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBJbiBicm93c2VyLCBuZWVkIHRvIGZsaXAgbWFudWFsbHlcclxuICAgIC8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vemJqb3Juc29uL25vZGUtYnN3YXAvYmxvYi9tYXN0ZXIvYnN3YXAuanNcclxuICAgIGNvbnN0IGZsaXBwZXIgPSBuZXcgVWludDhBcnJheShzcmMuYnVmZmVyLCBzcmMuYnl0ZU9mZnNldCwgc3JjLmxlbmd0aCAqIGIpO1xyXG4gICAgY29uc3QgbnVtRmxpcHMgPSBiIC8gMjtcclxuICAgIGNvbnN0IGVuZEJ5dGVJbmRleCA9IGIgLSAxO1xyXG4gICAgbGV0IHQ7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZsaXBwZXIubGVuZ3RoOyBpICs9IGIpIHtcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUZsaXBzOyBqKyspIHtcclxuICAgICAgICAgICAgdCA9IGZsaXBwZXJbaSArIGpdO1xyXG4gICAgICAgICAgICBmbGlwcGVyW2kgKyBqXSA9IGZsaXBwZXJbaSArIGVuZEJ5dGVJbmRleCAtIGpdO1xyXG4gICAgICAgICAgICBmbGlwcGVyW2kgKyBlbmRCeXRlSW5kZXggLSBqXSA9IHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgY29weSBvZiBhIFR5cGVkQXJyYXkgYW5kIHN3YXBzIGJ5dGVzLlxyXG4gKiBVc2VkIHRvIGZsaXAgZW5kaWFuLW5lc3Mgd2hlbiBnZXR0aW5nL3NldHRpbmcgY2h1bmtzIGZyb20vdG8gemFyciBzdG9yZS5cclxuICogQHBhcmFtIHNyYyBUeXBlZEFycmF5XHJcbiAqL1xyXG5mdW5jdGlvbiBieXRlU3dhcChzcmMpIHtcclxuICAgIGNvbnN0IGNvcHkgPSBzcmMuc2xpY2UoKTtcclxuICAgIGJ5dGVTd2FwSW5wbGFjZShjb3B5KTtcclxuICAgIHJldHVybiBjb3B5O1xyXG59XHJcbmZ1bmN0aW9uIGNvbnZlcnRDb2xNYWpvclRvUm93TWFqb3IyRChzcmMsIG91dCwgc2hhcGUpIHtcclxuICAgIGxldCBpZHggPSAwO1xyXG4gICAgY29uc3Qgc2hhcGUwID0gc2hhcGVbMF07XHJcbiAgICBjb25zdCBzaGFwZTEgPSBzaGFwZVsxXTtcclxuICAgIGNvbnN0IHN0cmlkZTAgPSBzaGFwZTE7XHJcbiAgICBmb3IgKGxldCBpMSA9IDA7IGkxIDwgc2hhcGUxOyBpMSsrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaTAgPSAwOyBpMCA8IHNoYXBlMDsgaTArKykge1xyXG4gICAgICAgICAgICBvdXRbaTAgKiBzdHJpZGUwICsgaTFdID0gc3JjW2lkeCsrXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29udmVydENvbE1ham9yVG9Sb3dNYWpvcjNEKHNyYywgb3V0LCBzaGFwZSkge1xyXG4gICAgbGV0IGlkeCA9IDA7XHJcbiAgICBjb25zdCBzaGFwZTAgPSBzaGFwZVswXTtcclxuICAgIGNvbnN0IHNoYXBlMSA9IHNoYXBlWzFdO1xyXG4gICAgY29uc3Qgc2hhcGUyID0gc2hhcGVbMl07XHJcbiAgICBjb25zdCBzdHJpZGUwID0gc2hhcGUyICogc2hhcGUxO1xyXG4gICAgY29uc3Qgc3RyaWRlMSA9IHNoYXBlMjtcclxuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBzaGFwZTI7IGkyKyspIHtcclxuICAgICAgICBmb3IgKGxldCBpMSA9IDA7IGkxIDwgc2hhcGUxOyBpMSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkwID0gMDsgaTAgPCBzaGFwZTA7IGkwKyspIHtcclxuICAgICAgICAgICAgICAgIG91dFtpMCAqIHN0cmlkZTAgKyBpMSAqIHN0cmlkZTEgKyBpMl0gPSBzcmNbaWR4KytdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvbnZlcnRDb2xNYWpvclRvUm93TWFqb3I0RChzcmMsIG91dCwgc2hhcGUpIHtcclxuICAgIGxldCBpZHggPSAwO1xyXG4gICAgY29uc3Qgc2hhcGUwID0gc2hhcGVbMF07XHJcbiAgICBjb25zdCBzaGFwZTEgPSBzaGFwZVsxXTtcclxuICAgIGNvbnN0IHNoYXBlMiA9IHNoYXBlWzJdO1xyXG4gICAgY29uc3Qgc2hhcGUzID0gc2hhcGVbM107XHJcbiAgICBjb25zdCBzdHJpZGUwID0gc2hhcGUzICogc2hhcGUyICogc2hhcGUxO1xyXG4gICAgY29uc3Qgc3RyaWRlMSA9IHNoYXBlMyAqIHNoYXBlMjtcclxuICAgIGNvbnN0IHN0cmlkZTIgPSBzaGFwZTM7XHJcbiAgICBmb3IgKGxldCBpMyA9IDA7IGkzIDwgc2hhcGUzOyBpMysrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHNoYXBlMjsgaTIrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpMSA9IDA7IGkxIDwgc2hhcGUxOyBpMSsrKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpMCA9IDA7IGkwIDwgc2hhcGUwOyBpMCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0W2kwICogc3RyaWRlMCArIGkxICogc3RyaWRlMSArIGkyICogc3RyaWRlMiArIGkzXSA9IHNyY1tpZHgrK107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29udmVydENvbE1ham9yVG9Sb3dNYWpvckdlbmVyaWMoc3JjLCBvdXQsIHNoYXBlKSB7XHJcbiAgICBjb25zdCBuRGltcyA9IHNoYXBlLmxlbmd0aDtcclxuICAgIGNvbnN0IHNpemUgPSBzaGFwZS5yZWR1Y2UoKHIsIGEpID0+IHIgKiBhKTtcclxuICAgIGNvbnN0IHJvd01ham9yU3RyaWRlcyA9IHNoYXBlLm1hcCgoXywgaSkgPT4gaSArIDEgPT09IG5EaW1zID8gMSA6IHNoYXBlLnNsaWNlKGkgKyAxKS5yZWR1Y2UoKHIsIGEpID0+IHIgKiBhLCAxKSk7XHJcbiAgICBjb25zdCBpbmRleCA9IEFycmF5KG5EaW1zKS5maWxsKDApO1xyXG4gICAgZm9yIChsZXQgY29sTWFqb3JJZHggPSAwOyBjb2xNYWpvcklkeCA8IHNpemU7IGNvbE1ham9ySWR4KyspIHtcclxuICAgICAgICBsZXQgcm93TWFqb3JJZHggPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IG5EaW1zOyBkaW0rKykge1xyXG4gICAgICAgICAgICByb3dNYWpvcklkeCArPSBpbmRleFtkaW1dICogcm93TWFqb3JTdHJpZGVzW2RpbV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG91dFtyb3dNYWpvcklkeF0gPSBzcmNbY29sTWFqb3JJZHhdO1xyXG4gICAgICAgIGluZGV4WzBdICs9IDE7XHJcbiAgICAgICAgLy8gSGFuZGxlIGNhcnJ5LW92ZXJcclxuICAgICAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBuRGltczsgZGltKyspIHtcclxuICAgICAgICAgICAgaWYgKGluZGV4W2RpbV0gPT09IHNoYXBlW2RpbV0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChkaW0gKyAxID09PSBuRGltcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGluZGV4W2RpbV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgaW5kZXhbZGltICsgMV0gKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jb25zdCBjb2xNYWpvclRvUm93TWFqb3JDb252ZXJ0ZXJzID0ge1xyXG4gICAgWzBdOiBub29wLFxyXG4gICAgWzFdOiBub29wLFxyXG4gICAgWzJdOiBjb252ZXJ0Q29sTWFqb3JUb1Jvd01ham9yMkQsXHJcbiAgICBbM106IGNvbnZlcnRDb2xNYWpvclRvUm93TWFqb3IzRCxcclxuICAgIFs0XTogY29udmVydENvbE1ham9yVG9Sb3dNYWpvcjRELFxyXG59O1xyXG4vKipcclxuICogUmV3cml0ZXMgYSBjb3B5IG9mIGEgVHlwZWRBcnJheSB3aGlsZSBjb252ZXJ0aW5nIGl0IGZyb20gY29sdW1uLW1ham9yIChGLW9yZGVyKSB0byByb3ctbWFqb3IgKEMtb3JkZXIpLlxyXG4gKiBAcGFyYW0gc3JjIFR5cGVkQXJyYXlcclxuICogQHBhcmFtIG91dCBUeXBlZEFycmF5XHJcbiAqIEBwYXJhbSBzaGFwZSBudW1iZXJbXVxyXG4gKi9cclxuZnVuY3Rpb24gY29udmVydENvbE1ham9yVG9Sb3dNYWpvcihzcmMsIG91dCwgc2hhcGUpIHtcclxuICAgIHJldHVybiAoY29sTWFqb3JUb1Jvd01ham9yQ29udmVydGVyc1tzaGFwZS5sZW5ndGhdIHx8IGNvbnZlcnRDb2xNYWpvclRvUm93TWFqb3JHZW5lcmljKShzcmMsIG91dCwgc2hhcGUpO1xyXG59XHJcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJMaWtlKG9iaikge1xyXG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiICYmIG9iaiBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoSVNfTk9ERSkgeyAvLyBOZWNlc3NhcnkgZm9yIE5vZGUuanMgZm9yIHNvbWUgcmVhc29uLi5cclxuICAgICAgICByZXR1cm4gb2JqLnRvU3RyaW5nKCkuc3RhcnRzV2l0aChcIltvYmplY3QgQXJyYXlCdWZmZXJdXCIpXHJcbiAgICAgICAgICAgIHx8IG9iai50b1N0cmluZygpLnN0YXJ0c1dpdGgoXCJbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxuXG5jb25zdCBBUlJBWV9NRVRBX0tFWSA9IFwiLnphcnJheVwiO1xyXG5jb25zdCBHUk9VUF9NRVRBX0tFWSA9IFwiLnpncm91cFwiO1xyXG5jb25zdCBBVFRSU19NRVRBX0tFWSA9IFwiLnphdHRyc1wiO1xuXG4vKipcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHN0b3JlIGNvbnRhaW5zIGFuIGFycmF5IGF0IHRoZSBnaXZlbiBsb2dpY2FsIHBhdGguXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBjb250YWluc0FycmF5KHN0b3JlLCBwYXRoID0gbnVsbCkge1xyXG4gICAgcGF0aCA9IG5vcm1hbGl6ZVN0b3JhZ2VQYXRoKHBhdGgpO1xyXG4gICAgY29uc3QgcHJlZml4ID0gcGF0aFRvUHJlZml4KHBhdGgpO1xyXG4gICAgY29uc3Qga2V5ID0gcHJlZml4ICsgQVJSQVlfTUVUQV9LRVk7XHJcbiAgICByZXR1cm4gc3RvcmUuY29udGFpbnNJdGVtKGtleSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybiB0cnVlIGlmIHRoZSBzdG9yZSBjb250YWlucyBhIGdyb3VwIGF0IHRoZSBnaXZlbiBsb2dpY2FsIHBhdGguXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBjb250YWluc0dyb3VwKHN0b3JlLCBwYXRoID0gbnVsbCkge1xyXG4gICAgcGF0aCA9IG5vcm1hbGl6ZVN0b3JhZ2VQYXRoKHBhdGgpO1xyXG4gICAgY29uc3QgcHJlZml4ID0gcGF0aFRvUHJlZml4KHBhdGgpO1xyXG4gICAgY29uc3Qga2V5ID0gcHJlZml4ICsgR1JPVVBfTUVUQV9LRVk7XHJcbiAgICByZXR1cm4gc3RvcmUuY29udGFpbnNJdGVtKGtleSk7XHJcbn1cclxuZnVuY3Rpb24gcGF0aFRvUHJlZml4KHBhdGgpIHtcclxuICAgIC8vIGFzc3VtZSBwYXRoIGFscmVhZHkgbm9ybWFsaXplZFxyXG4gICAgaWYgKHBhdGgubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHJldHVybiBwYXRoICsgJy8nO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICcnO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHJlcXVpcmVQYXJlbnRHcm91cChzdG9yZSwgcGF0aCwgY2h1bmtTdG9yZSwgb3ZlcndyaXRlKSB7XHJcbiAgICAvLyBBc3N1bWUgcGF0aCBpcyBub3JtYWxpemVkXHJcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xyXG4gICAgbGV0IHAgPSBcIlwiO1xyXG4gICAgZm9yIChjb25zdCBzIG9mIHNlZ21lbnRzLnNsaWNlKDAsIHNlZ21lbnRzLmxlbmd0aCAtIDEpKSB7XHJcbiAgICAgICAgcCArPSBzO1xyXG4gICAgICAgIGlmIChhd2FpdCBjb250YWluc0FycmF5KHN0b3JlLCBwKSkge1xyXG4gICAgICAgICAgICBhd2FpdCBpbml0R3JvdXBNZXRhZGF0YShzdG9yZSwgcCwgb3ZlcndyaXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWF3YWl0IGNvbnRhaW5zR3JvdXAoc3RvcmUsIHApKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGluaXRHcm91cE1ldGFkYXRhKHN0b3JlLCBwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcCArPSBcIi9cIjtcclxuICAgIH1cclxufVxyXG5hc3luYyBmdW5jdGlvbiBpbml0R3JvdXBNZXRhZGF0YShzdG9yZSwgcGF0aCA9IG51bGwsIG92ZXJ3cml0ZSA9IGZhbHNlKSB7XHJcbiAgICBwYXRoID0gbm9ybWFsaXplU3RvcmFnZVBhdGgocGF0aCk7XHJcbiAgICAvLyBHdWFyZCBjb25kaXRpb25zXHJcbiAgICBpZiAob3ZlcndyaXRlKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJHcm91cCBvdmVyd3JpdGluZyBub3QgaW1wbGVtZW50ZWQgeWV0IDooXCIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYXdhaXQgY29udGFpbnNBcnJheShzdG9yZSwgcGF0aCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgQ29udGFpbnNBcnJheUVycm9yKHBhdGgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYXdhaXQgY29udGFpbnNHcm91cChzdG9yZSwgcGF0aCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgQ29udGFpbnNHcm91cEVycm9yKHBhdGgpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbWV0YWRhdGEgPSB7IHphcnJfZm9ybWF0OiAyIH07XHJcbiAgICBjb25zdCBrZXkgPSBwYXRoVG9QcmVmaXgocGF0aCkgKyBHUk9VUF9NRVRBX0tFWTtcclxuICAgIGF3YWl0IHN0b3JlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xyXG59XHJcbi8qKlxyXG4gKiAgSW5pdGlhbGl6ZSBhIGdyb3VwIHN0b3JlLiBOb3RlIHRoYXQgdGhpcyBpcyBhIGxvdy1sZXZlbCBmdW5jdGlvbiBhbmQgdGhlcmUgc2hvdWxkIGJlIG5vXHJcbiAqICBuZWVkIHRvIGNhbGwgdGhpcyBkaXJlY3RseSBmcm9tIHVzZXIgY29kZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGluaXRHcm91cChzdG9yZSwgcGF0aCA9IG51bGwsIGNodW5rU3RvcmUgPSBudWxsLCBvdmVyd3JpdGUgPSBmYWxzZSkge1xyXG4gICAgcGF0aCA9IG5vcm1hbGl6ZVN0b3JhZ2VQYXRoKHBhdGgpO1xyXG4gICAgYXdhaXQgcmVxdWlyZVBhcmVudEdyb3VwKHN0b3JlLCBwYXRoLCBjaHVua1N0b3JlLCBvdmVyd3JpdGUpO1xyXG4gICAgYXdhaXQgaW5pdEdyb3VwTWV0YWRhdGEoc3RvcmUsIHBhdGgsIG92ZXJ3cml0ZSk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gaW5pdEFycmF5TWV0YWRhdGEoc3RvcmUsIHNoYXBlLCBjaHVua3MsIGR0eXBlLCBwYXRoLCBjb21wcmVzc29yLCBmaWxsVmFsdWUsIG9yZGVyLCBvdmVyd3JpdGUsIGNodW5rU3RvcmUsIGZpbHRlcnMsIGRpbWVuc2lvblNlcGFyYXRvcikge1xyXG4gICAgLy8gR3VhcmQgY29uZGl0aW9uc1xyXG4gICAgaWYgKG92ZXJ3cml0ZSkge1xyXG4gICAgICAgIHRocm93IEVycm9yKFwiQXJyYXkgb3ZlcndyaXRpbmcgbm90IGltcGxlbWVudGVkIHlldCA6KFwiKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGF3YWl0IGNvbnRhaW5zQXJyYXkoc3RvcmUsIHBhdGgpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IENvbnRhaW5zQXJyYXlFcnJvcihwYXRoKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGF3YWl0IGNvbnRhaW5zR3JvdXAoc3RvcmUsIHBhdGgpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IENvbnRhaW5zR3JvdXBFcnJvcihwYXRoKTtcclxuICAgIH1cclxuICAgIC8vIE5vcm1hbGl6ZSBtZXRhZGF0YSwgIGRvZXMgdHlwZSBjaGVja2luZyB0b28uXHJcbiAgICBkdHlwZSA9IG5vcm1hbGl6ZUR0eXBlKGR0eXBlKTtcclxuICAgIHNoYXBlID0gbm9ybWFsaXplU2hhcGUoc2hhcGUpO1xyXG4gICAgY2h1bmtzID0gbm9ybWFsaXplQ2h1bmtzKGNodW5rcywgc2hhcGUpO1xyXG4gICAgb3JkZXIgPSBub3JtYWxpemVPcmRlcihvcmRlcik7XHJcbiAgICBmaWxsVmFsdWUgPSBub3JtYWxpemVGaWxsVmFsdWUoZmlsbFZhbHVlKTtcclxuICAgIGlmIChmaWx0ZXJzICE9PSBudWxsICYmIGZpbHRlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHRocm93IEVycm9yKFwiRmlsdGVycyBhcmUgbm90IHN1cHBvcnRlZCB5ZXRcIik7XHJcbiAgICB9XHJcbiAgICBsZXQgc2VyaWFsaXplZEZpbGxWYWx1ZSA9IGZpbGxWYWx1ZTtcclxuICAgIGlmICh0eXBlb2YgZmlsbFZhbHVlID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihmaWxsVmFsdWUpKVxyXG4gICAgICAgICAgICBzZXJpYWxpemVkRmlsbFZhbHVlID0gXCJOYU5cIjtcclxuICAgICAgICBpZiAoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZID09PSBmaWxsVmFsdWUpXHJcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRGaWxsVmFsdWUgPSBcIkluZmluaXR5XCI7XHJcbiAgICAgICAgaWYgKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA9PT0gZmlsbFZhbHVlKVxyXG4gICAgICAgICAgICBzZXJpYWxpemVkRmlsbFZhbHVlID0gXCItSW5maW5pdHlcIjtcclxuICAgIH1cclxuICAgIGZpbHRlcnMgPSBudWxsO1xyXG4gICAgY29uc3QgbWV0YWRhdGEgPSB7XHJcbiAgICAgICAgemFycl9mb3JtYXQ6IDIsXHJcbiAgICAgICAgc2hhcGU6IHNoYXBlLFxyXG4gICAgICAgIGNodW5rczogY2h1bmtzLFxyXG4gICAgICAgIGR0eXBlOiBkdHlwZSxcclxuICAgICAgICBmaWxsX3ZhbHVlOiBzZXJpYWxpemVkRmlsbFZhbHVlLFxyXG4gICAgICAgIG9yZGVyOiBvcmRlcixcclxuICAgICAgICBjb21wcmVzc29yOiBjb21wcmVzc29yLFxyXG4gICAgICAgIGZpbHRlcnM6IGZpbHRlcnMsXHJcbiAgICB9O1xyXG4gICAgaWYgKGRpbWVuc2lvblNlcGFyYXRvcikge1xyXG4gICAgICAgIG1ldGFkYXRhLmRpbWVuc2lvbl9zZXBhcmF0b3IgPSBkaW1lbnNpb25TZXBhcmF0b3I7XHJcbiAgICB9XHJcbiAgICBjb25zdCBtZXRhS2V5ID0gcGF0aFRvUHJlZml4KHBhdGgpICsgQVJSQVlfTUVUQV9LRVk7XHJcbiAgICBhd2FpdCBzdG9yZS5zZXRJdGVtKG1ldGFLZXksIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSk7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIEluaXRpYWxpemUgYW4gYXJyYXkgc3RvcmUgd2l0aCB0aGUgZ2l2ZW4gY29uZmlndXJhdGlvbi4gTm90ZSB0aGF0IHRoaXMgaXMgYSBsb3ctbGV2ZWxcclxuICogZnVuY3Rpb24gYW5kIHRoZXJlIHNob3VsZCBiZSBubyBuZWVkIHRvIGNhbGwgdGhpcyBkaXJlY3RseSBmcm9tIHVzZXIgY29kZVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gaW5pdEFycmF5KHN0b3JlLCBzaGFwZSwgY2h1bmtzLCBkdHlwZSwgcGF0aCA9IG51bGwsIGNvbXByZXNzb3IgPSBudWxsLCBmaWxsVmFsdWUgPSBudWxsLCBvcmRlciA9IFwiQ1wiLCBvdmVyd3JpdGUgPSBmYWxzZSwgY2h1bmtTdG9yZSA9IG51bGwsIGZpbHRlcnMgPSBudWxsLCBkaW1lbnNpb25TZXBhcmF0b3IpIHtcclxuICAgIHBhdGggPSBub3JtYWxpemVTdG9yYWdlUGF0aChwYXRoKTtcclxuICAgIGF3YWl0IHJlcXVpcmVQYXJlbnRHcm91cChzdG9yZSwgcGF0aCwgY2h1bmtTdG9yZSwgb3ZlcndyaXRlKTtcclxuICAgIGF3YWl0IGluaXRBcnJheU1ldGFkYXRhKHN0b3JlLCBzaGFwZSwgY2h1bmtzLCBkdHlwZSwgcGF0aCwgY29tcHJlc3NvciwgZmlsbFZhbHVlLCBvcmRlciwgb3ZlcndyaXRlLCBjaHVua1N0b3JlLCBmaWx0ZXJzLCBkaW1lbnNpb25TZXBhcmF0b3IpO1xyXG59XG5cbmZ1bmN0aW9uIHBhcnNlTWV0YWRhdGEocykge1xyXG4gICAgLy8gSGVyZSB3ZSBhbGxvdyB0aGF0IGEgc3RvcmUgbWF5IHJldHVybiBhbiBhbHJlYWR5LXBhcnNlZCBtZXRhZGF0YSBvYmplY3QsXHJcbiAgICAvLyBvciBhIHN0cmluZyBvZiBKU09OIHRoYXQgd2Ugd2lsbCBwYXJzZSBoZXJlLiBXZSBhbGxvdyBmb3IgYW4gYWxyZWFkeS1wYXJzZWRcclxuICAgIC8vIG9iamVjdCB0byBhY2NvbW1vZGF0ZSBhIGNvbnNvbGlkYXRlZCBtZXRhZGF0YSBzdG9yZSwgd2hlcmUgYWxsIHRoZSBtZXRhZGF0YSBmb3JcclxuICAgIC8vIGFsbCBncm91cHMgYW5kIGFycmF5cyB3aWxsIGFscmVhZHkgaGF2ZSBiZWVuIHBhcnNlZCBmcm9tIEpTT04uXHJcbiAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBzdHJpY3QtdHlwZS1wcmVkaWNhdGVzXHJcbiAgICAgICAgaWYgKElTX05PREUgJiYgQnVmZmVyLmlzQnVmZmVyKHMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHMudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzQXJyYXlCdWZmZXJMaWtlKHMpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkocyk7XHJcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHV0ZjhEZWNvZGVyLmRlY29kZShieXRlcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIEpTT04ucGFyc2Uocyk7XHJcbn1cblxuLyoqXHJcbiAqIENsYXNzIHByb3ZpZGluZyBhY2Nlc3MgdG8gdXNlciBhdHRyaWJ1dGVzIG9uIGFuIGFycmF5IG9yIGdyb3VwLiBTaG91bGQgbm90IGJlXHJcbiAqIGluc3RhbnRpYXRlZCBkaXJlY3RseSwgd2lsbCBiZSBhdmFpbGFibGUgdmlhIHRoZSBgLmF0dHJzYCBwcm9wZXJ0eSBvZiBhbiBhcnJheSBvclxyXG4gKiBncm91cC5cclxuICovXHJcbmNsYXNzIEF0dHJpYnV0ZXMge1xyXG4gICAgY29uc3RydWN0b3Ioc3RvcmUsIGtleSwgcmVhZE9ubHksIGNhY2hlID0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLnJlYWRPbmx5ID0gcmVhZE9ubHk7XHJcbiAgICAgICAgdGhpcy5jYWNoZSA9IGNhY2hlO1xyXG4gICAgICAgIHRoaXMuY2FjaGVkVmFsdWUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSBhbGwgYXR0cmlidXRlcyBhcyBhIEpTT04gb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBhc3luYyBhc09iamVjdCgpIHtcclxuICAgICAgICBpZiAodGhpcy5jYWNoZSAmJiB0aGlzLmNhY2hlZFZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlZFZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvID0gYXdhaXQgdGhpcy5nZXROb1N5bmMoKTtcclxuICAgICAgICBpZiAodGhpcy5jYWNoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNhY2hlZFZhbHVlID0gbztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG87XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXROb1N5bmMoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuc3RvcmUuZ2V0SXRlbSh0aGlzLmtleSk7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gZml4IHR5cGluZz9cclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTWV0YWRhdGEoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgc2V0Tm9TeW5jKGtleSwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCBkID0gYXdhaXQgdGhpcy5nZXROb1N5bmMoKTtcclxuICAgICAgICBkW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICBhd2FpdCB0aGlzLnB1dE5vU3luYyhkKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGFzeW5jIHB1dE5vU3luYyhtKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5zdG9yZS5zZXRJdGVtKHRoaXMua2V5LCBKU09OLnN0cmluZ2lmeShtKSk7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FjaGUpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWNoZWRWYWx1ZSA9IG07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgZGVsTm9TeW5jKGtleSkge1xyXG4gICAgICAgIGNvbnN0IGQgPSBhd2FpdCB0aGlzLmdldE5vU3luYygpO1xyXG4gICAgICAgIGRlbGV0ZSBkW2tleV07XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wdXROb1N5bmMoZCk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJ3cml0ZSBhbGwgYXR0cmlidXRlcyB3aXRoIHRoZSBwcm92aWRlZCBvYmplY3QgaW4gYSBzaW5nbGUgb3BlcmF0aW9uXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHB1dChkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVhZE9ubHkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFBlcm1pc3Npb25FcnJvcihcImF0dHJpYnV0ZXMgYXJlIHJlYWQtb25seVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0Tm9TeW5jKGQpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc2V0SXRlbShrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVhZE9ubHkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFBlcm1pc3Npb25FcnJvcihcImF0dHJpYnV0ZXMgYXJlIHJlYWQtb25seVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0Tm9TeW5jKGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0SXRlbShrZXkpIHtcclxuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuYXNPYmplY3QoKSlba2V5XTtcclxuICAgIH1cclxuICAgIGFzeW5jIGRlbGV0ZUl0ZW0oa2V5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVhZE9ubHkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFBlcm1pc3Npb25FcnJvcihcImF0dHJpYnV0ZXMgYXJlIHJlYWQtb25seVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsTm9TeW5jKGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBjb250YWluc0l0ZW0oa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmFzT2JqZWN0KCkpW2tleV0gIT09IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHByb3h5KCkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVQcm94eSh0aGlzKTtcclxuICAgIH1cclxufVxuXG5jb25zdCBEVFlQRV9UWVBFREFSUkFZX01BUFBJTkcgPSB7XHJcbiAgICAnfGInOiBJbnQ4QXJyYXksXHJcbiAgICAnfEInOiBVaW50OEFycmF5LFxyXG4gICAgJ3x1MSc6IFVpbnQ4QXJyYXksXHJcbiAgICAnfGkxJzogSW50OEFycmF5LFxyXG4gICAgJzxiJzogSW50OEFycmF5LFxyXG4gICAgJzxCJzogVWludDhBcnJheSxcclxuICAgICc8dTEnOiBVaW50OEFycmF5LFxyXG4gICAgJzxpMSc6IEludDhBcnJheSxcclxuICAgICc8dTInOiBVaW50MTZBcnJheSxcclxuICAgICc8aTInOiBJbnQxNkFycmF5LFxyXG4gICAgJzx1NCc6IFVpbnQzMkFycmF5LFxyXG4gICAgJzxpNCc6IEludDMyQXJyYXksXHJcbiAgICAnPGY0JzogRmxvYXQzMkFycmF5LFxyXG4gICAgJzxmOCc6IEZsb2F0NjRBcnJheSxcclxuICAgICc+Yic6IEludDhBcnJheSxcclxuICAgICc+Qic6IFVpbnQ4QXJyYXksXHJcbiAgICAnPnUxJzogVWludDhBcnJheSxcclxuICAgICc+aTEnOiBJbnQ4QXJyYXksXHJcbiAgICAnPnUyJzogVWludDE2QXJyYXksXHJcbiAgICAnPmkyJzogSW50MTZBcnJheSxcclxuICAgICc+dTQnOiBVaW50MzJBcnJheSxcclxuICAgICc+aTQnOiBJbnQzMkFycmF5LFxyXG4gICAgJz5mNCc6IEZsb2F0MzJBcnJheSxcclxuICAgICc+ZjgnOiBGbG9hdDY0QXJyYXlcclxufTtcclxuZnVuY3Rpb24gZ2V0VHlwZWRBcnJheUN0cihkdHlwZSkge1xyXG4gICAgY29uc3QgY3RyID0gRFRZUEVfVFlQRURBUlJBWV9NQVBQSU5HW2R0eXBlXTtcclxuICAgIGlmICghY3RyKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3IoYER0eXBlIG5vdCByZWNvZ25pemVkIG9yIG5vdCBzdXBwb3J0ZWQgaW4gemFyci5qcywgZ290ICR7ZHR5cGV9LmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGN0cjtcclxufVxyXG4vKlxyXG4gKiBDYWxsZWQgYnkgTmVzdGVkQXJyYXkgYW5kIFJhd0FycmF5IGNvbnN0cnVjdG9ycyBvbmx5LlxyXG4gKiBXZSBieXRlLXN3YXAgdGhlIGJ1ZmZlciBvZiBhIHN0b3JlIGFmdGVyIGRlY29kaW5nXHJcbiAqIHNpbmNlIFR5cGVkQXJyYXkgdmlld3MgYXJlIGxpdHRsZSBlbmRpYW4gb25seS5cclxuICpcclxuICogVGhpcyBtZWFucyBOZXN0ZWRBcnJheXMgYW5kIFJhd0FycmF5cyB3aWxsIGFsd2F5cyBiZSBsaXR0bGUgZW5kaWFuLFxyXG4gKiB1bmxlc3MgYSBudW1weS1saWtlIGxpYnJhcnkgY29tZXMgYXJvdW5kIGFuZCBjYW4gaGFuZGxlIGVuZGlhbmVzc1xyXG4gKiBmb3IgYnVmZmVyIHZpZXdzLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VHlwZWRBcnJheUR0eXBlU3RyaW5nKHQpIHtcclxuICAgIC8vIEZhdm91ciB0aGUgdHlwZXMgYmVsb3cgaW5zdGVhZCBvZiBzbWFsbCBhbmQgYmlnIEJcclxuICAgIGlmICh0IGluc3RhbmNlb2YgVWludDhBcnJheSlcclxuICAgICAgICByZXR1cm4gJ3x1MSc7XHJcbiAgICBpZiAodCBpbnN0YW5jZW9mIEludDhBcnJheSlcclxuICAgICAgICByZXR1cm4gJ3xpMSc7XHJcbiAgICBpZiAodCBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KVxyXG4gICAgICAgIHJldHVybiAnPHUyJztcclxuICAgIGlmICh0IGluc3RhbmNlb2YgSW50MTZBcnJheSlcclxuICAgICAgICByZXR1cm4gJzxpMic7XHJcbiAgICBpZiAodCBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KVxyXG4gICAgICAgIHJldHVybiAnPHU0JztcclxuICAgIGlmICh0IGluc3RhbmNlb2YgSW50MzJBcnJheSlcclxuICAgICAgICByZXR1cm4gJzxpNCc7XHJcbiAgICBpZiAodCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSlcclxuICAgICAgICByZXR1cm4gJzxmNCc7XHJcbiAgICBpZiAodCBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSlcclxuICAgICAgICByZXR1cm4gJzxmOCc7XHJcbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcignTWFwcGluZyBmb3IgVHlwZWRBcnJheSB0byBEdHlwZXN0cmluZyBub3Qga25vd24nKTtcclxufVxuXG4vKipcclxuICogRGlncyBkb3duIGludG8gdGhlIGRpbWVuc2lvbnMgb2YgZ2l2ZW4gYXJyYXkgdG8gZmluZCB0aGUgVHlwZWRBcnJheSBhbmQgcmV0dXJucyBpdHMgY29uc3RydWN0b3IuXHJcbiAqIEJldHRlciB0byB1c2Ugc3BhcmluZ2x5LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TmVzdGVkQXJyYXlDb25zdHJ1Y3RvcihhcnIpIHtcclxuICAgIC8vIFRPRE8gZml4IHR5cGluZ1xyXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBzdHJpY3QtdHlwZS1wcmVkaWNhdGVzXHJcbiAgICBpZiAoYXJyLmJ5dGVMZW5ndGggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiAoYXJyKS5jb25zdHJ1Y3RvcjtcclxuICAgIH1cclxuICAgIHJldHVybiBnZXROZXN0ZWRBcnJheUNvbnN0cnVjdG9yKGFyclswXSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYm90aCB0aGUgc2xpY2UgcmVzdWx0IGFuZCBuZXcgb3V0cHV0IHNoYXBlXHJcbiAqIEBwYXJhbSBhcnIgTmVzdGVkQXJyYXkgdG8gc2xpY2VcclxuICogQHBhcmFtIHNoYXBlIFRoZSBzaGFwZSBvZiB0aGUgTmVzdGVkQXJyYXlcclxuICogQHBhcmFtIHNlbGVjdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gc2xpY2VOZXN0ZWRBcnJheShhcnIsIHNoYXBlLCBzZWxlY3Rpb24pIHtcclxuICAgIC8vIFRoaXMgdHJhbnNsYXRlcyBcIi4uLlwiLCBcIjpcIiwgbnVsbCBpbnRvIGEgbGlzdCBvZiBzbGljZXMgb3IgaW50ZWdlciBzZWxlY3Rpb25zXHJcbiAgICBjb25zdCBub3JtYWxpemVkU2VsZWN0aW9uID0gbm9ybWFsaXplQXJyYXlTZWxlY3Rpb24oc2VsZWN0aW9uLCBzaGFwZSk7XHJcbiAgICBjb25zdCBbc2xpY2VJbmRpY2VzLCBvdXRTaGFwZV0gPSBzZWxlY3Rpb25Ub1NsaWNlSW5kaWNlcyhub3JtYWxpemVkU2VsZWN0aW9uLCBzaGFwZSk7XHJcbiAgICBjb25zdCBvdXRBcnJheSA9IF9zbGljZU5lc3RlZEFycmF5KGFyciwgc2hhcGUsIHNsaWNlSW5kaWNlcyk7XHJcbiAgICByZXR1cm4gW291dEFycmF5LCBvdXRTaGFwZV07XHJcbn1cclxuZnVuY3Rpb24gX3NsaWNlTmVzdGVkQXJyYXkoYXJyLCBzaGFwZSwgc2VsZWN0aW9uKSB7XHJcbiAgICBjb25zdCBjdXJyZW50U2xpY2UgPSBzZWxlY3Rpb25bMF07XHJcbiAgICAvLyBJcyB0aGlzIG5lY2Vzc2FyeT9cclxuICAgIC8vIC8vIFRoaXMgaXMgcG9zc2libGUgd2hlbiBhIHNsaWNlIGxpc3QgaXMgcGFzc2VkIHNob3J0ZXIgdGhhbiB0aGUgYW1vdW50IG9mIGRpbWVuc2lvbnNcclxuICAgIC8vIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogc3RyaWN0LXR5cGUtcHJlZGljYXRlc1xyXG4gICAgLy8gaWYgKGN1cnJlbnRTbGljZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAvLyAgICAgcmV0dXJuIGFyci5zbGljZSgpO1xyXG4gICAgLy8gfVxyXG4gICAgLy8gV2hlbiBhIG51bWJlciBpcyBwYXNzZWQgdGhhdCBkaW1lbnNpb24gaXMgc3F1ZWV6ZWRcclxuICAgIGlmICh0eXBlb2YgY3VycmVudFNsaWNlID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgLy8gQXNzdW1lIGFscmVhZHkgbm9ybWFsaXplZCBpbnRlZ2VyIHNlbGVjdGlvbiBoZXJlLlxyXG4gICAgICAgIGlmIChzaGFwZS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFycltjdXJyZW50U2xpY2VdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zbGljZU5lc3RlZEFycmF5KGFycltjdXJyZW50U2xpY2VdLCBzaGFwZS5zbGljZSgxKSwgc2VsZWN0aW9uLnNsaWNlKDEpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBbZnJvbSwgdG8sIHN0ZXAsIG91dHB1dFNpemVdID0gY3VycmVudFNsaWNlO1xyXG4gICAgaWYgKG91dHB1dFNpemUgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gbmV3IChnZXROZXN0ZWRBcnJheUNvbnN0cnVjdG9yKGFycikpKDApO1xyXG4gICAgfVxyXG4gICAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIGlmIChzdGVwID09PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnIuc2xpY2UoZnJvbSwgdG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXdBcnJEYXRhID0gbmV3IGFyci5jb25zdHJ1Y3RvcihvdXRwdXRTaXplKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dFNpemU7IGkrKykge1xyXG4gICAgICAgICAgICBuZXdBcnJEYXRhW2ldID0gYXJyW2Zyb20gKyBpICogc3RlcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdBcnJEYXRhO1xyXG4gICAgfVxyXG4gICAgbGV0IG5ld0FyciA9IG5ldyBBcnJheShvdXRwdXRTaXplKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0U2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgbmV3QXJyW2ldID0gX3NsaWNlTmVzdGVkQXJyYXkoYXJyW2Zyb20gKyBpICogc3RlcF0sIHNoYXBlLnNsaWNlKDEpLCBzZWxlY3Rpb24uc2xpY2UoMSkpO1xyXG4gICAgfVxyXG4gICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIHRoYXQgdGhlIHJldHVybiB2YWx1ZSBpcyBhIE5lc3RlZEFycmF5IGlmIHRoZSBsYXN0IGRpbWVuc2lvbiBpcyBzcXVlZXplZFxyXG4gICAgLy8gZS5nLiBzaGFwZSBbMiwxXSB3aXRoIHNsaWNlIFs6LCAwXSB3b3VsZCBvdGhlcndpc2UgcmVzdWx0IGluIGEgbGlzdCBvZiBudW1iZXJzIGluc3RlYWQgb2YgYSB2YWxpZCBOZXN0ZWRBcnJheVxyXG4gICAgaWYgKG91dHB1dFNpemUgPiAwICYmIHR5cGVvZiBuZXdBcnJbMF0gPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICBjb25zdCB0eXBlZEFycmF5Q29uc3RydWN0b3IgPSBhcnJbMF0uY29uc3RydWN0b3I7XHJcbiAgICAgICAgbmV3QXJyID0gdHlwZWRBcnJheUNvbnN0cnVjdG9yLmZyb20obmV3QXJyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXdBcnI7XHJcbn1cclxuZnVuY3Rpb24gc2V0TmVzdGVkQXJyYXlUb1NjYWxhcihkc3RBcnIsIHZhbHVlLCBkZXN0U2hhcGUsIHNlbGVjdGlvbikge1xyXG4gICAgLy8gVGhpcyB0cmFuc2xhdGVzIFwiLi4uXCIsIFwiOlwiLCBudWxsLCBldGMgaW50byBhIGxpc3Qgb2Ygc2xpY2VzLlxyXG4gICAgY29uc3Qgbm9ybWFsaXplZFNlbGVjdGlvbiA9IG5vcm1hbGl6ZUFycmF5U2VsZWN0aW9uKHNlbGVjdGlvbiwgZGVzdFNoYXBlLCB0cnVlKTtcclxuICAgIC8vIEFib3ZlIHdlIGZvcmNlIHRoZSByZXN1bHRzIHRvIGJlIFNsaWNlSW5kaWNlc0luZGljZXMgb25seSwgd2l0aG91dCBpbnRlZ2VyIHNlbGVjdGlvbnMgbWFraW5nIHRoaXMgY2FzdCBpcyBzYWZlLlxyXG4gICAgY29uc3QgW3NsaWNlSW5kaWNlcywgX291dFNoYXBlXSA9IHNlbGVjdGlvblRvU2xpY2VJbmRpY2VzKG5vcm1hbGl6ZWRTZWxlY3Rpb24sIGRlc3RTaGFwZSk7XHJcbiAgICBfc2V0TmVzdGVkQXJyYXlUb1NjYWxhcihkc3RBcnIsIHZhbHVlLCBkZXN0U2hhcGUsIHNsaWNlSW5kaWNlcyk7XHJcbn1cclxuZnVuY3Rpb24gc2V0TmVzdGVkQXJyYXkoZHN0QXJyLCBzb3VyY2VBcnIsIGRlc3RTaGFwZSwgc291cmNlU2hhcGUsIHNlbGVjdGlvbikge1xyXG4gICAgLy8gVGhpcyB0cmFuc2xhdGVzIFwiLi4uXCIsIFwiOlwiLCBudWxsLCBldGMgaW50byBhIGxpc3Qgb2Ygc2xpY2VzLlxyXG4gICAgY29uc3Qgbm9ybWFsaXplZFNlbGVjdGlvbiA9IG5vcm1hbGl6ZUFycmF5U2VsZWN0aW9uKHNlbGVjdGlvbiwgZGVzdFNoYXBlLCBmYWxzZSk7XHJcbiAgICBjb25zdCBbc2xpY2VJbmRpY2VzLCBvdXRTaGFwZV0gPSBzZWxlY3Rpb25Ub1NsaWNlSW5kaWNlcyhub3JtYWxpemVkU2VsZWN0aW9uLCBkZXN0U2hhcGUpO1xyXG4gICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIG5vbiBzdHJpbmdpZnkgZXF1YWxpdHkgY2hlY2tcclxuICAgIGlmIChKU09OLnN0cmluZ2lmeShvdXRTaGFwZSkgIT09IEpTT04uc3RyaW5naWZ5KHNvdXJjZVNoYXBlKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKGBTaGFwZSBtaXNtYXRjaCBpbiB0YXJnZXQgYW5kIHNvdXJjZSBOZXN0ZWRBcnJheTogJHtvdXRTaGFwZX0gYW5kICR7c291cmNlU2hhcGV9YCk7XHJcbiAgICB9XHJcbiAgICBfc2V0TmVzdGVkQXJyYXkoZHN0QXJyLCBzb3VyY2VBcnIsIGRlc3RTaGFwZSwgc2xpY2VJbmRpY2VzKTtcclxufVxyXG5mdW5jdGlvbiBfc2V0TmVzdGVkQXJyYXkoZHN0QXJyLCBzb3VyY2VBcnIsIHNoYXBlLCBzZWxlY3Rpb24pIHtcclxuICAgIGNvbnN0IGN1cnJlbnRTbGljZSA9IHNlbGVjdGlvblswXTtcclxuICAgIGlmICh0eXBlb2Ygc291cmNlQXJyID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgX3NldE5lc3RlZEFycmF5VG9TY2FsYXIoZHN0QXJyLCBzb3VyY2VBcnIsIHNoYXBlLCBzZWxlY3Rpb24ubWFwKHggPT4gdHlwZW9mIHggPT09IFwibnVtYmVyXCIgPyBbeCwgeCArIDEsIDEsIDFdIDogeCkpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIFRoaXMgZGltZW5zaW9uIGlzIHNxdWVlemVkLlxyXG4gICAgaWYgKHR5cGVvZiBjdXJyZW50U2xpY2UgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICBfc2V0TmVzdGVkQXJyYXkoZHN0QXJyW2N1cnJlbnRTbGljZV0sIHNvdXJjZUFyciwgc2hhcGUuc2xpY2UoMSksIHNlbGVjdGlvbi5zbGljZSgxKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgW2Zyb20sIF90bywgc3RlcCwgb3V0cHV0U2l6ZV0gPSBjdXJyZW50U2xpY2U7XHJcbiAgICBpZiAoc2hhcGUubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgaWYgKHN0ZXAgPT09IDEpIHtcclxuICAgICAgICAgICAgZHN0QXJyLnNldChzb3VyY2VBcnIsIGZyb20pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRTaXplOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGRzdEFycltmcm9tICsgaSAqIHN0ZXBdID0gKHNvdXJjZUFycilbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRTaXplOyBpKyspIHtcclxuICAgICAgICBfc2V0TmVzdGVkQXJyYXkoZHN0QXJyW2Zyb20gKyBpICogc3RlcF0sIHNvdXJjZUFycltpXSwgc2hhcGUuc2xpY2UoMSksIHNlbGVjdGlvbi5zbGljZSgxKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gX3NldE5lc3RlZEFycmF5VG9TY2FsYXIoZHN0QXJyLCB2YWx1ZSwgc2hhcGUsIHNlbGVjdGlvbikge1xyXG4gICAgY29uc3QgY3VycmVudFNsaWNlID0gc2VsZWN0aW9uWzBdO1xyXG4gICAgY29uc3QgW2Zyb20sIHRvLCBzdGVwLCBvdXRwdXRTaXplXSA9IGN1cnJlbnRTbGljZTtcclxuICAgIGlmIChzaGFwZS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICBpZiAoc3RlcCA9PT0gMSkge1xyXG4gICAgICAgICAgICBkc3RBcnIuZmlsbCh2YWx1ZSwgZnJvbSwgdG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRTaXplOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGRzdEFycltmcm9tICsgaSAqIHN0ZXBdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRTaXplOyBpKyspIHtcclxuICAgICAgICBfc2V0TmVzdGVkQXJyYXlUb1NjYWxhcihkc3RBcnJbZnJvbSArIGkgKiBzdGVwXSwgdmFsdWUsIHNoYXBlLnNsaWNlKDEpLCBzZWxlY3Rpb24uc2xpY2UoMSkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZsYXR0ZW5OZXN0ZWRBcnJheShhcnIsIHNoYXBlLCBjb25zdHIpIHtcclxuICAgIGlmIChjb25zdHIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGNvbnN0ciA9IGdldE5lc3RlZEFycmF5Q29uc3RydWN0b3IoYXJyKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHNpemUgPSBzaGFwZS5yZWR1Y2UoKHgsIHkpID0+IHggKiB5LCAxKTtcclxuICAgIGNvbnN0IG91dEFyciA9IG5ldyBjb25zdHIoc2l6ZSk7XHJcbiAgICBfZmxhdHRlbk5lc3RlZEFycmF5KGFyciwgc2hhcGUsIG91dEFyciwgMCk7XHJcbiAgICByZXR1cm4gb3V0QXJyO1xyXG59XHJcbmZ1bmN0aW9uIF9mbGF0dGVuTmVzdGVkQXJyYXkoYXJyLCBzaGFwZSwgb3V0QXJyLCBvZmZzZXQpIHtcclxuICAgIGlmIChzaGFwZS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAvLyBUaGlzIGlzIG9ubHkgZXZlciByZWFjaGVkIGlmIGNhbGxlZCB3aXRoIHJhbmsgMSBzaGFwZSwgbmV2ZXIgcmVhY2hlZCB0aHJvdWdoIHJlY3Vyc2lvbi5cclxuICAgICAgICAvLyBXZSBqdXN0IHNsaWNlIHNldCB0aGUgYXJyYXkgZGlyZWN0bHkgZnJvbSBvbmUgbGV2ZWwgYWJvdmUgdG8gc2F2ZSBzb21lIGZ1bmN0aW9uIGNhbGxzLlxyXG4gICAgICAgIG91dEFyci5zZXQoYXJyLCBvZmZzZXQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChzaGFwZS5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNoYXBlWzBdOyBpKyspIHtcclxuICAgICAgICAgICAgb3V0QXJyLnNldChhcnJbaV0sIG9mZnNldCArIHNoYXBlWzFdICogaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnI7XHJcbiAgICB9XHJcbiAgICBjb25zdCBuZXh0U2hhcGUgPSBzaGFwZS5zbGljZSgxKTtcclxuICAgIC8vIFNtYWxsIG9wdGltaXphdGlvbiBwb3NzaWJsZSBoZXJlOiB0aGlzIGNhbiBiZSBwcmVjb21wdXRlZCBmb3IgZGlmZmVyZW50IGxldmVscyBvZiBkZXB0aCBhbmQgcGFzc2VkIG9uLlxyXG4gICAgY29uc3QgbXVsdCA9IG5leHRTaGFwZS5yZWR1Y2UoKHgsIHkpID0+IHggKiB5LCAxKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2hhcGVbMF07IGkrKykge1xyXG4gICAgICAgIF9mbGF0dGVuTmVzdGVkQXJyYXkoYXJyW2ldLCBuZXh0U2hhcGUsIG91dEFyciwgb2Zmc2V0ICsgbXVsdCAqIGkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFycjtcclxufVxuXG5jbGFzcyBOZXN0ZWRBcnJheSB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBzaGFwZSwgZHR5cGUpIHtcclxuICAgICAgICBjb25zdCBkYXRhSXNUeXBlZEFycmF5ID0gZGF0YSAhPT0gbnVsbCAmJiAhIWRhdGEuQllURVNfUEVSX0VMRU1FTlQ7XHJcbiAgICAgICAgaWYgKHNoYXBlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKCFkYXRhSXNUeXBlZEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlNoYXBlIGFyZ3VtZW50IGlzIHJlcXVpcmVkIHVubGVzcyB5b3UgcGFzcyBpbiBhIFR5cGVkQXJyYXlcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2hhcGUgPSBbZGF0YS5sZW5ndGhdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZHR5cGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoIWRhdGFJc1R5cGVkQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFwiRHR5cGUgYXJndW1lbnQgaXMgcmVxdWlyZWQgdW5sZXNzIHlvdSBwYXNzIGluIGEgVHlwZWRBcnJheVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkdHlwZSA9IGdldFR5cGVkQXJyYXlEdHlwZVN0cmluZyhkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2hhcGUgPSBub3JtYWxpemVTaGFwZShzaGFwZSk7XHJcbiAgICAgICAgdGhpcy5zaGFwZSA9IHNoYXBlO1xyXG4gICAgICAgIHRoaXMuZHR5cGUgPSBkdHlwZTtcclxuICAgICAgICBpZiAoZGF0YUlzVHlwZWRBcnJheSAmJiBzaGFwZS5sZW5ndGggIT09IDEpIHtcclxuICAgICAgICAgICAgZGF0YSA9IGRhdGEuYnVmZmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBaZXJvIGRpbWVuc2lvbiBhcnJheS4uIHRoZXkgYXJlIGEgYml0IHdlaXJkbHkgcmVwcmVzZW50ZWQgbm93LCB0aGV5IHdpbGwgb25seSBldmVyIG9jY3VyIGludGVybmFsbHlcclxuICAgICAgICBpZiAodGhpcy5zaGFwZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IChnZXRUeXBlZEFycmF5Q3RyKGR0eXBlKSkoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogc3RyaWN0LXR5cGUtcHJlZGljYXRlc1xyXG4gICAgICAgIChJU19OT0RFICYmIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSlcclxuICAgICAgICAgICAgfHwgaXNBcnJheUJ1ZmZlckxpa2UoZGF0YSlcclxuICAgICAgICAgICAgfHwgZGF0YSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBDcmVhdGUgZnJvbSBBcnJheUJ1ZmZlciBvciBCdWZmZXJcclxuICAgICAgICAgICAgY29uc3QgbnVtU2hhcGVFbGVtZW50cyA9IHNoYXBlLnJlZHVjZSgoeCwgeSkgPT4geCAqIHksIDEpO1xyXG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBBcnJheUJ1ZmZlcihudW1TaGFwZUVsZW1lbnRzICogcGFyc2VJbnQoZHR5cGVbZHR5cGUubGVuZ3RoIC0gMV0sIDEwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbnVtRGF0YUVsZW1lbnRzID0gZGF0YS5ieXRlTGVuZ3RoIC8gcGFyc2VJbnQoZHR5cGVbZHR5cGUubGVuZ3RoIC0gMV0sIDEwKTtcclxuICAgICAgICAgICAgaWYgKG51bVNoYXBlRWxlbWVudHMgIT09IG51bURhdGFFbGVtZW50cykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCdWZmZXIgaGFzICR7bnVtRGF0YUVsZW1lbnRzfSBvZiBkdHlwZSAke2R0eXBlfSwgc2hhcGUgaXMgdG9vIGxhcmdlIG9yIHNtYWxsICR7c2hhcGV9IChmbGF0PSR7bnVtU2hhcGVFbGVtZW50c30pYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdHlwZUNvbnN0cnVjdG9yID0gZ2V0VHlwZWRBcnJheUN0cihkdHlwZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGNyZWF0ZU5lc3RlZEFycmF5KGRhdGEsIHR5cGVDb25zdHJ1Y3Rvciwgc2hhcGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQoc2VsZWN0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgW3NsaWNlUmVzdWx0LCBvdXRTaGFwZV0gPSBzbGljZU5lc3RlZEFycmF5KHRoaXMuZGF0YSwgdGhpcy5zaGFwZSwgc2VsZWN0aW9uKTtcclxuICAgICAgICBpZiAob3V0U2hhcGUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzbGljZVJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmVzdGVkQXJyYXkoc2xpY2VSZXN1bHQsIG91dFNoYXBlLCB0aGlzLmR0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZXQoc2VsZWN0aW9uID0gbnVsbCwgdmFsdWUpIHtcclxuICAgICAgICBpZiAoc2VsZWN0aW9uID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IFtzbGljZShudWxsKV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2hhcGUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBaZXJvIGRpbWVuc2lvbiBhcnJheS4uXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFbMF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNldE5lc3RlZEFycmF5VG9TY2FsYXIodGhpcy5kYXRhLCB2YWx1ZSwgdGhpcy5zaGFwZSwgc2VsZWN0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2V0TmVzdGVkQXJyYXkodGhpcy5kYXRhLCB2YWx1ZS5kYXRhLCB0aGlzLnNoYXBlLCB2YWx1ZS5zaGFwZSwgc2VsZWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmbGF0dGVuKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNoYXBlLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmxhdHRlbk5lc3RlZEFycmF5KHRoaXMuZGF0YSwgdGhpcy5zaGFwZSwgZ2V0VHlwZWRBcnJheUN0cih0aGlzLmR0eXBlKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIGEgc2luZ2xlIGludGVnZXIgYXMgdGhlIHNpemUsIFRPRE86IHN1cHBvcnQgc3RhcnQsIHN0b3AsIHN0ZXAuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhcmFuZ2Uoc2l6ZSwgZHR5cGUgPSBcIjxpNFwiKSB7XHJcbiAgICAgICAgY29uc3QgY29uc3RyID0gZ2V0VHlwZWRBcnJheUN0cihkdHlwZSk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHJhbmdlVHlwZWRBcnJheShbc2l6ZV0sIGNvbnN0cik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOZXN0ZWRBcnJheShkYXRhLCBbc2l6ZV0sIGR0eXBlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIFR5cGVkQXJyYXkgd2l0aCB2YWx1ZXMgMCB0aHJvdWdoIE4gd2hlcmUgTiBpcyB0aGUgcHJvZHVjdCBvZiB0aGUgc2hhcGUuXHJcbiAqL1xyXG5mdW5jdGlvbiByYW5nZVR5cGVkQXJyYXkoc2hhcGUsIHRDb250cnVjdG9yKSB7XHJcbiAgICBjb25zdCBzaXplID0gc2hhcGUucmVkdWNlKCh4LCB5KSA9PiB4ICogeSwgMSk7XHJcbiAgICBjb25zdCBkYXRhID0gbmV3IHRDb250cnVjdG9yKHNpemUpO1xyXG4gICAgZGF0YS5zZXQoWy4uLkFycmF5KHNpemUpLmtleXMoKV0pOyAvLyBTZXRzIHJhbmdlIDAsMSwyLDMsNCw1XHJcbiAgICByZXR1cm4gZGF0YTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBtdWx0aS1kaW1lbnNpb25hbCAocmFuayA+IDEpIGFycmF5IGdpdmVuIGlucHV0IGRhdGEgYW5kIHNoYXBlIHJlY3Vyc2l2ZWx5LlxyXG4gKiBXaGF0IGl0IGRvZXMgaXMgY3JlYXRlIGEgQXJyYXk8QXJyYXk8Li4uPEFycmF5PFVpbnQ4QXJyYXk+Pj4gb3Igc29tZSBvdGhlciB0eXBlZCBhcnJheS5cclxuICogVGhpcyBpcyBmb3IgaW50ZXJuYWwgdXNlLCB0aGVyZSBzaG91bGQgYmUgbm8gbmVlZCB0byBjYWxsIHRoaXMgZnJvbSB1c2VyIGNvZGUuXHJcbiAqIEBwYXJhbSBkYXRhIGEgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIGRhdGEgZm9yIHRoaXMgYXJyYXkuXHJcbiAqIEBwYXJhbSB0IGNvbnN0cnVjdG9yIGZvciB0aGUgZGF0YXR5cGUgb2YgY2hvaWNlXHJcbiAqIEBwYXJhbSBzaGFwZSBsaXN0IG9mIG51bWJlcnMgZGVzY3JpYmluZyB0aGUgc2l6ZSBpbiBlYWNoIGRpbWVuc2lvblxyXG4gKiBAcGFyYW0gb2Zmc2V0IGluIGJ5dGVzIGZvciB0aGlzIGRpbWVuc2lvblxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlTmVzdGVkQXJyYXkoZGF0YSwgdCwgc2hhcGUsIG9mZnNldCA9IDApIHtcclxuICAgIGlmIChzaGFwZS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAvLyBUaGlzIGlzIG9ubHkgZXZlciByZWFjaGVkIGlmIGNhbGxlZCB3aXRoIHJhbmsgMSBzaGFwZSwgbmV2ZXIgcmVhY2hlZCB0aHJvdWdoIHJlY3Vyc2lvbi5cclxuICAgICAgICAvLyBXZSBqdXN0IHNsaWNlIHNldCB0aGUgYXJyYXkgZGlyZWN0bHkgZnJvbSBvbmUgbGV2ZWwgYWJvdmUgdG8gc2F2ZSBzb21lIGZ1bmN0aW9uIGNhbGxzLlxyXG4gICAgICAgIHJldHVybiBuZXcgdChkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc2hhcGVbMF0gKiB0LkJZVEVTX1BFUl9FTEVNRU5UKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhcnIgPSBuZXcgQXJyYXkoc2hhcGVbMF0pO1xyXG4gICAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2hhcGVbMF07IGkrKykge1xyXG4gICAgICAgICAgICBhcnJbaV0gPSBuZXcgdChkYXRhLnNsaWNlKG9mZnNldCArIHNoYXBlWzFdICogaSAqIHQuQllURVNfUEVSX0VMRU1FTlQsIG9mZnNldCArIHNoYXBlWzFdICogKGkgKyAxKSAqIHQuQllURVNfUEVSX0VMRU1FTlQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFycjtcclxuICAgIH1cclxuICAgIGNvbnN0IG5leHRTaGFwZSA9IHNoYXBlLnNsaWNlKDEpO1xyXG4gICAgLy8gU21hbGwgb3B0aW1pemF0aW9uIHBvc3NpYmxlIGhlcmU6IHRoaXMgY2FuIGJlIHByZWNvbXB1dGVkIGZvciBkaWZmZXJlbnQgbGV2ZWxzIG9mIGRlcHRoIGFuZCBwYXNzZWQgb24uXHJcbiAgICBjb25zdCBtdWx0ID0gbmV4dFNoYXBlLnJlZHVjZSgoeCwgeSkgPT4geCAqIHksIDEpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZVswXTsgaSsrKSB7XHJcbiAgICAgICAgYXJyW2ldID0gY3JlYXRlTmVzdGVkQXJyYXkoZGF0YSwgdCwgbmV4dFNoYXBlLCBvZmZzZXQgKyBtdWx0ICogaSAqIHQuQllURVNfUEVSX0VMRU1FTlQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFycjtcclxufVxuXG5mdW5jdGlvbiBzZXRSYXdBcnJheVRvU2NhbGFyKGRzdEFyciwgZHN0U3RyaWRlcywgZHN0U2hhcGUsIGRzdFNlbGVjdGlvbiwgdmFsdWUpIHtcclxuICAgIC8vIFRoaXMgdHJhbnNsYXRlcyBcIi4uLlwiLCBcIjpcIiwgbnVsbCwgZXRjIGludG8gYSBsaXN0IG9mIHNsaWNlcy5cclxuICAgIGNvbnN0IG5vcm1hbGl6ZWRTZWxlY3Rpb24gPSBub3JtYWxpemVBcnJheVNlbGVjdGlvbihkc3RTZWxlY3Rpb24sIGRzdFNoYXBlLCB0cnVlKTtcclxuICAgIGNvbnN0IFtzbGljZUluZGljZXNdID0gc2VsZWN0aW9uVG9TbGljZUluZGljZXMobm9ybWFsaXplZFNlbGVjdGlvbiwgZHN0U2hhcGUpO1xyXG4gICAgLy8gQWJvdmUgd2UgZm9yY2UgdGhlIHJlc3VsdHMgdG8gYmUgU2xpY2VJbmRpY2VzSW5kaWNlcyBvbmx5LCB3aXRob3V0IGludGVnZXIgc2VsZWN0aW9ucyBtYWtpbmcgdGhpcyBjYXN0IGlzIHNhZmUuXHJcbiAgICBfc2V0UmF3QXJyYXlUb1NjYWxhcih2YWx1ZSwgZHN0QXJyLCBkc3RTdHJpZGVzLCBzbGljZUluZGljZXMpO1xyXG59XHJcbmZ1bmN0aW9uIHNldFJhd0FycmF5KGRzdEFyciwgZHN0U3RyaWRlcywgZHN0U2hhcGUsIGRzdFNlbGVjdGlvbiwgc291cmNlQXJyLCBzb3VyY2VTdHJpZGVzLCBzb3VyY2VTaGFwZSkge1xyXG4gICAgLy8gVGhpcyB0cmFuc2xhdGVzIFwiLi4uXCIsIFwiOlwiLCBudWxsLCBldGMgaW50byBhIGxpc3Qgb2Ygc2xpY2VzLlxyXG4gICAgY29uc3Qgbm9ybWFsaXplZERzdFNlbGVjdGlvbiA9IG5vcm1hbGl6ZUFycmF5U2VsZWN0aW9uKGRzdFNlbGVjdGlvbiwgZHN0U2hhcGUsIGZhbHNlKTtcclxuICAgIGNvbnN0IFtkc3RTbGljZUluZGljZXMsIG91dFNoYXBlXSA9IHNlbGVjdGlvblRvU2xpY2VJbmRpY2VzKG5vcm1hbGl6ZWREc3RTZWxlY3Rpb24sIGRzdFNoYXBlKTtcclxuICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBub24gc3RyaW5naWZ5IGVxdWFsaXR5IGNoZWNrXHJcbiAgICBpZiAoSlNPTi5zdHJpbmdpZnkob3V0U2hhcGUpICE9PSBKU09OLnN0cmluZ2lmeShzb3VyY2VTaGFwZSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgU2hhcGUgbWlzbWF0Y2ggaW4gdGFyZ2V0IGFuZCBzb3VyY2UgUmF3QXJyYXk6ICR7b3V0U2hhcGV9IGFuZCAke3NvdXJjZVNoYXBlfWApO1xyXG4gICAgfVxyXG4gICAgX3NldFJhd0FycmF5KGRzdEFyciwgZHN0U3RyaWRlcywgZHN0U2xpY2VJbmRpY2VzLCBzb3VyY2VBcnIsIHNvdXJjZVN0cmlkZXMpO1xyXG59XHJcbmZ1bmN0aW9uIHNldFJhd0FycmF5RnJvbUNodW5rSXRlbShkc3RBcnIsIGRzdFN0cmlkZXMsIGRzdFNoYXBlLCBkc3RTZWxlY3Rpb24sIHNvdXJjZUFyciwgc291cmNlU3RyaWRlcywgc291cmNlU2hhcGUsIHNvdXJjZVNlbGVjdGlvbikge1xyXG4gICAgLy8gVGhpcyB0cmFuc2xhdGVzIFwiLi4uXCIsIFwiOlwiLCBudWxsLCBldGMgaW50byBhIGxpc3Qgb2Ygc2xpY2VzLlxyXG4gICAgY29uc3Qgbm9ybWFsaXplZERzdFNlbGVjdGlvbiA9IG5vcm1hbGl6ZUFycmF5U2VsZWN0aW9uKGRzdFNlbGVjdGlvbiwgZHN0U2hhcGUsIHRydWUpO1xyXG4gICAgLy8gQWJvdmUgd2UgZm9yY2UgdGhlIHJlc3VsdHMgdG8gYmUgZHN0U2xpY2VJbmRpY2VzIG9ubHksIHdpdGhvdXQgaW50ZWdlciBzZWxlY3Rpb25zIG1ha2luZyB0aGlzIGNhc3QgaXMgc2FmZS5cclxuICAgIGNvbnN0IFtkc3RTbGljZUluZGljZXNdID0gc2VsZWN0aW9uVG9TbGljZUluZGljZXMobm9ybWFsaXplZERzdFNlbGVjdGlvbiwgZHN0U2hhcGUpO1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZFNvdXJjZVNlbGVjdGlvbiA9IG5vcm1hbGl6ZUFycmF5U2VsZWN0aW9uKHNvdXJjZVNlbGVjdGlvbiwgc291cmNlU2hhcGUsIGZhbHNlKTtcclxuICAgIGNvbnN0IFtzb3VyY2VTbGljZUluZGljaWVzXSA9IHNlbGVjdGlvblRvU2xpY2VJbmRpY2VzKG5vcm1hbGl6ZWRTb3VyY2VTZWxlY3Rpb24sIHNvdXJjZVNoYXBlKTtcclxuICAgIC8vIFRPRE8gY2hlY2sgdG8gZW5zdXJlIGNodW5rIGFuZCBkZXN0IHNlbGVjdGlvbiBhcmUgc2FtZSBzaGFwZT9cclxuICAgIC8vIEFzIGlzLCB0aGlzIG9ubHkgZ2V0cyBjYWxsZWQgaW4gWmFyckFycmF5LmdldFJhdyB3aGVyZSB0aGlzIGNvbmRpdGlvbiBzaG91bGQgYmUgZW5zdXJlZCwgYW5kIGNoZWNrIG1pZ2h0IGhpbmRlciBwZXJmb3JtYW5jZS5cclxuICAgIF9zZXRSYXdBcnJheUZyb21DaHVua0l0ZW0oZHN0QXJyLCBkc3RTdHJpZGVzLCBkc3RTbGljZUluZGljZXMsIHNvdXJjZUFyciwgc291cmNlU3RyaWRlcywgc291cmNlU2xpY2VJbmRpY2llcyk7XHJcbn1cclxuZnVuY3Rpb24gX3NldFJhd0FycmF5VG9TY2FsYXIodmFsdWUsIGRzdEFyciwgZHN0U3RyaWRlcywgZHN0U2xpY2VJbmRpY2VzKSB7XHJcbiAgICBjb25zdCBbY3VycmVudERzdFNsaWNlLCAuLi5uZXh0RHN0U2xpY2VJbmRpY2VzXSA9IGRzdFNsaWNlSW5kaWNlcztcclxuICAgIGNvbnN0IFtjdXJyZW50RHN0U3RyaWRlLCAuLi5uZXh0RHN0U3RyaWRlc10gPSBkc3RTdHJpZGVzO1xyXG4gICAgY29uc3QgW2Zyb20sIF90bywgc3RlcCwgb3V0cHV0U2l6ZV0gPSBjdXJyZW50RHN0U2xpY2U7XHJcbiAgICBpZiAoZHN0U3RyaWRlcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICBpZiAoc3RlcCA9PT0gMSAmJiBjdXJyZW50RHN0U3RyaWRlID09PSAxKSB7XHJcbiAgICAgICAgICAgIGRzdEFyci5maWxsKHZhbHVlLCBmcm9tLCBmcm9tICsgb3V0cHV0U2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dFNpemU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZHN0QXJyW2N1cnJlbnREc3RTdHJpZGUgKiAoZnJvbSArIChzdGVwICogaSkpXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0U2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgX3NldFJhd0FycmF5VG9TY2FsYXIodmFsdWUsIGRzdEFyci5zdWJhcnJheShjdXJyZW50RHN0U3RyaWRlICogKGZyb20gKyAoc3RlcCAqIGkpKSksIG5leHREc3RTdHJpZGVzLCBuZXh0RHN0U2xpY2VJbmRpY2VzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBfc2V0UmF3QXJyYXkoZHN0QXJyLCBkc3RTdHJpZGVzLCBkc3RTbGljZUluZGljZXMsIHNvdXJjZUFyciwgc291cmNlU3RyaWRlcykge1xyXG4gICAgaWYgKGRzdFNsaWNlSW5kaWNlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBkc3RBcnIuc2V0KHNvdXJjZUFycik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgW2N1cnJlbnREc3RTbGljZSwgLi4ubmV4dERzdFNsaWNlSW5kaWNlc10gPSBkc3RTbGljZUluZGljZXM7XHJcbiAgICBjb25zdCBbY3VycmVudERzdFN0cmlkZSwgLi4ubmV4dERzdFN0cmlkZXNdID0gZHN0U3RyaWRlcztcclxuICAgIC8vIFRoaXMgZGltZW5zaW9uIGlzIHNxdWVlemVkLlxyXG4gICAgaWYgKHR5cGVvZiBjdXJyZW50RHN0U2xpY2UgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICBfc2V0UmF3QXJyYXkoZHN0QXJyLnN1YmFycmF5KGN1cnJlbnREc3RTbGljZSAqIGN1cnJlbnREc3RTdHJpZGUpLCBuZXh0RHN0U3RyaWRlcywgbmV4dERzdFNsaWNlSW5kaWNlcywgc291cmNlQXJyLCBzb3VyY2VTdHJpZGVzKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBbY3VycmVudFNvdXJjZVN0cmlkZSwgLi4ubmV4dFNvdXJjZVN0cmlkZXNdID0gc291cmNlU3RyaWRlcztcclxuICAgIGNvbnN0IFtmcm9tLCBfdG8sIHN0ZXAsIG91dHB1dFNpemVdID0gY3VycmVudERzdFNsaWNlO1xyXG4gICAgaWYgKGRzdFN0cmlkZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgaWYgKHN0ZXAgPT09IDEgJiYgY3VycmVudERzdFN0cmlkZSA9PT0gMSAmJiBjdXJyZW50U291cmNlU3RyaWRlID09PSAxKSB7XHJcbiAgICAgICAgICAgIGRzdEFyci5zZXQoc291cmNlQXJyLnN1YmFycmF5KDAsIG91dHB1dFNpemUpLCBmcm9tKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0U2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBkc3RBcnJbY3VycmVudERzdFN0cmlkZSAqIChmcm9tICsgKHN0ZXAgKiBpKSldID0gc291cmNlQXJyW2N1cnJlbnRTb3VyY2VTdHJpZGUgKiBpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dFNpemU7IGkrKykge1xyXG4gICAgICAgIC8vIEFwcGx5IHN0cmlkZXMgYXMgYWJvdmUsIHVzaW5nIGJvdGggZGVzdGluYXRpb24gYW5kIHNvdXJjZS1zcGVjaWZpYyBzdHJpZGVzLlxyXG4gICAgICAgIF9zZXRSYXdBcnJheShkc3RBcnIuc3ViYXJyYXkoY3VycmVudERzdFN0cmlkZSAqIChmcm9tICsgKGkgKiBzdGVwKSkpLCBuZXh0RHN0U3RyaWRlcywgbmV4dERzdFNsaWNlSW5kaWNlcywgc291cmNlQXJyLnN1YmFycmF5KGN1cnJlbnRTb3VyY2VTdHJpZGUgKiBpKSwgbmV4dFNvdXJjZVN0cmlkZXMpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIF9zZXRSYXdBcnJheUZyb21DaHVua0l0ZW0oZHN0QXJyLCBkc3RTdHJpZGVzLCBkc3RTbGljZUluZGljZXMsIHNvdXJjZUFyciwgc291cmNlU3RyaWRlcywgc291cmNlU2xpY2VJbmRpY2VzKSB7XHJcbiAgICBpZiAoc291cmNlU2xpY2VJbmRpY2VzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIC8vIENhc2Ugd2hlbiBsYXN0IHNvdXJjZSBkaW1lbnNpb24gaXMgc3F1ZWV6ZWRcclxuICAgICAgICBkc3RBcnIuc2V0KHNvdXJjZUFyci5zdWJhcnJheSgwLCBkc3RBcnIubGVuZ3RoKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gR2V0IGN1cnJlbnQgaW5kaWNpZXMgYW5kIHN0cmlkZXMgZm9yIGJvdGggZGVzdGluYXRpb24gYW5kIHNvdXJjZSBhcnJheXNcclxuICAgIGNvbnN0IFtjdXJyZW50RHN0U2xpY2UsIC4uLm5leHREc3RTbGljZUluZGljZXNdID0gZHN0U2xpY2VJbmRpY2VzO1xyXG4gICAgY29uc3QgW2N1cnJlbnRTb3VyY2VTbGljZSwgLi4ubmV4dFNvdXJjZVNsaWNlSW5kaWNlc10gPSBzb3VyY2VTbGljZUluZGljZXM7XHJcbiAgICBjb25zdCBbY3VycmVudERzdFN0cmlkZSwgLi4ubmV4dERzdFN0cmlkZXNdID0gZHN0U3RyaWRlcztcclxuICAgIGNvbnN0IFtjdXJyZW50U291cmNlU3RyaWRlLCAuLi5uZXh0U291cmNlU3RyaWRlc10gPSBzb3VyY2VTdHJpZGVzO1xyXG4gICAgLy8gVGhpcyBzb3VyY2UgZGltZW5zaW9uIGlzIHNxdWVlemVkXHJcbiAgICBpZiAodHlwZW9mIGN1cnJlbnRTb3VyY2VTbGljZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgU2V0cyBkaW1lbnNpb24gb2Zmc2V0IGZvciBzcXVlZXplZCBkaW1lbnNpb24uXHJcblxuICAgICAgICBFeC4gaWYgMHRoIGRpbWVuc2lvbiBpcyBzcXVlZXplZCB0byAybmQgaW5kZXggKG51bXB5IDogYXJyWzIsaV0pXHJcblxuICAgICAgICAgICAgc291cmNlQXJyW3N0cmlkZVswXSogMiArIGldIC0tPiBzb3VyY2VBcnIuc3ViYXJyYXkoc3RyaWRlWzBdICogMilbaV0gKHNvdXJjZUFycltpXSBpbiBuZXh0IGNhbGwpXHJcblxuICAgICAgICBUaHVzLCBzdWJzZXF1ZW50IHNxdWVlemVkIGRpbXMgYXJlIGFwcGVuZGVkIHRvIHRoZSBzb3VyY2Ugb2Zmc2V0LlxyXG4gICAgICAgICovXHJcbiAgICAgICAgX3NldFJhd0FycmF5RnJvbUNodW5rSXRlbShcclxuICAgICAgICAvLyBEb24ndCB1cGRhdGUgZGVzdGluYXRpb24gb2Zmc2V0L3NsaWNlcywganVzdCBzb3VyY2VcclxuICAgICAgICBkc3RBcnIsIGRzdFN0cmlkZXMsIGRzdFNsaWNlSW5kaWNlcywgc291cmNlQXJyLnN1YmFycmF5KGN1cnJlbnRTb3VyY2VTdHJpZGUgKiBjdXJyZW50U291cmNlU2xpY2UpLCBuZXh0U291cmNlU3RyaWRlcywgbmV4dFNvdXJjZVNsaWNlSW5kaWNlcyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgW2Zyb20sIF90bywgc3RlcCwgb3V0cHV0U2l6ZV0gPSBjdXJyZW50RHN0U2xpY2U7IC8vIGp1c3QgbmVlZCBzdGFydCBhbmQgc2l6ZVxyXG4gICAgY29uc3QgW3Nmcm9tLCBfc3RvLCBzc3RlcCwgX3NvdXRwdXRTaXplXSA9IGN1cnJlbnRTb3VyY2VTbGljZTsgLy8gV2lsbCBhbHdheXMgYmUgc3Vic2V0IG9mIGRzdCwgc28gZG9uJ3QgbmVlZCBvdXRwdXQgc2l6ZSBqdXN0IHN0YXJ0XHJcbiAgICBpZiAoZHN0U3RyaWRlcy5sZW5ndGggPT09IDEgJiYgc291cmNlU3RyaWRlcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICBpZiAoc3RlcCA9PT0gMSAmJiBjdXJyZW50RHN0U3RyaWRlID09PSAxICYmIHNzdGVwID09PSAxICYmIGN1cnJlbnRTb3VyY2VTdHJpZGUgPT09IDEpIHtcclxuICAgICAgICAgICAgZHN0QXJyLnNldChzb3VyY2VBcnIuc3ViYXJyYXkoc2Zyb20sIHNmcm9tICsgb3V0cHV0U2l6ZSksIGZyb20pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRTaXplOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGRzdEFycltjdXJyZW50RHN0U3RyaWRlICogKGZyb20gKyAoc3RlcCAqIGkpKV0gPSBzb3VyY2VBcnJbY3VycmVudFNvdXJjZVN0cmlkZSAqIChzZnJvbSArIChzc3RlcCAqIGkpKV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRTaXplOyBpKyspIHtcclxuICAgICAgICAvLyBBcHBseSBzdHJpZGVzIGFzIGFib3ZlLCB1c2luZyBib3RoIGRlc3RpbmF0aW9uIGFuZCBzb3VyY2Utc3BlY2lmaWMgc3RyaWRlcy5cclxuICAgICAgICBfc2V0UmF3QXJyYXlGcm9tQ2h1bmtJdGVtKGRzdEFyci5zdWJhcnJheShjdXJyZW50RHN0U3RyaWRlICogKGZyb20gKyAoaSAqIHN0ZXApKSksIG5leHREc3RTdHJpZGVzLCBuZXh0RHN0U2xpY2VJbmRpY2VzLCBzb3VyY2VBcnIuc3ViYXJyYXkoY3VycmVudFNvdXJjZVN0cmlkZSAqIChzZnJvbSArIChpICogc3N0ZXApKSksIG5leHRTb3VyY2VTdHJpZGVzLCBuZXh0U291cmNlU2xpY2VJbmRpY2VzKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBSYXdBcnJheSB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBzaGFwZSwgZHR5cGUsIHN0cmlkZXMpIHtcclxuICAgICAgICBjb25zdCBkYXRhSXNUeXBlZEFycmF5ID0gZGF0YSAhPT0gbnVsbCAmJiAhIWRhdGEuQllURVNfUEVSX0VMRU1FTlQ7XHJcbiAgICAgICAgaWYgKHNoYXBlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKCFkYXRhSXNUeXBlZEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlNoYXBlIGFyZ3VtZW50IGlzIHJlcXVpcmVkIHVubGVzcyB5b3UgcGFzcyBpbiBhIFR5cGVkQXJyYXlcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2hhcGUgPSBbZGF0YS5sZW5ndGhdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzaGFwZSA9IG5vcm1hbGl6ZVNoYXBlKHNoYXBlKTtcclxuICAgICAgICBpZiAoZHR5cGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoIWRhdGFJc1R5cGVkQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFwiRHR5cGUgYXJndW1lbnQgaXMgcmVxdWlyZWQgdW5sZXNzIHlvdSBwYXNzIGluIGEgVHlwZWRBcnJheVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkdHlwZSA9IGdldFR5cGVkQXJyYXlEdHlwZVN0cmluZyhkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0cmlkZXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBzdHJpZGVzID0gZ2V0U3RyaWRlcyhzaGFwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2hhcGUgPSBzaGFwZTtcclxuICAgICAgICB0aGlzLmR0eXBlID0gZHR5cGU7XHJcbiAgICAgICAgdGhpcy5zdHJpZGVzID0gc3RyaWRlcztcclxuICAgICAgICBpZiAoZGF0YUlzVHlwZWRBcnJheSAmJiBzaGFwZS5sZW5ndGggIT09IDEpIHtcclxuICAgICAgICAgICAgZGF0YSA9IGRhdGEuYnVmZmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBaZXJvIGRpbWVuc2lvbiBhcnJheS4uIHRoZXkgYXJlIGEgYml0IHdlaXJkbHkgcmVwcmVzZW50ZWQgbm93LCB0aGV5IHdpbGwgb25seSBldmVyIG9jY3VyIGludGVybmFsbHlcclxuICAgICAgICBpZiAodGhpcy5zaGFwZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IChnZXRUeXBlZEFycmF5Q3RyKGR0eXBlKSkoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogc3RyaWN0LXR5cGUtcHJlZGljYXRlc1xyXG4gICAgICAgIChJU19OT0RFICYmIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSlcclxuICAgICAgICAgICAgfHwgaXNBcnJheUJ1ZmZlckxpa2UoZGF0YSlcclxuICAgICAgICAgICAgfHwgZGF0YSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBDcmVhdGUgZnJvbSBBcnJheUJ1ZmZlciBvciBCdWZmZXJcclxuICAgICAgICAgICAgY29uc3QgbnVtU2hhcGVFbGVtZW50cyA9IHNoYXBlLnJlZHVjZSgoeCwgeSkgPT4geCAqIHksIDEpO1xyXG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBBcnJheUJ1ZmZlcihudW1TaGFwZUVsZW1lbnRzICogcGFyc2VJbnQoZHR5cGVbZHR5cGUubGVuZ3RoIC0gMV0sIDEwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbnVtRGF0YUVsZW1lbnRzID0gZGF0YS5ieXRlTGVuZ3RoIC8gcGFyc2VJbnQoZHR5cGVbZHR5cGUubGVuZ3RoIC0gMV0sIDEwKTtcclxuICAgICAgICAgICAgaWYgKG51bVNoYXBlRWxlbWVudHMgIT09IG51bURhdGFFbGVtZW50cykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCdWZmZXIgaGFzICR7bnVtRGF0YUVsZW1lbnRzfSBvZiBkdHlwZSAke2R0eXBlfSwgc2hhcGUgaXMgdG9vIGxhcmdlIG9yIHNtYWxsICR7c2hhcGV9IChmbGF0PSR7bnVtU2hhcGVFbGVtZW50c30pYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdHlwZUNvbnN0cnVjdG9yID0gZ2V0VHlwZWRBcnJheUN0cihkdHlwZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyB0eXBlQ29uc3RydWN0b3IoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldChzZWxlY3Rpb24gPSBudWxsLCB2YWx1ZSwgY2h1bmtTZWxlY3Rpb24pIHtcclxuICAgICAgICBpZiAoc2VsZWN0aW9uID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IFtzbGljZShudWxsKV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2hhcGUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBaZXJvIGRpbWVuc2lvbiBhcnJheS4uXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFbMF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNldFJhd0FycmF5VG9TY2FsYXIodGhpcy5kYXRhLCB0aGlzLnN0cmlkZXMsIHRoaXMuc2hhcGUsIHNlbGVjdGlvbiwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmF3QXJyYXkgJiYgY2h1bmtTZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgLy8gQ29weSBkaXJlY3RseSBmcm9tIGRlY29kZWQgY2h1bmsgdG8gZGVzdGluYXRpb24gYXJyYXlcclxuICAgICAgICAgICAgc2V0UmF3QXJyYXlGcm9tQ2h1bmtJdGVtKHRoaXMuZGF0YSwgdGhpcy5zdHJpZGVzLCB0aGlzLnNoYXBlLCBzZWxlY3Rpb24sIHZhbHVlLmRhdGEsIHZhbHVlLnN0cmlkZXMsIHZhbHVlLnNoYXBlLCBjaHVua1NlbGVjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzZXRSYXdBcnJheSh0aGlzLmRhdGEsIHRoaXMuc3RyaWRlcywgdGhpcy5zaGFwZSwgc2VsZWN0aW9uLCB2YWx1ZS5kYXRhLCB2YWx1ZS5zdHJpZGVzLCB2YWx1ZS5zaGFwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbnZhciBldmVudGVtaXR0ZXIzID0ge2V4cG9ydHM6IHt9fTtcblxuKGZ1bmN0aW9uIChtb2R1bGUpIHtcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKCkge31cblxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vXG4gIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIC8vXG4gIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gZW1pdHRlcjtcbn1cblxuLyoqXG4gKiBDbGVhciBldmVudCBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG59XG5cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgbmFtZXMgPSBbXVxuICAgICwgZXZlbnRzXG4gICAgLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG4gIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKFxuICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICAgICkge1xuICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG4gICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcbiAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgICAvL1xuICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQ7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbntcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG59KGV2ZW50ZW1pdHRlcjMpKTtcblxudmFyIEV2ZW50RW1pdHRlciA9IGV2ZW50ZW1pdHRlcjMuZXhwb3J0cztcblxuY2xhc3MgVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cdFx0dGhpcy5uYW1lID0gJ1RpbWVvdXRFcnJvcic7XG5cdH1cbn1cblxuZnVuY3Rpb24gcFRpbWVvdXQocHJvbWlzZSwgbWlsbGlzZWNvbmRzLCBmYWxsYmFjaywgb3B0aW9ucykge1xuXHRsZXQgdGltZXI7XG5cdGNvbnN0IGNhbmNlbGFibGVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdGlmICh0eXBlb2YgbWlsbGlzZWNvbmRzICE9PSAnbnVtYmVyJyB8fCBtaWxsaXNlY29uZHMgPCAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBgbWlsbGlzZWNvbmRzYCB0byBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuXHRcdH1cblxuXHRcdGlmIChtaWxsaXNlY29uZHMgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuXHRcdFx0cmVzb2x2ZShwcm9taXNlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRvcHRpb25zID0ge1xuXHRcdFx0Y3VzdG9tVGltZXJzOiB7c2V0VGltZW91dCwgY2xlYXJUaW1lb3V0fSxcblx0XHRcdC4uLm9wdGlvbnNcblx0XHR9O1xuXG5cdFx0dGltZXIgPSBvcHRpb25zLmN1c3RvbVRpbWVycy5zZXRUaW1lb3V0LmNhbGwodW5kZWZpbmVkLCAoKSA9PiB7XG5cdFx0XHRpZiAodHlwZW9mIGZhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShmYWxsYmFjaygpKTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtZXNzYWdlID0gdHlwZW9mIGZhbGxiYWNrID09PSAnc3RyaW5nJyA/IGZhbGxiYWNrIDogYFByb21pc2UgdGltZWQgb3V0IGFmdGVyICR7bWlsbGlzZWNvbmRzfSBtaWxsaXNlY29uZHNgO1xuXHRcdFx0Y29uc3QgdGltZW91dEVycm9yID0gZmFsbGJhY2sgaW5zdGFuY2VvZiBFcnJvciA/IGZhbGxiYWNrIDogbmV3IFRpbWVvdXRFcnJvcihtZXNzYWdlKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBwcm9taXNlLmNhbmNlbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRwcm9taXNlLmNhbmNlbCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZWplY3QodGltZW91dEVycm9yKTtcblx0XHR9LCBtaWxsaXNlY29uZHMpO1xuXG5cdFx0KGFzeW5jICgpID0+IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJlc29sdmUoYXdhaXQgcHJvbWlzZSk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0b3B0aW9ucy5jdXN0b21UaW1lcnMuY2xlYXJUaW1lb3V0LmNhbGwodW5kZWZpbmVkLCB0aW1lcik7XG5cdFx0XHR9XG5cdFx0fSkoKTtcblx0fSk7XG5cblx0Y2FuY2VsYWJsZVByb21pc2UuY2xlYXIgPSAoKSA9PiB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0XHR0aW1lciA9IHVuZGVmaW5lZDtcblx0fTtcblxuXHRyZXR1cm4gY2FuY2VsYWJsZVByb21pc2U7XG59XG5cbi8vIFBvcnQgb2YgbG93ZXJfYm91bmQgZnJvbSBodHRwczovL2VuLmNwcHJlZmVyZW5jZS5jb20vdy9jcHAvYWxnb3JpdGhtL2xvd2VyX2JvdW5kXG4vLyBVc2VkIHRvIGNvbXB1dGUgaW5zZXJ0aW9uIGluZGV4IHRvIGtlZXAgcXVldWUgc29ydGVkIGFmdGVyIGluc2VydGlvblxuZnVuY3Rpb24gbG93ZXJCb3VuZChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgICBsZXQgZmlyc3QgPSAwO1xuICAgIGxldCBjb3VudCA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAoY291bnQgPiAwKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSBNYXRoLnRydW5jKGNvdW50IC8gMik7XG4gICAgICAgIGxldCBpdCA9IGZpcnN0ICsgc3RlcDtcbiAgICAgICAgaWYgKGNvbXBhcmF0b3IoYXJyYXlbaXRdLCB2YWx1ZSkgPD0gMCkge1xuICAgICAgICAgICAgZmlyc3QgPSArK2l0O1xuICAgICAgICAgICAgY291bnQgLT0gc3RlcCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb3VudCA9IHN0ZXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0O1xufVxuXG5jbGFzcyBQcmlvcml0eVF1ZXVlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3F1ZXVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW5xdWV1ZShydW4sIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgcHJpb3JpdHk6IDAsXG4gICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB7XG4gICAgICAgICAgICBwcmlvcml0eTogb3B0aW9ucy5wcmlvcml0eSxcbiAgICAgICAgICAgIHJ1blxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5zaXplICYmICgoX2EgPSB0aGlzLl9xdWV1ZVt0aGlzLnNpemUgLSAxXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByaW9yaXR5KSA+PSBvcHRpb25zLnByaW9yaXR5KSB7XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbG93ZXJCb3VuZCh0aGlzLl9xdWV1ZSwgZWxlbWVudCwgKGEsIGIpID0+IGIucHJpb3JpdHkgLSBhLnByaW9yaXR5KTtcbiAgICAgICAgdGhpcy5fcXVldWUuc3BsaWNlKGluZGV4LCAwLCBlbGVtZW50KTtcbiAgICB9XG4gICAgZGVxdWV1ZSgpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiBpdGVtID09PSBudWxsIHx8IGl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGl0ZW0ucnVuO1xuICAgIH1cbiAgICBmaWx0ZXIob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVldWUuZmlsdGVyKChlbGVtZW50KSA9PiBlbGVtZW50LnByaW9yaXR5ID09PSBvcHRpb25zLnByaW9yaXR5KS5tYXAoKGVsZW1lbnQpID0+IGVsZW1lbnQucnVuKTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9xdWV1ZS5sZW5ndGg7XG4gICAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG5jb25zdCBlbXB0eSQxID0gKCkgPT4geyB9O1xuY29uc3QgdGltZW91dEVycm9yID0gbmV3IFRpbWVvdXRFcnJvcigpO1xuLyoqXG5Qcm9taXNlIHF1ZXVlIHdpdGggY29uY3VycmVuY3kgY29udHJvbC5cbiovXG5jbGFzcyBQUXVldWUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY2FycnlvdmVyQ29uY3VycmVuY3lDb3VudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaXNJbnRlcnZhbElnbm9yZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ludGVydmFsQ291bnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9pbnRlcnZhbENhcFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaW50ZXJ2YWxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ludGVydmFsRW5kXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaW50ZXJ2YWxJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGltZW91dElkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9xdWV1ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcXVldWVDbGFzc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcGVuZGluZ0NvdW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGUgYCFgIGlzIG5lZWRlZCBiZWNhdXNlIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzIxOTRcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NvbmN1cnJlbmN5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9pc1BhdXNlZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcmVzb2x2ZUVtcHR5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBlbXB0eSQxXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcmVzb2x2ZUlkbGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGVtcHR5JDFcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90aW1lb3V0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90aHJvd09uVGltZW91dFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2NvbnNpc3RlbnQtdHlwZS1hc3NlcnRpb25zXG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBjYXJyeW92ZXJDb25jdXJyZW5jeUNvdW50OiBmYWxzZSxcbiAgICAgICAgICAgIGludGVydmFsQ2FwOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgICAgICBpbnRlcnZhbDogMCxcbiAgICAgICAgICAgIGNvbmN1cnJlbmN5OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgICAgICBhdXRvU3RhcnQ6IHRydWUsXG4gICAgICAgICAgICBxdWV1ZUNsYXNzOiBQcmlvcml0eVF1ZXVlLFxuICAgICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICB9O1xuICAgICAgICBpZiAoISh0eXBlb2Ygb3B0aW9ucy5pbnRlcnZhbENhcCA9PT0gJ251bWJlcicgJiYgb3B0aW9ucy5pbnRlcnZhbENhcCA+PSAxKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgaW50ZXJ2YWxDYXBcXGAgdG8gYmUgYSBudW1iZXIgZnJvbSAxIGFuZCB1cCwgZ290IFxcYCR7KF9iID0gKF9hID0gb3B0aW9ucy5pbnRlcnZhbENhcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvU3RyaW5nKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnfVxcYCAoJHt0eXBlb2Ygb3B0aW9ucy5pbnRlcnZhbENhcH0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaW50ZXJ2YWwgPT09IHVuZGVmaW5lZCB8fCAhKE51bWJlci5pc0Zpbml0ZShvcHRpb25zLmludGVydmFsKSAmJiBvcHRpb25zLmludGVydmFsID49IDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBpbnRlcnZhbFxcYCB0byBiZSBhIGZpbml0ZSBudW1iZXIgPj0gMCwgZ290IFxcYCR7KF9kID0gKF9jID0gb3B0aW9ucy5pbnRlcnZhbCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvU3RyaW5nKCkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICcnfVxcYCAoJHt0eXBlb2Ygb3B0aW9ucy5pbnRlcnZhbH0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FycnlvdmVyQ29uY3VycmVuY3lDb3VudCA9IG9wdGlvbnMuY2FycnlvdmVyQ29uY3VycmVuY3lDb3VudDtcbiAgICAgICAgdGhpcy5faXNJbnRlcnZhbElnbm9yZWQgPSBvcHRpb25zLmludGVydmFsQ2FwID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHwgb3B0aW9ucy5pbnRlcnZhbCA9PT0gMDtcbiAgICAgICAgdGhpcy5faW50ZXJ2YWxDYXAgPSBvcHRpb25zLmludGVydmFsQ2FwO1xuICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IG9wdGlvbnMuaW50ZXJ2YWw7XG4gICAgICAgIHRoaXMuX3F1ZXVlID0gbmV3IG9wdGlvbnMucXVldWVDbGFzcygpO1xuICAgICAgICB0aGlzLl9xdWV1ZUNsYXNzID0gb3B0aW9ucy5xdWV1ZUNsYXNzO1xuICAgICAgICB0aGlzLmNvbmN1cnJlbmN5ID0gb3B0aW9ucy5jb25jdXJyZW5jeTtcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgICAgICAgdGhpcy5fdGhyb3dPblRpbWVvdXQgPSBvcHRpb25zLnRocm93T25UaW1lb3V0ID09PSB0cnVlO1xuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IG9wdGlvbnMuYXV0b1N0YXJ0ID09PSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IF9kb2VzSW50ZXJ2YWxBbGxvd0Fub3RoZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0ludGVydmFsSWdub3JlZCB8fCB0aGlzLl9pbnRlcnZhbENvdW50IDwgdGhpcy5faW50ZXJ2YWxDYXA7XG4gICAgfVxuICAgIGdldCBfZG9lc0NvbmN1cnJlbnRBbGxvd0Fub3RoZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQ291bnQgPCB0aGlzLl9jb25jdXJyZW5jeTtcbiAgICB9XG4gICAgX25leHQoKSB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdDb3VudC0tO1xuICAgICAgICB0aGlzLl90cnlUb1N0YXJ0QW5vdGhlcigpO1xuICAgICAgICB0aGlzLmVtaXQoJ25leHQnKTtcbiAgICB9XG4gICAgX3Jlc29sdmVQcm9taXNlcygpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUVtcHR5KCk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVFbXB0eSA9IGVtcHR5JDE7XG4gICAgICAgIGlmICh0aGlzLl9wZW5kaW5nQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVJZGxlKCk7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlSWRsZSA9IGVtcHR5JDE7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2lkbGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfb25SZXN1bWVJbnRlcnZhbCgpIHtcbiAgICAgICAgdGhpcy5fb25JbnRlcnZhbCgpO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplSW50ZXJ2YWxJZk5lZWRlZCgpO1xuICAgICAgICB0aGlzLl90aW1lb3V0SWQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIF9pc0ludGVydmFsUGF1c2VkKCkge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAodGhpcy5faW50ZXJ2YWxJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkZWxheSA9IHRoaXMuX2ludGVydmFsRW5kIC0gbm93O1xuICAgICAgICAgICAgaWYgKGRlbGF5IDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIEFjdCBhcyB0aGUgaW50ZXJ2YWwgd2FzIGRvbmVcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHJlc3VtZSBpdCBoZXJlIGJlY2F1c2UgaXQgd2lsbCBiZSByZXN1bWVkIG9uIGxpbmUgMTYwXG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWxDb3VudCA9ICh0aGlzLl9jYXJyeW92ZXJDb25jdXJyZW5jeUNvdW50KSA/IHRoaXMuX3BlbmRpbmdDb3VudCA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBY3QgYXMgdGhlIGludGVydmFsIGlzIHBlbmRpbmdcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdGltZW91dElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vblJlc3VtZUludGVydmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfdHJ5VG9TdGFydEFub3RoZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9xdWV1ZS5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAvLyBXZSBjYW4gY2xlYXIgdGhlIGludGVydmFsIChcInBhdXNlXCIpXG4gICAgICAgICAgICAvLyBCZWNhdXNlIHdlIGNhbiByZWRvIGl0IGxhdGVyIChcInJlc3VtZVwiKVxuICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVydmFsSWQpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWxJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVQcm9taXNlcygpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faXNQYXVzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbkluaXRpYWxpemVJbnRlcnZhbCA9ICF0aGlzLl9pc0ludGVydmFsUGF1c2VkKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZG9lc0ludGVydmFsQWxsb3dBbm90aGVyICYmIHRoaXMuX2RvZXNDb25jdXJyZW50QWxsb3dBbm90aGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgam9iID0gdGhpcy5fcXVldWUuZGVxdWV1ZSgpO1xuICAgICAgICAgICAgICAgIGlmICgham9iKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICBqb2IoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FuSW5pdGlhbGl6ZUludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVJbnRlcnZhbElmTmVlZGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX2luaXRpYWxpemVJbnRlcnZhbElmTmVlZGVkKCkge1xuICAgICAgICBpZiAodGhpcy5faXNJbnRlcnZhbElnbm9yZWQgfHwgdGhpcy5faW50ZXJ2YWxJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX29uSW50ZXJ2YWwoKTtcbiAgICAgICAgfSwgdGhpcy5faW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLl9pbnRlcnZhbEVuZCA9IERhdGUubm93KCkgKyB0aGlzLl9pbnRlcnZhbDtcbiAgICB9XG4gICAgX29uSW50ZXJ2YWwoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcnZhbENvdW50ID09PSAwICYmIHRoaXMuX3BlbmRpbmdDb3VudCA9PT0gMCAmJiB0aGlzLl9pbnRlcnZhbElkKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsSWQpO1xuICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWxJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnRlcnZhbENvdW50ID0gdGhpcy5fY2FycnlvdmVyQ29uY3VycmVuY3lDb3VudCA/IHRoaXMuX3BlbmRpbmdDb3VudCA6IDA7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NRdWV1ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICBFeGVjdXRlcyBhbGwgcXVldWVkIGZ1bmN0aW9ucyB1bnRpbCBpdCByZWFjaGVzIHRoZSBsaW1pdC5cbiAgICAqL1xuICAgIF9wcm9jZXNzUXVldWUoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgICAgICB3aGlsZSAodGhpcy5fdHJ5VG9TdGFydEFub3RoZXIoKSkgeyB9XG4gICAgfVxuICAgIGdldCBjb25jdXJyZW5jeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmN1cnJlbmN5O1xuICAgIH1cbiAgICBzZXQgY29uY3VycmVuY3kobmV3Q29uY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIG5ld0NvbmN1cnJlbmN5ID09PSAnbnVtYmVyJyAmJiBuZXdDb25jdXJyZW5jeSA+PSAxKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgY29uY3VycmVuY3lcXGAgdG8gYmUgYSBudW1iZXIgZnJvbSAxIGFuZCB1cCwgZ290IFxcYCR7bmV3Q29uY3VycmVuY3l9XFxgICgke3R5cGVvZiBuZXdDb25jdXJyZW5jeX0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29uY3VycmVuY3kgPSBuZXdDb25jdXJyZW5jeTtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc1F1ZXVlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZHMgYSBzeW5jIG9yIGFzeW5jIHRhc2sgdG8gdGhlIHF1ZXVlLiBBbHdheXMgcmV0dXJucyBhIHByb21pc2UuXG4gICAgKi9cbiAgICBhc3luYyBhZGQoZm4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcnVuID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdDb3VudCsrO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVydmFsQ291bnQrKztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcGVyYXRpb24gPSAodGhpcy5fdGltZW91dCA9PT0gdW5kZWZpbmVkICYmIG9wdGlvbnMudGltZW91dCA9PT0gdW5kZWZpbmVkKSA/IGZuKCkgOiBwVGltZW91dChQcm9taXNlLnJlc29sdmUoZm4oKSksIChvcHRpb25zLnRpbWVvdXQgPT09IHVuZGVmaW5lZCA/IHRoaXMuX3RpbWVvdXQgOiBvcHRpb25zLnRpbWVvdXQpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50aHJvd09uVGltZW91dCA9PT0gdW5kZWZpbmVkID8gdGhpcy5fdGhyb3dPblRpbWVvdXQgOiBvcHRpb25zLnRocm93T25UaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHRpbWVvdXRFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3BlcmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY29tcGxldGVkJywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX25leHQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZS5lbnF1ZXVlKHJ1biwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLl90cnlUb1N0YXJ0QW5vdGhlcigpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdhZGQnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFNhbWUgYXMgYC5hZGQoKWAsIGJ1dCBhY2NlcHRzIGFuIGFycmF5IG9mIHN5bmMgb3IgYXN5bmMgZnVuY3Rpb25zLlxuXG4gICAgQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgZnVuY3Rpb25zIGFyZSByZXNvbHZlZC5cbiAgICAqL1xuICAgIGFzeW5jIGFkZEFsbChmdW5jdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGZ1bmN0aW9ucy5tYXAoYXN5bmMgKGZ1bmN0aW9uXykgPT4gdGhpcy5hZGQoZnVuY3Rpb25fLCBvcHRpb25zKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBTdGFydCAob3IgcmVzdW1lKSBleGVjdXRpbmcgZW5xdWV1ZWQgdGFza3Mgd2l0aGluIGNvbmN1cnJlbmN5IGxpbWl0LiBObyBuZWVkIHRvIGNhbGwgdGhpcyBpZiBxdWV1ZSBpcyBub3QgcGF1c2VkICh2aWEgYG9wdGlvbnMuYXV0b1N0YXJ0ID0gZmFsc2VgIG9yIGJ5IGAucGF1c2UoKWAgbWV0aG9kLilcbiAgICAqL1xuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzUGF1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcm9jZXNzUXVldWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFB1dCBxdWV1ZSBleGVjdXRpb24gb24gaG9sZC5cbiAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIENsZWFyIHRoZSBxdWV1ZS5cbiAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IG5ldyB0aGlzLl9xdWV1ZUNsYXNzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMuIFVzZWZ1bCBpZiB5b3UgZm9yIGV4YW1wbGUgYWRkIGFkZGl0aW9uYWwgaXRlbXMgYXQgYSBsYXRlciB0aW1lLlxuXG4gICAgQHJldHVybnMgQSBwcm9taXNlIHRoYXQgc2V0dGxlcyB3aGVuIHRoZSBxdWV1ZSBiZWNvbWVzIGVtcHR5LlxuICAgICovXG4gICAgYXN5bmMgb25FbXB0eSgpIHtcbiAgICAgICAgLy8gSW5zdGFudGx5IHJlc29sdmUgaWYgdGhlIHF1ZXVlIGlzIGVtcHR5XG4gICAgICAgIGlmICh0aGlzLl9xdWV1ZS5zaXplID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdSZXNvbHZlID0gdGhpcy5fcmVzb2x2ZUVtcHR5O1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZUVtcHR5ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nUmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBAcmV0dXJucyBBIHByb21pc2UgdGhhdCBzZXR0bGVzIHdoZW4gdGhlIHF1ZXVlIHNpemUgaXMgbGVzcyB0aGFuIHRoZSBnaXZlbiBsaW1pdDogYHF1ZXVlLnNpemUgPCBsaW1pdGAuXG5cbiAgICBJZiB5b3Ugd2FudCB0byBhdm9pZCBoYXZpbmcgdGhlIHF1ZXVlIGdyb3cgYmV5b25kIGEgY2VydGFpbiBzaXplIHlvdSBjYW4gYGF3YWl0IHF1ZXVlLm9uU2l6ZUxlc3NUaGFuKClgIGJlZm9yZSBhZGRpbmcgYSBuZXcgaXRlbS5cblxuICAgIE5vdGUgdGhhdCB0aGlzIG9ubHkgbGltaXRzIHRoZSBudW1iZXIgb2YgaXRlbXMgd2FpdGluZyB0byBzdGFydC4gVGhlcmUgY291bGQgc3RpbGwgYmUgdXAgdG8gYGNvbmN1cnJlbmN5YCBqb2JzIGFscmVhZHkgcnVubmluZyB0aGF0IHRoaXMgY2FsbCBkb2VzIG5vdCBpbmNsdWRlIGluIGl0cyBjYWxjdWxhdGlvbi5cbiAgICAqL1xuICAgIGFzeW5jIG9uU2l6ZUxlc3NUaGFuKGxpbWl0KSB7XG4gICAgICAgIC8vIEluc3RhbnRseSByZXNvbHZlIGlmIHRoZSBxdWV1ZSBpcyBlbXB0eS5cbiAgICAgICAgaWYgKHRoaXMuX3F1ZXVlLnNpemUgPCBsaW1pdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9xdWV1ZS5zaXplIDwgbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignbmV4dCcsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9uKCduZXh0JywgbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGRpZmZlcmVuY2Ugd2l0aCBgLm9uRW1wdHlgIGlzIHRoYXQgYC5vbklkbGVgIGd1YXJhbnRlZXMgdGhhdCBhbGwgd29yayBmcm9tIHRoZSBxdWV1ZSBoYXMgZmluaXNoZWQuIGAub25FbXB0eWAgbWVyZWx5IHNpZ25hbHMgdGhhdCB0aGUgcXVldWUgaXMgZW1wdHksIGJ1dCBpdCBjb3VsZCBtZWFuIHRoYXQgc29tZSBwcm9taXNlcyBoYXZlbid0IGNvbXBsZXRlZCB5ZXQuXG5cbiAgICBAcmV0dXJucyBBIHByb21pc2UgdGhhdCBzZXR0bGVzIHdoZW4gdGhlIHF1ZXVlIGJlY29tZXMgZW1wdHksIGFuZCBhbGwgcHJvbWlzZXMgaGF2ZSBjb21wbGV0ZWQ7IGBxdWV1ZS5zaXplID09PSAwICYmIHF1ZXVlLnBlbmRpbmcgPT09IDBgLlxuICAgICovXG4gICAgYXN5bmMgb25JZGxlKCkge1xuICAgICAgICAvLyBJbnN0YW50bHkgcmVzb2x2ZSBpZiBub25lIHBlbmRpbmcgYW5kIGlmIG5vdGhpbmcgZWxzZSBpcyBxdWV1ZWRcbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdDb3VudCA9PT0gMCAmJiB0aGlzLl9xdWV1ZS5zaXplID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdSZXNvbHZlID0gdGhpcy5fcmVzb2x2ZUlkbGU7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlSWRsZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ1Jlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2l6ZSBvZiB0aGUgcXVldWUsIHRoZSBudW1iZXIgb2YgcXVldWVkIGl0ZW1zIHdhaXRpbmcgdG8gcnVuLlxuICAgICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9xdWV1ZS5zaXplO1xuICAgIH1cbiAgICAvKipcbiAgICBTaXplIG9mIHRoZSBxdWV1ZSwgZmlsdGVyZWQgYnkgdGhlIGdpdmVuIG9wdGlvbnMuXG5cbiAgICBGb3IgZXhhbXBsZSwgdGhpcyBjYW4gYmUgdXNlZCB0byBmaW5kIHRoZSBudW1iZXIgb2YgaXRlbXMgcmVtYWluaW5nIGluIHRoZSBxdWV1ZSB3aXRoIGEgc3BlY2lmaWMgcHJpb3JpdHkgbGV2ZWwuXG4gICAgKi9cbiAgICBzaXplQnkob3B0aW9ucykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby1hcnJheS1jYWxsYmFjay1yZWZlcmVuY2VcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXVlLmZpbHRlcihvcHRpb25zKS5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgIE51bWJlciBvZiBydW5uaW5nIGl0ZW1zIChubyBsb25nZXIgaW4gdGhlIHF1ZXVlKS5cbiAgICAqL1xuICAgIGdldCBwZW5kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0NvdW50O1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBxdWV1ZSBpcyBjdXJyZW50bHkgcGF1c2VkLlxuICAgICovXG4gICAgZ2V0IGlzUGF1c2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNQYXVzZWQ7XG4gICAgfVxuICAgIGdldCB0aW1lb3V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGltZW91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IHRoZSB0aW1lb3V0IGZvciBmdXR1cmUgb3BlcmF0aW9ucy5cbiAgICAqL1xuICAgIHNldCB0aW1lb3V0KG1pbGxpc2Vjb25kcykge1xuICAgICAgICB0aGlzLl90aW1lb3V0ID0gbWlsbGlzZWNvbmRzO1xuICAgIH1cbn1cblxuY2xhc3MgWmFyckFycmF5IHtcclxuICAgIC8qKlxyXG4gICAgICogSW5zdGFudGlhdGUgYW4gYXJyYXkgZnJvbSBhbiBpbml0aWFsaXplZCBzdG9yZS5cclxuICAgICAqIEBwYXJhbSBzdG9yZSBBcnJheSBzdG9yZSwgYWxyZWFkeSBpbml0aWFsaXplZC5cclxuICAgICAqIEBwYXJhbSBwYXRoIFN0b3JhZ2UgcGF0aC5cclxuICAgICAqIEBwYXJhbSBtZXRhZGF0YSBUaGUgaW5pdGlhbCB2YWx1ZSBmb3IgdGhlIG1ldGFkYXRhXHJcbiAgICAgKiBAcGFyYW0gcmVhZE9ubHkgVHJ1ZSBpZiBhcnJheSBzaG91bGQgYmUgcHJvdGVjdGVkIGFnYWluc3QgbW9kaWZpY2F0aW9uLlxyXG4gICAgICogQHBhcmFtIGNodW5rU3RvcmUgU2VwYXJhdGUgc3RvcmFnZSBmb3IgY2h1bmtzLiBJZiBub3QgcHJvdmlkZWQsIGBzdG9yZWAgd2lsbCBiZSB1c2VkIGZvciBzdG9yYWdlIG9mIGJvdGggY2h1bmtzIGFuZCBtZXRhZGF0YS5cclxuICAgICAqIEBwYXJhbSBjYWNoZU1ldGFkYXRhIElmIHRydWUgKGRlZmF1bHQpLCBhcnJheSBjb25maWd1cmF0aW9uIG1ldGFkYXRhIHdpbGwgYmUgY2FjaGVkIGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIG9iamVjdC5cclxuICAgICAqIElmIGZhbHNlLCBhcnJheSBtZXRhZGF0YSB3aWxsIGJlIHJlbG9hZGVkIHByaW9yIHRvIGFsbCBkYXRhIGFjY2VzcyBhbmQgbW9kaWZpY2F0aW9uIG9wZXJhdGlvbnMgKG1heSBpbmN1ciBvdmVyaGVhZCBkZXBlbmRpbmcgb24gc3RvcmFnZSBhbmQgZGF0YSBhY2Nlc3MgcGF0dGVybikuXHJcbiAgICAgKiBAcGFyYW0gY2FjaGVBdHRycyBJZiB0cnVlIChkZWZhdWx0KSwgdXNlciBhdHRyaWJ1dGVzIHdpbGwgYmUgY2FjaGVkIGZvciBhdHRyaWJ1dGUgcmVhZCBvcGVyYXRpb25zLlxyXG4gICAgICogSWYgZmFsc2UsIHVzZXIgYXR0cmlidXRlcyBhcmUgcmVsb2FkZWQgZnJvbSB0aGUgc3RvcmUgcHJpb3IgdG8gYWxsIGF0dHJpYnV0ZSByZWFkIG9wZXJhdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHN0b3JlLCBwYXRoID0gbnVsbCwgbWV0YWRhdGEsIHJlYWRPbmx5ID0gZmFsc2UsIGNodW5rU3RvcmUgPSBudWxsLCBjYWNoZU1ldGFkYXRhID0gdHJ1ZSwgY2FjaGVBdHRycyA9IHRydWUpIHtcclxuICAgICAgICAvLyBOLkIuLCBleHBlY3QgYXQgdGhpcyBwb2ludCBzdG9yZSBpcyBmdWxseSBpbml0aWFsaXplZCB3aXRoIGFsbFxyXG4gICAgICAgIC8vIGNvbmZpZ3VyYXRpb24gbWV0YWRhdGEgZnVsbHkgc3BlY2lmaWVkIGFuZCBub3JtYWxpemVkXHJcbiAgICAgICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xyXG4gICAgICAgIHRoaXMuX2NodW5rU3RvcmUgPSBjaHVua1N0b3JlO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IG5vcm1hbGl6ZVN0b3JhZ2VQYXRoKHBhdGgpO1xyXG4gICAgICAgIHRoaXMua2V5UHJlZml4ID0gcGF0aFRvUHJlZml4KHRoaXMucGF0aCk7XHJcbiAgICAgICAgdGhpcy5yZWFkT25seSA9IHJlYWRPbmx5O1xyXG4gICAgICAgIHRoaXMuY2FjaGVNZXRhZGF0YSA9IGNhY2hlTWV0YWRhdGE7XHJcbiAgICAgICAgdGhpcy5jYWNoZUF0dHJzID0gY2FjaGVBdHRycztcclxuICAgICAgICB0aGlzLm1ldGEgPSBtZXRhZGF0YTtcclxuICAgICAgICBpZiAodGhpcy5tZXRhLmNvbXByZXNzb3IgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wcmVzc29yID0gZ2V0Q29kZWModGhpcy5tZXRhLmNvbXByZXNzb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wcmVzc29yID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXR0cktleSA9IHRoaXMua2V5UHJlZml4ICsgQVRUUlNfTUVUQV9LRVk7XHJcbiAgICAgICAgdGhpcy5hdHRycyA9IG5ldyBBdHRyaWJ1dGVzKHRoaXMuc3RvcmUsIGF0dHJLZXksIHRoaXMucmVhZE9ubHksIGNhY2hlQXR0cnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBTdG9yZWAgcHJvdmlkaW5nIHRoZSB1bmRlcmx5aW5nIHN0b3JhZ2UgZm9yIGFycmF5IGNodW5rcy5cclxuICAgICAqL1xyXG4gICAgZ2V0IGNodW5rU3RvcmUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NodW5rU3RvcmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NodW5rU3RvcmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcnJheSBuYW1lIGZvbGxvd2luZyBoNXB5IGNvbnZlbnRpb24uXHJcbiAgICAgKi9cclxuICAgIGdldCBuYW1lKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnBhdGgubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXRoWzBdICE9PSBcIi9cIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiL1wiICsgdGhpcy5wYXRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5hbCBjb21wb25lbnQgb2YgbmFtZS5cclxuICAgICAqL1xyXG4gICAgZ2V0IGJhc2VuYW1lKCkge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWU7XHJcbiAgICAgICAgaWYgKG5hbWUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhcnRzID0gbmFtZS5zcGxpdChcIi9cIik7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBcIkEgbGlzdCBvZiBpbnRlZ2VycyBkZXNjcmliaW5nIHRoZSBsZW5ndGggb2YgZWFjaCBkaW1lbnNpb24gb2YgdGhlIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBnZXQgc2hhcGUoKSB7XHJcbiAgICAgICAgLy8gdGhpcy5yZWZyZXNoTWV0YWRhdGEoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZXRhLnNoYXBlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGxpc3Qgb2YgaW50ZWdlcnMgZGVzY3JpYmluZyB0aGUgbGVuZ3RoIG9mIGVhY2ggZGltZW5zaW9uIG9mIGEgY2h1bmsgb2YgdGhlIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBnZXQgY2h1bmtzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1ldGEuY2h1bmtzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlZ2VyIGRlc2NyaWJpbmcgaG93IG1hbnkgZWxlbWVudCBhIGNodW5rIGNvbnRhaW5zXHJcbiAgICAgKi9cclxuICAgIGdldCBjaHVua1NpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2h1bmtzLnJlZHVjZSgoeCwgeSkgPT4geCAqIHksIDEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIE51bVB5IGRhdGEgdHlwZS5cclxuICAgICAqL1xyXG4gICAgZ2V0IGR0eXBlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1ldGEuZHR5cGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBBIHZhbHVlIHVzZWQgZm9yIHVuaW5pdGlhbGl6ZWQgcG9ydGlvbnMgb2YgdGhlIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBnZXQgZmlsbFZhbHVlKCkge1xyXG4gICAgICAgIGNvbnN0IGZpbGxUeXBlVmFsdWUgPSB0aGlzLm1ldGEuZmlsbF92YWx1ZTtcclxuICAgICAgICAvLyBUT0RPIGV4dHJhY3QgaW50byBmdW5jdGlvblxyXG4gICAgICAgIGlmIChmaWxsVHlwZVZhbHVlID09PSBcIk5hTlwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGZpbGxUeXBlVmFsdWUgPT09IFwiSW5maW5pdHlcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGZpbGxUeXBlVmFsdWUgPT09IFwiLUluZmluaXR5XCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC1JbmZpbml0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0YS5maWxsX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgTnVtYmVyIG9mIGRpbWVuc2lvbnMuXHJcbiAgICAgKi9cclxuICAgIGdldCBuRGltcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZXRhLnNoYXBlLmxlbmd0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFRoZSB0b3RhbCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICAvLyB0aGlzLnJlZnJlc2hNZXRhZGF0YSgpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0YS5zaGFwZS5yZWR1Y2UoKHgsIHkpID0+IHggKiB5LCAxKTtcclxuICAgIH1cclxuICAgIGdldCBsZW5ndGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcGVbMF07XHJcbiAgICB9XHJcbiAgICBnZXQgX2NodW5rRGF0YVNoYXBlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNoYXBlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2hhcGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHNbaV0gPSBNYXRoLmNlaWwodGhpcy5zaGFwZVtpXSAvIHRoaXMuY2h1bmtzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgdHVwbGUgb2YgaW50ZWdlcnMgZGVzY3JpYmluZyB0aGUgbnVtYmVyIG9mIGNodW5rcyBhbG9uZyBlYWNoXHJcbiAgICAgKiBkaW1lbnNpb24gb2YgdGhlIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBnZXQgY2h1bmtEYXRhU2hhcGUoKSB7XHJcbiAgICAgICAgLy8gdGhpcy5yZWZyZXNoTWV0YWRhdGEoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2h1bmtEYXRhU2hhcGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRvdGFsIG51bWJlciBvZiBjaHVua3MuXHJcbiAgICAgKi9cclxuICAgIGdldCBudW1DaHVua3MoKSB7XHJcbiAgICAgICAgLy8gdGhpcy5yZWZyZXNoTWV0YWRhdGEoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaHVua0RhdGFTaGFwZS5yZWR1Y2UoKHgsIHkpID0+IHggKiB5LCAxKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5zdGFudGlhdGUgYW4gYXJyYXkgZnJvbSBhbiBpbml0aWFsaXplZCBzdG9yZS5cclxuICAgICAqIEBwYXJhbSBzdG9yZSBBcnJheSBzdG9yZSwgYWxyZWFkeSBpbml0aWFsaXplZC5cclxuICAgICAqIEBwYXJhbSBwYXRoIFN0b3JhZ2UgcGF0aC5cclxuICAgICAqIEBwYXJhbSByZWFkT25seSBUcnVlIGlmIGFycmF5IHNob3VsZCBiZSBwcm90ZWN0ZWQgYWdhaW5zdCBtb2RpZmljYXRpb24uXHJcbiAgICAgKiBAcGFyYW0gY2h1bmtTdG9yZSBTZXBhcmF0ZSBzdG9yYWdlIGZvciBjaHVua3MuIElmIG5vdCBwcm92aWRlZCwgYHN0b3JlYCB3aWxsIGJlIHVzZWQgZm9yIHN0b3JhZ2Ugb2YgYm90aCBjaHVua3MgYW5kIG1ldGFkYXRhLlxyXG4gICAgICogQHBhcmFtIGNhY2hlTWV0YWRhdGEgSWYgdHJ1ZSAoZGVmYXVsdCksIGFycmF5IGNvbmZpZ3VyYXRpb24gbWV0YWRhdGEgd2lsbCBiZSBjYWNoZWQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgb2JqZWN0LlxyXG4gICAgICogSWYgZmFsc2UsIGFycmF5IG1ldGFkYXRhIHdpbGwgYmUgcmVsb2FkZWQgcHJpb3IgdG8gYWxsIGRhdGEgYWNjZXNzIGFuZCBtb2RpZmljYXRpb24gb3BlcmF0aW9ucyAobWF5IGluY3VyIG92ZXJoZWFkIGRlcGVuZGluZyBvbiBzdG9yYWdlIGFuZCBkYXRhIGFjY2VzcyBwYXR0ZXJuKS5cclxuICAgICAqIEBwYXJhbSBjYWNoZUF0dHJzIElmIHRydWUgKGRlZmF1bHQpLCB1c2VyIGF0dHJpYnV0ZXMgd2lsbCBiZSBjYWNoZWQgZm9yIGF0dHJpYnV0ZSByZWFkIG9wZXJhdGlvbnMuXHJcbiAgICAgKiBJZiBmYWxzZSwgdXNlciBhdHRyaWJ1dGVzIGFyZSByZWxvYWRlZCBmcm9tIHRoZSBzdG9yZSBwcmlvciB0byBhbGwgYXR0cmlidXRlIHJlYWQgb3BlcmF0aW9ucy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShzdG9yZSwgcGF0aCA9IG51bGwsIHJlYWRPbmx5ID0gZmFsc2UsIGNodW5rU3RvcmUgPSBudWxsLCBjYWNoZU1ldGFkYXRhID0gdHJ1ZSwgY2FjaGVBdHRycyA9IHRydWUpIHtcclxuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMubG9hZE1ldGFkYXRhRm9yQ29uc3RydWN0b3Ioc3RvcmUsIHBhdGgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgWmFyckFycmF5KHN0b3JlLCBwYXRoLCBtZXRhZGF0YSwgcmVhZE9ubHksIGNodW5rU3RvcmUsIGNhY2hlTWV0YWRhdGEsIGNhY2hlQXR0cnMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGxvYWRNZXRhZGF0YUZvckNvbnN0cnVjdG9yKHN0b3JlLCBwYXRoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcGF0aCA9IG5vcm1hbGl6ZVN0b3JhZ2VQYXRoKHBhdGgpO1xyXG4gICAgICAgICAgICBjb25zdCBrZXlQcmVmaXggPSBwYXRoVG9QcmVmaXgocGF0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1ldGFTdG9yZVZhbHVlID0gYXdhaXQgc3RvcmUuZ2V0SXRlbShrZXlQcmVmaXggKyBBUlJBWV9NRVRBX0tFWSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU1ldGFkYXRhKG1ldGFTdG9yZVZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGlmIChhd2FpdCBjb250YWluc0dyb3VwKHN0b3JlLCBwYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvbnRhaW5zR3JvdXBFcnJvcihwYXRoICE9PSBudWxsICYmIHBhdGggIT09IHZvaWQgMCA/IHBhdGggOiAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgbWV0YWRhdGEgZm9yIFphcnJBcnJheTpcIiArIGVycm9yLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogKFJlKWxvYWQgbWV0YWRhdGEgZnJvbSBzdG9yZVxyXG4gICAgICovXHJcbiAgICBhc3luYyByZWxvYWRNZXRhZGF0YSgpIHtcclxuICAgICAgICBjb25zdCBtZXRhS2V5ID0gdGhpcy5rZXlQcmVmaXggKyBBUlJBWV9NRVRBX0tFWTtcclxuICAgICAgICBjb25zdCBtZXRhU3RvcmVWYWx1ZSA9IHRoaXMuc3RvcmUuZ2V0SXRlbShtZXRhS2V5KTtcclxuICAgICAgICB0aGlzLm1ldGEgPSBwYXJzZU1ldGFkYXRhKGF3YWl0IG1ldGFTdG9yZVZhbHVlKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZXRhO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcmVmcmVzaE1ldGFkYXRhKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5jYWNoZU1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVsb2FkTWV0YWRhdGEoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQoc2VsZWN0aW9uID0gbnVsbCwgb3B0cyA9IHt9KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmFzaWNTZWxlY3Rpb24oc2VsZWN0aW9uLCBmYWxzZSwgb3B0cyk7XHJcbiAgICB9XHJcbiAgICBnZXRSYXcoc2VsZWN0aW9uID0gbnVsbCwgb3B0cyA9IHt9KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmFzaWNTZWxlY3Rpb24oc2VsZWN0aW9uLCB0cnVlLCBvcHRzKTtcclxuICAgIH1cclxuICAgIGFzeW5jIGdldEJhc2ljU2VsZWN0aW9uKHNlbGVjdGlvbiwgYXNSYXcgPSBmYWxzZSwgeyBjb25jdXJyZW5jeUxpbWl0ID0gMTAsIHByb2dyZXNzQ2FsbGJhY2sgfSA9IHt9KSB7XHJcbiAgICAgICAgLy8gUmVmcmVzaCBtZXRhZGF0YVxyXG4gICAgICAgIGlmICghdGhpcy5jYWNoZU1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVsb2FkTWV0YWRhdGEoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgZmllbGRzIChUT0RPPylcclxuICAgICAgICBpZiAodGhpcy5zaGFwZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2hhcGUgW10gaW5kZXhpbmcgaXMgbm90IHN1cHBvcnRlZCB5ZXRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCYXNpY1NlbGVjdGlvbk5EKHNlbGVjdGlvbiwgYXNSYXcsIGNvbmN1cnJlbmN5TGltaXQsIHByb2dyZXNzQ2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEJhc2ljU2VsZWN0aW9uTkQoc2VsZWN0aW9uLCBhc1JhdywgY29uY3VycmVuY3lMaW1pdCwgcHJvZ3Jlc3NDYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ZXIgPSBuZXcgQmFzaWNJbmRleGVyKHNlbGVjdGlvbiwgdGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VsZWN0aW9uKGluZGV4ZXIsIGFzUmF3LCBjb25jdXJyZW5jeUxpbWl0LCBwcm9ncmVzc0NhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIGFzeW5jIGdldFNlbGVjdGlvbihpbmRleGVyLCBhc1JhdywgY29uY3VycmVuY3lMaW1pdCwgcHJvZ3Jlc3NDYWxsYmFjaykge1xyXG4gICAgICAgIC8vIFdlIGl0ZXJhdGUgb3ZlciBhbGwgY2h1bmtzIHdoaWNoIG92ZXJsYXAgdGhlIHNlbGVjdGlvbiBhbmQgdGh1cyBjb250YWluIGRhdGFcclxuICAgICAgICAvLyB0aGF0IG5lZWRzIHRvIGJlIGV4dHJhY3RlZC4gRWFjaCBjaHVuayBpcyBwcm9jZXNzZWQgaW4gdHVybiwgZXh0cmFjdGluZyB0aGVcclxuICAgICAgICAvLyBuZWNlc3NhcnkgZGF0YSBhbmQgc3RvcmluZyBpbnRvIHRoZSBjb3JyZWN0IGxvY2F0aW9uIGluIHRoZSBvdXRwdXQgYXJyYXkuXHJcbiAgICAgICAgLy8gTi5CLiwgaXQgaXMgYW4gaW1wb3J0YW50IG9wdGltaXNhdGlvbiB0aGF0IHdlIG9ubHkgdmlzaXQgY2h1bmtzIHdoaWNoIG92ZXJsYXBcclxuICAgICAgICAvLyB0aGUgc2VsZWN0aW9uLiBUaGlzIG1pbmltaXNlcyB0aGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgaW4gdGhlIG1haW4gZm9yIGxvb3AuXHJcbiAgICAgICAgLy8gY2hlY2sgZmllbGRzIGFyZSBzZW5zaWJsZSAoVE9ETz8pXHJcbiAgICAgICAgY29uc3Qgb3V0RHR5cGUgPSB0aGlzLmR0eXBlO1xyXG4gICAgICAgIGNvbnN0IG91dFNoYXBlID0gaW5kZXhlci5zaGFwZTtcclxuICAgICAgICBjb25zdCBvdXRTaXplID0gaW5kZXhlci5zaGFwZS5yZWR1Y2UoKHgsIHkpID0+IHggKiB5LCAxKTtcclxuICAgICAgICBpZiAoYXNSYXcgJiYgKG91dFNpemUgPT09IHRoaXMuY2h1bmtTaXplKSkge1xyXG4gICAgICAgICAgICAvLyBPcHRpbWl6YXRpb246IGlmIG91dHB1dCBzdHJpZGVkIGFycmF5IF9pc18gY2h1bmsgZXhhY3RseSxcclxuICAgICAgICAgICAgLy8gZGVjb2RlIGRpcmVjdGx5IGFzIG5ldyBUeXBlZEFycmF5IGFuZCByZXR1cm5cclxuICAgICAgICAgICAgY29uc3QgaXRyID0gaW5kZXhlci5pdGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb2ogPSBpdHIubmV4dCgpOyAvLyBlbnN1cmUgdGhlcmUgaXMgb25seSBvbmUgcHJvamVjdGlvblxyXG4gICAgICAgICAgICBpZiAocHJvai5kb25lID09PSBmYWxzZSAmJiBpdHIubmV4dCgpLmRvbmUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rUHJvamVjdGlvbiA9IHByb2oudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvdXQgPSBhd2FpdCB0aGlzLmRlY29kZURpcmVjdFRvUmF3QXJyYXkoY2h1bmtQcm9qZWN0aW9uLCBvdXRTaGFwZSwgb3V0U2l6ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG91dCA9IGFzUmF3XHJcbiAgICAgICAgICAgID8gbmV3IFJhd0FycmF5KG51bGwsIG91dFNoYXBlLCBvdXREdHlwZSlcclxuICAgICAgICAgICAgOiBuZXcgTmVzdGVkQXJyYXkobnVsbCwgb3V0U2hhcGUsIG91dER0eXBlKTtcclxuICAgICAgICBpZiAob3V0U2l6ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjcmVhdGUgcHJvbWlzZSBxdWV1ZSB3aXRoIGNvbmN1cnJlbmN5IGNvbnRyb2xcclxuICAgICAgICBjb25zdCBxdWV1ZSA9IG5ldyBQUXVldWUoeyBjb25jdXJyZW5jeTogY29uY3VycmVuY3lMaW1pdCB9KTtcclxuICAgICAgICBpZiAocHJvZ3Jlc3NDYWxsYmFjaykge1xyXG4gICAgICAgICAgICBsZXQgcHJvZ3Jlc3MgPSAwO1xyXG4gICAgICAgICAgICBsZXQgcXVldWVTaXplID0gMDtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBfIG9mIGluZGV4ZXIuaXRlcigpKVxyXG4gICAgICAgICAgICAgICAgcXVldWVTaXplICs9IDE7XHJcbiAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2soeyBwcm9ncmVzczogMCwgcXVldWVTaXplOiBxdWV1ZVNpemUgfSk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvaiBvZiBpbmRleGVyLml0ZXIoKSkge1xyXG4gICAgICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBxdWV1ZS5hZGQoKCkgPT4gdGhpcy5jaHVua0dldEl0ZW0ocHJvai5jaHVua0Nvb3JkcywgcHJvai5jaHVua1NlbGVjdGlvbiwgb3V0LCBwcm9qLm91dFNlbGVjdGlvbiwgaW5kZXhlci5kcm9wQXhlcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayh7IHByb2dyZXNzOiBwcm9ncmVzcywgcXVldWVTaXplOiBxdWV1ZVNpemUgfSk7XHJcbiAgICAgICAgICAgICAgICB9KSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb2ogb2YgaW5kZXhlci5pdGVyKCkpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlLmFkZCgoKSA9PiB0aGlzLmNodW5rR2V0SXRlbShwcm9qLmNodW5rQ29vcmRzLCBwcm9qLmNodW5rU2VsZWN0aW9uLCBvdXQsIHByb2oub3V0U2VsZWN0aW9uLCBpbmRleGVyLmRyb3BBeGVzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZ3VhcmFudGVlcyB0aGF0IGFsbCB3b3JrIG9uIHF1ZXVlIGhhcyBmaW5pc2hlZFxyXG4gICAgICAgIGF3YWl0IHF1ZXVlLm9uSWRsZSgpO1xyXG4gICAgICAgIC8vIFJldHVybiBzY2FsYXIgaW5zdGVhZCBvZiB6ZXJvLWRpbWVuc2lvbmFsIGFycmF5LlxyXG4gICAgICAgIGlmIChvdXQuc2hhcGUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvdXQuZGF0YVswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT2J0YWluIHBhcnQgb3Igd2hvbGUgb2YgYSBjaHVuay5cclxuICAgICAqIEBwYXJhbSBjaHVua0Nvb3JkcyBJbmRpY2VzIG9mIHRoZSBjaHVuay5cclxuICAgICAqIEBwYXJhbSBjaHVua1NlbGVjdGlvbiBMb2NhdGlvbiBvZiByZWdpb24gd2l0aGluIHRoZSBjaHVuayB0byBleHRyYWN0LlxyXG4gICAgICogQHBhcmFtIG91dCBBcnJheSB0byBzdG9yZSByZXN1bHQgaW4uXHJcbiAgICAgKiBAcGFyYW0gb3V0U2VsZWN0aW9uIExvY2F0aW9uIG9mIHJlZ2lvbiB3aXRoaW4gb3V0cHV0IGFycmF5IHRvIHN0b3JlIHJlc3VsdHMgaW4uXHJcbiAgICAgKiBAcGFyYW0gZHJvcEF4ZXMgQXhlcyB0byBzcXVlZXplIG91dCBvZiB0aGUgY2h1bmsuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGNodW5rR2V0SXRlbShjaHVua0Nvb3JkcywgY2h1bmtTZWxlY3Rpb24sIG91dCwgb3V0U2VsZWN0aW9uLCBkcm9wQXhlcykge1xyXG4gICAgICAgIGlmIChjaHVua0Nvb3Jkcy5sZW5ndGggIT09IHRoaXMuX2NodW5rRGF0YVNoYXBlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgSW5jb25zaXN0ZW50IHNoYXBlczogY2h1bmtDb29yZHNMZW5ndGg6ICR7Y2h1bmtDb29yZHMubGVuZ3RofSwgY0RhdGFTaGFwZUxlbmd0aDogJHt0aGlzLmNodW5rRGF0YVNoYXBlLmxlbmd0aH1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY0tleSA9IHRoaXMuY2h1bmtLZXkoY2h1bmtDb29yZHMpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNkYXRhID0gYXdhaXQgdGhpcy5jaHVua1N0b3JlLmdldEl0ZW0oY0tleSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZWRDaHVuayA9IGF3YWl0IHRoaXMuZGVjb2RlQ2h1bmsoY2RhdGEpO1xyXG4gICAgICAgICAgICBpZiAob3V0IGluc3RhbmNlb2YgTmVzdGVkQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0NvbnRpZ3VvdXNTZWxlY3Rpb24ob3V0U2VsZWN0aW9uKSAmJiBpc1RvdGFsU2xpY2UoY2h1bmtTZWxlY3Rpb24sIHRoaXMuY2h1bmtzKSAmJiAhdGhpcy5tZXRhLmZpbHRlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6YXRpb246IHdlIHdhbnQgdGhlIHdob2xlIGNodW5rLCBhbmQgdGhlIGRlc3RpbmF0aW9uIGlzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udGlndW91cywgc28gd2UgY2FuIGRlY29tcHJlc3MgZGlyZWN0bHkgZnJvbSB0aGUgY2h1bmtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRvIHRoZSBkZXN0aW5hdGlvbiBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gY2hlY2sgb3JkZXJcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGZpbHRlcnMuLlxyXG4gICAgICAgICAgICAgICAgICAgIG91dC5zZXQob3V0U2VsZWN0aW9uLCB0aGlzLnRvTmVzdGVkQXJyYXkoZGVjb2RlZENodW5rKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRGVjb2RlIGNodW5rXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMudG9OZXN0ZWRBcnJheShkZWNvZGVkQ2h1bmspO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG1wID0gY2h1bmsuZ2V0KGNodW5rU2VsZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIGlmIChkcm9wQXhlcyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRyb3AgYXhlcyBpcyBub3Qgc3VwcG9ydGVkIHlldFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG91dC5zZXQob3V0U2VsZWN0aW9uLCB0bXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLyogUmF3QXJyYXlcclxuICAgICAgICAgICAgICAgIENvcGllcyBjaHVuayBieSBpbmRleCBkaXJlY3RseSBpbnRvIG91dHB1dC4gRG9lc24ndCBtYXR0ZXIgaWYgc2VsZWN0aW9uIGlzIGNvbnRpZ3VvdXNcclxuICAgICAgICAgICAgICAgIHNpbmNlIHN0b3JlL291dHB1dCBhcmUgZGlmZmVyZW50IHNoYXBlcy9zdHJpZGVzLlxyXG4gICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIG91dC5zZXQob3V0U2VsZWN0aW9uLCB0aGlzLmNodW5rQnVmZmVyVG9SYXdBcnJheShkZWNvZGVkQ2h1bmspLCBjaHVua1NlbGVjdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0tleUVycm9yKGVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZmlsbCB3aXRoIHNjYWxhciBpZiBjS2V5IGRvZXNuJ3QgZXhpc3QgaW4gc3RvcmVcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbGxWYWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dC5zZXQob3V0U2VsZWN0aW9uLCB0aGlzLmZpbGxWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEaWZmZXJlbnQgdHlwZSBvZiBlcnJvciAtIHJldGhyb3dcclxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0UmF3Q2h1bmsoY2h1bmtDb29yZHMsIG9wdHMpIHtcclxuICAgICAgICBpZiAoY2h1bmtDb29yZHMubGVuZ3RoICE9PSB0aGlzLnNoYXBlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENodW5rIGNvb3JkaW5hdGVzICR7Y2h1bmtDb29yZHMuam9pbihcIi5cIil9IGRvIG5vdCBjb3JyZXNwb25kIHRvIHNoYXBlICR7dGhpcy5zaGFwZX0uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtDb29yZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpbUxlbmd0aCA9IE1hdGguY2VpbCh0aGlzLnNoYXBlW2ldIC8gdGhpcy5jaHVua3NbaV0pO1xyXG4gICAgICAgICAgICAgICAgY2h1bmtDb29yZHNbaV0gPSBub3JtYWxpemVJbnRlZ2VyU2VsZWN0aW9uKGNodW5rQ29vcmRzW2ldLCBkaW1MZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCb3VuZHNDaGVja0Vycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQm91bmRzQ2hlY2tFcnJvcihgaW5kZXggJHtjaHVua0Nvb3Jkcy5qb2luKFwiLlwiKX0gaXMgb3V0IG9mIGJvdW5kcyBmb3Igc2hhcGU6ICR7dGhpcy5zaGFwZX0gYW5kIGNodW5rcyAke3RoaXMuY2h1bmtzfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY0tleSA9IHRoaXMuY2h1bmtLZXkoY2h1bmtDb29yZHMpO1xyXG4gICAgICAgIGNvbnN0IGNkYXRhID0gdGhpcy5jaHVua1N0b3JlLmdldEl0ZW0oY0tleSwgb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnN0b3JlT3B0aW9ucyk7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gYXdhaXQgdGhpcy5kZWNvZGVDaHVuayhhd2FpdCBjZGF0YSk7XHJcbiAgICAgICAgY29uc3Qgb3V0U2hhcGUgPSB0aGlzLmNodW5rcy5maWx0ZXIoZCA9PiBkICE9PSAxKTsgLy8gc3F1ZWV6ZSBjaHVuayBkaW0gaWYgMVxyXG4gICAgICAgIHJldHVybiBuZXcgUmF3QXJyYXkoYnVmZmVyLCBvdXRTaGFwZSwgdGhpcy5kdHlwZSk7XHJcbiAgICB9XHJcbiAgICBjaHVua0tleShjaHVua0Nvb3Jkcykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBzZXAgPSAoX2EgPSB0aGlzLm1ldGEuZGltZW5zaW9uX3NlcGFyYXRvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCIuXCI7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5UHJlZml4ICsgY2h1bmtDb29yZHMuam9pbihzZXApO1xyXG4gICAgfVxyXG4gICAgZW5zdXJlQnl0ZUFycmF5KGNodW5rRGF0YSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2h1bmtEYXRhID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbShjaHVua0RhdGEpLmJ1ZmZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShjaHVua0RhdGEpO1xyXG4gICAgfVxyXG4gICAgdG9UeXBlZEFycmF5KGJ1ZmZlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgKGdldFR5cGVkQXJyYXlDdHIodGhpcy5kdHlwZSkpKGJ1ZmZlcik7XHJcbiAgICB9XHJcbiAgICB0b05lc3RlZEFycmF5KGRhdGEpIHtcclxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLmVuc3VyZUJ5dGVBcnJheShkYXRhKS5idWZmZXI7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOZXN0ZWRBcnJheShidWZmZXIsIHRoaXMuY2h1bmtzLCB0aGlzLmR0eXBlKTtcclxuICAgIH1cclxuICAgIGFzeW5jIGRlY29kZUNodW5rKGNodW5rRGF0YSkge1xyXG4gICAgICAgIGxldCBieXRlcyA9IHRoaXMuZW5zdXJlQnl0ZUFycmF5KGNodW5rRGF0YSk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcHJlc3NvciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBieXRlcyA9IGF3YWl0IChhd2FpdCB0aGlzLmNvbXByZXNzb3IpLmRlY29kZShieXRlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmR0eXBlLmluY2x1ZGVzKCc+JykpIHtcclxuICAgICAgICAgICAgLy8gTmVlZCB0byBmbGlwIGJ5dGVzIGZvciBKYXZhc2NyaXB0IFR5cGVkQXJyYXlzXHJcbiAgICAgICAgICAgIC8vIFdlIGZsaXAgYnl0ZXMgaW4tcGxhY2UgdG8gYXZvaWQgY3JlYXRpbmcgYW4gZXh0cmEgY29weSBvZiB0aGUgZGVjb2RlZCBidWZmZXIuXHJcbiAgICAgICAgICAgIGJ5dGVTd2FwSW5wbGFjZSh0aGlzLnRvVHlwZWRBcnJheShieXRlcy5idWZmZXIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubWV0YS5vcmRlciA9PT0gXCJGXCIgJiYgdGhpcy5uRGltcyA+IDEpIHtcclxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB0cmFuc3Bvc2UgdGhlIGFycmF5LCBiZWNhdXNlIHRoaXMgbGlicmFyeSBvbmx5IHN1cHBvcnQgQy1vcmRlci5cclxuICAgICAgICAgICAgY29uc3Qgc3JjID0gdGhpcy50b1R5cGVkQXJyYXkoYnl0ZXMuYnVmZmVyKTtcclxuICAgICAgICAgICAgY29uc3Qgb3V0ID0gbmV3IChnZXRUeXBlZEFycmF5Q3RyKHRoaXMuZHR5cGUpKShzcmMubGVuZ3RoKTtcclxuICAgICAgICAgICAgY29udmVydENvbE1ham9yVG9Sb3dNYWpvcihzcmMsIG91dCwgdGhpcy5jaHVua3MpO1xyXG4gICAgICAgICAgICByZXR1cm4gb3V0LmJ1ZmZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETyBmaWx0ZXJpbmcgZXRjXHJcbiAgICAgICAgcmV0dXJuIGJ5dGVzLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIGNodW5rQnVmZmVyVG9SYXdBcnJheShidWZmZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJhd0FycmF5KGJ1ZmZlciwgdGhpcy5jaHVua3MsIHRoaXMuZHR5cGUpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZGVjb2RlRGlyZWN0VG9SYXdBcnJheSh7IGNodW5rQ29vcmRzIH0sIG91dFNoYXBlLCBvdXRTaXplKSB7XHJcbiAgICAgICAgY29uc3QgY0tleSA9IHRoaXMuY2h1bmtLZXkoY2h1bmtDb29yZHMpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNkYXRhID0gYXdhaXQgdGhpcy5jaHVua1N0b3JlLmdldEl0ZW0oY0tleSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmF3QXJyYXkoYXdhaXQgdGhpcy5kZWNvZGVDaHVuayhjZGF0YSksIG91dFNoYXBlLCB0aGlzLmR0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0tleUVycm9yKGVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZmlsbCB3aXRoIHNjYWxhciBpZiBpdGVtIGRvZXNuJ3QgZXhpc3RcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgKGdldFR5cGVkQXJyYXlDdHIodGhpcy5kdHlwZSkpKG91dFNpemUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSYXdBcnJheShkYXRhLmZpbGwodGhpcy5maWxsVmFsdWUpLCBvdXRTaGFwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEaWZmZXJlbnQgdHlwZSBvZiBlcnJvciAtIHJldGhyb3dcclxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgc2V0KHNlbGVjdGlvbiA9IG51bGwsIHZhbHVlLCBvcHRzID0ge30pIHtcclxuICAgICAgICBhd2FpdCB0aGlzLnNldEJhc2ljU2VsZWN0aW9uKHNlbGVjdGlvbiwgdmFsdWUsIG9wdHMpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc2V0QmFzaWNTZWxlY3Rpb24oc2VsZWN0aW9uLCB2YWx1ZSwgeyBjb25jdXJyZW5jeUxpbWl0ID0gMTAsIHByb2dyZXNzQ2FsbGJhY2sgfSA9IHt9KSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVhZE9ubHkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFBlcm1pc3Npb25FcnJvcihcIk9iamVjdCBpcyByZWFkIG9ubHlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5jYWNoZU1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVsb2FkTWV0YWRhdGEoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc2hhcGUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNoYXBlIFtdIGluZGV4aW5nIGlzIG5vdCBzdXBwb3J0ZWQgeWV0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXRCYXNpY1NlbGVjdGlvbk5EKHNlbGVjdGlvbiwgdmFsdWUsIGNvbmN1cnJlbmN5TGltaXQsIHByb2dyZXNzQ2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzeW5jIHNldEJhc2ljU2VsZWN0aW9uTkQoc2VsZWN0aW9uLCB2YWx1ZSwgY29uY3VycmVuY3lMaW1pdCwgcHJvZ3Jlc3NDYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ZXIgPSBuZXcgQmFzaWNJbmRleGVyKHNlbGVjdGlvbiwgdGhpcyk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5zZXRTZWxlY3Rpb24oaW5kZXhlciwgdmFsdWUsIGNvbmN1cnJlbmN5TGltaXQsIHByb2dyZXNzQ2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2h1bmtWYWx1ZShwcm9qLCBpbmRleGVyLCB2YWx1ZSwgc2VsZWN0aW9uU2hhcGUpIHtcclxuICAgICAgICBsZXQgY2h1bmtWYWx1ZTtcclxuICAgICAgICBpZiAoc2VsZWN0aW9uU2hhcGUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNodW5rVmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIGNodW5rVmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNodW5rVmFsdWUgPSB2YWx1ZS5nZXQocHJvai5vdXRTZWxlY3Rpb24pO1xyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IHN0cmljdC10eXBlLXByZWRpY2F0ZXNcclxuICAgICAgICAgICAgaWYgKGluZGV4ZXIuZHJvcEF4ZXMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhhbmRsaW5nIGRyb3AgYXhlcyBub3Qgc3VwcG9ydGVkIHlldFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2h1bmtWYWx1ZTtcclxuICAgIH1cclxuICAgIGFzeW5jIHNldFNlbGVjdGlvbihpbmRleGVyLCB2YWx1ZSwgY29uY3VycmVuY3lMaW1pdCwgcHJvZ3Jlc3NDYWxsYmFjaykge1xyXG4gICAgICAgIC8vIFdlIGl0ZXJhdGUgb3ZlciBhbGwgY2h1bmtzIHdoaWNoIG92ZXJsYXAgdGhlIHNlbGVjdGlvbiBhbmQgdGh1cyBjb250YWluIGRhdGFcclxuICAgICAgICAvLyB0aGF0IG5lZWRzIHRvIGJlIHJlcGxhY2VkLiBFYWNoIGNodW5rIGlzIHByb2Nlc3NlZCBpbiB0dXJuLCBleHRyYWN0aW5nIHRoZVxyXG4gICAgICAgIC8vIG5lY2Vzc2FyeSBkYXRhIGZyb20gdGhlIHZhbHVlIGFycmF5IGFuZCBzdG9yaW5nIGludG8gdGhlIGNodW5rIGFycmF5LlxyXG4gICAgICAgIC8vIE4uQi4sIGl0IGlzIGFuIGltcG9ydGFudCBvcHRpbWlzYXRpb24gdGhhdCB3ZSBvbmx5IHZpc2l0IGNodW5rcyB3aGljaCBvdmVybGFwXHJcbiAgICAgICAgLy8gdGhlIHNlbGVjdGlvbi4gVGhpcyBtaW5pbWlzZXMgdGhlIG51bWJlciBvZiBpdGVyYXRpb25zIGluIHRoZSBtYWluIGZvciBsb29wLlxyXG4gICAgICAgIC8vIFRPRE8/IGNoZWNrIGZpZWxkcyBhcmUgc2Vuc2libGVcclxuICAgICAgICAvLyBEZXRlcm1pbmUgaW5kaWNlcyBvZiBjaHVua3Mgb3ZlcmxhcHBpbmcgdGhlIHNlbGVjdGlvblxyXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvblNoYXBlID0gaW5kZXhlci5zaGFwZTtcclxuICAgICAgICAvLyBDaGVjayB2YWx1ZSBzaGFwZVxyXG4gICAgICAgIGlmIChzZWxlY3Rpb25TaGFwZS5sZW5ndGggPT09IDApIDtcclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIDtcclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE5lc3RlZEFycmF5KSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IG5vbiBzdHJpbmdpZnkgZXF1YWxpdHkgY2hlY2tcclxuICAgICAgICAgICAgaWYgKCFhcnJheUVxdWFsczFEKHZhbHVlLnNoYXBlLCBzZWxlY3Rpb25TaGFwZSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKGBTaGFwZSBtaXNtYXRjaCBpbiBzb3VyY2UgTmVzdGVkQXJyYXkgYW5kIHNldCBzZWxlY3Rpb246ICR7dmFsdWUuc2hhcGV9IGFuZCAke3NlbGVjdGlvblNoYXBlfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUT0RPIHN1cHBvcnQgVHlwZWRBcnJheXMsIGJ1ZmZlcnMsIGV0Y1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZSBmb3Igc2V0dGluZyA6KFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcXVldWUgPSBuZXcgUFF1ZXVlKHsgY29uY3VycmVuY3k6IGNvbmN1cnJlbmN5TGltaXQgfSk7XHJcbiAgICAgICAgaWYgKHByb2dyZXNzQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgbGV0IHF1ZXVlU2l6ZSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgXyBvZiBpbmRleGVyLml0ZXIoKSlcclxuICAgICAgICAgICAgICAgIHF1ZXVlU2l6ZSArPSAxO1xyXG4gICAgICAgICAgICBsZXQgcHJvZ3Jlc3MgPSAwO1xyXG4gICAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKHsgcHJvZ3Jlc3M6IDAsIHF1ZXVlU2l6ZTogcXVldWVTaXplIH0pO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb2ogb2YgaW5kZXhlci5pdGVyKCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rVmFsdWUgPSB0aGlzLmdldENodW5rVmFsdWUocHJvaiwgaW5kZXhlciwgdmFsdWUsIHNlbGVjdGlvblNoYXBlKTtcclxuICAgICAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcXVldWUuYWRkKCgpID0+IHRoaXMuY2h1bmtTZXRJdGVtKHByb2ouY2h1bmtDb29yZHMsIHByb2ouY2h1bmtTZWxlY3Rpb24sIGNodW5rVmFsdWUpKTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzcyArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2soeyBwcm9ncmVzczogcHJvZ3Jlc3MsIHF1ZXVlU2l6ZTogcXVldWVTaXplIH0pO1xyXG4gICAgICAgICAgICAgICAgfSkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9qIG9mIGluZGV4ZXIuaXRlcigpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua1ZhbHVlID0gdGhpcy5nZXRDaHVua1ZhbHVlKHByb2osIGluZGV4ZXIsIHZhbHVlLCBzZWxlY3Rpb25TaGFwZSk7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZS5hZGQoKCkgPT4gdGhpcy5jaHVua1NldEl0ZW0ocHJvai5jaHVua0Nvb3JkcywgcHJvai5jaHVua1NlbGVjdGlvbiwgY2h1bmtWYWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGd1YXJhbnRlZXMgdGhhdCBhbGwgd29yayBvbiBxdWV1ZSBoYXMgZmluaXNoZWRcclxuICAgICAgICBhd2FpdCBxdWV1ZS5vbklkbGUoKTtcclxuICAgIH1cclxuICAgIGFzeW5jIGNodW5rU2V0SXRlbShjaHVua0Nvb3JkcywgY2h1bmtTZWxlY3Rpb24sIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubWV0YS5vcmRlciA9PT0gXCJGXCIgJiYgdGhpcy5uRGltcyA+IDEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2V0dGluZyBjb250ZW50IGZvciBhcnJheXMgaW4gRi1vcmRlciBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gT2J0YWluIGtleSBmb3IgY2h1bmsgc3RvcmFnZVxyXG4gICAgICAgIGNvbnN0IGNodW5rS2V5ID0gdGhpcy5jaHVua0tleShjaHVua0Nvb3Jkcyk7XHJcbiAgICAgICAgbGV0IGNodW5rID0gbnVsbDtcclxuICAgICAgICBjb25zdCBkdHlwZUNvbnN0ciA9IGdldFR5cGVkQXJyYXlDdHIodGhpcy5kdHlwZSk7XHJcbiAgICAgICAgY29uc3QgY2h1bmtTaXplID0gdGhpcy5jaHVua1NpemU7XHJcbiAgICAgICAgaWYgKGlzVG90YWxTbGljZShjaHVua1NlbGVjdGlvbiwgdGhpcy5jaHVua3MpKSB7XHJcbiAgICAgICAgICAgIC8vIFRvdGFsbHkgcmVwbGFjZSBjaHVua1xyXG4gICAgICAgICAgICAvLyBPcHRpbWl6YXRpb246IHdlIGFyZSBjb21wbGV0ZWx5IHJlcGxhY2luZyB0aGUgY2h1bmssIHNvIG5vIG5lZWRcclxuICAgICAgICAgICAgLy8gdG8gYWNjZXNzIHRoZSBleGlzdGluZyBjaHVuayBkYXRhXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gZ2V0IHRoZSByaWdodCB0eXBlIGhlcmVcclxuICAgICAgICAgICAgICAgIGNodW5rID0gbmV3IGR0eXBlQ29uc3RyKGNodW5rU2l6ZSk7XHJcbiAgICAgICAgICAgICAgICBjaHVuay5maWxsKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNodW5rID0gdmFsdWUuZmxhdHRlbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBwYXJ0aWFsbHkgcmVwbGFjZSB0aGUgY29udGVudHMgb2YgdGhpcyBjaHVua1xyXG4gICAgICAgICAgICAvLyBFeGlzdGluZyBjaHVuayBkYXRhXHJcbiAgICAgICAgICAgIGxldCBjaHVua0RhdGE7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaHVuayBpcyBpbml0aWFsaXplZCBpZiB0aGlzIGRvZXMgbm90IGVycm9yXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua1N0b3JlRGF0YSA9IGF3YWl0IHRoaXMuY2h1bmtTdG9yZS5nZXRJdGVtKGNodW5rS2V5KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRCeXRlcyA9IGF3YWl0IHRoaXMuZGVjb2RlQ2h1bmsoY2h1bmtTdG9yZURhdGEpO1xyXG4gICAgICAgICAgICAgICAgY2h1bmtEYXRhID0gdGhpcy50b1R5cGVkQXJyYXkoZEJ5dGVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0tleUVycm9yKGVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENodW5rIGlzIG5vdCBpbml0aWFsaXplZFxyXG4gICAgICAgICAgICAgICAgICAgIGNodW5rRGF0YSA9IG5ldyBkdHlwZUNvbnN0cihjaHVua1NpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbGxWYWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVua0RhdGEuZmlsbCh0aGlzLmZpbGxWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGlmZmVyZW50IHR5cGUgb2YgZXJyb3IgLSByZXRocm93XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY2h1bmtOZXN0ZWRBcnJheSA9IG5ldyBOZXN0ZWRBcnJheShjaHVua0RhdGEsIHRoaXMuY2h1bmtzLCB0aGlzLmR0eXBlKTtcclxuICAgICAgICAgICAgY2h1bmtOZXN0ZWRBcnJheS5zZXQoY2h1bmtTZWxlY3Rpb24sIHZhbHVlKTtcclxuICAgICAgICAgICAgY2h1bmsgPSBjaHVua05lc3RlZEFycmF5LmZsYXR0ZW4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2h1bmtEYXRhID0gYXdhaXQgdGhpcy5lbmNvZGVDaHVuayhjaHVuayk7XHJcbiAgICAgICAgdGhpcy5jaHVua1N0b3JlLnNldEl0ZW0oY2h1bmtLZXksIGNodW5rRGF0YSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBlbmNvZGVDaHVuayhjaHVuaykge1xyXG4gICAgICAgIGlmICh0aGlzLmR0eXBlLmluY2x1ZGVzKCc+JykpIHtcclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICogSWYgYmlnIGVuZGlhbiwgZmxpcCBieXRlcyBiZWZvcmUgYXBwbHlpbmcgY29tcHJlc3Npb24gYW5kIHNldHRpbmcgc3RvcmUuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEhlcmUgd2UgY3JlYXRlIGEgY29weSAobm90IGluLXBsYWNlIGJ5dGVzd2FwcGluZykgdG8gYXZvaWQgZmxpcHBpbmcgdGhlXHJcbiAgICAgICAgICAgICAqIGJ5dGVzIGluIHRoZSBidWZmZXJzIG9mIHVzZXItY3JlYXRlZCBSYXctIGFuZCBOZXN0ZWRBcnJheXMuXHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNodW5rID0gYnl0ZVN3YXAoY2h1bmspO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jb21wcmVzc29yICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnVmZmVyKTtcclxuICAgICAgICAgICAgY29uc3QgY2J5dGVzID0gYXdhaXQgKGF3YWl0IHRoaXMuY29tcHJlc3NvcikuZW5jb2RlKGJ5dGVzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNieXRlcy5idWZmZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IGZpbHRlcnMsIGV0Y1xyXG4gICAgICAgIHJldHVybiBjaHVuay5idWZmZXI7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgTWVtb3J5U3RvcmUge1xyXG4gICAgY29uc3RydWN0b3Iocm9vdCA9IHt9KSB7XHJcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcclxuICAgIH1cclxuICAgIHByb3h5KCkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVQcm94eSh0aGlzKTtcclxuICAgIH1cclxuICAgIGdldFBhcmVudChpdGVtKSB7XHJcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucm9vdDtcclxuICAgICAgICBjb25zdCBzZWdtZW50cyA9IGl0ZW0uc3BsaXQoJy8nKTtcclxuICAgICAgICAvLyBmaW5kIHRoZSBwYXJlbnQgY29udGFpbmVyXHJcbiAgICAgICAgZm9yIChjb25zdCBrIG9mIHNlZ21lbnRzLnNsaWNlKDAsIHNlZ21lbnRzLmxlbmd0aCAtIDEpKSB7XHJcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudFtrXTtcclxuICAgICAgICAgICAgaWYgKCFwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGl0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlmIG5vdCBpc2luc3RhbmNlKHBhcmVudCwgc2VsZi5jbHMpOlxyXG4gICAgICAgICAgICAvLyAgICAgcmFpc2UgS2V5RXJyb3IoaXRlbSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtwYXJlbnQsIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdXTtcclxuICAgIH1cclxuICAgIHJlcXVpcmVQYXJlbnQoaXRlbSkge1xyXG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnJvb3Q7XHJcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBpdGVtLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgLy8gcmVxdWlyZSB0aGUgcGFyZW50IGNvbnRhaW5lclxyXG4gICAgICAgIGZvciAoY29uc3QgayBvZiBzZWdtZW50cy5zbGljZSgwLCBzZWdtZW50cy5sZW5ndGggLSAxKSkge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiB2ZXJpZnkgY29ycmVjdCBpbXBsZW1lbnRhdGlvblxyXG4gICAgICAgICAgICBpZiAocGFyZW50W2tdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudFtrXSA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudFtrXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtwYXJlbnQsIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdXTtcclxuICAgIH1cclxuICAgIGdldEl0ZW0oaXRlbSkge1xyXG4gICAgICAgIGNvbnN0IFtwYXJlbnQsIGtleV0gPSB0aGlzLmdldFBhcmVudChpdGVtKTtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmVudFtrZXldO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBLZXlFcnJvcihpdGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0SXRlbShpdGVtLCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IFtwYXJlbnQsIGtleV0gPSB0aGlzLnJlcXVpcmVQYXJlbnQoaXRlbSk7XHJcbiAgICAgICAgcGFyZW50W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGRlbGV0ZUl0ZW0oaXRlbSkge1xyXG4gICAgICAgIGNvbnN0IFtwYXJlbnQsIGtleV0gPSB0aGlzLmdldFBhcmVudChpdGVtKTtcclxuICAgICAgICByZXR1cm4gZGVsZXRlIHBhcmVudFtrZXldO1xyXG4gICAgfVxyXG4gICAgY29udGFpbnNJdGVtKGl0ZW0pIHtcclxuICAgICAgICAvLyBUT0RPOiBtb3JlIHNhbmUgaW1wbGVtZW50YXRpb25cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVtKGl0ZW0pICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBrZXlzKCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xyXG4gICAgfVxyXG59XG5cbnZhciBIVFRQTWV0aG9kO1xyXG4oZnVuY3Rpb24gKEhUVFBNZXRob2QpIHtcclxuICAgIEhUVFBNZXRob2RbXCJIRUFEXCJdID0gXCJIRUFEXCI7XHJcbiAgICBIVFRQTWV0aG9kW1wiR0VUXCJdID0gXCJHRVRcIjtcclxuICAgIEhUVFBNZXRob2RbXCJQVVRcIl0gPSBcIlBVVFwiO1xyXG59KShIVFRQTWV0aG9kIHx8IChIVFRQTWV0aG9kID0ge30pKTtcclxuY29uc3QgREVGQVVMVF9NRVRIT0RTID0gW0hUVFBNZXRob2QuSEVBRCwgSFRUUE1ldGhvZC5HRVQsIEhUVFBNZXRob2QuUFVUXTtcclxuY2xhc3MgSFRUUFN0b3JlIHtcclxuICAgIGNvbnN0cnVjdG9yKHVybCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XHJcbiAgICAgICAgY29uc3QgeyBmZXRjaE9wdGlvbnMgPSB7fSwgc3VwcG9ydGVkTWV0aG9kcyA9IERFRkFVTFRfTUVUSE9EUyB9ID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLmZldGNoT3B0aW9ucyA9IGZldGNoT3B0aW9ucztcclxuICAgICAgICB0aGlzLnN1cHBvcnRlZE1ldGhvZHMgPSBuZXcgU2V0KHN1cHBvcnRlZE1ldGhvZHMpO1xyXG4gICAgfVxyXG4gICAga2V5cygpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRJdGVtKGl0ZW0sIG9wdHMpIHtcclxuICAgICAgICBjb25zdCB1cmwgPSByZXNvbHZlVXJsKHRoaXMudXJsLCBpdGVtKTtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGZldGNoKHVybCwgeyAuLi50aGlzLmZldGNoT3B0aW9ucywgLi4ub3B0cyB9KTtcclxuICAgICAgICBpZiAodmFsdWUuc3RhdHVzID09PSA0MDQpIHtcclxuICAgICAgICAgICAgLy8gSXRlbSBpcyBub3QgZm91bmRcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEtleUVycm9yKGl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZS5zdGF0dXMgIT09IDIwMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSFRUUEVycm9yKFN0cmluZyh2YWx1ZS5zdGF0dXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gb25seSBkZWNvZGUgaWYgMjAwXHJcbiAgICAgICAgaWYgKElTX05PREUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGF3YWl0IHZhbHVlLmFycmF5QnVmZmVyKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmFycmF5QnVmZmVyKCk7IC8vIEJyb3dzZXJcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3luYyBzZXRJdGVtKGl0ZW0sIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRlZE1ldGhvZHMuaGFzKEhUVFBNZXRob2QuUFVUKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hUVFAgUFVUIG5vIGEgc3VwcG9ydGVkIG1ldGhvZCBmb3Igc3RvcmUuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHVybCA9IHJlc29sdmVVcmwodGhpcy51cmwsIGl0ZW0pO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHZhbHVlKS5idWZmZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNldCA9IGF3YWl0IGZldGNoKHVybCwgeyAuLi50aGlzLmZldGNoT3B0aW9ucywgbWV0aG9kOiBIVFRQTWV0aG9kLlBVVCwgYm9keTogdmFsdWUgfSk7XHJcbiAgICAgICAgcmV0dXJuIHNldC5zdGF0dXMudG9TdHJpbmcoKVswXSA9PT0gJzInO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlSXRlbShfaXRlbSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcclxuICAgIH1cclxuICAgIGFzeW5jIGNvbnRhaW5zSXRlbShpdGVtKSB7XHJcbiAgICAgICAgY29uc3QgdXJsID0gcmVzb2x2ZVVybCh0aGlzLnVybCwgaXRlbSk7XHJcbiAgICAgICAgLy8gSnVzdCBjaGVjayBoZWFkZXJzIGlmIEhFQUQgbWV0aG9kIHN1cHBvcnRlZFxyXG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMuc3VwcG9ydGVkTWV0aG9kcy5oYXMoSFRUUE1ldGhvZC5IRUFEKSA/IEhUVFBNZXRob2QuSEVBRCA6IEhUVFBNZXRob2QuR0VUO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZmV0Y2godXJsLCB7IC4uLnRoaXMuZmV0Y2hPcHRpb25zLCBtZXRob2QgfSk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLnN0YXR1cyA9PT0gMjAwO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gc2hhcGUgQXJyYXkgc2hhcGUuXHJcbiAqIEBwYXJhbSBjaHVua3MgIENodW5rIHNoYXBlLiBJZiBgdHJ1ZWAsIHdpbGwgYmUgZ3Vlc3NlZCBmcm9tIGBzaGFwZWAgYW5kIGBkdHlwZWAuIElmXHJcbiAqICAgICAgYGZhbHNlYCwgd2lsbCBiZSBzZXQgdG8gYHNoYXBlYCwgaS5lLiwgc2luZ2xlIGNodW5rIGZvciB0aGUgd2hvbGUgYXJyYXkuXHJcbiAqICAgICAgSWYgYW4gaW50LCB0aGUgY2h1bmsgc2l6ZSBpbiBlYWNoIGRpbWVuc2lvbiB3aWxsIGJlIGdpdmVuIGJ5IHRoZSB2YWx1ZVxyXG4gKiAgICAgIG9mIGBjaHVua3NgLiBEZWZhdWx0IGlzIGB0cnVlYC5cclxuICogQHBhcmFtIGR0eXBlIE51bVB5IGR0eXBlLlxyXG4gKiBAcGFyYW0gY29tcHJlc3NvciBQcmltYXJ5IGNvbXByZXNzb3IuXHJcbiAqIEBwYXJhbSBmaWxsVmFsdWUgRGVmYXVsdCB2YWx1ZSB0byB1c2UgZm9yIHVuaW5pdGlhbGl6ZWQgcG9ydGlvbnMgb2YgdGhlIGFycmF5LlxyXG4gKiBAcGFyYW0gb3JkZXIgTWVtb3J5IGxheW91dCB0byBiZSB1c2VkIHdpdGhpbiBlYWNoIGNodW5rLlxyXG4gKiBAcGFyYW0gc3RvcmUgU3RvcmUgb3IgcGF0aCB0byBkaXJlY3RvcnkgaW4gZmlsZSBzeXN0ZW0gb3IgbmFtZSBvZiB6aXAgZmlsZS5cclxuICogQHBhcmFtIG92ZXJ3cml0ZSAgSWYgVHJ1ZSwgZGVsZXRlIGFsbCBwcmUtZXhpc3RpbmcgZGF0YSBpbiBgc3RvcmVgIGF0IGBwYXRoYCBiZWZvcmUgY3JlYXRpbmcgdGhlIGFycmF5LlxyXG4gKiBAcGFyYW0gcGF0aCBQYXRoIHVuZGVyIHdoaWNoIGFycmF5IGlzIHN0b3JlZC5cclxuICogQHBhcmFtIGNodW5rU3RvcmUgU2VwYXJhdGUgc3RvcmFnZSBmb3IgY2h1bmtzLiBJZiBub3QgcHJvdmlkZWQsIGBzdG9yZWAgd2lsbCBiZSB1c2VkIGZvciBzdG9yYWdlIG9mIGJvdGggY2h1bmtzIGFuZCBtZXRhZGF0YS5cclxuICogQHBhcmFtIGZpbHRlcnMgU2VxdWVuY2Ugb2YgZmlsdGVycyB0byB1c2UgdG8gZW5jb2RlIGNodW5rIGRhdGEgcHJpb3IgdG8gY29tcHJlc3Npb24uXHJcbiAqIEBwYXJhbSBjYWNoZU1ldGFkYXRhIElmIGB0cnVlYCAoZGVmYXVsdCksIGFycmF5IGNvbmZpZ3VyYXRpb24gbWV0YWRhdGEgd2lsbCBiZSBjYWNoZWQgZm9yIHRoZVxyXG4gKiAgICAgIGxpZmV0aW1lIG9mIHRoZSBvYmplY3QuIElmIGBmYWxzZWAsIGFycmF5IG1ldGFkYXRhIHdpbGwgYmUgcmVsb2FkZWRcclxuICogICAgICBwcmlvciB0byBhbGwgZGF0YSBhY2Nlc3MgYW5kIG1vZGlmaWNhdGlvbiBvcGVyYXRpb25zIChtYXkgaW5jdXJcclxuICogICAgICBvdmVyaGVhZCBkZXBlbmRpbmcgb24gc3RvcmFnZSBhbmQgZGF0YSBhY2Nlc3MgcGF0dGVybikuXHJcbiAqIEBwYXJhbSBjYWNoZUF0dHJzIElmIGB0cnVlYCAoZGVmYXVsdCksIHVzZXIgYXR0cmlidXRlcyB3aWxsIGJlIGNhY2hlZCBmb3IgYXR0cmlidXRlIHJlYWRcclxuICogICAgICBvcGVyYXRpb25zLiBJZiBgZmFsc2VgLCB1c2VyIGF0dHJpYnV0ZXMgYXJlIHJlbG9hZGVkIGZyb20gdGhlIHN0b3JlIHByaW9yXHJcbiAqICAgICAgdG8gYWxsIGF0dHJpYnV0ZSByZWFkIG9wZXJhdGlvbnMuXHJcbiAqIEBwYXJhbSByZWFkT25seSBgdHJ1ZWAgaWYgYXJyYXkgc2hvdWxkIGJlIHByb3RlY3RlZCBhZ2FpbnN0IG1vZGlmaWNhdGlvbiwgZGVmYXVsdHMgdG8gYGZhbHNlYC5cclxuICogQHBhcmFtIGRpbWVuc2lvblNlcGFyYXRvciBpZiBzcGVjaWZpZWQsIGRlZmluZXMgYW4gYWx0ZXJuYXRlIHN0cmluZyBzZXBhcmF0b3IgcGxhY2VkIGJldHdlZW4gdGhlIGRpbWVuc2lvbiBjaHVua3MuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBjcmVhdGUoeyBzaGFwZSwgY2h1bmtzID0gdHJ1ZSwgZHR5cGUgPSBcIjxpNFwiLCBjb21wcmVzc29yID0gbnVsbCwgZmlsbFZhbHVlID0gbnVsbCwgb3JkZXIgPSBcIkNcIiwgc3RvcmUsIG92ZXJ3cml0ZSA9IGZhbHNlLCBwYXRoLCBjaHVua1N0b3JlLCBmaWx0ZXJzLCBjYWNoZU1ldGFkYXRhID0gdHJ1ZSwgY2FjaGVBdHRycyA9IHRydWUsIHJlYWRPbmx5ID0gZmFsc2UsIGRpbWVuc2lvblNlcGFyYXRvciB9KSB7XHJcbiAgICBzdG9yZSA9IG5vcm1hbGl6ZVN0b3JlQXJndW1lbnQoc3RvcmUpO1xyXG4gICAgYXdhaXQgaW5pdEFycmF5KHN0b3JlLCBzaGFwZSwgY2h1bmtzLCBkdHlwZSwgcGF0aCwgY29tcHJlc3NvciwgZmlsbFZhbHVlLCBvcmRlciwgb3ZlcndyaXRlLCBjaHVua1N0b3JlLCBmaWx0ZXJzLCBkaW1lbnNpb25TZXBhcmF0b3IpO1xyXG4gICAgY29uc3QgeiA9IGF3YWl0IFphcnJBcnJheS5jcmVhdGUoc3RvcmUsIHBhdGgsIHJlYWRPbmx5LCBjaHVua1N0b3JlLCBjYWNoZU1ldGFkYXRhLCBjYWNoZUF0dHJzKTtcclxuICAgIHJldHVybiB6O1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgYW4gZW1wdHkgYXJyYXkuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBlbXB0eShzaGFwZSwgb3B0cyA9IHt9KSB7XHJcbiAgICBvcHRzLmZpbGxWYWx1ZSA9IG51bGw7XHJcbiAgICByZXR1cm4gY3JlYXRlKHsgc2hhcGUsIC4uLm9wdHMgfSk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBhbiBhcnJheSwgd2l0aCB6ZXJvIGJlaW5nIHVzZWQgYXMgdGhlIGRlZmF1bHQgdmFsdWUgZm9yXHJcbiAqIHVuaW5pdGlhbGl6ZWQgcG9ydGlvbnMgb2YgdGhlIGFycmF5LlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gemVyb3Moc2hhcGUsIG9wdHMgPSB7fSkge1xyXG4gICAgb3B0cy5maWxsVmFsdWUgPSAwO1xyXG4gICAgcmV0dXJuIGNyZWF0ZSh7IHNoYXBlLCAuLi5vcHRzIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgYW4gYXJyYXksIHdpdGggb25lIGJlaW5nIHVzZWQgYXMgdGhlIGRlZmF1bHQgdmFsdWUgZm9yXHJcbiAqIHVuaW5pdGlhbGl6ZWQgcG9ydGlvbnMgb2YgdGhlIGFycmF5LlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gb25lcyhzaGFwZSwgb3B0cyA9IHt9KSB7XHJcbiAgICBvcHRzLmZpbGxWYWx1ZSA9IDE7XHJcbiAgICByZXR1cm4gY3JlYXRlKHsgc2hhcGUsIC4uLm9wdHMgfSk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBhbiBhcnJheSwgd2l0aCBgZmlsbF92YWx1ZWAgYmVpbmcgdXNlZCBhcyB0aGUgZGVmYXVsdCB2YWx1ZSBmb3JcclxuICogdW5pbml0aWFsaXplZCBwb3J0aW9ucyBvZiB0aGUgYXJyYXlcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGZ1bGwoc2hhcGUsIGZpbGxWYWx1ZSwgb3B0cyA9IHt9KSB7XHJcbiAgICBvcHRzLmZpbGxWYWx1ZSA9IGZpbGxWYWx1ZTtcclxuICAgIHJldHVybiBjcmVhdGUoeyBzaGFwZSwgLi4ub3B0cyB9KTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBhcnJheShkYXRhLCBvcHRzID0ge30pIHtcclxuICAgIC8vIFRPRE86IGluZmVyIGNodW5rcz9cclxuICAgIGxldCBzaGFwZSA9IG51bGw7XHJcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIE5lc3RlZEFycmF5KSB7XHJcbiAgICAgICAgc2hhcGUgPSBkYXRhLnNoYXBlO1xyXG4gICAgICAgIG9wdHMuZHR5cGUgPSBvcHRzLmR0eXBlID09PSB1bmRlZmluZWQgPyBkYXRhLmR0eXBlIDogb3B0cy5kdHlwZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHNoYXBlID0gZGF0YS5ieXRlTGVuZ3RoO1xyXG4gICAgICAgIC8vIFRPRE86IGluZmVyIGRhdGF0eXBlXHJcbiAgICB9XHJcbiAgICAvLyBUT0RPOiBzdXBwb3J0IFR5cGVkQXJyYXlcclxuICAgIGNvbnN0IHdhc1JlYWRPbmx5ID0gb3B0cy5yZWFkT25seSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvcHRzLnJlYWRPbmx5O1xyXG4gICAgb3B0cy5yZWFkT25seSA9IGZhbHNlO1xyXG4gICAgY29uc3QgeiA9IGF3YWl0IGNyZWF0ZSh7IHNoYXBlLCAuLi5vcHRzIH0pO1xyXG4gICAgYXdhaXQgei5zZXQobnVsbCwgZGF0YSk7XHJcbiAgICB6LnJlYWRPbmx5ID0gd2FzUmVhZE9ubHk7XHJcbiAgICByZXR1cm4gejtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBvcGVuQXJyYXkoeyBzaGFwZSwgbW9kZSA9IFwiYVwiLCBjaHVua3MgPSB0cnVlLCBkdHlwZSA9IFwiPGk0XCIsIGNvbXByZXNzb3IgPSBudWxsLCBmaWxsVmFsdWUgPSBudWxsLCBvcmRlciA9IFwiQ1wiLCBzdG9yZSwgb3ZlcndyaXRlID0gZmFsc2UsIHBhdGggPSBudWxsLCBjaHVua1N0b3JlLCBmaWx0ZXJzLCBjYWNoZU1ldGFkYXRhID0gdHJ1ZSwgY2FjaGVBdHRycyA9IHRydWUsIGRpbWVuc2lvblNlcGFyYXRvciB9ID0ge30pIHtcclxuICAgIHN0b3JlID0gbm9ybWFsaXplU3RvcmVBcmd1bWVudChzdG9yZSk7XHJcbiAgICBpZiAoY2h1bmtTdG9yZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgY2h1bmtTdG9yZSA9IG5vcm1hbGl6ZVN0b3JlQXJndW1lbnQoc3RvcmUpO1xyXG4gICAgfVxyXG4gICAgcGF0aCA9IG5vcm1hbGl6ZVN0b3JhZ2VQYXRoKHBhdGgpO1xyXG4gICAgaWYgKG1vZGUgPT09IFwiclwiIHx8IG1vZGUgPT09IFwicitcIikge1xyXG4gICAgICAgIGlmICghYXdhaXQgY29udGFpbnNBcnJheShzdG9yZSwgcGF0aCkpIHtcclxuICAgICAgICAgICAgaWYgKGF3YWl0IGNvbnRhaW5zR3JvdXAoc3RvcmUsIHBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ29udGFpbnNHcm91cEVycm9yKHBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBBcnJheU5vdEZvdW5kRXJyb3IocGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobW9kZSA9PT0gXCJ3XCIpIHtcclxuICAgICAgICBpZiAoc2hhcGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlNoYXBlIGNhbiBub3QgYmUgdW5kZWZpbmVkIHdoZW4gY3JlYXRpbmcgYSBuZXcgYXJyYXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF3YWl0IGluaXRBcnJheShzdG9yZSwgc2hhcGUsIGNodW5rcywgZHR5cGUsIHBhdGgsIGNvbXByZXNzb3IsIGZpbGxWYWx1ZSwgb3JkZXIsIG92ZXJ3cml0ZSwgY2h1bmtTdG9yZSwgZmlsdGVycywgZGltZW5zaW9uU2VwYXJhdG9yKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG1vZGUgPT09IFwiYVwiKSB7XHJcbiAgICAgICAgaWYgKCFhd2FpdCBjb250YWluc0FycmF5KHN0b3JlLCBwYXRoKSkge1xyXG4gICAgICAgICAgICBpZiAoYXdhaXQgY29udGFpbnNHcm91cChzdG9yZSwgcGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDb250YWluc0dyb3VwRXJyb3IocGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNoYXBlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFwiU2hhcGUgY2FuIG5vdCBiZSB1bmRlZmluZWQgd2hlbiBjcmVhdGluZyBhIG5ldyBhcnJheVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhd2FpdCBpbml0QXJyYXkoc3RvcmUsIHNoYXBlLCBjaHVua3MsIGR0eXBlLCBwYXRoLCBjb21wcmVzc29yLCBmaWxsVmFsdWUsIG9yZGVyLCBvdmVyd3JpdGUsIGNodW5rU3RvcmUsIGZpbHRlcnMsIGRpbWVuc2lvblNlcGFyYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobW9kZSA9PT0gXCJ3LVwiIHx8IG1vZGUgPT09IFwieFwiKSB7XHJcbiAgICAgICAgaWYgKGF3YWl0IGNvbnRhaW5zQXJyYXkoc3RvcmUsIHBhdGgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBDb250YWluc0FycmF5RXJyb3IocGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGF3YWl0IGNvbnRhaW5zR3JvdXAoc3RvcmUsIHBhdGgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBDb250YWluc0dyb3VwRXJyb3IocGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoc2hhcGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJTaGFwZSBjYW4gbm90IGJlIHVuZGVmaW5lZCB3aGVuIGNyZWF0aW5nIGEgbmV3IGFycmF5XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF3YWl0IGluaXRBcnJheShzdG9yZSwgc2hhcGUsIGNodW5rcywgZHR5cGUsIHBhdGgsIGNvbXByZXNzb3IsIGZpbGxWYWx1ZSwgb3JkZXIsIG92ZXJ3cml0ZSwgY2h1bmtTdG9yZSwgZmlsdGVycywgZGltZW5zaW9uU2VwYXJhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgSW52YWxpZCBtb2RlIGFyZ3VtZW50OiAke21vZGV9YCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZWFkT25seSA9IG1vZGUgPT09IFwiclwiO1xyXG4gICAgcmV0dXJuIFphcnJBcnJheS5jcmVhdGUoc3RvcmUsIHBhdGgsIHJlYWRPbmx5LCBjaHVua1N0b3JlLCBjYWNoZU1ldGFkYXRhLCBjYWNoZUF0dHJzKTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVTdG9yZUFyZ3VtZW50KHN0b3JlKSB7XHJcbiAgICBpZiAoc3RvcmUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTWVtb3J5U3RvcmUoKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBzdG9yZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHJldHVybiBuZXcgSFRUUFN0b3JlKHN0b3JlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdG9yZTtcclxufVxuXG5jbGFzcyBHcm91cCB7XHJcbiAgICBjb25zdHJ1Y3RvcihzdG9yZSwgcGF0aCA9IG51bGwsIG1ldGFkYXRhLCByZWFkT25seSA9IGZhbHNlLCBjaHVua1N0b3JlID0gbnVsbCwgY2FjaGVBdHRycyA9IHRydWUpIHtcclxuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XHJcbiAgICAgICAgdGhpcy5fY2h1bmtTdG9yZSA9IGNodW5rU3RvcmU7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gbm9ybWFsaXplU3RvcmFnZVBhdGgocGF0aCk7XHJcbiAgICAgICAgdGhpcy5rZXlQcmVmaXggPSBwYXRoVG9QcmVmaXgodGhpcy5wYXRoKTtcclxuICAgICAgICB0aGlzLnJlYWRPbmx5ID0gcmVhZE9ubHk7XHJcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YWRhdGE7XHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhdHRyaWJ1dGVzXHJcbiAgICAgICAgY29uc3QgYXR0cktleSA9IHRoaXMua2V5UHJlZml4ICsgQVRUUlNfTUVUQV9LRVk7XHJcbiAgICAgICAgdGhpcy5hdHRycyA9IG5ldyBBdHRyaWJ1dGVzKHRoaXMuc3RvcmUsIGF0dHJLZXksIHRoaXMucmVhZE9ubHksIGNhY2hlQXR0cnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHcm91cCBuYW1lIGZvbGxvd2luZyBoNXB5IGNvbnZlbnRpb24uXHJcbiAgICAgKi9cclxuICAgIGdldCBuYW1lKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnBhdGgubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXRoWzBdICE9PSBcIi9cIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiL1wiICsgdGhpcy5wYXRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcIi9cIjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmluYWwgY29tcG9uZW50IG9mIG5hbWUuXHJcbiAgICAgKi9cclxuICAgIGdldCBiYXNlbmFtZSgpIHtcclxuICAgICAgICBjb25zdCBwYXJ0cyA9IHRoaXMubmFtZS5zcGxpdChcIi9cIik7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBTdG9yZWAgcHJvdmlkaW5nIHRoZSB1bmRlcmx5aW5nIHN0b3JhZ2UgZm9yIGFycmF5IGNodW5rcy5cclxuICAgICAqL1xyXG4gICAgZ2V0IGNodW5rU3RvcmUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NodW5rU3RvcmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NodW5rU3RvcmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShzdG9yZSwgcGF0aCA9IG51bGwsIHJlYWRPbmx5ID0gZmFsc2UsIGNodW5rU3RvcmUgPSBudWxsLCBjYWNoZUF0dHJzID0gdHJ1ZSkge1xyXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5sb2FkTWV0YWRhdGFGb3JDb25zdHJ1Y3RvcihzdG9yZSwgcGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHcm91cChzdG9yZSwgcGF0aCwgbWV0YWRhdGEsIHJlYWRPbmx5LCBjaHVua1N0b3JlLCBjYWNoZUF0dHJzKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBsb2FkTWV0YWRhdGFGb3JDb25zdHJ1Y3RvcihzdG9yZSwgcGF0aCkge1xyXG4gICAgICAgIHBhdGggPSBub3JtYWxpemVTdG9yYWdlUGF0aChwYXRoKTtcclxuICAgICAgICBjb25zdCBrZXlQcmVmaXggPSBwYXRoVG9QcmVmaXgocGF0aCk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgbWV0YVN0b3JlVmFsdWUgPSBhd2FpdCBzdG9yZS5nZXRJdGVtKGtleVByZWZpeCArIEdST1VQX01FVEFfS0VZKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTWV0YWRhdGEobWV0YVN0b3JlVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgaWYgKGF3YWl0IGNvbnRhaW5zQXJyYXkoc3RvcmUsIHBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ29udGFpbnNBcnJheUVycm9yKHBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBHcm91cE5vdEZvdW5kRXJyb3IocGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXRlbVBhdGgoaXRlbSkge1xyXG4gICAgICAgIGNvbnN0IGFic29sdXRlID0gdHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIgJiYgaXRlbS5sZW5ndGggPiAwICYmIGl0ZW1bMF0gPT09ICcvJztcclxuICAgICAgICBjb25zdCBwYXRoID0gbm9ybWFsaXplU3RvcmFnZVBhdGgoaXRlbSk7XHJcbiAgICAgICAgLy8gQWJzb2x1dGUgcGF0aFxyXG4gICAgICAgIGlmICghYWJzb2x1dGUgJiYgdGhpcy5wYXRoLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMua2V5UHJlZml4ICsgcGF0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIHN1Yi1ncm91cC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgY3JlYXRlR3JvdXAobmFtZSwgb3ZlcndyaXRlID0gZmFsc2UpIHtcclxuICAgICAgICBpZiAodGhpcy5yZWFkT25seSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUGVybWlzc2lvbkVycm9yKFwiZ3JvdXAgaXMgcmVhZCBvbmx5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5pdGVtUGF0aChuYW1lKTtcclxuICAgICAgICBhd2FpdCBpbml0R3JvdXAodGhpcy5zdG9yZSwgcGF0aCwgdGhpcy5fY2h1bmtTdG9yZSwgb3ZlcndyaXRlKTtcclxuICAgICAgICByZXR1cm4gR3JvdXAuY3JlYXRlKHRoaXMuc3RvcmUsIHBhdGgsIHRoaXMucmVhZE9ubHksIHRoaXMuX2NodW5rU3RvcmUsIHRoaXMuYXR0cnMuY2FjaGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnRhaW4gYSBzdWItZ3JvdXAsIGNyZWF0aW5nIG9uZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxyXG4gICAgICovXHJcbiAgICBhc3luYyByZXF1aXJlR3JvdXAobmFtZSwgb3ZlcndyaXRlID0gZmFsc2UpIHtcclxuICAgICAgICBpZiAodGhpcy5yZWFkT25seSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUGVybWlzc2lvbkVycm9yKFwiZ3JvdXAgaXMgcmVhZCBvbmx5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5pdGVtUGF0aChuYW1lKTtcclxuICAgICAgICBpZiAoIWF3YWl0IGNvbnRhaW5zR3JvdXAodGhpcy5zdG9yZSwgcGF0aCkpIHtcclxuICAgICAgICAgICAgYXdhaXQgaW5pdEdyb3VwKHRoaXMuc3RvcmUsIHBhdGgsIHRoaXMuX2NodW5rU3RvcmUsIG92ZXJ3cml0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBHcm91cC5jcmVhdGUodGhpcy5zdG9yZSwgcGF0aCwgdGhpcy5yZWFkT25seSwgdGhpcy5fY2h1bmtTdG9yZSwgdGhpcy5hdHRycy5jYWNoZSk7XHJcbiAgICB9XHJcbiAgICBnZXRPcHRzRm9yQXJyYXlDcmVhdGlvbihuYW1lLCBvcHRzID0ge30pIHtcclxuICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5pdGVtUGF0aChuYW1lKTtcclxuICAgICAgICBvcHRzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgIGlmIChvcHRzLmNhY2hlQXR0cnMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvcHRzLmNhY2hlQXR0cnMgPSB0aGlzLmF0dHJzLmNhY2hlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvcHRzLnN0b3JlID0gdGhpcy5zdG9yZTtcclxuICAgICAgICBvcHRzLmNodW5rU3RvcmUgPSB0aGlzLmNodW5rU3RvcmU7XHJcbiAgICAgICAgcmV0dXJuIG9wdHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXlcclxuICAgICAqL1xyXG4gICAgYXJyYXkobmFtZSwgZGF0YSwgb3B0cywgb3ZlcndyaXRlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVhZE9ubHkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFBlcm1pc3Npb25FcnJvcihcImdyb3VwIGlzIHJlYWQgb25seVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3B0cyA9IHRoaXMuZ2V0T3B0c0ZvckFycmF5Q3JlYXRpb24obmFtZSwgb3B0cyk7XHJcbiAgICAgICAgb3B0cy5vdmVyd3JpdGUgPSBvdmVyd3JpdGUgPT09IHVuZGVmaW5lZCA/IG9wdHMub3ZlcndyaXRlIDogb3ZlcndyaXRlO1xyXG4gICAgICAgIHJldHVybiBhcnJheShkYXRhLCBvcHRzKTtcclxuICAgIH1cclxuICAgIGVtcHR5KG5hbWUsIHNoYXBlLCBvcHRzID0ge30pIHtcclxuICAgICAgICBpZiAodGhpcy5yZWFkT25seSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUGVybWlzc2lvbkVycm9yKFwiZ3JvdXAgaXMgcmVhZCBvbmx5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvcHRzID0gdGhpcy5nZXRPcHRzRm9yQXJyYXlDcmVhdGlvbihuYW1lLCBvcHRzKTtcclxuICAgICAgICByZXR1cm4gZW1wdHkoc2hhcGUsIG9wdHMpO1xyXG4gICAgfVxyXG4gICAgemVyb3MobmFtZSwgc2hhcGUsIG9wdHMgPSB7fSkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWRPbmx5KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBQZXJtaXNzaW9uRXJyb3IoXCJncm91cCBpcyByZWFkIG9ubHlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9wdHMgPSB0aGlzLmdldE9wdHNGb3JBcnJheUNyZWF0aW9uKG5hbWUsIG9wdHMpO1xyXG4gICAgICAgIHJldHVybiB6ZXJvcyhzaGFwZSwgb3B0cyk7XHJcbiAgICB9XHJcbiAgICBvbmVzKG5hbWUsIHNoYXBlLCBvcHRzID0ge30pIHtcclxuICAgICAgICBpZiAodGhpcy5yZWFkT25seSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUGVybWlzc2lvbkVycm9yKFwiZ3JvdXAgaXMgcmVhZCBvbmx5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvcHRzID0gdGhpcy5nZXRPcHRzRm9yQXJyYXlDcmVhdGlvbihuYW1lLCBvcHRzKTtcclxuICAgICAgICByZXR1cm4gb25lcyhzaGFwZSwgb3B0cyk7XHJcbiAgICB9XHJcbiAgICBmdWxsKG5hbWUsIHNoYXBlLCBmaWxsVmFsdWUsIG9wdHMgPSB7fSkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWRPbmx5KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBQZXJtaXNzaW9uRXJyb3IoXCJncm91cCBpcyByZWFkIG9ubHlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9wdHMgPSB0aGlzLmdldE9wdHNGb3JBcnJheUNyZWF0aW9uKG5hbWUsIG9wdHMpO1xyXG4gICAgICAgIHJldHVybiBmdWxsKHNoYXBlLCBmaWxsVmFsdWUsIG9wdHMpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlRGF0YXNldChuYW1lLCBzaGFwZSwgZGF0YSwgb3B0cykge1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWRPbmx5KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBQZXJtaXNzaW9uRXJyb3IoXCJncm91cCBpcyByZWFkIG9ubHlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9wdHMgPSB0aGlzLmdldE9wdHNGb3JBcnJheUNyZWF0aW9uKG5hbWUsIG9wdHMpO1xyXG4gICAgICAgIGxldCB6O1xyXG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKHNoYXBlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFwiU2hhcGUgbXVzdCBiZSBzZXQgaWYgbm8gZGF0YSBpcyBwYXNzZWQgdG8gQ3JlYXRlRGF0YXNldFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB6ID0gY3JlYXRlKHsgc2hhcGUsIC4uLm9wdHMgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB6ID0gYXJyYXkoZGF0YSwgb3B0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB6O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0SXRlbShpdGVtKSB7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMuaXRlbVBhdGgoaXRlbSk7XHJcbiAgICAgICAgaWYgKGF3YWl0IGNvbnRhaW5zQXJyYXkodGhpcy5zdG9yZSwgcGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFphcnJBcnJheS5jcmVhdGUodGhpcy5zdG9yZSwgcGF0aCwgdGhpcy5yZWFkT25seSwgdGhpcy5jaHVua1N0b3JlLCB1bmRlZmluZWQsIHRoaXMuYXR0cnMuY2FjaGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhd2FpdCBjb250YWluc0dyb3VwKHRoaXMuc3RvcmUsIHBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBHcm91cC5jcmVhdGUodGhpcy5zdG9yZSwgcGF0aCwgdGhpcy5yZWFkT25seSwgdGhpcy5fY2h1bmtTdG9yZSwgdGhpcy5hdHRycy5jYWNoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBLZXlFcnJvcihpdGVtKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHNldEl0ZW0oaXRlbSwgdmFsdWUpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLmFycmF5KGl0ZW0sIHZhbHVlLCB7fSwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXHJcbiAgICBhc3luYyBkZWxldGVJdGVtKF9pdGVtKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVhZE9ubHkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFBlcm1pc3Npb25FcnJvcihcImdyb3VwIGlzIHJlYWQgb25seVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XHJcbiAgICB9XHJcbiAgICBhc3luYyBjb250YWluc0l0ZW0oaXRlbSkge1xyXG4gICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLml0ZW1QYXRoKGl0ZW0pO1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBjb250YWluc0FycmF5KHRoaXMuc3RvcmUsIHBhdGgpIHx8IGNvbnRhaW5zR3JvdXAodGhpcy5zdG9yZSwgcGF0aCk7XHJcbiAgICB9XHJcbiAgICBwcm94eSgpIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlUHJveHkodGhpcyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBhIGdyb3VwLlxyXG4gKiBAcGFyYW0gc3RvcmUgU3RvcmUgb3IgcGF0aCB0byBkaXJlY3RvcnkgaW4gZmlsZSBzeXN0ZW0uXHJcbiAqIEBwYXJhbSBwYXRoIEdyb3VwIHBhdGggd2l0aGluIHN0b3JlLlxyXG4gKiBAcGFyYW0gY2h1bmtTdG9yZSBTZXBhcmF0ZSBzdG9yYWdlIGZvciBjaHVua3MuIElmIG5vdCBwcm92aWRlZCwgYHN0b3JlYCB3aWxsIGJlIHVzZWQgZm9yIHN0b3JhZ2Ugb2YgYm90aCBjaHVua3MgYW5kIG1ldGFkYXRhLlxyXG4gKiBAcGFyYW0gb3ZlcndyaXRlIElmIGB0cnVlYCwgZGVsZXRlIGFueSBwcmUtZXhpc3RpbmcgZGF0YSBpbiBgc3RvcmVgIGF0IGBwYXRoYCBiZWZvcmUgY3JlYXRpbmcgdGhlIGdyb3VwLlxyXG4gKiBAcGFyYW0gY2FjaGVBdHRycyBJZiBgdHJ1ZWAgKGRlZmF1bHQpLCB1c2VyIGF0dHJpYnV0ZXMgd2lsbCBiZSBjYWNoZWQgZm9yIGF0dHJpYnV0ZSByZWFkIG9wZXJhdGlvbnMuXHJcbiAqICAgSWYgYGZhbHNlYCwgdXNlciBhdHRyaWJ1dGVzIGFyZSByZWxvYWRlZCBmcm9tIHRoZSBzdG9yZSBwcmlvciB0byBhbGwgYXR0cmlidXRlIHJlYWQgb3BlcmF0aW9ucy5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGdyb3VwKHN0b3JlLCBwYXRoID0gbnVsbCwgY2h1bmtTdG9yZSwgb3ZlcndyaXRlID0gZmFsc2UsIGNhY2hlQXR0cnMgPSB0cnVlKSB7XHJcbiAgICBzdG9yZSA9IG5vcm1hbGl6ZVN0b3JlQXJndW1lbnQoc3RvcmUpO1xyXG4gICAgcGF0aCA9IG5vcm1hbGl6ZVN0b3JhZ2VQYXRoKHBhdGgpO1xyXG4gICAgaWYgKG92ZXJ3cml0ZSB8fCBhd2FpdCBjb250YWluc0dyb3VwKHN0b3JlKSkge1xyXG4gICAgICAgIGF3YWl0IGluaXRHcm91cChzdG9yZSwgcGF0aCwgY2h1bmtTdG9yZSwgb3ZlcndyaXRlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBHcm91cC5jcmVhdGUoc3RvcmUsIHBhdGgsIGZhbHNlLCBjaHVua1N0b3JlLCBjYWNoZUF0dHJzKTtcclxufVxyXG4vKipcclxuICogT3BlbiBhIGdyb3VwIHVzaW5nIGZpbGUtbW9kZS1saWtlIHNlbWFudGljcy5cclxuICogQHBhcmFtIHN0b3JlIFN0b3JlIG9yIHBhdGggdG8gZGlyZWN0b3J5IGluIGZpbGUgc3lzdGVtIG9yIG5hbWUgb2YgemlwIGZpbGUuXHJcbiAqIEBwYXJhbSBwYXRoIEdyb3VwIHBhdGggd2l0aGluIHN0b3JlLlxyXG4gKiBAcGFyYW0gbW9kZSBQZXJzaXN0ZW5jZSBtb2RlLCBzZWUgYFBlcnNpc3RlbmNlTW9kZWAgdHlwZS5cclxuICogQHBhcmFtIGNodW5rU3RvcmUgU3RvcmUgb3IgcGF0aCB0byBkaXJlY3RvcnkgaW4gZmlsZSBzeXN0ZW0gb3IgbmFtZSBvZiB6aXAgZmlsZS5cclxuICogQHBhcmFtIGNhY2hlQXR0cnMgSWYgYHRydWVgIChkZWZhdWx0KSwgdXNlciBhdHRyaWJ1dGVzIHdpbGwgYmUgY2FjaGVkIGZvciBhdHRyaWJ1dGUgcmVhZCBvcGVyYXRpb25zXHJcbiAqICAgSWYgRmFsc2UsIHVzZXIgYXR0cmlidXRlcyBhcmUgcmVsb2FkZWQgZnJvbSB0aGUgc3RvcmUgcHJpb3IgdG8gYWxsIGF0dHJpYnV0ZSByZWFkIG9wZXJhdGlvbnMuXHJcbiAqXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBvcGVuR3JvdXAoc3RvcmUsIHBhdGggPSBudWxsLCBtb2RlID0gXCJhXCIsIGNodW5rU3RvcmUsIGNhY2hlQXR0cnMgPSB0cnVlKSB7XHJcbiAgICBzdG9yZSA9IG5vcm1hbGl6ZVN0b3JlQXJndW1lbnQoc3RvcmUpO1xyXG4gICAgaWYgKGNodW5rU3RvcmUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGNodW5rU3RvcmUgPSBub3JtYWxpemVTdG9yZUFyZ3VtZW50KHN0b3JlKTtcclxuICAgIH1cclxuICAgIHBhdGggPSBub3JtYWxpemVTdG9yYWdlUGF0aChwYXRoKTtcclxuICAgIGlmIChtb2RlID09PSBcInJcIiB8fCBtb2RlID09PSBcInIrXCIpIHtcclxuICAgICAgICBpZiAoIWF3YWl0IGNvbnRhaW5zR3JvdXAoc3RvcmUsIHBhdGgpKSB7XHJcbiAgICAgICAgICAgIGlmIChhd2FpdCBjb250YWluc0FycmF5KHN0b3JlLCBwYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvbnRhaW5zQXJyYXlFcnJvcihwYXRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JvdXBOb3RGb3VuZEVycm9yKHBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG1vZGUgPT09IFwid1wiKSB7XHJcbiAgICAgICAgYXdhaXQgaW5pdEdyb3VwKHN0b3JlLCBwYXRoLCBjaHVua1N0b3JlLCB0cnVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG1vZGUgPT09IFwiYVwiKSB7XHJcbiAgICAgICAgaWYgKCFhd2FpdCBjb250YWluc0dyb3VwKHN0b3JlLCBwYXRoKSkge1xyXG4gICAgICAgICAgICBpZiAoYXdhaXQgY29udGFpbnNBcnJheShzdG9yZSwgcGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDb250YWluc0FycmF5RXJyb3IocGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXdhaXQgaW5pdEdyb3VwKHN0b3JlLCBwYXRoLCBjaHVua1N0b3JlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChtb2RlID09PSBcInctXCIgfHwgbW9kZSA9PT0gXCJ4XCIpIHtcclxuICAgICAgICBpZiAoYXdhaXQgY29udGFpbnNBcnJheShzdG9yZSwgcGF0aCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IENvbnRhaW5zQXJyYXlFcnJvcihwYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXdhaXQgY29udGFpbnNHcm91cChzdG9yZSwgcGF0aCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IENvbnRhaW5zR3JvdXBFcnJvcihwYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGluaXRHcm91cChzdG9yZSwgcGF0aCwgY2h1bmtTdG9yZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoYEludmFsaWQgbW9kZSBhcmd1bWVudDogJHttb2RlfWApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVhZE9ubHkgPSBtb2RlID09PSBcInJcIjtcclxuICAgIHJldHVybiBHcm91cC5jcmVhdGUoc3RvcmUsIHBhdGgsIHJlYWRPbmx5LCBjaHVua1N0b3JlLCBjYWNoZUF0dHJzKTtcclxufVxuXG5jbGFzcyBPYmplY3RTdG9yZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLm9iamVjdCA9IHt9O1xyXG4gICAgfVxyXG4gICAgZ2V0SXRlbShpdGVtKSB7XHJcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5vYmplY3QsIGl0ZW0pKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBLZXlFcnJvcihpdGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0W2l0ZW1dO1xyXG4gICAgfVxyXG4gICAgc2V0SXRlbShpdGVtLCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMub2JqZWN0W2l0ZW1dID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBkZWxldGVJdGVtKGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gZGVsZXRlIHRoaXMub2JqZWN0W2l0ZW1dO1xyXG4gICAgfVxyXG4gICAgY29udGFpbnNJdGVtKGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMub2JqZWN0LCBpdGVtKTtcclxuICAgIH1cclxuICAgIHByb3h5KCkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVQcm94eSh0aGlzKTtcclxuICAgIH1cclxuICAgIGtleXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMub2JqZWN0KTtcclxuICAgIH1cclxufVxuXG5leHBvcnQgeyBBcnJheU5vdEZvdW5kRXJyb3IsIEJvdW5kc0NoZWNrRXJyb3IsIENvbnRhaW5zQXJyYXlFcnJvciwgQ29udGFpbnNHcm91cEVycm9yLCBHcm91cCwgR3JvdXBOb3RGb3VuZEVycm9yLCBIVFRQRXJyb3IsIEhUVFBTdG9yZSwgSW52YWxpZFNsaWNlRXJyb3IsIEtleUVycm9yLCBNZW1vcnlTdG9yZSwgTmVnYXRpdmVTdGVwRXJyb3IsIE5lc3RlZEFycmF5LCBPYmplY3RTdG9yZSwgUGF0aE5vdEZvdW5kRXJyb3IsIFBlcm1pc3Npb25FcnJvciwgVG9vTWFueUluZGljZXNFcnJvciwgVmFsdWVFcnJvciwgWmFyckFycmF5LCBhZGRDb2RlYywgYXJyYXksIGNyZWF0ZSwgY3JlYXRlUHJveHksIGVtcHR5LCBmdWxsLCBnZXRDb2RlYywgZ2V0VHlwZWRBcnJheUN0ciwgZ2V0VHlwZWRBcnJheUR0eXBlU3RyaW5nLCBncm91cCwgaXNLZXlFcnJvciwgbm9ybWFsaXplU3RvcmVBcmd1bWVudCwgb25lcywgb3BlbkFycmF5LCBvcGVuR3JvdXAsIHJhbmdlVHlwZWRBcnJheSwgc2xpY2UsIHNsaWNlSW5kaWNlcywgemVyb3MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zarr/core.mjs\n");

/***/ }),

/***/ "./node_modules/zarr/zarr.mjs":
/*!************************************!*\
  !*** ./node_modules/zarr/zarr.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ArrayNotFoundError\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayNotFoundError),\n/* harmony export */   \"BoundsCheckError\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.BoundsCheckError),\n/* harmony export */   \"ContainsArrayError\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.ContainsArrayError),\n/* harmony export */   \"ContainsGroupError\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.ContainsGroupError),\n/* harmony export */   \"Group\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.Group),\n/* harmony export */   \"GroupNotFoundError\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.GroupNotFoundError),\n/* harmony export */   \"HTTPError\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.HTTPError),\n/* harmony export */   \"HTTPStore\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.HTTPStore),\n/* harmony export */   \"InvalidSliceError\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.InvalidSliceError),\n/* harmony export */   \"KeyError\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.KeyError),\n/* harmony export */   \"MemoryStore\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.MemoryStore),\n/* harmony export */   \"NegativeStepError\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.NegativeStepError),\n/* harmony export */   \"NestedArray\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.NestedArray),\n/* harmony export */   \"ObjectStore\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.ObjectStore),\n/* harmony export */   \"PathNotFoundError\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.PathNotFoundError),\n/* harmony export */   \"PermissionError\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.PermissionError),\n/* harmony export */   \"TooManyIndicesError\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.TooManyIndicesError),\n/* harmony export */   \"ValueError\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.ValueError),\n/* harmony export */   \"ZarrArray\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.ZarrArray),\n/* harmony export */   \"addCodec\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.addCodec),\n/* harmony export */   \"array\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.array),\n/* harmony export */   \"create\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.create),\n/* harmony export */   \"createProxy\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.createProxy),\n/* harmony export */   \"empty\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.empty),\n/* harmony export */   \"full\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.full),\n/* harmony export */   \"getCodec\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.getCodec),\n/* harmony export */   \"getTypedArrayCtr\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.getTypedArrayCtr),\n/* harmony export */   \"getTypedArrayDtypeString\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.getTypedArrayDtypeString),\n/* harmony export */   \"group\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.group),\n/* harmony export */   \"isKeyError\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.isKeyError),\n/* harmony export */   \"normalizeStoreArgument\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.normalizeStoreArgument),\n/* harmony export */   \"ones\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.ones),\n/* harmony export */   \"openArray\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.openArray),\n/* harmony export */   \"openGroup\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.openGroup),\n/* harmony export */   \"rangeTypedArray\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.rangeTypedArray),\n/* harmony export */   \"slice\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.slice),\n/* harmony export */   \"sliceIndices\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.sliceIndices),\n/* harmony export */   \"zeros\": () => (/* reexport safe */ _core_mjs__WEBPACK_IMPORTED_MODULE_0__.zeros)\n/* harmony export */ });\n/* harmony import */ var _core_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.mjs */ \"./node_modules/zarr/core.mjs\");\n\n\n\n/*! pako 2.0.3 https://github.com/nodeca/pako @license (MIT AND Zlib) */\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//const Z_FILTERED          = 1;\n//const Z_HUFFMAN_ONLY      = 2;\n//const Z_RLE               = 3;\nconst Z_FIXED               = 4;\n//const Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nconst Z_BINARY              = 0;\nconst Z_TEXT                = 1;\n//const Z_ASCII             = 1; // = Z_TEXT\nconst Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nconst STORED_BLOCK = 0;\nconst STATIC_TREES = 1;\nconst DYN_TREES    = 2;\n/* The three kinds of block type */\n\nconst MIN_MATCH    = 3;\nconst MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nconst LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nconst LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nconst L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nconst D_CODES       = 30;\n/* number of distance codes */\n\nconst BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nconst HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nconst MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nconst Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nconst MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nconst END_BLOCK   = 256;\n/* end of block literal code */\n\nconst REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nconst REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nconst REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nconst extra_lbits =   /* extra bits for each length code */\n  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);\n\nconst extra_dbits =   /* extra bits for each distance code */\n  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);\n\nconst extra_blbits =  /* extra bits for each bit length code */\n  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);\n\nconst bl_order =\n  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nconst DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nconst static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nconst static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nconst _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nconst _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nconst base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nconst base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nlet static_l_desc;\nlet static_d_desc;\nlet static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nconst d_code = (dist) => {\n\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n};\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nconst put_short = (s, w) => {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n};\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nconst send_bits = (s, value, length) => {\n\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n};\n\n\nconst send_code = (s, c, tree) => {\n\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n};\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nconst bi_reverse = (code, len) => {\n\n  let res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n};\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nconst bi_flush = (s) => {\n\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n};\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nconst gen_bitlen = (s, desc) =>\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  const tree            = desc.dyn_tree;\n  const max_code        = desc.max_code;\n  const stree           = desc.stat_desc.static_tree;\n  const has_stree       = desc.stat_desc.has_stree;\n  const extra           = desc.stat_desc.extra_bits;\n  const base            = desc.stat_desc.extra_base;\n  const max_length      = desc.stat_desc.max_length;\n  let h;              /* heap index */\n  let n, m;           /* iterate over the tree elements */\n  let bits;           /* bit length */\n  let xbits;          /* extra bits */\n  let f;              /* frequency */\n  let overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nconst gen_codes = (tree, max_code, bl_count) =>\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  const next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  let code = 0;              /* running code value */\n  let bits;                  /* bit index */\n  let n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    let len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n};\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nconst tr_static_init = () => {\n\n  let n;        /* iterates over tree elements */\n  let bits;     /* bit counter */\n  let length;   /* length value */\n  let code;     /* code value */\n  let dist;     /* distance index */\n  const bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n};\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nconst init_block = (s) => {\n\n  let n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n};\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nconst bi_windup = (s) =>\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n};\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nconst copy_block = (s, buf, len, header) =>\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);\n  s.pending += len;\n};\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nconst smaller = (tree, n, m, depth) => {\n\n  const _n2 = n * 2;\n  const _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n};\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nconst pqdownheap = (s, tree, k) =>\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  const v = s.heap[k];\n  let j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n};\n\n\n// inlined manually\n// const SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nconst compress_block = (s, ltree, dtree) =>\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  let dist;           /* distance of matched string */\n  let lc;             /* match length or unmatched char (if dist == 0) */\n  let lx = 0;         /* running index in l_buf */\n  let code;           /* the code to send */\n  let extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n};\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nconst build_tree = (s, desc) =>\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  const tree     = desc.dyn_tree;\n  const stree    = desc.stat_desc.static_tree;\n  const has_stree = desc.stat_desc.has_stree;\n  const elems    = desc.stat_desc.elems;\n  let n, m;          /* iterate over heap elements */\n  let max_code = -1; /* largest code with non zero frequency */\n  let node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n};\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nconst scan_tree = (s, tree, max_code) =>\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  let n;                     /* iterates over all tree elements */\n  let prevlen = -1;          /* last emitted length */\n  let curlen;                /* length of current code */\n\n  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  let count = 0;             /* repeat count of the current code */\n  let max_count = 7;         /* max repeat count */\n  let min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nconst send_tree = (s, tree, max_code) =>\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  let n;                     /* iterates over all tree elements */\n  let prevlen = -1;          /* last emitted length */\n  let curlen;                /* length of current code */\n\n  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  let count = 0;             /* repeat count of the current code */\n  let max_count = 7;         /* max repeat count */\n  let min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nconst build_bl_tree = (s) => {\n\n  let max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n};\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nconst send_all_trees = (s, lcodes, dcodes, blcodes) =>\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  let rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n};\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nconst detect_data_type = (s) => {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  let black_mask = 0xf3ffc07f;\n  let n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n};\n\n\nlet static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nconst _tr_init = (s) =>\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n};\n\n\n/* ===========================================================================\n * Send a stored block\n */\nconst _tr_stored_block = (s, buf, stored_len, last) =>\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n};\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nconst _tr_align = (s) => {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n};\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nconst _tr_flush_block = (s, buf, stored_len, last) =>\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  let max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n};\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nconst _tr_tally = (s, dist, lc) =>\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //let out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n};\n\nvar _tr_init_1  = _tr_init;\nvar _tr_stored_block_1 = _tr_stored_block;\nvar _tr_flush_block_1  = _tr_flush_block;\nvar _tr_tally_1 = _tr_tally;\nvar _tr_align_1 = _tr_align;\n\nvar trees = {\n\t_tr_init: _tr_init_1,\n\t_tr_stored_block: _tr_stored_block_1,\n\t_tr_flush_block: _tr_flush_block_1,\n\t_tr_tally: _tr_tally_1,\n\t_tr_align: _tr_align_1\n};\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst adler32 = (adler, buf, len, pos) => {\n  let s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n};\n\n\nvar adler32_1 = adler32;\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nconst makeTable = () => {\n  let c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n};\n\n// Create table on load. Just 255 signed longs. Not a problem.\nconst crcTable = new Uint32Array(makeTable());\n\n\nconst crc32 = (crc, buf, len, pos) => {\n  const t = crcTable;\n  const end = pos + len;\n\n  crc ^= -1;\n\n  for (let i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n};\n\n\nvar crc32_1 = crc32;\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar messages = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar constants = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  Z_MEM_ERROR:       -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst { _tr_init: _tr_init$1, _tr_stored_block: _tr_stored_block$1, _tr_flush_block: _tr_flush_block$1, _tr_tally: _tr_tally$1, _tr_align: _tr_align$1 } = trees;\n\n\n\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH, Z_PARTIAL_FLUSH, Z_FULL_FLUSH, Z_FINISH, Z_BLOCK,\n  Z_OK, Z_STREAM_END, Z_STREAM_ERROR, Z_DATA_ERROR, Z_BUF_ERROR,\n  Z_DEFAULT_COMPRESSION,\n  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED: Z_FIXED$1, Z_DEFAULT_STRATEGY,\n  Z_UNKNOWN: Z_UNKNOWN$1,\n  Z_DEFLATED\n} = constants;\n\n/*============================================================================*/\n\n\nconst MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nconst MAX_WBITS = 15;\n/* 32K LZ77 window */\nconst DEF_MEM_LEVEL = 8;\n\n\nconst LENGTH_CODES$1  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nconst LITERALS$1      = 256;\n/* number of literal bytes 0..255 */\nconst L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;\n/* number of Literal or Length codes, including the END_BLOCK code */\nconst D_CODES$1       = 30;\n/* number of distance codes */\nconst BL_CODES$1      = 19;\n/* number of codes used to transfer the bit lengths */\nconst HEAP_SIZE$1     = 2 * L_CODES$1 + 1;\n/* maximum heap size */\nconst MAX_BITS$1  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nconst MIN_MATCH$1 = 3;\nconst MAX_MATCH$1 = 258;\nconst MIN_LOOKAHEAD = (MAX_MATCH$1 + MIN_MATCH$1 + 1);\n\nconst PRESET_DICT = 0x20;\n\nconst INIT_STATE = 42;\nconst EXTRA_STATE = 69;\nconst NAME_STATE = 73;\nconst COMMENT_STATE = 91;\nconst HCRC_STATE = 103;\nconst BUSY_STATE = 113;\nconst FINISH_STATE = 666;\n\nconst BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nconst BS_BLOCK_DONE     = 2; /* block flush performed */\nconst BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nconst BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nconst OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nconst err = (strm, errorCode) => {\n  strm.msg = messages[errorCode];\n  return errorCode;\n};\n\nconst rank = (f) => {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n};\n\nconst zero$1 = (buf) => {\n  let len = buf.length; while (--len >= 0) { buf[len] = 0; }\n};\n\n\n/* eslint-disable new-cap */\nlet HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;\n// This hash causes less collisions, https://github.com/nodeca/pako/issues/135\n// But breaks binary compatibility\n//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;\nlet HASH = HASH_ZLIB;\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nconst flush_pending = (strm) => {\n  const s = strm.state;\n\n  //_tr_flush_bits(s);\n  let len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n};\n\n\nconst flush_block_only = (s, last) => {\n  _tr_flush_block$1(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n};\n\n\nconst put_byte = (s, b) => {\n  s.pending_buf[s.pending++] = b;\n};\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nconst putShortMSB = (s, b) => {\n\n  //  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n};\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nconst read_buf = (strm, buf, start, size) => {\n\n  let len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32_1(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32_1(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n};\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nconst longest_match = (s, cur_match) => {\n\n  let chain_length = s.max_chain_length;      /* max hash chain length */\n  let scan = s.strstart; /* current string */\n  let match;                       /* matched string */\n  let len;                           /* length of current match */\n  let best_len = s.prev_length;              /* best match length so far */\n  let nice_match = s.nice_match;             /* stop if match long enough */\n  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  const _win = s.window; // shortcut\n\n  const wmask = s.w_mask;\n  const prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  const strend = s.strstart + MAX_MATCH$1;\n  let scan_end1  = _win[scan + best_len - 1];\n  let scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH$1 - (strend - scan);\n    scan = strend - MAX_MATCH$1;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n};\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nconst fill_window = (s) => {\n\n  const _w_size = s.w_size;\n  let p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH$1) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1]);\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH$1) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    const curr = s.strstart + s.lookahead;\n//    let init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n};\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nconst deflate_stored = (s, flush) => {\n\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  let max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    const max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n};\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nconst deflate_fast = (s, flush) => {\n\n  let hash_head;        /* head of the hash chain */\n  let bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH$1) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH$1) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally$1(s, s.strstart - s.match_start, s.match_length - MIN_MATCH$1);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH$1) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally$1(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH$1 - 1)) ? s.strstart : MIN_MATCH$1 - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nconst deflate_slow = (s, flush) => {\n\n  let hash_head;          /* head of hash chain */\n  let bflush;              /* set if current block must be flushed */\n\n  let max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH$1) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH$1 - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH$1 && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH$1 - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH$1 && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH$1;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = _tr_tally$1(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH$1);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH$1 - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n};\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nconst deflate_rle = (s, flush) => {\n\n  let bflush;            /* set if current block must be flushed */\n  let prev;              /* byte at distance one to match */\n  let scan, strend;      /* scan goes up to strend for length of run */\n\n  const _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH$1) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH$1 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH$1 && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH$1;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH$1 - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH$1) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally$1(s, 1, s.match_length - MIN_MATCH$1);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally$1(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nconst deflate_huff = (s, flush) => {\n\n  let bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = _tr_tally$1(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nconst configuration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nconst lm_init = (s) => {\n\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero$1(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH$1 - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n};\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new Uint16Array(HEAP_SIZE$1 * 2);\n  this.dyn_dtree  = new Uint16Array((2 * D_CODES$1 + 1) * 2);\n  this.bl_tree    = new Uint16Array((2 * BL_CODES$1 + 1) * 2);\n  zero$1(this.dyn_ltree);\n  zero$1(this.dyn_dtree);\n  zero$1(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new Uint16Array(MAX_BITS$1 + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new Uint16Array(2 * L_CODES$1 + 1);  /* heap used to build the Huffman trees */\n  zero$1(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new Uint16Array(2 * L_CODES$1 + 1); //uch depth[2*L_CODES+1];\n  zero$1(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nconst deflateResetKeep = (strm) => {\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN$1;\n\n  const s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  _tr_init$1(s);\n  return Z_OK;\n};\n\n\nconst deflateReset = (strm) => {\n\n  const ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n};\n\n\nconst deflateSetHeader = (strm, head) => {\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n};\n\n\nconst deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {\n\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  let wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED$1) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  const s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH$1 - 1) / MIN_MATCH$1);\n\n  s.window = new Uint8Array(s.w_size * 2);\n  s.head = new Uint16Array(s.hash_size);\n  s.prev = new Uint16Array(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new Uint8Array(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n};\n\nconst deflateInit = (strm, level) => {\n\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n};\n\n\nconst deflate = (strm, flush) => {\n\n  let beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  const s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  const old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n        );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      let header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      let level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    let bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        _tr_align$1(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        _tr_stored_block$1(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero$1(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n};\n\n\nconst deflateEnd = (strm) => {\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  const status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n};\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nconst deflateSetDictionary = (strm, dictionary) => {\n\n  let dictLength = dictionary.length;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  const s = strm.state;\n  const wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero$1(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    let tmpDict = new Uint8Array(s.w_size);\n    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  const avail = strm.avail_in;\n  const next = strm.next_in;\n  const input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH$1) {\n    let str = s.strstart;\n    let n = s.lookahead - (MIN_MATCH$1 - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1]);\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH$1 - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH$1 - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n};\n\n\nvar deflateInit_1 = deflateInit;\nvar deflateInit2_1 = deflateInit2;\nvar deflateReset_1 = deflateReset;\nvar deflateResetKeep_1 = deflateResetKeep;\nvar deflateSetHeader_1 = deflateSetHeader;\nvar deflate_2 = deflate;\nvar deflateEnd_1 = deflateEnd;\nvar deflateSetDictionary_1 = deflateSetDictionary;\nvar deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nmodule.exports.deflateBound = deflateBound;\nmodule.exports.deflateCopy = deflateCopy;\nmodule.exports.deflateParams = deflateParams;\nmodule.exports.deflatePending = deflatePending;\nmodule.exports.deflatePrime = deflatePrime;\nmodule.exports.deflateTune = deflateTune;\n*/\n\nvar deflate_1 = {\n\tdeflateInit: deflateInit_1,\n\tdeflateInit2: deflateInit2_1,\n\tdeflateReset: deflateReset_1,\n\tdeflateResetKeep: deflateResetKeep_1,\n\tdeflateSetHeader: deflateSetHeader_1,\n\tdeflate: deflate_2,\n\tdeflateEnd: deflateEnd_1,\n\tdeflateSetDictionary: deflateSetDictionary_1,\n\tdeflateInfo: deflateInfo\n};\n\nconst _has = (obj, key) => {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n\nvar assign = function (obj /*from1, from2, from3, ...*/) {\n  const sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    const source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (const p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// Join array of chunks to single array.\nvar flattenChunks = (chunks) => {\n  // calculate data length\n  let len = 0;\n\n  for (let i = 0, l = chunks.length; i < l; i++) {\n    len += chunks[i].length;\n  }\n\n  // join chunks\n  const result = new Uint8Array(len);\n\n  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {\n    let chunk = chunks[i];\n    result.set(chunk, pos);\n    pos += chunk.length;\n  }\n\n  return result;\n};\n\nvar common = {\n\tassign: assign,\n\tflattenChunks: flattenChunks\n};\n\n// String encode/decode helpers\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nlet STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nconst _utf8len = new Uint8Array(256);\nfor (let q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nvar string2buf = (str) => {\n  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new Uint8Array(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper\nconst buf2binstring = (buf, len) => {\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\n  // If the length of the buffer is smaller than that, we can use this optimization,\n  // otherwise we will take a slower path.\n  if (len < 65534) {\n    if (buf.subarray && STR_APPLY_UIA_OK) {\n      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));\n    }\n  }\n\n  let result = '';\n  for (let i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n};\n\n\n// convert array to string\nvar buf2string = (buf, max) => {\n  let i, out;\n  const len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  const utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    let c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    let c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nvar utf8border = (buf, max) => {\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  let pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\nvar strings = {\n\tstring2buf: string2buf,\n\tbuf2string: buf2string,\n\tutf8border: utf8border\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nvar zstream = ZStream;\n\nconst toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$1,\n  Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1,\n  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,\n  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,\n  Z_DEFLATED: Z_DEFLATED$1\n} = constants;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * const deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  this.options = common.assign({\n    level: Z_DEFAULT_COMPRESSION$1,\n    method: Z_DEFLATED$1,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY$1\n  }, options || {});\n\n  let opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new zstream();\n  this.strm.avail_out = 0;\n\n  let status = deflate_1.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK$1) {\n    throw new Error(messages[status]);\n  }\n\n  if (opt.header) {\n    deflate_1.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    let dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = deflate_1.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK$1) {\n      throw new Error(messages[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, flush_mode]) -> Boolean\n * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must\n * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending\n * buffers and call [[Deflate#onEnd]].\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, flush_mode) {\n  const strm = this.strm;\n  const chunkSize = this.options.chunkSize;\n  let status, _flush_mode;\n\n  if (this.ended) { return false; }\n\n  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;\n  else _flush_mode = flush_mode === true ? Z_FINISH$1 : Z_NO_FLUSH$1;\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  for (;;) {\n    if (strm.avail_out === 0) {\n      strm.output = new Uint8Array(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    // Make sure avail_out > 6 to avoid repeating markers\n    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH$1) && strm.avail_out <= 6) {\n      this.onData(strm.output.subarray(0, strm.next_out));\n      strm.avail_out = 0;\n      continue;\n    }\n\n    status = deflate_1.deflate(strm, _flush_mode);\n\n    // Ended => flush and finish\n    if (status === Z_STREAM_END$1) {\n      if (strm.next_out > 0) {\n        this.onData(strm.output.subarray(0, strm.next_out));\n      }\n      status = deflate_1.deflateEnd(this.strm);\n      this.onEnd(status);\n      this.ended = true;\n      return status === Z_OK$1;\n    }\n\n    // Flush if out buffer full\n    if (strm.avail_out === 0) {\n      this.onData(strm.output);\n      continue;\n    }\n\n    // Flush if requested and has data\n    if (_flush_mode > 0 && strm.next_out > 0) {\n      this.onData(strm.output.subarray(0, strm.next_out));\n      strm.avail_out = 0;\n      continue;\n    }\n\n    if (strm.avail_in === 0) break;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array): output data.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH). By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK$1) {\n    this.result = common.flattenChunks(this.chunks);\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array\n * - data (Uint8Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate$1(input, options) {\n  const deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || messages[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array\n * - data (Uint8Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate$1(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array\n * - data (Uint8Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate$1(input, options);\n}\n\n\nvar Deflate_1 = Deflate;\nvar deflate_2$1 = deflate$1;\nvar deflateRaw_1 = deflateRaw;\nvar gzip_1 = gzip;\nvar constants$1 = constants;\n\nvar deflate_1$1 = {\n\tDeflate: Deflate_1,\n\tdeflate: deflate_2$1,\n\tdeflateRaw: deflateRaw_1,\n\tgzip: gzip_1,\n\tconstants: constants$1\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// See state defs from inflate.js\nconst BAD = 30;       /* got a data error -- remain here until reset */\nconst TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nvar inffast = function inflate_fast(strm, start) {\n  let _in;                    /* local strm.input */\n  let last;                   /* have enough input while in < last */\n  let _out;                   /* local strm.output */\n  let beg;                    /* inflate()'s initial strm.output */\n  let end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  let dmax;                   /* maximum distance from zlib header */\n//#endif\n  let wsize;                  /* window size or zero if not using window */\n  let whave;                  /* valid bytes in the window */\n  let wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  let s_window;               /* allocated sliding window, if wsize != 0 */\n  let hold;                   /* local strm.hold */\n  let bits;                   /* local strm.bits */\n  let lcode;                  /* local strm.lencode */\n  let dcode;                  /* local strm.distcode */\n  let lmask;                  /* mask for first level of length codes */\n  let dmask;                  /* mask for first level of distance codes */\n  let here;                   /* retrieved table entry */\n  let op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  let len;                    /* match length, unused bytes */\n  let dist;                   /* match distance */\n  let from;                   /* where to copy match from */\n  let from_source;\n\n\n  let input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  const state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst MAXBITS = 15;\nconst ENOUGH_LENS = 852;\nconst ENOUGH_DISTS = 592;\n//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nconst CODES = 0;\nconst LENS = 1;\nconst DISTS = 2;\n\nconst lbase = new Uint16Array([ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n]);\n\nconst lext = new Uint8Array([ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n]);\n\nconst dbase = new Uint16Array([ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n]);\n\nconst dext = new Uint8Array([ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n]);\n\nconst inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>\n{\n  const bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  let len = 0;               /* a code's length in bits */\n  let sym = 0;               /* index of code symbols */\n  let min = 0, max = 0;          /* minimum and maximum code lengths */\n  let root = 0;              /* number of index bits for root table */\n  let curr = 0;              /* number of index bits for current table */\n  let drop = 0;              /* code bits to drop for sub-table */\n  let left = 0;                   /* number of prefix codes available */\n  let used = 0;              /* code entries in table used */\n  let huff = 0;              /* Huffman code */\n  let incr;              /* for incrementing code, index */\n  let fill;              /* index for replicating entries */\n  let low;               /* low bits for current root entry */\n  let mask;              /* mask for low root bits */\n  let next;             /* next available space in table */\n  let base = null;     /* base value table to use */\n  let base_index = 0;\n//  let shoextra;    /* extra bits table to use */\n  let end;                    /* use base and extra for symbol > end */\n  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  let extra = null;\n  let extra_index = 0;\n\n  let here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES) {\n    base = extra = work;    /* dummy value--not used */\n    end = 19;\n\n  } else if (type === LENS) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS && used > ENOUGH_LENS) ||\n    (type === DISTS && used > ENOUGH_DISTS)) {\n    return 1;\n  }\n\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS && used > ENOUGH_LENS) ||\n        (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n\n\nvar inftrees = inflate_table;\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n\n\n\n\n\nconst CODES$1 = 0;\nconst LENS$1 = 1;\nconst DISTS$1 = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_FINISH: Z_FINISH$2, Z_BLOCK: Z_BLOCK$1, Z_TREES,\n  Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2, Z_NEED_DICT, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR, Z_BUF_ERROR: Z_BUF_ERROR$1,\n  Z_DEFLATED: Z_DEFLATED$2\n} = constants;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nconst    HEAD = 1;       /* i: waiting for magic header */\nconst    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\nconst    TIME = 3;       /* i: waiting for modification time (gzip) */\nconst    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\nconst    EXLEN = 5;      /* i: waiting for extra length (gzip) */\nconst    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\nconst    NAME = 7;       /* i: waiting for end of file name (gzip) */\nconst    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\nconst    HCRC = 9;       /* i: waiting for header crc (gzip) */\nconst    DICTID = 10;    /* i: waiting for dictionary check value */\nconst    DICT = 11;      /* waiting for inflateSetDictionary() call */\nconst        TYPE$1 = 12;      /* i: waiting for type bits, including last-flag bit */\nconst        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\nconst        STORED = 14;    /* i: waiting for stored size (length and complement) */\nconst        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\nconst        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\nconst        TABLE = 17;     /* i: waiting for dynamic block table lengths */\nconst        LENLENS = 18;   /* i: waiting for code length code lengths */\nconst        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\nconst            LEN_ = 20;      /* i: same as LEN below, but only first time in */\nconst            LEN = 21;       /* i: waiting for length/lit/eob code */\nconst            LENEXT = 22;    /* i: waiting for length extra bits */\nconst            DIST = 23;      /* i: waiting for distance code */\nconst            DISTEXT = 24;   /* i: waiting for distance extra bits */\nconst            MATCH = 25;     /* o: waiting for output space to copy string */\nconst            LIT = 26;       /* o: waiting for output space to write literal */\nconst    CHECK = 27;     /* i: waiting for 32-bit check value */\nconst    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\nconst    DONE = 29;      /* finished check, done -- remain here until reset */\nconst    BAD$1 = 30;       /* got a data error -- remain here until reset */\nconst    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\nconst    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nconst ENOUGH_LENS$1 = 852;\nconst ENOUGH_DISTS$1 = 592;\n//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nconst MAX_WBITS$1 = 15;\n/* 32K LZ77 window */\nconst DEF_WBITS = MAX_WBITS$1;\n\n\nconst zswap32 = (q) => {\n\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n};\n\n\nfunction InflateState() {\n  this.mode = 0;             /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new Uint16Array(320); /* temporary storage for code lengths */\n  this.work = new Uint16Array(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\n\nconst inflateResetKeep = (strm) => {\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS$1);\n  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS$1);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK$2;\n};\n\n\nconst inflateReset = (strm) => {\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n};\n\n\nconst inflateReset2 = (strm, windowBits) => {\n  let wrap;\n\n  /* get the state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR$1;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n};\n\n\nconst inflateInit2 = (strm, windowBits) => {\n\n  if (!strm) { return Z_STREAM_ERROR$1; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  const state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.window = null/*Z_NULL*/;\n  const ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK$2) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n};\n\n\nconst inflateInit = (strm) => {\n\n  return inflateInit2(strm, DEF_WBITS);\n};\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nlet virgin = true;\n\nlet lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\n\nconst fixedtables = (state) => {\n\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    lenfix = new Int32Array(512);\n    distfix = new Int32Array(32);\n\n    /* literal/length table */\n    let sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inftrees(LENS$1,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inftrees(DISTS$1, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n};\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nconst updatewindow = (strm, src, end, copy) => {\n\n  let dist;\n  const state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new Uint8Array(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    state.window.set(src.subarray(end - state.wsize, end), 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      state.window.set(src.subarray(end - copy, end), 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n};\n\n\nconst inflate = (strm, flush) => {\n\n  let state;\n  let input, output;          // input/output buffers\n  let next;                   /* next input INDEX */\n  let put;                    /* next output INDEX */\n  let have, left;             /* available input and output */\n  let hold;                   /* bit buffer */\n  let bits;                   /* bits in bit buffer */\n  let _in, _out;              /* save starting available input and output */\n  let copy;                   /* number of stored or match bytes to copy */\n  let from;                   /* where to copy match bytes from */\n  let from_source;\n  let here = 0;               /* current decoding table entry */\n  let here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //let last;                   /* parent table entry */\n  let last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  let len;                    /* length to copy for repeats, bits to drop */\n  let ret;                    /* return code */\n  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */\n  let opts;\n\n  let n; // temporary variable for NEED_BITS\n\n  const order = /* permutation of code lengths */\n    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);\n\n\n  if (!strm || !strm.state || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR$1;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE$1) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK$2;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        }\n        //=== NEEDBITS(16);\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n          state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 2, 0);\n          //===//\n\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          state.mode = FLAGS;\n          break;\n        }\n        state.flags = 0;           /* expect zlib header */\n        if (state.head) {\n          state.head.done = false;\n        }\n        if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD$1;\n          break;\n        }\n        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED$2) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD$1;\n          break;\n        }\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        len = (hold & 0x0f)/*BITS(4)*/ + 8;\n        if (state.wbits === 0) {\n          state.wbits = len;\n        }\n        else if (len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD$1;\n          break;\n        }\n\n        // !!! pako patch. Force use `options.windowBits` if passed.\n        // Required to always use max window size by default.\n        state.dmax = 1 << state.wbits;\n        //state.dmax = 1 << len;\n\n        //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = hold & 0x200 ? DICTID : TYPE$1;\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        break;\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.flags = hold;\n        if ((state.flags & 0xff) !== Z_DEFLATED$2) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD$1;\n          break;\n        }\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD$1;\n          break;\n        }\n        if (state.head) {\n          state.head.text = ((hold >> 8) & 1);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = TIME;\n        /* falls through */\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.time = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          hbuf[2] = (hold >>> 16) & 0xff;\n          hbuf[3] = (hold >>> 24) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 4, 0);\n          //===\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = OS;\n        /* falls through */\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.xflags = (hold & 0xff);\n          state.head.os = (hold >> 8);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = EXLEN;\n        /* falls through */\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length = hold;\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n          if (state.flags & 0x0200) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = (hold >>> 8) & 0xff;\n            state.check = crc32_1(state.check, hbuf, 2, 0);\n            //===//\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        else if (state.head) {\n          state.head.extra = null/*Z_NULL*/;\n        }\n        state.mode = EXTRA;\n        /* falls through */\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n          if (copy > have) { copy = have; }\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n              if (!state.head.extra) {\n                // Use untyped array for more convenient processing later\n                state.head.extra = new Uint8Array(state.head.extra_len);\n              }\n              state.head.extra.set(\n                input.subarray(\n                  next,\n                  // extra field is limited to 65536 bytes\n                  // - no need for additional size check\n                  next + copy\n                ),\n                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n                len\n              );\n              //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n            if (state.flags & 0x0200) {\n              state.check = crc32_1(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n          if (state.length) { break inf_leave; }\n        }\n        state.length = 0;\n        state.mode = NAME;\n        /* falls through */\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.name_max*/)) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if (state.flags & 0x0200) {\n            state.check = crc32_1(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.name = null;\n        }\n        state.length = 0;\n        state.mode = COMMENT;\n        /* falls through */\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.comm_max*/)) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n          if (state.flags & 0x0200) {\n            state.check = crc32_1(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.comment = null;\n        }\n        state.mode = HCRC;\n        /* falls through */\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD$1;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        if (state.head) {\n          state.head.hcrc = ((state.flags >> 9) & 1);\n          state.head.done = true;\n        }\n        strm.adler = state.check = 0;\n        state.mode = TYPE$1;\n        break;\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        strm.adler = state.check = zswap32(hold);\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = DICT;\n        /* falls through */\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          return Z_NEED_DICT;\n        }\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = TYPE$1;\n        /* falls through */\n      case TYPE$1:\n        if (flush === Z_BLOCK$1 || flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          //---//\n          state.mode = CHECK;\n          break;\n        }\n        //=== NEEDBITS(3); */\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.last = (hold & 0x01)/*BITS(1)*/;\n        //--- DROPBITS(1) ---//\n        hold >>>= 1;\n        bits -= 1;\n        //---//\n\n        switch ((hold & 0x03)/*BITS(2)*/) {\n          case 0:                             /* stored block */\n            //Tracev((stderr, \"inflate:     stored block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = STORED;\n            break;\n          case 1:                             /* fixed block */\n            fixedtables(state);\n            //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = LEN_;             /* decode codes */\n            if (flush === Z_TREES) {\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n              break inf_leave;\n            }\n            break;\n          case 2:                             /* dynamic block */\n            //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = TABLE;\n            break;\n          case 3:\n            strm.msg = 'invalid block type';\n            state.mode = BAD$1;\n        }\n        //--- DROPBITS(2) ---//\n        hold >>>= 2;\n        bits -= 2;\n        //---//\n        break;\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD$1;\n          break;\n        }\n        state.length = hold & 0xffff;\n        //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = COPY_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case COPY_:\n        state.mode = COPY;\n        /* falls through */\n      case COPY:\n        copy = state.length;\n        if (copy) {\n          if (copy > have) { copy = have; }\n          if (copy > left) { copy = left; }\n          if (copy === 0) { break inf_leave; }\n          //--- zmemcpy(put, next, copy); ---\n          output.set(input.subarray(next, next + copy), put);\n          //---//\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       stored end\\n\"));\n        state.mode = TYPE$1;\n        break;\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD$1;\n          break;\n        }\n//#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n        state.have = 0;\n        state.mode = LENLENS;\n        /* falls through */\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n          //--- DROPBITS(3) ---//\n          hold >>>= 3;\n          bits -= 3;\n          //---//\n        }\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        }\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n\n        opts = { bits: state.lenbits };\n        ret = inftrees(CODES$1, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD$1;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n        state.have = 0;\n        state.mode = CODELENS;\n        /* falls through */\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            state.lens[state.have++] = here_val;\n          }\n          else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD$1;\n                break;\n              }\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03);//BITS(2);\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n            }\n            else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 3 + (hold & 0x07);//BITS(3);\n              //--- DROPBITS(3) ---//\n              hold >>>= 3;\n              bits -= 3;\n              //---//\n            }\n            else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 11 + (hold & 0x7f);//BITS(7);\n              //--- DROPBITS(7) ---//\n              hold >>>= 7;\n              bits -= 7;\n              //---//\n            }\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD$1;\n              break;\n            }\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n\n        /* handle error breaks in while */\n        if (state.mode === BAD$1) { break; }\n\n        /* check for end-of-block code (better have one) */\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD$1;\n          break;\n        }\n\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n        state.lenbits = 9;\n\n        opts = { bits: state.lenbits };\n        ret = inftrees(LENS$1, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.lenbits = opts.bits;\n        // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD$1;\n          break;\n        }\n\n        state.distbits = 6;\n        //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n        state.distcode = state.distdyn;\n        opts = { bits: state.distbits };\n        ret = inftrees(DISTS$1, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.distbits = opts.bits;\n        // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD$1;\n          break;\n        }\n        //Tracev((stderr, 'inflate:       codes ok\\n'));\n        state.mode = LEN_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case LEN_:\n        state.mode = LEN;\n        /* falls through */\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          inffast(strm, _out);\n          //--- LOAD() ---\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits;\n          //---\n\n          if (state.mode === TYPE$1) {\n            state.back = -1;\n          }\n          break;\n        }\n        state.back = 0;\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.lencode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        state.length = here_val;\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE$1;\n          break;\n        }\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD$1;\n          break;\n        }\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n        /* falls through */\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n        state.was = state.length;\n        state.mode = DIST;\n        /* falls through */\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.distcode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD$1;\n          break;\n        }\n        state.offset = here_val;\n        state.extra = (here_op) & 15;\n        state.mode = DISTEXT;\n        /* falls through */\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n//#ifdef INFLATE_STRICT\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD$1;\n          break;\n        }\n//#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n        state.mode = MATCH;\n        /* falls through */\n      case MATCH:\n        if (left === 0) { break inf_leave; }\n        copy = _out - left;\n        if (state.offset > copy) {         /* copy from window */\n          copy = state.offset - copy;\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD$1;\n              break;\n            }\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n          }\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          }\n          else {\n            from = state.wnext - copy;\n          }\n          if (copy > state.length) { copy = state.length; }\n          from_source = state.window;\n        }\n        else {                              /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n        if (copy > left) { copy = left; }\n        left -= copy;\n        state.length -= copy;\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n        if (state.length === 0) { state.mode = LEN; }\n        break;\n      case LIT:\n        if (left === 0) { break inf_leave; }\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            // Use '|' instead of '+' to make sure that result is signed\n            hold |= input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n          if (_out) {\n            strm.adler = state.check =\n                /*UPDATE(state.check, put - _out, _out);*/\n                (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));\n\n          }\n          _out = left;\n          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n          if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD$1;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n        state.mode = LENGTH;\n        /* falls through */\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD$1;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n        state.mode = DONE;\n        /* falls through */\n      case DONE:\n        ret = Z_STREAM_END$2;\n        break inf_leave;\n      case BAD$1:\n        ret = Z_DATA_ERROR$1;\n        break inf_leave;\n      case MEM:\n        return Z_MEM_ERROR;\n      case SYNC:\n        /* falls through */\n      default:\n        return Z_STREAM_ERROR$1;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD$1 &&\n                      (state.mode < CHECK || flush !== Z_FINISH$2))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE$1 ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH$2) && ret === Z_OK$2) {\n    ret = Z_BUF_ERROR$1;\n  }\n  return ret;\n};\n\n\nconst inflateEnd = (strm) => {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n    return Z_STREAM_ERROR$1;\n  }\n\n  let state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK$2;\n};\n\n\nconst inflateGetHeader = (strm, head) => {\n\n  /* check state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK$2;\n};\n\n\nconst inflateSetDictionary = (strm, dictionary) => {\n  const dictLength = dictionary.length;\n\n  let state;\n  let dictid;\n  let ret;\n\n  /* check state */\n  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR$1; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR$1;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32_1(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR$1;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK$2;\n};\n\n\nvar inflateReset_1 = inflateReset;\nvar inflateReset2_1 = inflateReset2;\nvar inflateResetKeep_1 = inflateResetKeep;\nvar inflateInit_1 = inflateInit;\nvar inflateInit2_1 = inflateInit2;\nvar inflate_2 = inflate;\nvar inflateEnd_1 = inflateEnd;\nvar inflateGetHeader_1 = inflateGetHeader;\nvar inflateSetDictionary_1 = inflateSetDictionary;\nvar inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nmodule.exports.inflateCopy = inflateCopy;\nmodule.exports.inflateGetDictionary = inflateGetDictionary;\nmodule.exports.inflateMark = inflateMark;\nmodule.exports.inflatePrime = inflatePrime;\nmodule.exports.inflateSync = inflateSync;\nmodule.exports.inflateSyncPoint = inflateSyncPoint;\nmodule.exports.inflateUndermine = inflateUndermine;\n*/\n\nvar inflate_1 = {\n\tinflateReset: inflateReset_1,\n\tinflateReset2: inflateReset2_1,\n\tinflateResetKeep: inflateResetKeep_1,\n\tinflateInit: inflateInit_1,\n\tinflateInit2: inflateInit2_1,\n\tinflate: inflate_2,\n\tinflateEnd: inflateEnd_1,\n\tinflateGetHeader: inflateGetHeader_1,\n\tinflateSetDictionary: inflateSetDictionary_1,\n\tinflateInfo: inflateInfo\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nvar gzheader = GZheader;\n\nconst toString$1 = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH: Z_NO_FLUSH$2, Z_FINISH: Z_FINISH$3,\n  Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_MEM_ERROR: Z_MEM_ERROR$1\n} = constants;\n\n/* ===========================================================================*/\n\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * const inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate(options) {\n  this.options = common.assign({\n    chunkSize: 1024 * 64,\n    windowBits: 15,\n    to: ''\n  }, options || {});\n\n  const opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new zstream();\n  this.strm.avail_out = 0;\n\n  let status  = inflate_1.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== Z_OK$3) {\n    throw new Error(messages[status]);\n  }\n\n  this.header = new gzheader();\n\n  inflate_1.inflateGetHeader(this.strm, this.header);\n\n  // Setup dictionary\n  if (opt.dictionary) {\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      opt.dictionary = strings.string2buf(opt.dictionary);\n    } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {\n      opt.dictionary = new Uint8Array(opt.dictionary);\n    }\n    if (opt.raw) { //In raw mode we need to set the dictionary early\n      status = inflate_1.inflateSetDictionary(this.strm, opt.dictionary);\n      if (status !== Z_OK$3) {\n        throw new Error(messages[status]);\n      }\n    }\n  }\n}\n\n/**\n * Inflate#push(data[, flush_mode]) -> Boolean\n * - data (Uint8Array|ArrayBuffer): input data\n * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE\n *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,\n *   `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. If end of stream detected,\n * [[Inflate#onEnd]] will be called.\n *\n * `flush_mode` is not needed for normal operation, because end of stream\n * detected automatically. You may try to use it for advanced things, but\n * this functionality was not tested.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate.prototype.push = function (data, flush_mode) {\n  const strm = this.strm;\n  const chunkSize = this.options.chunkSize;\n  const dictionary = this.options.dictionary;\n  let status, _flush_mode, last_avail_out;\n\n  if (this.ended) return false;\n\n  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;\n  else _flush_mode = flush_mode === true ? Z_FINISH$3 : Z_NO_FLUSH$2;\n\n  // Convert data if needed\n  if (toString$1.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  for (;;) {\n    if (strm.avail_out === 0) {\n      strm.output = new Uint8Array(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = inflate_1.inflate(strm, _flush_mode);\n\n    if (status === Z_NEED_DICT$1 && dictionary) {\n      status = inflate_1.inflateSetDictionary(strm, dictionary);\n\n      if (status === Z_OK$3) {\n        status = inflate_1.inflate(strm, _flush_mode);\n      } else if (status === Z_DATA_ERROR$2) {\n        // Replace code with more verbose\n        status = Z_NEED_DICT$1;\n      }\n    }\n\n    // Skip snyc markers if more data follows and not raw mode\n    while (strm.avail_in > 0 &&\n           status === Z_STREAM_END$3 &&\n           strm.state.wrap > 0 &&\n           data[strm.next_in] !== 0)\n    {\n      inflate_1.inflateReset(strm);\n      status = inflate_1.inflate(strm, _flush_mode);\n    }\n\n    switch (status) {\n      case Z_STREAM_ERROR$2:\n      case Z_DATA_ERROR$2:\n      case Z_NEED_DICT$1:\n      case Z_MEM_ERROR$1:\n        this.onEnd(status);\n        this.ended = true;\n        return false;\n    }\n\n    // Remember real `avail_out` value, because we may patch out buffer content\n    // to align utf8 strings boundaries.\n    last_avail_out = strm.avail_out;\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === Z_STREAM_END$3) {\n\n        if (this.options.to === 'string') {\n\n          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          let tail = strm.next_out - next_out_utf8;\n          let utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail & realign counters\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));\n        }\n      }\n    }\n\n    // Must repeat iteration if out buffer is full\n    if (status === Z_OK$3 && last_avail_out === 0) continue;\n\n    // Finalize if end of stream reached.\n    if (status === Z_STREAM_END$3) {\n      status = inflate_1.inflateEnd(this.strm);\n      this.onEnd(status);\n      this.ended = true;\n      return true;\n    }\n\n    if (strm.avail_in === 0) break;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|String): output data. When string output requested,\n *   each chunk will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH). By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK$3) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = common.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|String\n * - data (Uint8Array): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako');\n * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));\n * let output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate$1(input, options) {\n  const inflator = new Inflate(options);\n\n  inflator.push(input);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) throw inflator.msg || messages[inflator.err];\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|String\n * - data (Uint8Array): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate$1(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|String\n * - data (Uint8Array): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nvar Inflate_1 = Inflate;\nvar inflate_2$1 = inflate$1;\nvar inflateRaw_1 = inflateRaw;\nvar ungzip = inflate$1;\nvar constants$2 = constants;\n\nvar inflate_1$1 = {\n\tInflate: Inflate_1,\n\tinflate: inflate_2$1,\n\tinflateRaw: inflateRaw_1,\n\tungzip: ungzip,\n\tconstants: constants$2\n};\n\nconst { Deflate: Deflate$1, deflate: deflate$2, deflateRaw: deflateRaw$1, gzip: gzip$1 } = deflate_1$1;\n\nconst { Inflate: Inflate$1, inflate: inflate$2, inflateRaw: inflateRaw$1, ungzip: ungzip$1 } = inflate_1$1;\n\n\n\nvar Deflate_1$1 = Deflate$1;\nvar deflate_1$2 = deflate$2;\nvar deflateRaw_1$1 = deflateRaw$1;\nvar gzip_1$1 = gzip$1;\nvar Inflate_1$1 = Inflate$1;\nvar inflate_1$2 = inflate$2;\nvar inflateRaw_1$1 = inflateRaw$1;\nvar ungzip_1 = ungzip$1;\nvar constants_1 = constants;\n\nvar pako = {\n\tDeflate: Deflate_1$1,\n\tdeflate: deflate_1$2,\n\tdeflateRaw: deflateRaw_1$1,\n\tgzip: gzip_1$1,\n\tInflate: Inflate_1$1,\n\tinflate: inflate_1$2,\n\tinflateRaw: inflateRaw_1$1,\n\tungzip: ungzip_1,\n\tconstants: constants_1\n};\n\nvar _a$2;\nconst GZip = (_a$2 = class {\n  constructor(level = 1) {\n    if (level < 0 || level > 9) {\n      throw new Error(\"Invalid gzip compression level, it should be between 0 and 9\");\n    }\n    this.level = level;\n  }\n  static fromConfig({ level }) {\n    return new _a$2(level);\n  }\n  encode(data) {\n    const gzipped = pako.gzip(data, { level: this.level });\n    return gzipped;\n  }\n  decode(data, out) {\n    const uncompressed = pako.ungzip(data);\n    if (out !== void 0) {\n      out.set(uncompressed);\n      return out;\n    }\n    return uncompressed;\n  }\n}, _a$2.codecId = \"gzip\", _a$2);\n\nvar GZip$1 = GZip;\n\nvar _a$1;\nconst Zlib = (_a$1 = class {\n  constructor(level = 1) {\n    if (level < -1 || level > 9) {\n      throw new Error(\"Invalid zlib compression level, it should be between -1 and 9\");\n    }\n    this.level = level;\n  }\n  static fromConfig({ level }) {\n    return new _a$1(level);\n  }\n  encode(data) {\n    const gzipped = pako.deflate(data, { level: this.level });\n    return gzipped;\n  }\n  decode(data, out) {\n    const uncompressed = pako.inflate(data);\n    if (out !== void 0) {\n      out.set(uncompressed);\n      return out;\n    }\n    return uncompressed;\n  }\n}, _a$1.codecId = \"zlib\", _a$1);\n\nvar Zlib$1 = Zlib;\n\nvar blosc_codec = function() {\n  typeof document !== \"undefined\" && document.currentScript ? document.currentScript.src : void 0;\n  return function(blosc_codec2) {\n    blosc_codec2 = blosc_codec2 || {};\n    var f;\n    f || (f = typeof blosc_codec2 !== \"undefined\" ? blosc_codec2 : {});\n    var aa, ba;\n    f.ready = new Promise(function(a, b) {\n      aa = a;\n      ba = b;\n    });\n    var r = {}, t;\n    for (t in f)\n      f.hasOwnProperty(t) && (r[t] = f[t]);\n    var ca = \"./this.program\", da = f.print || console.log.bind(console), u = f.printErr || console.warn.bind(console);\n    for (t in r)\n      r.hasOwnProperty(t) && (f[t] = r[t]);\n    r = null;\n    f.thisProgram && (ca = f.thisProgram);\n    var v;\n    f.wasmBinary && (v = f.wasmBinary);\n    f.noExitRuntime && (f.noExitRuntime);\n    typeof WebAssembly !== \"object\" && w(\"no native wasm support detected\");\n    var y, ea = false, fa = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf8\") : void 0;\n    function ha(a, b, c) {\n      var d = b + c;\n      for (c = b; a[c] && !(c >= d); )\n        ++c;\n      if (16 < c - b && a.subarray && fa)\n        return fa.decode(a.subarray(b, c));\n      for (d = \"\"; b < c; ) {\n        var e = a[b++];\n        if (e & 128) {\n          var g = a[b++] & 63;\n          if ((e & 224) == 192)\n            d += String.fromCharCode((e & 31) << 6 | g);\n          else {\n            var k = a[b++] & 63;\n            e = (e & 240) == 224 ? (e & 15) << 12 | g << 6 | k : (e & 7) << 18 | g << 12 | k << 6 | a[b++] & 63;\n            65536 > e ? d += String.fromCharCode(e) : (e -= 65536, d += String.fromCharCode(55296 | e >> 10, 56320 | e & 1023));\n          }\n        } else\n          d += String.fromCharCode(e);\n      }\n      return d;\n    }\n    function ia(a, b, c) {\n      var d = z;\n      if (0 < c) {\n        c = b + c - 1;\n        for (var e = 0; e < a.length; ++e) {\n          var g = a.charCodeAt(e);\n          if (55296 <= g && 57343 >= g) {\n            var k = a.charCodeAt(++e);\n            g = 65536 + ((g & 1023) << 10) | k & 1023;\n          }\n          if (127 >= g) {\n            if (b >= c)\n              break;\n            d[b++] = g;\n          } else {\n            if (2047 >= g) {\n              if (b + 1 >= c)\n                break;\n              d[b++] = 192 | g >> 6;\n            } else {\n              if (65535 >= g) {\n                if (b + 2 >= c)\n                  break;\n                d[b++] = 224 | g >> 12;\n              } else {\n                if (b + 3 >= c)\n                  break;\n                d[b++] = 240 | g >> 18;\n                d[b++] = 128 | g >> 12 & 63;\n              }\n              d[b++] = 128 | g >> 6 & 63;\n            }\n            d[b++] = 128 | g & 63;\n          }\n        }\n        d[b] = 0;\n      }\n    }\n    var ja = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-16le\") : void 0;\n    function ka(a, b) {\n      var c = a >> 1;\n      for (var d = c + b / 2; !(c >= d) && A[c]; )\n        ++c;\n      c <<= 1;\n      if (32 < c - a && ja)\n        return ja.decode(z.subarray(a, c));\n      c = 0;\n      for (d = \"\"; ; ) {\n        var e = C[a + 2 * c >> 1];\n        if (e == 0 || c == b / 2)\n          return d;\n        ++c;\n        d += String.fromCharCode(e);\n      }\n    }\n    function la(a, b, c) {\n      c === void 0 && (c = 2147483647);\n      if (2 > c)\n        return 0;\n      c -= 2;\n      var d = b;\n      c = c < 2 * a.length ? c / 2 : a.length;\n      for (var e = 0; e < c; ++e)\n        C[b >> 1] = a.charCodeAt(e), b += 2;\n      C[b >> 1] = 0;\n      return b - d;\n    }\n    function ma(a) {\n      return 2 * a.length;\n    }\n    function na(a, b) {\n      for (var c = 0, d = \"\"; !(c >= b / 4); ) {\n        var e = D[a + 4 * c >> 2];\n        if (e == 0)\n          break;\n        ++c;\n        65536 <= e ? (e -= 65536, d += String.fromCharCode(55296 | e >> 10, 56320 | e & 1023)) : d += String.fromCharCode(e);\n      }\n      return d;\n    }\n    function oa(a, b, c) {\n      c === void 0 && (c = 2147483647);\n      if (4 > c)\n        return 0;\n      var d = b;\n      c = d + c - 4;\n      for (var e = 0; e < a.length; ++e) {\n        var g = a.charCodeAt(e);\n        if (55296 <= g && 57343 >= g) {\n          var k = a.charCodeAt(++e);\n          g = 65536 + ((g & 1023) << 10) | k & 1023;\n        }\n        D[b >> 2] = g;\n        b += 4;\n        if (b + 4 > c)\n          break;\n      }\n      D[b >> 2] = 0;\n      return b - d;\n    }\n    function pa(a) {\n      for (var b = 0, c = 0; c < a.length; ++c) {\n        var d = a.charCodeAt(c);\n        55296 <= d && 57343 >= d && ++c;\n        b += 4;\n      }\n      return b;\n    }\n    var E, F, z, C, A, D, G, qa, ra;\n    function sa(a) {\n      E = a;\n      f.HEAP8 = F = new Int8Array(a);\n      f.HEAP16 = C = new Int16Array(a);\n      f.HEAP32 = D = new Int32Array(a);\n      f.HEAPU8 = z = new Uint8Array(a);\n      f.HEAPU16 = A = new Uint16Array(a);\n      f.HEAPU32 = G = new Uint32Array(a);\n      f.HEAPF32 = qa = new Float32Array(a);\n      f.HEAPF64 = ra = new Float64Array(a);\n    }\n    var ta = f.INITIAL_MEMORY || 16777216;\n    f.wasmMemory ? y = f.wasmMemory : y = new WebAssembly.Memory({ initial: ta / 65536, maximum: 32768 });\n    y && (E = y.buffer);\n    ta = E.byteLength;\n    sa(E);\n    var I, ua = [], va = [], wa = [], xa = [];\n    function ya() {\n      var a = f.preRun.shift();\n      ua.unshift(a);\n    }\n    var J = 0, K = null;\n    f.preloadedImages = {};\n    f.preloadedAudios = {};\n    function w(a) {\n      if (f.onAbort)\n        f.onAbort(a);\n      u(a);\n      ea = true;\n      a = new WebAssembly.RuntimeError(\"abort(\" + a + \"). Build with -s ASSERTIONS=1 for more info.\");\n      ba(a);\n      throw a;\n    }\n    function Aa(a) {\n      var b = L;\n      return String.prototype.startsWith ? b.startsWith(a) : b.indexOf(a) === 0;\n    }\n    function Ba() {\n      return Aa(\"data:application/octet-stream;base64,\");\n    }\n    var L = \"blosc_codec.wasm\";\n    if (!Ba()) {\n      var Ca = L;\n      L = f.locateFile ? f.locateFile(Ca, \"\") : \"\" + Ca;\n    }\n    function Da() {\n      try {\n        if (v)\n          return new Uint8Array(v);\n        throw \"both async and sync fetching of the wasm failed\";\n      } catch (a) {\n        w(a);\n      }\n    }\n    function N(a) {\n      for (; 0 < a.length; ) {\n        var b = a.shift();\n        if (typeof b == \"function\")\n          b(f);\n        else {\n          var c = b.T;\n          typeof c === \"number\" ? b.O === void 0 ? I.get(c)() : I.get(c)(b.O) : c(b.O === void 0 ? null : b.O);\n        }\n      }\n    }\n    function Ea(a) {\n      this.N = a - 16;\n      this.$ = function(b) {\n        D[this.N + 8 >> 2] = b;\n      };\n      this.X = function(b) {\n        D[this.N + 0 >> 2] = b;\n      };\n      this.Y = function() {\n        D[this.N + 4 >> 2] = 0;\n      };\n      this.W = function() {\n        F[this.N + 12 >> 0] = 0;\n      };\n      this.Z = function() {\n        F[this.N + 13 >> 0] = 0;\n      };\n      this.V = function(b, c) {\n        this.$(b);\n        this.X(c);\n        this.Y();\n        this.W();\n        this.Z();\n      };\n    }\n    function Fa(a) {\n      switch (a) {\n        case 1:\n          return 0;\n        case 2:\n          return 1;\n        case 4:\n          return 2;\n        case 8:\n          return 3;\n        default:\n          throw new TypeError(\"Unknown type size: \" + a);\n      }\n    }\n    var Ga = void 0;\n    function P(a) {\n      for (var b = \"\"; z[a]; )\n        b += Ga[z[a++]];\n      return b;\n    }\n    var Q = {}, R = {}, S = {};\n    function Ha(a) {\n      if (a === void 0)\n        return \"_unknown\";\n      a = a.replace(/[^a-zA-Z0-9_]/g, \"$\");\n      var b = a.charCodeAt(0);\n      return 48 <= b && 57 >= b ? \"_\" + a : a;\n    }\n    function Ia(a, b) {\n      a = Ha(a);\n      return new Function(\"body\", \"return function \" + a + '() {\\n    \"use strict\";    return body.apply(this, arguments);\\n};\\n')(b);\n    }\n    function Ja(a) {\n      var b = Error, c = Ia(a, function(d) {\n        this.name = a;\n        this.message = d;\n        d = Error(d).stack;\n        d !== void 0 && (this.stack = this.toString() + \"\\n\" + d.replace(/^Error(:[^\\n]*)?\\n/, \"\"));\n      });\n      c.prototype = Object.create(b.prototype);\n      c.prototype.constructor = c;\n      c.prototype.toString = function() {\n        return this.message === void 0 ? this.name : this.name + \": \" + this.message;\n      };\n      return c;\n    }\n    var Ka = void 0;\n    function T(a) {\n      throw new Ka(a);\n    }\n    var La = void 0;\n    function Ma(a, b) {\n      function c(h) {\n        h = b(h);\n        if (h.length !== d.length)\n          throw new La(\"Mismatched type converter count\");\n        for (var l = 0; l < d.length; ++l)\n          U(d[l], h[l]);\n      }\n      var d = [];\n      d.forEach(function(h) {\n        S[h] = a;\n      });\n      var e = Array(a.length), g = [], k = 0;\n      a.forEach(function(h, l) {\n        R.hasOwnProperty(h) ? e[l] = R[h] : (g.push(h), Q.hasOwnProperty(h) || (Q[h] = []), Q[h].push(function() {\n          e[l] = R[h];\n          ++k;\n          k === g.length && c(e);\n        }));\n      });\n      g.length === 0 && c(e);\n    }\n    function U(a, b, c) {\n      c = c || {};\n      if (!(\"argPackAdvance\" in b))\n        throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n      var d = b.name;\n      a || T('type \"' + d + '\" must have a positive integer typeid pointer');\n      if (R.hasOwnProperty(a)) {\n        if (c.U)\n          return;\n        T(\"Cannot register type '\" + d + \"' twice\");\n      }\n      R[a] = b;\n      delete S[a];\n      Q.hasOwnProperty(a) && (b = Q[a], delete Q[a], b.forEach(function(e) {\n        e();\n      }));\n    }\n    var Na = [], V = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }];\n    function Qa(a) {\n      4 < a && --V[a].P === 0 && (V[a] = void 0, Na.push(a));\n    }\n    function Ra(a) {\n      switch (a) {\n        case void 0:\n          return 1;\n        case null:\n          return 2;\n        case true:\n          return 3;\n        case false:\n          return 4;\n        default:\n          var b = Na.length ? Na.pop() : V.length;\n          V[b] = { P: 1, value: a };\n          return b;\n      }\n    }\n    function Sa(a) {\n      return this.fromWireType(G[a >> 2]);\n    }\n    function Ta(a) {\n      if (a === null)\n        return \"null\";\n      var b = typeof a;\n      return b === \"object\" || b === \"array\" || b === \"function\" ? a.toString() : \"\" + a;\n    }\n    function Ua(a, b) {\n      switch (b) {\n        case 2:\n          return function(c) {\n            return this.fromWireType(qa[c >> 2]);\n          };\n        case 3:\n          return function(c) {\n            return this.fromWireType(ra[c >> 3]);\n          };\n        default:\n          throw new TypeError(\"Unknown float type: \" + a);\n      }\n    }\n    function Va(a) {\n      var b = Function;\n      if (!(b instanceof Function))\n        throw new TypeError(\"new_ called with constructor type \" + typeof b + \" which is not a function\");\n      var c = Ia(b.name || \"unknownFunctionName\", function() {\n      });\n      c.prototype = b.prototype;\n      c = new c();\n      a = b.apply(c, a);\n      return a instanceof Object ? a : c;\n    }\n    function Wa(a) {\n      for (; a.length; ) {\n        var b = a.pop();\n        a.pop()(b);\n      }\n    }\n    function Xa(a, b) {\n      var c = f;\n      if (c[a].L === void 0) {\n        var d = c[a];\n        c[a] = function() {\n          c[a].L.hasOwnProperty(arguments.length) || T(\"Function '\" + b + \"' called with an invalid number of arguments (\" + arguments.length + \") - expects one of (\" + c[a].L + \")!\");\n          return c[a].L[arguments.length].apply(this, arguments);\n        };\n        c[a].L = [];\n        c[a].L[d.S] = d;\n      }\n    }\n    function Ya(a, b, c) {\n      f.hasOwnProperty(a) ? ((c === void 0 || f[a].L !== void 0 && f[a].L[c] !== void 0) && T(\"Cannot register public name '\" + a + \"' twice\"), Xa(a, a), f.hasOwnProperty(c) && T(\"Cannot register multiple overloads of a function with the same number of arguments (\" + c + \")!\"), f[a].L[c] = b) : (f[a] = b, c !== void 0 && (f[a].ba = c));\n    }\n    function Za(a, b) {\n      for (var c = [], d = 0; d < a; d++)\n        c.push(D[(b >> 2) + d]);\n      return c;\n    }\n    function $a(a, b) {\n      0 <= a.indexOf(\"j\") || w(\"Assertion failed: getDynCaller should only be called with i64 sigs\");\n      var c = [];\n      return function() {\n        c.length = arguments.length;\n        for (var d = 0; d < arguments.length; d++)\n          c[d] = arguments[d];\n        var e;\n        a.indexOf(\"j\") != -1 ? e = c && c.length ? f[\"dynCall_\" + a].apply(null, [b].concat(c)) : f[\"dynCall_\" + a].call(null, b) : e = I.get(b).apply(null, c);\n        return e;\n      };\n    }\n    function ab(a, b) {\n      a = P(a);\n      var c = a.indexOf(\"j\") != -1 ? $a(a, b) : I.get(b);\n      typeof c !== \"function\" && T(\"unknown function pointer with signature \" + a + \": \" + b);\n      return c;\n    }\n    var bb = void 0;\n    function cb(a) {\n      a = db(a);\n      var b = P(a);\n      W(a);\n      return b;\n    }\n    function eb(a, b) {\n      function c(g) {\n        e[g] || R[g] || (S[g] ? S[g].forEach(c) : (d.push(g), e[g] = true));\n      }\n      var d = [], e = {};\n      b.forEach(c);\n      throw new bb(a + \": \" + d.map(cb).join([\", \"]));\n    }\n    function fb(a, b, c) {\n      switch (b) {\n        case 0:\n          return c ? function(d) {\n            return F[d];\n          } : function(d) {\n            return z[d];\n          };\n        case 1:\n          return c ? function(d) {\n            return C[d >> 1];\n          } : function(d) {\n            return A[d >> 1];\n          };\n        case 2:\n          return c ? function(d) {\n            return D[d >> 2];\n          } : function(d) {\n            return G[d >> 2];\n          };\n        default:\n          throw new TypeError(\"Unknown integer type: \" + a);\n      }\n    }\n    var gb = {};\n    function hb() {\n      if (!ib) {\n        var a = { USER: \"web_user\", LOGNAME: \"web_user\", PATH: \"/\", PWD: \"/\", HOME: \"/home/web_user\", LANG: (typeof navigator === \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\", _: ca || \"./this.program\" }, b;\n        for (b in gb)\n          a[b] = gb[b];\n        var c = [];\n        for (b in a)\n          c.push(b + \"=\" + a[b]);\n        ib = c;\n      }\n      return ib;\n    }\n    for (var ib, jb = [null, [], []], kb = Array(256), X = 0; 256 > X; ++X)\n      kb[X] = String.fromCharCode(X);\n    Ga = kb;\n    Ka = f.BindingError = Ja(\"BindingError\");\n    La = f.InternalError = Ja(\"InternalError\");\n    f.count_emval_handles = function() {\n      for (var a = 0, b = 5; b < V.length; ++b)\n        V[b] !== void 0 && ++a;\n      return a;\n    };\n    f.get_first_emval = function() {\n      for (var a = 5; a < V.length; ++a)\n        if (V[a] !== void 0)\n          return V[a];\n      return null;\n    };\n    bb = f.UnboundTypeError = Ja(\"UnboundTypeError\");\n    va.push({ T: function() {\n      lb();\n    } });\n    var mb = { p: function(a) {\n      return Y(a + 16) + 16;\n    }, o: function(a, b, c) {\n      new Ea(a).V(b, c);\n      throw a;\n    }, z: function(a, b, c, d, e) {\n      var g = Fa(c);\n      b = P(b);\n      U(a, { name: b, fromWireType: function(k) {\n        return !!k;\n      }, toWireType: function(k, h) {\n        return h ? d : e;\n      }, argPackAdvance: 8, readValueFromPointer: function(k) {\n        if (c === 1)\n          var h = F;\n        else if (c === 2)\n          h = C;\n        else if (c === 4)\n          h = D;\n        else\n          throw new TypeError(\"Unknown boolean type size: \" + b);\n        return this.fromWireType(h[k >> g]);\n      }, M: null });\n    }, y: function(a, b) {\n      b = P(b);\n      U(a, { name: b, fromWireType: function(c) {\n        var d = V[c].value;\n        Qa(c);\n        return d;\n      }, toWireType: function(c, d) {\n        return Ra(d);\n      }, argPackAdvance: 8, readValueFromPointer: Sa, M: null });\n    }, h: function(a, b, c) {\n      c = Fa(c);\n      b = P(b);\n      U(a, { name: b, fromWireType: function(d) {\n        return d;\n      }, toWireType: function(d, e) {\n        if (typeof e !== \"number\" && typeof e !== \"boolean\")\n          throw new TypeError('Cannot convert \"' + Ta(e) + '\" to ' + this.name);\n        return e;\n      }, argPackAdvance: 8, readValueFromPointer: Ua(b, c), M: null });\n    }, e: function(a, b, c, d, e, g) {\n      var k = Za(b, c);\n      a = P(a);\n      e = ab(d, e);\n      Ya(a, function() {\n        eb(\"Cannot call \" + a + \" due to unbound types\", k);\n      }, b - 1);\n      Ma(k, function(h) {\n        var l = a, n = a;\n        h = [h[0], null].concat(h.slice(1));\n        var p = e, q = h.length;\n        2 > q && T(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n        for (var x = h[1] !== null && false, B = false, m = 1; m < h.length; ++m)\n          if (h[m] !== null && h[m].M === void 0) {\n            B = true;\n            break;\n          }\n        var Oa = h[0].name !== \"void\", H = \"\", M = \"\";\n        for (m = 0; m < q - 2; ++m)\n          H += (m !== 0 ? \", \" : \"\") + \"arg\" + m, M += (m !== 0 ? \", \" : \"\") + \"arg\" + m + \"Wired\";\n        n = \"return function \" + Ha(n) + \"(\" + H + \") {\\nif (arguments.length !== \" + (q - 2) + \") {\\nthrowBindingError('function \" + n + \" called with ' + arguments.length + ' arguments, expected \" + (q - 2) + \" args!');\\n}\\n\";\n        B && (n += \"var destructors = [];\\n\");\n        var Pa = B ? \"destructors\" : \"null\";\n        H = \"throwBindingError invoker fn runDestructors retType classParam\".split(\" \");\n        p = [T, p, g, Wa, h[0], h[1]];\n        x && (n += \"var thisWired = classParam.toWireType(\" + Pa + \", this);\\n\");\n        for (m = 0; m < q - 2; ++m)\n          n += \"var arg\" + m + \"Wired = argType\" + m + \".toWireType(\" + Pa + \", arg\" + m + \"); // \" + h[m + 2].name + \"\\n\", H.push(\"argType\" + m), p.push(h[m + 2]);\n        x && (M = \"thisWired\" + (0 < M.length ? \", \" : \"\") + M);\n        n += (Oa ? \"var rv = \" : \"\") + \"invoker(fn\" + (0 < M.length ? \", \" : \"\") + M + \");\\n\";\n        if (B)\n          n += \"runDestructors(destructors);\\n\";\n        else\n          for (m = x ? 1 : 2; m < h.length; ++m)\n            q = m === 1 ? \"thisWired\" : \"arg\" + (m - 2) + \"Wired\", h[m].M !== null && (n += q + \"_dtor(\" + q + \"); // \" + h[m].name + \"\\n\", H.push(q + \"_dtor\"), p.push(h[m].M));\n        Oa && (n += \"var ret = retType.fromWireType(rv);\\nreturn ret;\\n\");\n        H.push(n + \"}\\n\");\n        h = Va(H).apply(null, p);\n        m = b - 1;\n        if (!f.hasOwnProperty(l))\n          throw new La(\"Replacing nonexistant public symbol\");\n        f[l].L !== void 0 && m !== void 0 ? f[l].L[m] = h : (f[l] = h, f[l].S = m);\n        return [];\n      });\n    }, c: function(a, b, c, d, e) {\n      function g(n) {\n        return n;\n      }\n      b = P(b);\n      e === -1 && (e = 4294967295);\n      var k = Fa(c);\n      if (d === 0) {\n        var h = 32 - 8 * c;\n        g = function(n) {\n          return n << h >>> h;\n        };\n      }\n      var l = b.indexOf(\"unsigned\") != -1;\n      U(a, { name: b, fromWireType: g, toWireType: function(n, p) {\n        if (typeof p !== \"number\" && typeof p !== \"boolean\")\n          throw new TypeError('Cannot convert \"' + Ta(p) + '\" to ' + this.name);\n        if (p < d || p > e)\n          throw new TypeError('Passing a number \"' + Ta(p) + '\" from JS side to C/C++ side to an argument of type \"' + b + '\", which is outside the valid range [' + d + \", \" + e + \"]!\");\n        return l ? p >>> 0 : p | 0;\n      }, argPackAdvance: 8, readValueFromPointer: fb(b, k, d !== 0), M: null });\n    }, b: function(a, b, c) {\n      function d(g) {\n        g >>= 2;\n        var k = G;\n        return new e(E, k[g + 1], k[g]);\n      }\n      var e = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][b];\n      c = P(c);\n      U(a, { name: c, fromWireType: d, argPackAdvance: 8, readValueFromPointer: d }, { U: true });\n    }, i: function(a, b) {\n      b = P(b);\n      var c = b === \"std::string\";\n      U(a, { name: b, fromWireType: function(d) {\n        var e = G[d >> 2];\n        if (c)\n          for (var g = d + 4, k = 0; k <= e; ++k) {\n            var h = d + 4 + k;\n            if (k == e || z[h] == 0) {\n              g = g ? ha(z, g, h - g) : \"\";\n              if (l === void 0)\n                var l = g;\n              else\n                l += String.fromCharCode(0), l += g;\n              g = h + 1;\n            }\n          }\n        else {\n          l = Array(e);\n          for (k = 0; k < e; ++k)\n            l[k] = String.fromCharCode(z[d + 4 + k]);\n          l = l.join(\"\");\n        }\n        W(d);\n        return l;\n      }, toWireType: function(d, e) {\n        e instanceof ArrayBuffer && (e = new Uint8Array(e));\n        var g = typeof e === \"string\";\n        g || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Int8Array || T(\"Cannot pass non-string to std::string\");\n        var k = (c && g ? function() {\n          for (var n = 0, p = 0; p < e.length; ++p) {\n            var q = e.charCodeAt(p);\n            55296 <= q && 57343 >= q && (q = 65536 + ((q & 1023) << 10) | e.charCodeAt(++p) & 1023);\n            127 >= q ? ++n : n = 2047 >= q ? n + 2 : 65535 >= q ? n + 3 : n + 4;\n          }\n          return n;\n        } : function() {\n          return e.length;\n        })(), h = Y(4 + k + 1);\n        G[h >> 2] = k;\n        if (c && g)\n          ia(e, h + 4, k + 1);\n        else if (g)\n          for (g = 0; g < k; ++g) {\n            var l = e.charCodeAt(g);\n            255 < l && (W(h), T(\"String has UTF-16 code units that do not fit in 8 bits\"));\n            z[h + 4 + g] = l;\n          }\n        else\n          for (g = 0; g < k; ++g)\n            z[h + 4 + g] = e[g];\n        d !== null && d.push(W, h);\n        return h;\n      }, argPackAdvance: 8, readValueFromPointer: Sa, M: function(d) {\n        W(d);\n      } });\n    }, d: function(a, b, c) {\n      c = P(c);\n      if (b === 2) {\n        var d = ka;\n        var e = la;\n        var g = ma;\n        var k = function() {\n          return A;\n        };\n        var h = 1;\n      } else\n        b === 4 && (d = na, e = oa, g = pa, k = function() {\n          return G;\n        }, h = 2);\n      U(a, { name: c, fromWireType: function(l) {\n        for (var n = G[l >> 2], p = k(), q, x = l + 4, B = 0; B <= n; ++B) {\n          var m = l + 4 + B * b;\n          if (B == n || p[m >> h] == 0)\n            x = d(x, m - x), q === void 0 ? q = x : (q += String.fromCharCode(0), q += x), x = m + b;\n        }\n        W(l);\n        return q;\n      }, toWireType: function(l, n) {\n        typeof n !== \"string\" && T(\"Cannot pass non-string to C++ string type \" + c);\n        var p = g(n), q = Y(4 + p + b);\n        G[q >> 2] = p >> h;\n        e(n, q + 4, p + b);\n        l !== null && l.push(W, q);\n        return q;\n      }, argPackAdvance: 8, readValueFromPointer: Sa, M: function(l) {\n        W(l);\n      } });\n    }, A: function(a, b) {\n      b = P(b);\n      U(a, {\n        aa: true,\n        name: b,\n        argPackAdvance: 0,\n        fromWireType: function() {\n        },\n        toWireType: function() {\n        }\n      });\n    }, n: Qa, x: function(a) {\n      4 < a && (V[a].P += 1);\n    }, C: function(a, b) {\n      var c = R[a];\n      c === void 0 && T(\"_emval_take_value has unknown type \" + cb(a));\n      a = c.readValueFromPointer(b);\n      return Ra(a);\n    }, t: function() {\n      w();\n    }, r: function(a, b, c) {\n      z.copyWithin(a, b, b + c);\n    }, s: function(a) {\n      a >>>= 0;\n      var b = z.length;\n      if (2147483648 < a)\n        return false;\n      for (var c = 1; 4 >= c; c *= 2) {\n        var d = b * (1 + 0.2 / c);\n        d = Math.min(d, a + 100663296);\n        d = Math.max(16777216, a, d);\n        0 < d % 65536 && (d += 65536 - d % 65536);\n        a: {\n          try {\n            y.grow(Math.min(2147483648, d) - E.byteLength + 65535 >>> 16);\n            sa(y.buffer);\n            var e = 1;\n            break a;\n          } catch (g) {\n          }\n          e = void 0;\n        }\n        if (e)\n          return true;\n      }\n      return false;\n    }, u: function(a, b) {\n      var c = 0;\n      hb().forEach(function(d, e) {\n        var g = b + c;\n        e = D[a + 4 * e >> 2] = g;\n        for (g = 0; g < d.length; ++g)\n          F[e++ >> 0] = d.charCodeAt(g);\n        F[e >> 0] = 0;\n        c += d.length + 1;\n      });\n      return 0;\n    }, v: function(a, b) {\n      var c = hb();\n      D[a >> 2] = c.length;\n      var d = 0;\n      c.forEach(function(e) {\n        d += e.length + 1;\n      });\n      D[b >> 2] = d;\n      return 0;\n    }, w: function() {\n      return 0;\n    }, q: function() {\n    }, g: function(a, b, c, d) {\n      for (var e = 0, g = 0; g < c; g++) {\n        for (var k = D[b + 8 * g >> 2], h = D[b + (8 * g + 4) >> 2], l = 0; l < h; l++) {\n          var n = z[k + l], p = jb[a];\n          n === 0 || n === 10 ? ((a === 1 ? da : u)(ha(p, 0)), p.length = 0) : p.push(n);\n        }\n        e += h;\n      }\n      D[d >> 2] = e;\n      return 0;\n    }, a: y, l: function() {\n      return 0;\n    }, k: function() {\n      return 0;\n    }, j: function() {\n    }, B: function() {\n      return 6;\n    }, m: function() {\n    }, f: function() {\n    } };\n    (function() {\n      function a(e) {\n        f.asm = e.exports;\n        I = f.asm.D;\n        J--;\n        f.monitorRunDependencies && f.monitorRunDependencies(J);\n        J == 0 && (K && (e = K, K = null, e()));\n      }\n      function b(e) {\n        a(e.instance);\n      }\n      function c(e) {\n        return Promise.resolve().then(Da).then(function(g) {\n          return WebAssembly.instantiate(g, d);\n        }).then(e, function(g) {\n          u(\"failed to asynchronously prepare wasm: \" + g);\n          w(g);\n        });\n      }\n      var d = { a: mb };\n      J++;\n      f.monitorRunDependencies && f.monitorRunDependencies(J);\n      if (f.instantiateWasm)\n        try {\n          return f.instantiateWasm(d, a);\n        } catch (e) {\n          return u(\"Module.instantiateWasm callback failed with error: \" + e), false;\n        }\n      (function() {\n        return v || typeof WebAssembly.instantiateStreaming !== \"function\" || Ba() || Aa(\"file://\") || typeof fetch !== \"function\" ? c(b) : fetch(L, { credentials: \"same-origin\" }).then(function(e) {\n          return WebAssembly.instantiateStreaming(e, d).then(b, function(g) {\n            u(\"wasm streaming compile failed: \" + g);\n            u(\"falling back to ArrayBuffer instantiation\");\n            return c(b);\n          });\n        });\n      })().catch(ba);\n      return {};\n    })();\n    var lb = f.___wasm_call_ctors = function() {\n      return (lb = f.___wasm_call_ctors = f.asm.E).apply(null, arguments);\n    }, Y = f._malloc = function() {\n      return (Y = f._malloc = f.asm.F).apply(null, arguments);\n    }, W = f._free = function() {\n      return (W = f._free = f.asm.G).apply(null, arguments);\n    }, db = f.___getTypeName = function() {\n      return (db = f.___getTypeName = f.asm.H).apply(null, arguments);\n    };\n    f.___embind_register_native_and_builtin_types = function() {\n      return (f.___embind_register_native_and_builtin_types = f.asm.I).apply(null, arguments);\n    };\n    f.dynCall_jiiiii = function() {\n      return (f.dynCall_jiiiii = f.asm.J).apply(null, arguments);\n    };\n    f.dynCall_jiji = function() {\n      return (f.dynCall_jiji = f.asm.K).apply(null, arguments);\n    };\n    var Z;\n    K = function nb() {\n      Z || ob();\n      Z || (K = nb);\n    };\n    function ob() {\n      function a() {\n        if (!Z && (Z = true, f.calledRun = true, !ea)) {\n          N(va);\n          N(wa);\n          aa(f);\n          if (f.onRuntimeInitialized)\n            f.onRuntimeInitialized();\n          if (f.postRun)\n            for (typeof f.postRun == \"function\" && (f.postRun = [f.postRun]); f.postRun.length; ) {\n              var b = f.postRun.shift();\n              xa.unshift(b);\n            }\n          N(xa);\n        }\n      }\n      if (!(0 < J)) {\n        if (f.preRun)\n          for (typeof f.preRun == \"function\" && (f.preRun = [f.preRun]); f.preRun.length; )\n            ya();\n        N(ua);\n        0 < J || (f.setStatus ? (f.setStatus(\"Running...\"), setTimeout(function() {\n          setTimeout(function() {\n            f.setStatus(\"\");\n          }, 1);\n          a();\n        }, 1)) : a());\n      }\n    }\n    f.run = ob;\n    if (f.preInit)\n      for (typeof f.preInit == \"function\" && (f.preInit = [f.preInit]); 0 < f.preInit.length; )\n        f.preInit.pop()();\n    ob();\n    return blosc_codec2.ready;\n  };\n}();\n\nvar __isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;\nvar __toBinary = __isNode\n  ? base64 => new Uint8Array(Buffer.from(base64, 'base64'))\n  : /* @__PURE__ */ (() => {\n    var table = new Uint8Array(128);\n    for (var i = 0; i < 64; i++) table[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i * 4 - 205] = i;\n    return base64 => {\n      var n = base64.length, bytes = new Uint8Array((n - (base64[n - 1] == '=') - (base64[n - 2] == '=')) * 3 / 4 | 0);\n      for (var i = 0, j = 0; i < n;) {\n        var c0 = table[base64.charCodeAt(i++)], c1 = table[base64.charCodeAt(i++)];\n        var c2 = table[base64.charCodeAt(i++)], c3 = table[base64.charCodeAt(i++)];\n        bytes[j++] = (c0 << 2) | (c1 >> 4);\n        bytes[j++] = (c1 << 4) | (c2 >> 2);\n        bytes[j++] = (c2 << 6) | c3;\n      }\n      return bytes\n    }\n  })();\nvar wasmBinary = __toBinary(\"AGFzbQEAAAABwAImYAF/AX9gA39/fwF/YAV/f39/fwF/YAJ/fwF/YAJ/fwBgAX8AYAN/f38AYAR/f39/AX9gBH9/f38AYAAAYAZ/f39/f38Bf2AFf39/f38AYAZ/f39/f38AYAd/f39/f39/AX9gBH9/f38BfmAFf39/f38BfmAIf39/f39/f38Bf2AJf39/f39/f39/AX9gAn5/AX9gC39/f39/f39/f39/AX9gA39+fwF+YAN/f34AYAN/f34Bf2ADfn9/AX9gAn5+AX5gCH9/f39/f39/AGAJf39/f39/f39/AGAFf35/f38AYAABf2ANf39/f39/f39/f39/fwF/YA9/f39/f39/f39/f39/f38Bf2AFf39/fn8Bf2AGf3x/f39/AX9gAX8BfmACf38BfmAHf35/f39/fwF+YAF+AX5gBH5/f34BfgK0AR0BYQFiAAYBYQFjAAsBYQFkAAYBYQFlAAwBYQFmAAUBYQFnAAcBYQFoAAYBYQFpAAQBYQFqAAMBYQFrAAABYQFsAAABYQFtAAMBYQFuAAUBYQFvAAYBYQFwAAABYQFxAAIBYQFyAAEBYQFzAAABYQF0AAkBYQF1AAMBYQF2AAMBYQF3AAABYQF4AAUBYQF5AAQBYQF6AAsBYQFBAAQBYQFCAAcBYQFDAAMBYQFhAgGAAoCAAgOtBKsEBAEBAwIACAAAAAQHAQEBAAIBAAQDAQMBBAEFAwUFAAYAAwAIAgIDAQgBAwYBCwEBAAQYBAEEBwoGAwMLBwgBBggDCwUDAwMGCAEGBAYABwIGAAABAAIEBAYEBQMDAAsABgwDAAANBgIYAwkAAQwGBggAAgAAAAUQHQAEAQMbBwcHBwMDBh4TBAgBAgECCgcGCgYEAAQAARARAwAIAAYDBgAFBQUFBQUJCwUGAQAFBQICAgcHAwQEAAcSARIXJQQGAwMDAAUEAQABBQUDAAMGCgAFBQMBHwUDAwUFAREDBwoEAAUBAwcKCiEGBQEABgYGBQUIAxMNAAADAAkBBwcHBwcHBwcAAQgGBwMRAgICAgYCCAoCAgcCCAAFBAUFAAMAAAIKBBQACQwMCwMLCAgICwwAAQEFAAUABQkDAAMSEhcGAQAUAAAJCQkJBgAJCQkJCQkJCQkJCQkJDQ0ABgcBAQcHAgEBAgEEAwoABAcFBRwKCgoFAgoCAgMaGQUE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BCAGanQgAWohASACIARHIQwgBEEBaiEEIAwNAAsLIA1BAWoiDSACayIBIAcgAWtBAWoiCEkEQCAKQQJJIQYDQEEBIQQgBkUEQANAIARBAnQiCiADIAFBNGxqaiADIApqKAIAIAF2NgIAIAIgBEchCiAEQQFqIQQgCg0ACwsgAUEBaiIBIAhJDQALCyAAQQRqIAcgCyAJIANBpAVqIAMgAiANEJYDIAVBAToABSAFIAc6AAYgACAFKAIENgIACyAQIQQLIAVBEGokACAEC+ACAQl/IwBBEGsiBCQAIARBADYCDCAEQQA2AggCQCADQUBrIgkgAyAEQQhqIARBDGogASACEPsBIggQIQ0AIARBBGogACgCABA0QQEhASAEKAIMIgUgBC0ABEEBak0EQEEAIQIgBEEAOgAFIAQgBToABiAAIAQoAgQ2AgAgBUEBakEBSwRAA0AgAyABQQJ0aiIGKAIAIQcgBiACNgIAIAcgAUF/anQgAmohAiABIAVGIQYgAUEBaiEBIAZFDQALCyAEKAIIIgdFDQEgAEEEaiEKIAVBAWohC0EAIQADQCADIAAgCWotAAAiBUECdGoiBigCACIBIAFBASAFdEEBdSIMaiICSQRAIAsgBWshBQNAIAogAUEBdGoiAiAFOgABIAIgADoAACABQQFqIgEgBigCACAMaiICSQ0ACwsgBiACNgIAIABBAWoiACAHRw0ACwwBC0FUIQgLIARBEGokACAICxQAIAAoAABBgPqerQNsQSAgAWt2CygAAkACQAJAIAAoAowBQX9qDgIAAQILIAAgARDCAw8LIAAgARDHAwsLOgEBfyABIAAoAgRrIgEgACgCGCICQYAIaksEQCAAIAEgASACa0GAeGoiAEGABCAAQYAESRtrNgIYCwsVACAAEJEBBEAgACgCBA8LIAAtAAsLRQEBfwJAIAIgA00gACABTXINAANAIABBf2oiAC0AACACQX9qIgItAABHDQEgBEEBaiEEIAIgA00NASAAIAFLDQALCyAECwwAIABBICABa62IpwsQACAAIAEgAigCCHRBA3RqCxIAIABBwAAgAWutiKdBACABGwsvAEEgIAFrIgEgAkkEQCAAp0F/IAJ0QX9zcQ8LIAAgASACa62Ip0F/IAJ0QX9zcQsgACACrSAAIAGtQgp8IAN+fULjyJW9y5vvjU9+fEIKfAsoAQF/IwBBEGsiAiQAIABBzA8gAkEIaiABEMYCEBs2AgAgAkEQaiQACxAAIAAgAjYCBCAAIAE2AgALGwAgACkAAEKAgOz8y5vvjU9+QcAAIAFrrYinCxsAIAApAABCgICA2Mub741PfkHAACABa62IpwsUACAAKAAAQbHz3fF5bEEgIAFrdgsNACAAKAIIQQh2QQFxCxAAIABCADcCACAAQgA3AggLUgEBfyAAKAIgIgIgAUkEQCACRQRAIAAgACgCCDYCEAsCQCABQQJJDQAgACAAKAIUQXxxIgI2AhQgAiAAKAIQTw0AIAAgAjYCEAsgACABNgIgCwtHAQF/IAAoAgwhAyAAIAIQ4QEgACgCFCABayIBIANJBEAgAEEBNgIYQQAPCyABIAAoAhBJBEAgACABNgIQCyAAIAE2AhQgAQsKACAAQQNqQXxxCw8AIAAgARDnASACQQNsTwsdAQF/IAAgACgCACAAKAIEayIBNgIQIAAgATYCDAsvACAAQQA2AhggACAAKAIINgIMIAAgACgCBDYCFCAAKAIgQQJPBEAgAEEBNgIgCwsHACABIABrCw0AIAAoAhAgACgCDEkLFQAgACABQX9qQQYgAUEHSxt2QQJqC8oBAQd/AkAgAUUNACAAKAIEIgMgACgCCCIGIAMgBksbIQgDQCADIAhGDQEgACgCACIJIANBDGxqIgUhBCABIAUoAgQiB00EQCAEIAcgAWs2AgQPCyAEQQA2AgQgASAHayIBIAUoAggiBEkEQCAFIAQgAWsiATYCCCABIAJPDQIgA0EBaiICIAZJBEAgCUEMaiADQQxsaiIDIAMoAgQgAWo2AgQLIAAgAjYCBA8LIAVBADYCCCAAIANBAWoiAzYCBCABIARrIgENAAsLC5gEAgx/AX4jAEEQayIIJAAgBCAFaiEJIAEoAoQBIQ8gASgCjAEgARDsARDzASELAkACQCAFQQFIDQAgACgCBCAAKAIITw0AIAlBYGohDANAIAggACAJIARrIgUgDxCmAyAIKAIAIg1FDQIgASAEENIBIAEgBBDRASABIAIgAyAEIAgoAgQiBSALEQIAIQYgAykCACESIAMgDTYCACADIBI3AgQgBCAFaiIKIAZrIQcgCCgCCCIQQX1qIQ4gAigCDCEEAkACQCAKIAxNBEAgBCAHEBwgAigCDCEEIAZBEE0EQCACIAQgBmo2AgwMAwsgBEEQaiAHQRBqIgUQHCAEQSBqIAdBIGoQHCAGQTFIDQEgBCAGaiERIARBMGohBANAIAQgBUEgaiIHEBwgBEEQaiAFQTBqEBwgByEFIARBIGoiBCARSQ0ACwwBCyAEIAcgCiAMECILIAIgAigCDCAGajYCDCAGQYCABEkNACACQQE2AiQgAiACKAIEIAIoAgBrQQN1NgIoCyACKAIEIgQgDUEDajYCACAEIAY7AQQgDkGAgARPBEAgAkECNgIkIAIgBCACKAIAa0EDdTYCKAsgBCAOOwEGIAIgBEEIajYCBCAKIBBqIgQgCU8NASAAKAIEIAAoAghJDQALCyAJIARrIQULIAEgBBDSASABIAQQ0QEgASACIAMgBCAFIAsRAgAhACAIQRBqJAAgAAtRAQJ/IwBBIGsiASQAIAEgACgCEDYCGCABIAApAgg3AxAgASAAKQIANwMIQQEhAiABQQhqEOgBRQRAIAAoAnBBAEdBAXQhAgsgAUEgaiQAIAILGwEBfyAAKAIQIAAoAgwiAUkEQCAAIAE2AhALCwwAIAAgACgCCDYCEAsRACABIAAoAgRrQYCAgIB6SwupAQEEfwJAIAEgACgCACIDRgRAIAAoAgwhAyAAKAIQIQUgACgCCCEEQQEhBgwBCyAAIAAoAgwiBTYCECAAIAAoAgQiBDYCCCAAIAMgBGsiAzYCDCAAIAEgA2s2AgQgAyAFa0EHSw0AIAAgAzYCECADIQULIAAgASACaiICNgIAIAIgBCAFak0gAyAEaiABTXJFBEAgACADIAIgBGsiACAAIANKGzYCEAsgBguRAwEGfyACKAIoIQYgAigCBCEJIAIoAiQhByACKAIgIgoEQCADQv8BViADQv+BBFZqIANC/v///w9WaiEIC0G6fyEFAkAgAUESSQ0AQQAgBEEARyAEQf8BS2ogBEH//wNLaiAGGyIGIAdBAEpBAnRqQSBBACAKQQBHQQEgCXStIANacSIBG3IgCEEGdHIhB0EAIQUgAigCAEUEQCAAQajqvmkQTUEEIQULIAAgBWogBzoAACAFQQFyIQUgAUUEQCAAIAVqIAlBA3RBsH9qOgAAIAVBAWohBQsCQAJAAkACQCAGQX9qDgMAAQIDCyAAIAVqIAQ6AAAgBUEBaiEFDAILIAAgBWogBEH//wNxEC8gBUECaiEFDAELIAAgBWogBBBNIAVBBGohBQsCQAJAAkACQCAIQX9qDgMBAgMACyABRQ0DIAAgBWogAzwAACAFQQFqDwsgACAFaiADp0GAfmpB//8DcRAvIAVBAmoPCyAAIAVqIAOnEE0gBUEEag8LIAAgBWogAzcAACAFQQhqIQULIAULHQAgAEEANgIkIAAgACgCCDYCDCAAIAAoAgA2AgQLFQAgAUEobCAAQQJ0akGQmQFqKAIACwoAIAAgAUEFS2sLAwABC00AIAAoAvAFIAAoApgDIAAoApwDIAAoAqADEGQgACgCgAYQ9wMgAEEANgKQBiAAQgA3A4gGIABCADcDgAYgAEIANwP4BSAAQgA3A/AFC0QBA38gAkEATgR/A0AgBCABIANBAnQiBGooAgAgACAEai0AAmxqIQQgAiADRyEFIANBAWohAyAFDQALIARBA3YFIAMLC6AEAQV/IwBBEGsiCyQAIAtB/wE2AgxBfyEJAkAgBUEDcQ0AIAFFBEBBACEJDAELQbh/IQkgA0GAgAhLDQAgACABaiEMAkAgB0EARyAIQQBHcSIIRQ0AIAcoAgBBAkcNACAAIAAgDCACIAMgBCAGEIEBIQkMAQsgBSALQQxqIAIgAyAFEIkEIgkQIQ0AIAMgCUYEQCAAIAItAAA6AABBASEJDAELIAkgA0EHdkEEak0hCkEAIQkgCg0AAkAgB0UNAAJAAkAgBygCACIJQQFGBEAgBiAFIAsoAgwQ+wMNASAHQQA2AgAMAwsgCUUNAiAIQQFzRQ0BDAILIAhFDQELIAAgACAMIAIgAyAEIAYQgQEhCQwBCyAFQYAIaiIIIAUgCygCDCIKQQsgAyAKQQEQgQIgBUGAEGoQ/wMiCRAhDQAgCkECdCINIAhqQQRqQQBB/AcgDWsQKBogACABIAggCiAJEIAEIgEQIQRAIAEhCQwBCwJAAkAgBwRAIAcoAgBFBEAgAUEMaiEFDAILIAYgBSAKEPcBIQkgCCAFIAoQ9wEhCiABQQxqIgUgA0lBACAJIAEgCmpLGw0BIAAgACAMIAIgAyAEIAYQgQEhCQwDC0EAIQkgAUEMaiADTw0CDAELQQAhCSAFIANPDQEgB0EANgIACyAGBEAgBiAIQYAIECoaCyAAIAAgAWogDCACIAMgBCAIEIEBIQkLIAtBEGokACAJCw0AIAAgAUECdGotAAILgAIBBn8jAEGQA2siBCQAIARBDDYCjAMCQCADQQJJDQAgBEEgaiAEQYwDaiACIAMQqgEiBSADRiEGIAVBAUYgAyAFRnINACAEQQYgAyAEKAKMAyIHEKcBIgggBEEgaiADIAcQpgEiBhAhDQAgACABIAQgByAIEKgBIgUQISIJBEAgBSEGDAELIARBoAFqIAQgByAIIARB4ABqQcAAEKkBIgYQIQ0AIAAgACAFaiAJGyIFIAAgAWogBWsiASACIAMgBEGgAWogAyADQQd2akEIaiABTRCGBCIBECEEQCABIQYMAQtBACEGIAFFDQAgASAFaiAAayEGCyAEQZADaiQAIAYLggQBBn8jAEGQAmsiCyQAQbh/IQgCQCAFRQ0AIAQsAAAiCUH/AXEhBgJAAkAgCUF/TARAIAZBgn9qQQF2IgkgBU8NA0FsIQggBkGBf2oiB0H/AUsNAyAHRQ0CIARBAWohBEEAIQUDQCAAIAVqIAQgBUEBdmoiBi0AAEEEdjoAACAAIAVBAXJqIAYtAABBD3E6AAAgBUECaiIFIAdJDQALIAkhBgwBCyAGIAVPDQIgACAEQQFqIAYgCxCBBCIHIQggBxAhDQILIAFCADcCAEEAIQQgAUEANgIwIAFCADcCKCABQgA3AiAgAUIANwIYIAFCADcCECABQgA3AghBbCEIIAdFDQFBACEFA0AgACAFaiIJLQAAIgpBC0sNAiABIApBAnRqIgogCigCAEEBajYCAEEBIAktAAB0QQF1IARqIQQgBUEBaiIFIAdHDQALIARFDQEgBBAkQQFqIgVBDEsNASADIAU2AgBBAUEBIAV0IARrIgMQJCIEdCADRw0BIAAgB2ogBEEBaiIAOgAAIAEgAEECdGoiACAAKAIAQQFqNgIAIAEoAgQiAEECSSAAQQFxcg0BIAIgB0EBajYCACAGQQFqIQgMAQsgAUIANwIAIAFBADYCMCABQgA3AiggAUIANwIgIAFCADcCGCABQgA3AhAgAUIANwIICyALQZACaiQAIAgLCAAgACABEE0LMQECfyAAEIQEIAAQOSAAKAIMIgIgACgCEEkEfyACIAAoAghrIAAoAgRBAEdqBSABCwtFAQF/IAAoAgQhASAAKAIMIAAoAgAQ/AEgACAAKAIMIAFBA3ZqNgIMIAAgACgCBEEHcTYCBCAAIAAoAgAgAUF4cXY2AgALLwAgACABNgIMIAAgATYCCCAAQgA3AgAgACABIAJqQXxqNgIQQbp/QQAgAkEFSRsLGgAgABAkQQFqIgAgARAkQQJqIgEgACABSRsLQQEBfyABQX9qECQhBCABIAIQgAIiASAEIANrIgIgACACIABJGyIAIAEgAEsbIgBBBSAAQQVLGyIAQQwgAEEMSRsL5AQBC38Cf0F/IANBAWoiDiADSQ0AGiAEQQFqIQ8gBEF7aiEHQQEgBHQiDEEBaiEKIAAgAWpBfmohDUEEIQEgACEIA0ACQAJAIAtFBEAgBiEEDAELAkAgBiIEIA5PDQADQCACIARBAXRqLwEADQEgAyAERiEJIARBAWohBCAJRQ0ACyAKIQkMAgsgBCAORgRAIAohCQwCCyAEIAZBGGoiCU8EQEH//wMgAXQhCwNAIAUgCCANTXJFBEBBun8PCyAIIAcgC2oiBjsAACAGQRB2IQcgCEECaiEIIAkiBkEYaiIQIQkgBCAQTw0ACwsgBCAGQQNqIglPBEADQEEDIAF0IAdqIQcgAUECaiEBIAQgCSIGQQNqIglPDQALCyAEIAZrIAF0IAdqIQcgAUEPSARAIAFBAmohAQwBCyAFIAggDU1yRQRAQbp/DwsgCCAHOwAAIAFBcmohASAHQRB2IQcgCEECaiEIC0F/IAIgBEEBdGouAQAiBkEAIAZrIAZBAEgbIApqIglBAUgNAhogASAPakEAIApBf3MgDEEBdGoiCyAGQQFqIgYgDEgbIAZqIgogC0hrIQYgCSAMSARAA0AgD0F/aiEPIAkgDEEBdSIMSA0ACwsgCiABdCAHaiEHIAZBEUgEfyAGBSAFIAggDU1yRQRAQbp/DwsgCCAHOwAAIAdBEHYhByAIQQJqIQggBkFwagshASAJQQJIDQAgCkEBRiELIAkhCiAEQQFqIgYgDkkNAQsLQX8gCUEBRw0AGiAFRQRAQbp/IAggDUsNARoLIAggBzsAACAIIAFBB2pBCG1qIABrCwvgBgEJfyABKAIAIQwgBUEAQYAgECghByADRQRAIABBACAMQQFqECgaIAFBADYCAEEADwsgB0GAGGohCCAHQYAQaiEJIAdBgAhqIQogAiADaiENAkAgA0EUSARAIAIhAwwBCyANQXFqIQ4gAkEEaiEFIAIoAAAhBgNAIAUoAAAhAyAHIAZB/wFxQQJ0aiIFIAUoAgBBAWo2AgAgCiAGQQZ2QfwHcWoiBSAFKAIAQQFqNgIAIAkgBkEOdkH8B3FqIgUgBSgCAEEBajYCACAIIAZBFnZB/AdxaiIFIAUoAgBBAWo2AgAgAigACCEFIAcgA0H/AXFBAnRqIgYgBigCAEEBajYCACAKIANBBnZB/AdxaiIGIAYoAgBBAWo2AgAgCSADQQ52QfwHcWoiBiAGKAIAQQFqNgIAIAggA0EWdkH8B3FqIgMgAygCAEEBajYCACACKAAMIQsgByAFQf8BcUECdGoiAyADKAIAQQFqNgIAIAogBUEGdkH8B3FqIgMgAygCAEEBajYCACAJIAVBDnZB/AdxaiIDIAMoAgBBAWo2AgAgCCAFQRZ2QfwHcWoiAyADKAIAQQFqNgIAIAJBEGoiAygAACEGIAcgC0H/AXFBAnRqIgUgBSgCAEEBajYCACAKIAtBBnZB/AdxaiIFIAUoAgBBAWo2AgAgCSALQQ52QfwHcWoiBSAFKAIAQQFqNgIAIAggC0EWdkH8B3FqIgUgBSgCAEEBajYCACACQRRqIQUgAyECIAUgDkkNAAsLIAMgDUkEQANAIAcgAy0AAEECdGoiAiACKAIAQQFqNgIAIANBAWoiAyANRw0ACwsCQCAERSAMQf8BIAwbIgJB/wFPcg0AQf8BIQMDQAJAIAcgA0ECdCIEaiIFIAUoAgAgBCAIaigCACAEIAlqKAIAIAQgCmooAgBqamoiBDYCACAEDQAgA0F/aiIDIAJLDQEMAgsLQVAPCyACQf8BIAJB/wFJGyEFQQAhA0EAIQYDQCAAIANBAnQiAmogAiAIaigCACACIAlqKAIAIAIgCmooAgAgAiAHaigCAGpqaiICNgIAIAIgBiACIAZLGyEGIAMgBUchAiADQQFqIQMgAg0ACwNAIAUiAkF/aiEFIAAgAkECdGooAgBFDQALIAEgAjYCACAGC4gDAgV/BX4gAEEoaiIBIAAoAkgiBWohAgJ+IAApAwAiBkIgWgRAIAApAxAiB0IHiSAAKQMIIghCAYl8IAApAxgiCUIMiXwgACkDICIKQhKJfCAIEIQBIAcQhAEgCRCEASAKEIQBDAELIAApAxhCxc/ZsvHluuonfAsgBnwhBgJAIAIgAEEwaiIESQRAIAEhAwwBCwNAQgAgASkAABBOIAaFQhuJQoeVr6+Ytt6bnn9+QuPcypX8zvL1hX98IQYgBCIDIgFBCGoiBCACTQ0ACwsCQCADQQRqIgEgAksEQCADIQEMAQsgAygAAK1Ch5Wvr5i23puef34gBoVCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQYLIAEgAkkEQCAAIAVqQShqIQADQCABMQAAQsXP2bLx5brqJ34gBoVCC4lCh5Wvr5i23puef34hBiABQQFqIgEgAEcNAAsLIAZCIYggBoVCz9bTvtLHq9lCfiIGQh2IIAaFQvnz3fGZ9pmrFn4iBkIgiCAGhQv4AgICfwR+IAAgACkDACACrXw3AwACQAJAIAAoAkgiAyACakEfTQRAIAAgA2pBKGogASACEKsBIAAoAkggAmohAQwBCyABIAJqIQQCQAJ/IAMEQCAAQShqIgIgA2ogAUEgIANrEKsBIAAgACkDCCACKQAAEE43AwggACAAKQMQIAApADAQTjcDECAAIAApAxggACkAOBBONwMYIAAgACkDICAAQUBrKQAAEE43AyAgACgCSCECIABBADYCSCABIAJrQSBqIQELIAFBIGogBEsLBEAgASECDAELIARBYGohAyAAKQMgIQUgACkDGCEGIAApAxAhByAAKQMIIQgDQCAIIAEpAAAQTiEIIAcgASkACBBOIQcgBiABKQAQEE4hBiAFIAEpABgQTiEFIAFBIGoiAiEBIAIgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyACIARPDQEgAEEoaiACIAQgAmsiARCrAQsgACABNgJICwtlACAAQgA3AyggAEL56tDQ58mh5OEANwMgIABCADcDGCAAQs/W077Sx6vZQjcDECAAQtbrgu7q/Yn14AA3AwggAEIANwMAIABCADcDMCAAQgA3AzggAEFAa0IANwMAIABCADcDSAsVACABBEAgAiAAIAERAwAPCyAAEEwLYQEDf0F+IQECQCAARQ0AIAAoAhwiAkUNACAAKAIkIgNFDQAgAigCNCIBBEAgACgCKCABIAMRBAAgACgCJCEDIAAoAhwhAgsgACgCKCACIAMRBABBACEBIABBADYCHAsgAQudCwEMfyACQQBOBEBBBEEDIAEvAQIiCxshB0EHQYoBIAsbIQQgAEG5LWohCEF/IQYDQCALIQkCQCAJIAEgDCINQQFqIgxBAnRqLwECIgtH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AhQgCiAAKAIIaiADOgAAIAAgACgCFCIDQQFqNgIUIAMgACgCCGogAEG5LWotAAA6AAAgACABQRAgACgCvC0iAWt2OwG4LSAAIAEgAmpBcGo2ArwtDwsgACACIARqNgK8LQuXAQECfwJAAn8gACgCvC0iAUEJTgRAIAAgACgCFCIBQQFqNgIUIAEgACgCCGogAC0AuC06AAAgACAAKAIUIgFBAWo2AhQgAEG5LWotAAAhAiABIAAoAghqDAELIAFBAUgNASAAIAAoAhQiAUEBajYCFCAALQC4LSECIAEgACgCCGoLIAI6AAALIABBADYCvC0gAEEAOwG4LQvaBAEBfwNAIAAgAUECdGpBADsBlAEgAUEBaiIBQZ4CRw0ACyAAQQA7AfwUIABBADsBiBMgAEHEFWpBADsBACAAQcAVakEAOwEAIABBvBVqQQA7AQAgAEG4FWpBADsBACAAQbQVakEAOwEAIABBsBVqQQA7AQAgAEGsFWpBADsBACAAQagVakEAOwEAIABBpBVqQQA7AQAgAEGgFWpBADsBACAAQZwVakEAOwEAIABBmBVqQQA7AQAgAEGUFWpBADsBACAAQZAVakEAOwEAIABBjBVqQQA7AQAgAEGIFWpBADsBACAAQYQVakEAOwEAIABBgBVqQQA7AQAgAEH8E2pBADsBACAAQfgTakEAOwEAIABB9BNqQQA7AQAgAEHwE2pBADsBACAAQewTakEAOwEAIABB6BNqQQA7AQAgAEHkE2pBADsBACAAQeATakEAOwEAIABB3BNqQQA7AQAgAEHYE2pBADsBACAAQdQTakEAOwEAIABB0BNqQQA7AQAgAEHME2pBADsBACAAQcgTakEAOwEAIABBxBNqQQA7AQAgAEHAE2pBADsBACAAQbwTakEAOwEAIABBuBNqQQA7AQAgAEG0E2pBADsBACAAQbATakEAOwEAIABBrBNqQQA7AQAgAEGoE2pBADsBACAAQaQTakEAOwEAIABBoBNqQQA7AQAgAEGcE2pBADsBACAAQZgTakEAOwEAIABBlBNqQQA7AQAgAEGQE2pBADsBACAAQYwTakEAOwEAIABCADcCrC0gAEGUCWpBATsBACAAQQA2AqgtIABBADYCoC0LngEBAn8gACAALwG4LSADQf//A3EiBCAAKAK8LSIDdHIiBTsBuC0gAAJ/IANB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A0AgCSAFIARBAXRqIgotAAEiC0ECdGoiDCgCACEDIAlBPGogCi0AAEEIdCAIakH//wNxEC8gCUECOgA/IAkgByALayIKIAJqOgA+IANBASABIAprdGohCiAJKAI8IQsDQCAAIANBAnRqIAs2AQAgA0EBaiIDIApJDQALIAwgCjYCACAEQQFqIgQgBkcNAAsLIAlBQGskAAvdAgEJfyMAQdAAayIJJAAgCUFAayAFKAIwNgIAIAkgBSkCKDcDOCAJIAUpAiA3AzAgCSAFKQIYNwMoIAkgBSkCEDcDICAJIAUpAgA3AxAgCSAFKQIINwMYIAMEQCAHIAZrIQ8gByABayEQA0BBASABIAcgAiALQQF0aiIGLQABIgxrIghrIgp0IQ0gBi0AACEOIAlBEGogDEECdGoiDCgCACEGAkAgCiAPTwRAIAAgBkECdGogCiAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QlQMgBiANaiEIDAELIAlBDGogDhAvIAlBAToADyAJIAg6AA4gBiAGIA1qIghPDQAgCSgCDCEKA0AgACAGQQJ0aiAKNgEAIAZBAWoiBiAIRw0ACwsgDCAINgIAIAtBAWoiCyADRw0ACwsgCUHQAGokAAs+AQN/IAAEQCAAKAIAIABBvNABaigCACIBIABBwNABaigCACICIABBxNABaigCACIDEGQgACABIAIgAxBkCwvMAQEBfyAAIAEoArTQATYCmOIBIAAgASgCBCICNgLA4AEgACACNgK84AEgACACIAEoAghqIgI2ArjgASAAIAI2AsTgASABKAK40AEEQCAAQoGAgIAQNwOI4QEgACABQaTQAGo2AgwgACABQZQgajYCCCAAIAFBnDBqNgIEIAAgAUEMajYCACAAQazQAWogAUGo0AFqKAIANgIAIABBsNABaiABQazQAWooAgA2AgAgAEG00AFqIAFBsNABaigCADYCAA8LIABCADcDiOEBC6JIAS5/IwBB4ABrIhIkACAAKAKEASEGIAAoAgQhByAAKAKIASEFIAAoAgwhCCASIAAoAhg2AlwgACgCPCEbIABBQGsoAgAhHCAAQSxqIiYgAyAEQQIQWSADIAcgCGogA0ZqIg0gAyAEaiIMQXhqIi5JBEAgBUH/HyAFQf8fSRsh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AnRBsKcBaigCABBHIAtBOGoQOSALQThqIAAvAQYgAi0AAEECdEGQpAFqKAIAEEcgC0E4ahA5AkAgCgRAIAEtAAAiASABQRggAUEYSRsiAmsiAQRAIAtBOGogACgCACABEEcgC0E4ahA5CyALQThqIAAoAgAgAXYgAhBHDAELIAtBOGogACgCACABLQAAEEcLIAtBOGoQOSAJQQJPBEAgCUF+aiEMA0AgByAMai0AACECIAMgDGotAAAhBCALQThqIAtBGGogBSAMai0AACIAEGwgC0E4aiALQShqIAQQbCALQThqEDkgC0E4aiALQQhqIAIQbCALQThqEDkgC0E4aiAIIAxBA3RqIgEvAQQgAkECdEGwpwFqKAIAIgIQRyACIARBAnRBkKQBaigCACICakEZTwRAIAtBOGoQOQsgC0E4aiABLwEGIAIQRyALQThqEDkCQCAKBEAgACAAQRggAEEYSRsiAmsiAARAIAtBOGogASgCACAAEEcgC0E4ahA5CyALQThqIAEoAgAgAHYgAhBHDAELIAtBOGogASgCACAAEEcLIAtBOGoQOSAMQX9qIgwgCUkNAAsLIAtBOGogCygCKCALKAI0EHQgC0E4aiALKAIYIAsoAiQQdCALQThqIAsoAgggCygCFBB0IAtBOGoQ/QEiAEG6fyAAGyEMCyALQdAAaiQAIAwLLwAgACACQQN0aigCBCIAQRB2QQFqIgJBCHRBfyABdCAAayACQRB0akEIdCABdmsLTwEEfwNAIANBASAAIARBAnRqKAIAIgNBCHQiBSACbiIGIAUgAkkbIAYgAxtBAnRBkJwBaigCACADbGohAyAEQQFqIgQgAU0NAAsgA0EIdgtKAQF/IwBB8ARrIgQkACAEIAMgAiABEKcBIgMgACACIAEQpgEiAhAhRQRAIARB8ABqQYAEIAQgASADEKgBIQILIARB8ARqJAAgAguKAQEIfyMAQRBrIgMkACADIAAQc0F/IQUCQCAALwACIAJJDQAgAygCDCIHQQh0QYACaiEIIAMoAgghCUEAIQADQCAJIAcgABDJAyEGIAEgAEECdGooAgAiCgRAIAYgCE8NAiAGIApsIARqIQQLIABBAWoiACACTQ0ACyAEQQh2IQULIANBEGokACAFC18BAn9BCCABayEFQQAhAQNAIARBASAAIAFBAXRqLwEAIgQg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ASACEEUiARAhDQEgBEEQaiAEQRhqIAMQggEgBEEIaiAEQRhqIAMQggFBACEBAkAgBEEYahAjBEBBACEDDAELA0AgACABaiICIARBEGogBEEYahBiOgAAIAIgBEEIaiAEQRhqEGI6AAEgBEEYahAjBEAgAUECciEDDAILIAIgBEEQaiAEQRhqEGI6AAIgAiAEQQhqIARBGGoQYjoAAyABQQRqIQMgBEEYahAjIQIgAUH3AUsNASADIQEgAkUNAAsLAn8DQEG6fyEBIANB/QFLDQMgACADaiICIARBEGogBEEYahBiOgAAIAIiBkEBaiEFIARBGGoQI0EDRgRAQQIhAyAEQQhqDAILIANB/AFLDQMgBiAEQQhqIARBGGoQYjoAASADQQJqIQMgBEEYahAjQQNHDQALIAAgA2ohBUEDIQMgBEEQagshASAFIAEgBEEYahBiOgAAIAIgA2ogAGshAQwBCyAEQRhqIAEgAhBFIgEQIQ0AIARBEGogBEEYaiADEIIBIARBCGogBEEYaiADEIIBQQAhAQJAIARBGGoQIwRAQQAhAwwBCwNAIAAgAWoiAiAEQRBqIARBGGoQYToAACACIARBCGogBEEYahBhOgABIARBGGoQIwRAIAFBAnIhAwwCCyACIARBEGogBEEYahBhOgACIAIgBEEIaiAEQRhqEGE6AAMgAUEEaiEDIARBGGoQIyECIAFB9wFLDQEgAyEBIAJFDQALCwJ/A0BBun8hASADQf0BSw0CIAAgA2oiAiAEQRBqIARBGGoQYToAACACIgZBAWohBSAEQRhqECNBA0YEQEECIQMgBEEIagwCCyADQfwBSw0CIAYgBEEIaiAEQRhqEGE6AAEgA0ECaiEDIARBGGoQI0EDRw0ACyAAIANqIQVBAyEDIARBEGoLIQEgBSABIARBGGoQYToAACACIANqIABrIQELIARBMGokACABC68DAQp/IwBBgARrIgkkAEFSIQUCQCACQf8BSw0AIABBBGohCkGAgAQgA0F/anRBEHUhC0EBIAN0IghBf2oiDCEHQQEhBQNAAkAgASAEQQF0Ig1qLwEAIgZB//8DRgRAIAogB0ECdGogBDoAAiAHQX9qIQdBASEGDAELIAVBACALIAZBEHRBEHVKGyEFCyAJIA1qIAY7AQAgAiAERyEGIARBAWohBCAGDQALIAAgBTsBAiAAIAM7AQAgCEEDdiAIQQF2akEDaiEGQQAhBEEAIQUDQCABIAVBAXRqLgEAIgBBAU4EQCAAQf//A3EiAEEBIABBAUsbIQtBACEAA0AgCiAEQQJ0aiAFOgACA0AgBCAGaiAMcSIEIAdLDQALIABBAWoiACALRw0ACwsgAiAFRyEAIAVBAWohBSAADQALQX8hBSAEDQAgCEEBIAhBAUsbIQJBACEFQQAhBANAIAkgCiAEQQJ0aiIALQACQQF0aiIBIAEvAQAiAUEBajsBACAAIAMgARAkayIHOgADIAAgASAHdCAIazsBACAEQQFqIgQgAkcNAAsLIAlBgARqJAAgBQsjAQF/IAAgACgCBCIBQQFqNgIEIAAgACgCAEEBIAF0cjYCAAtZAQF/IAAgAC0ASiIBQX9qIAFyOgBKIAAoAgAiAUEIcQRAIAAgAUEgcjYCAEF/DwsgAEIANwIEIAAgACgCLCIBNgIcIAAgATYCFCAAIAEgACgCMGo2AhBBAAuzAgECfyMAQUBqIgYkAAJAIANBA0kNACAGQShqIAAgARD/ARAhDQAgAiADakF/aiIALQAAIQECQCADQQFxBEAgBkEYaiAEIAEQYyAGQQhqIAQgAEF/ai0AABBjIAZBKGogBkEYaiAAQX5qIgMtAAAQbCAFBEAgBkEoahD+AQwCCyAGQShqEDkMAQsgBkEIaiAEIAEQYyAGQRhqIAQgAEF/aiIDLQAAEGMLIAMgAksEQANAIAZBKGogBkEIaiADQX9qLQAAEGwgBkEoaiAGQRhqIANBfmoiAy0AABBsAkAgBQRAIAZBKGoQ/gEMAQsgBkEoahA5CyADIAJLDQALCyAGQShqIAYoAgggBigCFBB0IAZBKGogBigCGCAGKAIkEHQgBkEoahD9ASEHCyAGQUBrJAAgBwskACAAQQA2AQQgAEEAOwEAIAAgATsBAiAAIAFBA3RqQgA3AggLzgQCBn8EfiADQQNsIAFBAWp2IQggAyABdiEKA0ACQCACIAVBAnRqKAIAIgZFBEAgACAFQQF0akEAOwEADAELAkACQCAGIApNBEAgACAFQQF0akH//wM7AQAMAQsgACAFQQF0aiEJIAYgCEsNASAJQQE7AQALIAMgBmshAyAHQQFqIQcMAQsgCUH+/wM7AQALIAVBAWoiBSAETQ0ACwJAAkBBASABdCIJIAdrIgZFDQAgAyAGbiAISwRAIANBA2wgBkEBdG4hBkEAIQUDQAJAIAAgBUEBdGoiCC8BAEH+/wNHDQAgAiAFQQJ0aigCACIKIAZLDQAgCEEBOwEAIAMgCmshAyAHQQFqIQcLIAVBAWoiBSAETQ0ACyAJIAdrIQYLIAcgBEEBaiIHRgRAQQAhBUEAIQFBACEDA0AgAiAFQQJ0aigCACIHIAEgByABSyIHGyEBIAUgAyAHGyEDIAVBAWoiBSAETQ0ACyAAIANBAXRqIgAgAC8BACAGajsBAAwBCyADRQRAQQAhAiAGRQ0CQQAhBQNAIAAgBUEBdGoiAS4BACIDQQFOBEAgASADQQFqOwEAIAZBf2ohBgsgBUEBaiAHcCEFIAYNAAsMAgsgBq1BPiABa60iC4ZCfyALQn98hkJ/hSIMfCADrYAhDUEAIQUDQCAAIAVBAXRqIgEvAQBB/v8DRgRAIAwgC4ghDiANIAIgBUECdGo1AgB+IAx8IgwgC4inIA6nayIDRQRAQX8PCyABIAM7AQALIAVBAWoiBSAETQ0ACwtBACECCyACC0QBAX9BfyEFIARBA3EEfyAFBSABKAIAQf4BTQRAIAAgASACIANBASAEEIMCDwsgAUH/ATYCACAAIAEgAiADIAQQgwELC1gBAX8jAEEQayIEJAACf0EBIAAgASAEQQxqEMAERQ0AGkECIAMoAgAgBCgCDEkNABpBASAAIAEgAhChBEUNABogAyAEKAIMNgIAQQALIQAgBEEQaiQAIAALiQIBA38CQAJAIAAoAhwiAygCNCIERQRAQQEhBSADIAAoAihBASADKAIkdEEBIAAoAiARAQAiBDYCNCAERQ0BCyADKAIoIgBFBEAgA0IANwIsIANBASADKAIkdCIANgIoCyAAIAJNBEAgBCABIABrIAAQKhogA0EANgIwDAILIAQgAygCMCIFaiABIAJrIAIgACAFayIAIAAgAksbIgAQKhogAiAAayICBEAgAygCNCABIAJrIAIQKhogAyACNgIwDAILQQAhBSADQQAgAygCMCAAaiIBIAEgAygCKCICRhs2AjAgAygCLCIBIAJPDQAgAyAAIAFqNgIsCyAFDwsgAyADKAIoNgIsQQALsjcBHX8jAEEQayISJABBfiEUAkAgAEUNACAAKAIcIgFFDQAgACgCDCIORQ0AIAAoAgAiBkUEQCAAKAIEDQELIAEoAgAiAkELRgRAIAFBDDYCAEEMIQILIAFB2ABqIRsgAUHwBWohFyABQfAAaiEZIAFB1ABqIRogAUHsAGohGCABQbAKaiEWIAEoAjwhBCABKAI4IQUgACgCBCIcIQcgACgCECIMIRMCQANAAkBBfCEUQQEhAwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAIOHwgJCg0QAwIBABobHBwdHh8gIQclJgY3BTknKARFLkYvCyABKAIQIQMMGAsgASgCECEDDBYLIAEoAhAhAwwUCyABKAIQIQMMEgsgASgCCCEJDCQLIAEoAkghCQwyCyABKAJIIQkMLwsgASgCaCEJDBwLIAEoAggiA0UNISAEQRBJBEADQCAHRQ08IAdBf2ohByAGLQAAIAR0IAVqIQUgBEEISSECIARBCGohBCAGQQFqIQYgAg0ACwsgA0ECcUUgBUGflgJHckUEQEEAIQUgAUEAQQBBABA1IgM2AhggEkGflgI7AAwgAyASQQxqQQIQNSEDIAFBATYCACABIAM2AhhBACEEIAEoAgAhAgw8CyABQQA2AhAgASgCICICBEAgAkF/NgIwCwJAIANBAXEEQCAFQQh0QYD+A3EgBUEIdmpBH3BFDQELIABBnu8ANgIYIAFBHTYCACABKAIAIQIMPAsgBUEPcUEIRwRAIABBte8ANgIYIAFBHTYCACABKAIAIQIMPAsgBUEEdiIDQQ9xIghBCGohAiABKAIkIglFBEAgASACNgIkDDoLIAIgCU0NOSAEQXxqIQQgAEHQ7wA2AhggAUEdNgIAIAMhBSABKAIAIQIMOwsgBEEQSQRAA0AgB0UNOyAHQX9qIQcgBi0AACAEdCAFaiEFIARBCEkhAyAEQQhqIQQgBkEBaiEGIAMNAAsLIAEgBTYCECAFQf8BcUEIRwRAIABBte8ANgIYIAFBHTYCACABKAIAIQIMOwsgBUGAwANxBEAgAEHk7wA2AhggAUEdNgIAIAEoAgAhAgw7CyABKAIgIgMEQCADIAVBCHZBAXE2AgALIAVBgARxBEAgEiAFOwAMIAEgASgCGCASQQxqQQIQNTYCGAsgAUECNgIAQQAhBEEAIQUMAQsgBEEfSw0BCyAGIQIDQCAHRQRAQQAhByACIQYgDyEDDDsLIAdBf2ohByACLQAAIAR0IAVqIQUgBEEYSSEDIARBCGohBCACQQFqIgYhAiADDQALCyABKAIgIgMEQCADIAU2AgQLIAEtABFBAnEEQCASIAU2AAwgASABKAIYIBJBDGpBBBA1NgIYCyABQQM2AgBBACEEQQAhBQwBCyAEQQ9LDQELIAYhAgNAIAdFBEBBACEHIAIhBiAPIQMMOAsgB0F/aiEHIAItAAAgBHQgBWohBSAEQQhJIQMgBEEIaiEEIAJBAWoiBiECIAMNAAsLIAEoAiAiCQRAIAkgBUEIdjYCDCAJIAVB/wFxNgIICyABKAIQIgNBgARxBEAgEiAFOwAMIAEgASgCGCASQQxqQQIQNTYCGAsgAUEENgIAQQAhBEEAIQVBACICIANBgAhxRQ0BGgwDCyABKAIQIgNBgAhxDQEgASgCICEJIAQLIQQgCQRAIAlBADYCEAsMAwsgBSECIARBD0sNAQsDQCAHRQRAQQAhByACIQUgDyEDDDMLIAdBf2ohByAGLQAAIAR0IAJqIQIgBEEISSEFIARBCGohBCAGQQFqIgghBiAFDQALIAghBiACIQULIAEgBTYCQCABKAIgIgIEQCACIAU2AhQLQQAhBCADQYAEcQRAIBIgBTsADCABIAEoAhggEkEMakECEDU2AhgLQQAhBQsgAUEFNgIACwJAIANBgAhxRQ0AIAcgASgCQCICIAIgB0sbIggEQAJAIAEoAiAiCUUNACAJKAIQIgpFDQAgCiAJKAIUIAJrIgNqIAYgCSgCGCICIANrIAggAyAIaiACSxsQKhogASgCECEDCyADQYAEcQRAIAEgASgCGCAGIAgQNTYCGAsgASABKAJAIAhrIgI2AkAgByAIayEHIAYgCGohBgsgAkUNACAPIQMMLwsgAUEGNgIAIAFBADYCQAsCQCADQYAQcQRAQQAhAyAHRQ0tA0AgA0EBaiECIAMgBmotAAAhCAJAIAEoAiAiA0UNACADKAIcIgpFDQAgASgCQCIJIAMoAiBPDQAgASAJQQFqNgJAIAkgCmogCDoAAAsgByACSwRAIAIhAyAIDQELCyABKAIQIgNBgARxBEAgASABKAIYIAYgAhA1NgIYCyACIAZqIQYgByACayEHIAhFDQEgDyEDDC8LIAEoAiAiAkUNACACQQA2AhwLIAFBBzYCACABQQA2AkALAkAgA0GAIHEEQEEAIQMgB0UNLANAIANBAWohAiADIAZqLQAAIQgCQCABKAIgIgNFDQAgAygCJCIKRQ0AIAEoAkAiCSADKAIoTw0AIAEgCUEBajYCQCAJIApqIAg6AAALIAcgAksEQCACIQMgCA0BCwsgASgCECIDQYAEcQRAIAEgASgCGCAGIAIQNTYCGAsgAiAGaiEGIAcgAmshByAIRQ0BIA8hAwwuCyABKAIgIgJFDQAgAkEANgIkCyABQQg2AgALIANBgARxBEAgBEEPTQRAA0AgB0UNLCAHQX9qIQcgBi0AACAEdCAFaiEFIARBCEkhAiAEQQhqIQQgBkEBaiEGIAINAAsLIAUgAS8BGEcNF0EAIQVBACEECyABKAIgIgIEQCACQQE2AjAgAiADQQl2QQFxNgIsCyABQQBBAEEAEDUiAzYCGCAAIAM2AjAgAUELNgIAIAEoAgAhAgwqCyAEQSBJBEADQCAHRQ0qIAdBf2ohByAGLQAAIAR0IAVqIQUgBEEYSSEDIARBCGohBCAGQQFqIQYgAw0ACwsgASAFQQh0QYCA/AdxIAVBGHRyIAVBCHZBgP4DcSAFQRh2cnIiAzYCGCAAIAM2AjAgAUEKNgIAQQAhBUEAIQQLIAEoAgxFBEAgACAMNgIQIAAgDjYCDCAAIAc2AgQgACAGNgIAIAEgBDYCPCABIAU2AjhBAiEUDCsLIAFBAEEAQQAQZSIDNgIYIAAgAzYCMCABQQs2AgALIAEoAgQNFCAEQQJLBH8gBAUgB0UNJyAHQX9qIQcgBi0AACAEdCAFaiEFIAZBAWohBiAEQQhqCyEDIAEgBUEBcTYCBEENIQQCQAJAAkACQCAFQQF2QQNxQQFrDgMAAQIDCyABQaDzADYCTCABQomAgIDQADcCVCABQaCDATYCUEETIQQMAgtBECEEDAELIABBkfAANgIYQR0hBAsgASAENgIAIANBfWohBCAFQQN2IQUgASgCACECDCcLIAUgBEEHcXYhBSAEQXhxIgRBH00EQANAIAdFDScgB0F/aiEHIAYtAAAgBHQgBWohBSAEQRhJIQMgBEEIaiEEIAZBAWohBiADDQALCyAFQf//A3EiAyAFQX9zQRB2RwRAIABBpPAANgIYIAFBHTYCACABKAIAIQIMJwsgAUEONgIAIAEgAzYCQEEAIQVBACEECyABQQ82AgALIAEoAkAiAwRAIAwgByADIAMgB0sbIgMgAyAMSxsiA0UEQCAPIQMMJwsgDiAGIAMQKiECIAEgASgCQCADazYCQCACIANqIQ4gDCADayEMIAMgBmohBiAHIANrIQcgASgCACECDCULIAFBCzYCACABKAIAIQIMJAsgBEEOSQRAA0AgB0UNJCAHQX9qIQcgBi0AACAEdCAFaiEFIARBBkkhAyAEQQhqIQQgBkEBaiEGIAMNAAsLIAEgBUEfcSIDQYECajYCYCABIAVBBXZBH3EiAkEBajYCZCABIAVBCnZBD3FBBGoiCDYCXCAEQXJqIQQgBUEOdiEFIANBHU1BACACQR5JG0UEQCAAQcHwADYCGCABQR02AgAgASgCACECDCQLIAFBETYCAEEAIQIgAUEANgJoDAELIAEoAmgiAiABKAJcIghPDQELIAIhAwNAIARBAk0EQCAHRQ0iIAdBf2ohByAGLQAAIAR0IAVqIQUgBkEBaiEGIARBCGohBAsgASADQQFqIgI2AmggASADQQF0QfDwAGovAQBBAXRqIAVBB3E7AXAgBEF9aiEEIAVBA3YhBSACIQMgAiAISQ0ACwsgAkETSQRAA0AgASACQQF0QfDwAGovAQBBAXRqQQA7AXAgAkEBaiICQRNHDQALIAFBEzYCaAsgAUEHNgJUIAEgFjYCTCABIBY2AmxBACEJQQAgGUETIBggGiAXEKwBIg8EQCAAQZbxADYCGCABQR02AgAgASgCACECDCELIAFBEjYCACABQQA2AmhBACEPCyAJIAEoAmAiHSABKAJkaiIQSQRAQX8gASgCVHRBf3MhFSABKAJMIQ0DQCAEIQogByECIAYhAwJAIAQgDSAFIBVxIhFBAnRqLQABIgtPBEAgBCEIDAELA0AgAkUNCiADLQAAIAp0IQsgA0EBaiEDIAJBf2ohAiAKQQhqIgghCiAIIA0gBSALaiIFIBVxIhFBAnRqLQABIgtJDQALCwJAIA0gEUECdGovAQIiBEEPTQRAIAEgCUEBaiIGNgJoIAEgCUEBdGogBDsBcCAIIAtrIQQgBSALdiEFIAYhCQwBCwJ/An8CQAJAAkAgBEFwag4CAAECCyAIIAtBAmoiBkkEQANAIAJFDSUgAkF/aiECIAMtAAAgCHQgBWohBSADQQFqIQMgCEEIaiIIIAZJDQALCyAIIAtrIQQgBSALdiEIIAlFBEAgAEGv8QA2AhggAUEdNgIAIAMhBiACIQcgCCEFIAEoAgAhAgwnCyAEQX5qIQQgCEECdiEFIAhBA3FBA2ohByAJQQF0IAFqLwFuDAMLIAggC0EDaiIGSQRAA0AgAkUNJCACQX9qIQIgAy0AACAIdCAFaiEFIANBAWohAyAIQQhqIgggBkkNAAsLIAggC2tBfWohBCAFIAt2IgZBA3YhBSAGQQdxQQNqDAELIAggC0EHaiIGSQRAA0AgAkUNIyACQX9qIQIgAy0AACAIdCAFaiEFIANBAWohAyAIQQhqIgggBkkNAAsLIAggC2tBeWohBCAFIAt2IgZBB3YhBSAGQf8AcUELagshB0EACyEGIAcgCWogEEsEQCAAQa/xADYCGCABQR02AgAgAyEGIAIhByABKAIAIQIMIwsDQCABIAlBAXRqIAY7AXAgCUEBaiEJIAdBf2oiBw0ACyABIAk2AmgLIAMhBiACIQcgCSAQSQ0ACwsgAS8B8ARFBEAgAEHJ8QA2AhggAUEdNgIAIAEoAgAhAgwgCyABQQk2AlQgASAWNgJMIAEgFjYCbEEBIBkgHSAYIBogFxCsASIPBEAgAEHu8QA2AhggAUEdNgIAIAEoAgAhAgwgCyABQQY2AlggASABKAJsNgJQQQIgASABKAJgQQF0akHwAGogASgCZCAYIBsgFxCsASIPBEAgAEGK8gA2AhggAUEdNgIAIAEoAgAhAgwgCyABQRM2AgBBACEPCyABQRQ2AgALIAxBggJJIAdBBklyRQRAIAAgDDYCECAAIA42AgwgACAHNgIEIAAgBjYCACABIAQ2AjwgASAFNgI4IAAgExCRBCABKAI8IQQgASgCOCEFIAAoAgQhByAAKAIAIQYgACgCECEMIAAoAgwhDiABKAIAQQtHDRYgAUF/NgLENyABKAIAIQIMHgsgAUEANgLENyAEIQkgByECIAYhAwJAIAQgASgCTCIQIAVBfyABKAJUdEF/cyINcSILQQJ0ai0AASIKTwRAIAQhCAwBCwNAIAJFDQggAy0AACAJdCEKIANBAWohAyACQX9qIQIgCUEIaiIIIQkgCCAQIAUgCmoiBSANcSILQQJ0ai0AASIKSQ0ACwsgCiEEIBAgC0ECdGoiBi8BAiERIAYtAAAiDUUgDUHwAXFyDQ0gAiEHIAMhBgJAIAQgECAFQX8gBCANanRBf3MiFXEgBHYgEWoiDUECdGotAAEiCmogCCIJTQRAIAghCwwBCwNAIAdFDQcgBi0AACAJdCEKIAZBAWohBiAHQX9qIQcgCUEIaiILIQkgBCAQIAUgCmoiBSAVcSAEdiARaiINQQJ0ai0AASIKaiALSw0ACwsgECANQQJ0aiIDLQAAIQ0gAy8BAiERIAEgBDYCxDcgCyAEayEIIAUgBHYhBQwOCyAMRQ0SIA4gASgCQDoAACABQRQ2AgAgDEF/aiEMIA5BAWohDiABKAIAIQIMHAsgASgCCCIJBEAgBEEfTQRAA0AgB0UNHSAHQX9qIQcgBi0AACAEdCAFaiEFIARBGEkhAiAEQQhqIQQgBkEBaiEGIAINAAsLIAAgEyAMayICIAAoAhRqNgIUIAEgASgCHCACajYCHAJAIAJFBEAgASgCECEIIAEoAhghAgwBCyAOIAJrIQogASgCGCETIAECfyABKAIQIggEQCATIAogAhA1DAELIBMgCiACEGULIgI2AhggACACNgIwCyAFIAVBCHRBgID8B3EgBUEYdHIgBUEIdkGA/gNxIAVBGHZyciAIGyACRw0KQQAhBSAMIRNBACEECyABQRs2AgALAkAgCUUNACABKAIQRQ0AIARBH00EQANAIAdFDRwgB0F/aiEHIAYtAAAgBHQgBWohBSAEQRhJIQIgBEEIaiEEIAZBAWohBiACDQALCyAFIAEoAhxHDQpBACEFQQAhBAsgAUEcNgIADBsLIAFBDDYCAAwRCyAGIAdqIQYgBCAHQQN0aiEEDBcLIAIgA2ohBiAIIAJBA3RqIQQMFgsgBiAHaiEGIAQgB0EDdGohBAwVC0F9IQMMFgtBfiEUDBYLIABB/e8ANgIYIAFBHTYCACABKAIAIQIMEwsgAUEaNgIAIAUgBEEHcXYhBSAEQXhxIQQgASgCACECDBILIABB8PIANgIYIAFBHTYCACAMIRMgASgCACECDBELIABBhfMANgIYIAFBHTYCACABKAIAIQIMEAtBACEEIAMhBiACIQcLIAEgEUH//wNxNgJAIAEgBCAKajYCxDcgCCAKayEEIAUgCnYhBSANRQRAIAFBGTYCACABKAIAIQIMDwsgDUEgcQRAIAFBCzYCACABQX82AsQ3IAEoAgAhAgwPCyANQcAAcQRAIABBoPIANgIYIAFBHTYCACABKAIAIQIMDwsgAUEVNgIAIAEgDUEPcSIJNgJICyAGIQggByEKAkAgCUUEQCABKAJAIQMMAQsgCCEDIAQiAiAJSQRAA0AgB0UNDCAHQX9qIQcgAy0AACACdCAFaiEFIANBAWoiBiEDIAJBCGoiAiAJSQ0ACwsgASABKALENyAJajYCxDcgASABKAJAIAVBfyAJdEF/c3FqIgM2AkAgAiAJayEEIAUgCXYhBQsgAUEWNgIAIAEgAzYCyDcLIAQhCSAHIQIgBiEDAkAgBCABKAJQIhAgBUF/IAEoAlh0QX9zIg1xIgtBAnRqLQABIgpPBEAgBCEIDAELA0AgAkUNCSADLQAAIAl0IQogA0EBaiEDIAJBf2ohAiAJQQhqIgghCSAIIBAgBSAKaiIFIA1xIgtBAnRqLQABIgpJDQALCyAQIAtBAnRqIgYvAQIhEQJAIAYtAAAiDUHwAXEEQCABKALENyEEIAMhBiACIQcgCiEJDAELIAIhByADIQYCQCAKIBAgBUF/IAogDWp0QX9zIhVxIAp2IBFqIg1BAnRqLQABIglqIAgiBE0EQCAIIQsMAQsDQCAHRQ0JIAYtAAAgBHQhCSAGQQFqIQYgB0F/aiEHIARBCGoiCyEEIAogECAFIAlqIgUgFXEgCnYgEWoiDUECdGotAAEiCWogC0sNAAsLIBAgDUECdGoiAy0AACENIAMvAQIhESABIAEoAsQ3IApqIgQ2AsQ3IAsgCmshCCAFIAp2IQULIAEgBCAJajYCxDcgCCAJayEEIAUgCXYhBSANQcAAcQRAIABBvPIANgIYIAFBHTYCACABKAIAIQIMDQsgAUEXNgIAIAEgDUEPcSIJNgJIIAEgEUH//wNxNgJECyAGIQggByEKIAkEQCAIIQMgBCICIAlJBEADQCAHRQ0HIAdBf2ohByADLQAAIAJ0IAVqIQUgA0EBaiIGIQMgAkEIaiICIAlJDQALCyABIAEoAsQ3IAlqNgLENyABIAEoAkQgBUF/IAl0QX9zcWo2AkQgBSAJdiEFIAIgCWshBAsgAUEYNgIACyAMDQELQQAhDCAPIQMMCgsCQCABKAJEIgMgEyAMayICSwRAAkAgAyACayICIAEoAixNDQAgASgCwDdFDQAgAEHS8gA2AhggAUEdNgIAIAEoAgAhAgwLCwJ/IAIgASgCMCIDSwRAIAEoAiggAiADayICawwBCyADIAJrCyEIIAEoAkAiFCACIAIgFEsbIQMgASgCNCAIaiECDAELIA4gA2shAiABKAJAIhQhAwsgASAUIAwgAyADIAxLGyIIazYCQCAIIQMDQCAOIAItAAA6AAAgDkEBaiEOIAJBAWohAiADQX9qIgMNAAsgDCAIayEMIAEoAkANACABQRQ2AgAgASgCACECDAgLIAEoAgAhAgwHCyAIIApqIQYgBCAKQQN0aiEEDAULIAIgA2ohBiAIIAJBA3RqIQQMBAsgBiAHaiEGIAQgB0EDdGohBAwDCyAIIApqIQYgBCAKQQN0aiEEDAILQQAhByADIQYgCCEEIA8hAwwDCyABQYACIAh0NgIUQQAhBCABQQBBAEEAEGUiAzYCGCAAIAM2AjAgAUEJQQsgBUGAwABxGzYCAEEAIQUgASgCACECDAELC0EAIQcgDyEDCyAAIAw2AhAgACAONgIMIAAgBzYCBCAAIAY2AgAgASAENgI8IAEgBTYCOAJAAkAgASgCKEUEQCAMIBNGDQEgASgCAEEZSw0BCyAAIA4gEyAMaxCLBA0BIAAoAhAhDCAAKAIEIQcLIAAgACgCCCAcIAdrajYCCCAAIBMgDGsiAiAAKAIUajYCFCABIAEoAhwgAmo2AhwCQCACRQ0AIAEoAghFDQAgACgCDCACayEGIAEoAhghBCABAn8gASgCEARAIAQgBiACEDUMAQsgBCAGIAIQZQsiAjYCGCAAIAI2AjALIAAgASgCPCABKAIEQQBHQQZ0aiABKAIAIgBBC0ZBB3RqQYACIABBDkZBCHQgAEETRhtqNgIsIANBeyADGyEUDAELIAFBHjYCAAsgEkEQaiQAIBQLkAEBA38gAEUEQEF+DwsgAEEANgIYIAAoAiAiAUUEQCAAQQA2AiggAEEbNgIgQRshAQsgACgCJEUEQCAAQRw2AiQLIAAoAihBAUHMNyABEQEAIgJFBEBBfA8LIAAgAjYCHEEAIQEgAkEANgI0IAAQjgQiAwR/IAAoAiggAiAAKAIkEQQAIABBADYCHCADBSABCwteAQJ/QX4hAgJAIABFDQAgACgCHCIBRQ0AAkAgASgCNCICRQ0AIAEoAiRBD0YNACAAKAIoIAIgACgCJBEEACABQQA2AjQLIAFBDzYCJCABQQE2AgggABCPBCECCyACCzEBAn9BfiEBAkAgAEUNACAAKAIcIgJFDQAgAkEANgIwIAJCADcCKCAAEJAEIQELIAELlQEBA39BfiECAkAgAEUNACAAKAIcIgFFDQBBACECIAFBADYCHCAAQQA2AgggAEIANwIUIAEoAggiAwRAIAAgA0EBcTYCMAsgAUIANwI4IAFBADYCICABQYCAAjYCFCABQQA2AgwgAUIANwIAIAFCgYCAgHA3AsA3IAEgAUGwCmoiADYCbCABIAA2AlAgASAANgJMCyACC9QLARV/IAAoAgxBf2oiBCAAKAIQIgMgAWtqIREgACgCHCIJKAIwIgogCSgCKCISaiETIAkoAjRBf2ohDEF/IAkoAlh0QX9zIRRBfyAJKAJUdEF/cyEVIAMgBGpB/31qIQ0gACgCAEF/aiIIIAAoAgRqQXtqIQ4gCSgCUCEPIAkoAkwhECAJKAI8IQUgCSgCOCEBIAkoAiwhFgNAIAVBDk0EQCAILQABIAV0IAFqIAgtAAIgBUEIanRqIQEgBUEQaiEFIAhBAmohCAsgBSAQIAEgFXFBAnRqIgMtAAEiAmshBSABIAJ2IQEgAy8BAiEHAkACQAJAIAMtAAAiAkUNACAJAn8CQAJAA0AgAkH/AXEhAyACQRBxBEAgB0H//wNxIQcCfyADQQ9xIgZFBEAgCCEDIAEMAQsCfyAFIAZPBEAgBSECIAgMAQsgBUEIaiECIAgtAAEgBXQgAWohASAIQQFqCyEDIAIgBmshBSABQX8gBnRBf3NxIAdqIQcgASAGdgshAiAFQQ5NBEAgAy0AASAFdCACaiADLQACIAVBCGp0aiECIAVBEGohBSADQQJqIQMLIAUgDyACIBRxQQJ0aiIILQABIgFrIQUgAiABdiEBIAgvAQIhBiAILQAAIgJBEHENAgNAIAJBwABxRQRAIAUgDyABQX8gAnRBf3NxIAZB//8DcWpBAnRqIgItAAEiBmshBSABIAZ2IQEgAi8BAiEGIAItAAAiAkEQcUUNAQwECwtBvPIAIQcgAyEIDAMLIANBwABxRQRAIAUgECABQX8gA3RBf3NxIAdB//8DcWpBAnRqIgMtAAEiAmshBSABIAJ2IQEgAy8BAiEHIAMtAAAiAkUNBQwBCwtBoPIAIQdBCyADQSBxDQIaDAELIAZB//8DcSELAn8gBSACQQ9xIgJPBEAgBSEGIAMMAQsgAy0AASAFdCABaiEBIANBAWogBUEIaiIGIAJPDQAaIAMtAAIgBnQgAWohASAFQRBqIQYgA0ECagshCCABQX8gAnRBf3NxIQMgBiACayEFIAEgAnYhAQJAIAMgC2oiCyAEIBFrIgNLBEACQCALIANrIgMgFk0NACAJKALAN0UNAEHS8gAhBwwDCwJAAkAgCkUEQCAMIBIgA2tqIQIgAyEGIAcgA00NAgNAIAQgAi0AAToAASAEQQFqIQQgAkEBaiECIAZBf2oiBg0ACwwBCyAKIANJBEAgDCATIANraiECIAMgCmsiAyEGIAcgA00NAgNAIAQgAi0AAToAASAEQQFqIQQgAkEBaiECIAZBf2oiBg0ACyAMIQIgByADayIHIAoiBk0EQAwDCwNAIAQgAi0AAToAASAEQQFqIQQgAkEBaiECIAZBf2oiBg0ACyAEIAtrIQIgByAKayEHDAILIAwgCiADa2ohAiADIQYgByADTQ0BA0AgBCACLQABOgABIARBAWohBCACQQFqIQIgBkF/aiIGDQALCyAEIAtrIQIgByADayEHCyAHQQNPBEADQCAEIAItAAE6AAEgBCACLQACOgACIAQgAi0AAzoAAyAEQQNqIQQgAkEDaiECIAdBfWoiB0ECSw0ACwsgB0UNBSAEIAItAAE6AAEgB0EBRw0BIARBAWohBAwFCyAEIAtrIQMDQCAEIgIgAyIGLQABOgABIAIgAy0AAjoAAiACIAMtAAM6AAMgAkEDaiEEIANBA2ohAyAHQX1qIgdBAksNAAsgB0UNBCACIAYtAAQ6AAQgB0EBRgRAIAJBBGohBAwFCyACIAYtAAU6AAUgAkEFaiEEDAQLIAQgAi0AAjoAAiAEQQJqIQQMAwsgACAHNgIYQR0LNgIADAILIAQgBzoAASAEQQFqIQQLIAQgDU8NACAIIA5JDQELCyAAIARBAWo2AgwgACANIARrQYECajYCECAAIAggBUEDdmsiA0EBajYCACAAIA4gA2tBBWo2AgQgCSAFQQdxIgA2AjwgCSABQX8gAHRBf3NxNgI4CzgBA38DQCACIABBAXFyIgNBAXQhAiABQQFKIQQgAEEBdiEAIAFBf2ohASAEDQALIANB/////wdxC6oDAQR/IwBBIGsiBCQAIAQgAi8BAEEBdCIDOwECIAQgAi8BAiADQf7/A3FqQQF0IgM7AQQgBCACLwEEIANB/v8DcWpBAXQiAzsBBiAEIAIvAQYgA0H+/wNxakEBdCIDOwEIIAQgAi8BCCADQf7/A3FqQQF0IgM7AQogBCACLwEKIANB/v8DcWpBAXQiAzsBDCAEIAIvAQwgA0H+/wNxakEBdCIDOwEOIAQgAi8BDiADQf7/A3FqQQF0IgM7ARAgBCACLwEQIANB/v8DcWpBAXQiAzsBEiAEIAIvARIgA0H+/wNxakEBdCIDOwEUIAQgAi8BFCADQf7/A3FqQQF0IgM7ARYgBCACLwEWIANB/v8DcWpBAXQiAzsBGCAEIAMgAi8BGGpBAXQiAzsBGiAEIAIvARogA2pBAXQiAzsBHCAEIAIvARwgA2pBAXQ7AR5BACECIAFBAE4EQANAIAAgAkECdGoiBi8BAiIDBEAgBCADQQF0aiIFIAUvAQAiBUEBajsBACAGIAUgAxCSBDsBAAsgASACRyEDIAJBAWohAiADDQALCyAEQSBqJAAL7gQBC38gAygCECEGIAMoAgghCCADKAIEIQwgAygCACEJIABB1BZqQgA3AQAgAEHMFmpCADcBACAAQcQWakIANwEAIABBvBZqQgA3AQAgASAAIAAoAtQoQQJ0akHcFmooAgBBAnRqQQA7AQICQCAAKALUKCIDQbsESg0AIANBAWohAwNAIAEgACADQQJ0akHcFmooAgAiBUECdCINaiIKIAEgCi8BAkECdGovAQIiBEEBaiAGIAYgBEobIgs7AQIgBiAETCEOAkAgBSACSg0AIAAgC0EBdGpBvBZqIgQgBC8BAEEBajsBAEEAIQQgBSAITgRAIAwgBSAIa0ECdGooAgAhBAsgACAAKAKoLSAKLwEAIgUgBCALamxqNgKoLSAJRQ0AIAAgACgCrC0gBCAJIA1qLwECaiAFbGo2AqwtCyAHIA5qIQcgA0EBaiIDQb0ERw0ACyAHRQ0AIAAgBkEBdGpBvBZqIQQDQCAGIQMDQCAAIAMiBUF/aiIDQQF0akG8FmoiCC8BACIJRQ0ACyAIIAlBf2o7AQAgACAFQQF0akG8FmoiAyADLwEAQQJqOwEAIAQgBC8BAEF/aiIDOwEAIAdBAkohBSAHQX5qIQcgBQ0ACyAGRQ0AQb0EIQUDQCADQf//A3EhByAFIQMDQCAHBEAgACADQX9qIgNBAnRqQdwWaigCACIEIAJKDQEgASAEQQJ0aiIFLwECIgQgBkcEQCAAIAAoAqgtIAUvAQAgBiAEa2xqNgKoLSAFIAY7AQILIAdBf2ohByADIQUMAQsLIAZBf2oiBkUNASAAIAZBAXRqQbwWai8BACEDDAALAAsLUwEBfyMAQSBrIgQkACAEIAE2AhggBCAANgIUIARBvAg2AhAgBEGACTYCCCAEIAI2AgwgBEEQaiAEQQhqEKoEIAMgBCgCDCACazYCACAEQSBqJAALkwUBBX8gAC8BuC0gAUH//QNqQf//A3EiBiAAKAK8LSIEdHIhBQJAIARBDE4EQCAAIAU7AbgtIAAgACgCFCIEQQFqNgIUIAQgACgCCGogBToAACAAIAAoAhQiBEEBajYCFCAEIAAoAghqIABBuS1qLQAAOgAAIAAoArwtIgVBdWohBCAGQRAgBWt2IQUMAQsgBEEFaiEECyAAIAQ2ArwtIAJBf2pB//8DcSIHIAR0IQYCfyAEQQxOBEAgACAFIAZyIgQ7AbgtIAAgACgCFCIFQQFqNgIUIAUgACgCCGogBDoAACAAIAAoAhQiBEEBajYCFCAEIAAoAghqIABBuS1qLQAAOgAAIAAoArwtIgVBdWohBCAHQRAgBWt2DAELIARBBWohBCAFIAZyCyEFIAAgBDYCvC0gACAFIANB/P8DakH//wNxIgYgBHRyIgU7AbgtAkAgBEENTgRAIAAgACgCFCIEQQFqNgIUIAQgACgCCGogBToAACAAIAAoAhQiBEEBajYCFCAEIAAoAghqIABBuS1qLQAAOgAAIAAoArwtIgVBdGohBCAGQRAgBWt2IQUMAQsgBEEEaiEECyAAIAQ2ArwtQQAhBiAAQbktaiEHA0AgACAFIAAgBkGA5QBqLQAAQQJ0akH+FGovAQAiCCAEdHIiBTsBuC0gAAJ/IARBDk4EQCAAIAAoAhQiBEEBajYCFCAEIAAoAghqIAU6AAAgACAAKAIUIgRBAWo2AhQgBCAAKAIIaiAHLQAAOgAAIAAgCEEQIAAoArwtIgRrdiIFOwG4LSAEQXNqDAELIARBA2oLIgQ2ArwtIAZBAWoiBiADRw0ACyAAIABBlAFqIAFBf2oQiQIgACAAQYgTaiACQX9qEIkCC68CACAAIABBlAFqIABBnBZqKAIAEIoCIAAgAEGIE2ogAEGoFmooAgAQigIgACAAQbAWahCuASAAIAAoAqgtAn9BEiAAQboVai8BAA0AGkERIABBghVqLwEADQAaQRAgAEG2FWovAQANABpBDyAAQYYVai8BAA0AGkEOIABBshVqLwEADQAaQQ0gAEGKFWovAQANABpBDCAAQa4Vai8BAA0AGkELIABBjhVqLwEADQAaQQogAEGqFWovAQANABpBCSAAQZIVai8BAA0AGkEIIABBphVqLwEADQAaQQcgAEGWFWovAQANABpBBiAAQaIVai8BAA0AGkEFIABBmhVqLwEADQAaQQQgAEGeFWovAQANABpBA0ECIABB/hRqLwEAGwsiAEEDbGpBEWo2AqgtIAALjgEBAn9B/4D/n38hAQNAAkAgAUEBcUUNACAAIAJBAnRqLwGUAUUNAEEADwsgAUEBdiEBIAJBAWoiAkEgRw0AC0EBIQECQCAALwG4AQ0AIAAvAbwBDQAgAC8ByAENAEEgIQIDQCAAIAJBAnRqLwGUAUUEQEEAIQEgAkEBaiICQYACRw0BDAILC0EBIQELIAELrAEBAX8CQCAAAn8gACgCvC0iAUEQRgRAIAAgACgCFCIBQQFqNgIUIAEgACgCCGogAC0AuC06AAAgACAAKAIUIgFBAWo2AhQgASAAKAIIaiAAQbktai0AADoAACAAQQA7AbgtQQAMAQsgAUEISA0BIAAgACgCFCIBQQFqNgIUIAEgACgCCGogAC0AuC06AAAgACAAQbktai0AADsBuC0gACgCvC1BeGoLNgK8LQsLvwEBAn8gABCMAiAAIAAoAhQiA0EBajYCFCADIAAoAghqIAI6AAAgACAAKAIUIgNBAWo2AhQgAyAAKAIIaiACQQh2OgAAIAAgACgCFCIDQQFqNgIUIAMgACgCCGogAkF/cyIDOgAAIAAgACgCFCIEQQFqNgIUIAQgACgCCGogA0EIdjoAACACBEADQCABLQAAIQMgACAAKAIUIgRBAWo2AhQgBCAAKAIIaiADOgAAIAFBAWohASACQX9qIgINAAsLC/0GAQt/IwBBEGsiCiQAAkAgACgCCCAAKAIEIgNrQQRMBEAgABCxAUUNASAAKAIEIQMLA0AgA0EBaiEIIAMtAAAiB0EDcUUEQCAHQQJ2IgZBAWohBCAAKAIIIgsgCGsiBUEVSSAHQT9LciABKAIIIgwgASgCBCICayIJQRBJckUEQCACIAMoAAE2AAAgAiADKAAFNgAEIAIgAygACTYACCACIAMoAA02AAwgASACIARqNgIEIAQgCGohAwwCCwJAIAdB8AFJBEAgCCEGDAELIAsgCCAGQUVqIgdqIgZrIQUgB0ECdEHADWooAgAgCCgAAHFBAWohBAsCQCAEIAVNDQAgDCACayAFSQ0DA0AgASACIAYgBRAqIAVqNgIEIAAoAgAiAiAAKAIMIAIoAgAoAhARBAAgACgCACICIApBDGogAigCACgCDBEDACEGIAAgCigCDCIHNgIMIAdFDQQgACAGIAdqNgIIIAEoAgggASgCBCICayEJIAQgBWsiBCAHTQ0BIAkgByIFTw0ACwwDCyAJIARJDQIgASACIAYgBBAqIARqNgIEIAAoAgggBCAGaiIDa0EESg0BIAAgAzYCBCAAELEBRQ0CIAAoAgQhAwwBCyABKAIEIgYgASgCAGsgB0EBdEHACWovAQAiBUELdiIJQQJ0QcANaigCACAIKAAAcSAFQYAOcWoiBEF/ak0NAQJAIARBCEkgBUH/AXEiB0EQS3IgASgCCCAGayICQRBJckUEQCAGIAYgBGsiAigAADYAACAGIAIoAAQ2AAQgBiACKAAINgAIIAYgAigADDYADAwBCwJAAkAgAiAHQQpqTwRAIAYgBGshBSAGIQMgByECIARBB0wNAQwCCyACIAdJDQQgBiAEayEDIAYhBSAHIQIDQCAFIAMtAAA6AAAgBUEBaiEFIANBAWohAyACQQFKIQQgAkF/aiECIAQNAAsMAgsDQCADIAUoAAA2AAAgAyAFKAAENgAEIAIgBGshAiADIARqIgMgBWsiBEEISA0ACwsgAkEATA0AA0AgAyAFKAAANgAAIAMgBSgABDYABCADQQhqIQMgBUEIaiEFIAJBCEohBCACQXhqIQIgBA0ACwsgASAGIAdqNgIEIAAoAgggCCAJaiIDa0EESg0AIAAgAzYCBCAAELEBRQ0BIAAoAgQhAwwACwALIApBEGokAAuoBgEJfwNAAkACQAJAIAAoAnQiBkGDAk8EQCAAQQA2AmAMAQsgABB2IAAoAnQiBkGDAk9BBHJFBEBBAA8LIAYEQCAAQQA2AmAgBkECSw0BIAAoAmwhBwwCCyAAQQA2ArQtIAAgACgCXCIBQQBOBH8gACgCOCABagVBAAsgACgCbCABa0EBEEQgACAAKAJsNgJcIAAoAgAQNkEDQQIgACgCACgCEBsPCyAAKAJsIgdFBEBBACEHDAELIAAoAjggB2oiCEF/aiIBLQAAIgMgCC0AAEcNACADIAEtAAJHDQAgAyABLQADRw0AIAhBggJqIQlBfyEBA0ACQCABIAhqIgItAAQgA0cEQCACQQRqIQUMAQsgAi0ABSADRwRAIAJBBWohBQwBCyACLQAGIANHBEAgAkEGaiEFDAELIAItAAcgA0cEQCACQQdqIQUMAQsgAyAIIAFBCGoiBGoiBS0AAEcNACACLQAJIANHBEAgAkEJaiEFDAELIAItAAogA0cEQCACQQpqIQUMAQsgAkELaiEFIAFB9gFKDQAgBCEBIAMgBS0AAEYNAQsLIAAgBiAFIAlrQYICaiIBIAEgBksbIgE2AmAgAUEDSQ0AIAAoAqQtIAAoAqAtIgRBAXRqQQE7AQAgACAEQQFqNgKgLSAEIAAoApgtaiABQX1qIgE6AAAgAUH/AXFBoOUAai0AAEECdEGACHIgAGoiASABLwGYAUEBajsBmAEgACgCYCEBIABBADYCYCAAIAAvAYgTQQFqOwGIEyAAIAAoAnQgAWs2AnQgACABIAAoAmxqIgY2AmwMAQsgACgCOCAHai0AACEBIAAoAqQtIAAoAqAtIgRBAXRqQQA7AQAgACAEQQFqNgKgLSAEIAAoApgtaiABOgAAIAAgAUECdGoiASABLwGUAUEBajsBlAEgACAAKAJ0QX9qNgJ0IAAgACgCbEEBaiIGNgJsCyAAKAKgLSAAKAKcLUF/akcNAEEAIQEgACAAKAJcIgRBAE4EfyAAKAI4IARqBUEACyAGIARrQQAQRCAAIAAoAmw2AlwgACgCABA2IAAoAgAoAhANAAsgAQu/AgEDfwJAA0ACQAJAIAAoAnQNACAAEHYgACgCdA0ADAELIABBADYCYCAAKAI4IAAoAmxqLQAAIQEgACgCpC0gACgCoC0iAkEBdGpBADsBACAAIAJBAWo2AqAtIAIgACgCmC1qIAE6AAAgACABQQJ0aiIBIAEvAZQBQQFqOwGUASAAIAAoAnRBf2o2AnQgACAAKAJsQQFqIgI2AmwgACgCoC0gACgCnC1Bf2pHDQEgACAAKAJcIgFBAE4EfyAAKAI4IAFqBUEACyACIAFrQQAQRCAAIAAoAmw2AlwgACgCABA2IAAoAgAoAhANAQwCCwsgAEEANgK0LSAAIAAoAlwiAUEATgR/IAAoAjggAWoFQQALIAAoAmwgAWtBARBEIAAgACgCbDYCXCAAKAIAEDZBA0ECIAAoAgAoAhAbDwsgAwuGAQEBfyACIAAoAgQiAyADIAJLGyICBEAgACADIAJrNgIEIAEgACgCACACECohAQJAAkACQCAAKAIcKAIYQX9qDgIAAQILIAAgACgCMCABIAIQZTYCMAwBCyAAIAAoAjAgASACEDU2AjALIAAgACgCACACajYCACAAIAAoAgggAmo2AggLIAIL2goBB38CQANAAkACQAJAIAAoAnRBhQJLDQAgABB2IAEgACgCdCICQYYCT3JFBEBBAA8LIAJFDQIgAkECSw0AIAAgACgCYCICNgJ4IAAgACgCcDYCZEECIQQgAEECNgJgDAELQQIhBCAAIAAoAlQgACgCbCIDIAAoAjhqLQACIAAoAkggACgCWHRzcSICNgJIIAAoAkAgAyAAKAI0cUEBdGogACgCRCACQQF0aiICLwEAIgU7AQAgAiADOwEAIAAgACgCYCICNgJ4IAAgACgCcDYCZCAAQQI2AmAgBUUNAAJAIAIgACgCgAFPDQAgAyAFayAAKAIsQfp9aksNACAAIAAgBRCPAiIENgJgIARBBUsNACAAKAKIAUEBRwRAIARBA0cNAUEDIQQgACgCbCAAKAJwa0GBIEkNAQtBAiEEIABBAjYCYAsgACgCeCECCyACQQNJIAQgAktyRQRAIAAoAnQhBSAAKAKkLSAAKAKgLSIDQQF0aiAAKAJsIgYgACgCZEF/c2oiBDsBACAAIANBAWo2AqAtIAMgACgCmC1qIAJBfWoiAjoAACACQf8BcUGg5QBqLQAAQQJ0QYAIciAAaiICQZgBaiACLwGYAUEBajsBACAAIARBf2pB//8DcSICIAJBB3ZBgAJqIAJBgAJJG0Gg6ABqLQAAQQJ0akGIE2oiAiACLwEAQQFqOwEAIAAgACgCeCICQX5qIgQ2AnggACAAKAJ0IAJrQQFqNgJ0IAUgBmpBfWohBSAAKAJsIQIgACgCnC0hBiAAKAKgLSEIA0AgACACIgNBAWoiAjYCbCACIAVNBEAgACAAKAJUIAMgACgCOGotAAMgACgCSCAAKAJYdHNxIgc2AkggACgCQCAAKAI0IAJxQQF0aiAAKAJEIAdBAXRqIgcvAQA7AQAgByACOwEACyAAIARBf2oiBDYCeCAEDQALIABBAjYCYCAAQQA2AmggACADQQJqIgU2AmwgCCAGQX9qRw0CQQAhAkEAIQQgACAAKAJcIgNBAE4EfyAAKAI4IANqBSAECyAFIANrQQAQRCAAIAAoAmw2AlwgACgCABA2IAAoAgAoAhANAgwDCyAAKAJoBEAgACgCbCAAKAI4akF/ai0AACECIAAoAqQtIAAoAqAtIgNBAXRqQQA7AQAgACADQQFqNgKgLSADIAAoApgtaiACOgAAIAAgAkECdGoiAkGUAWogAi8BlAFBAWo7AQAgACgCoC0gACgCnC1Bf2pGBEBBACECIAAgACgCXCIDQQBOBH8gACgCOCADagUgAgsgACgCbCADa0EAEEQgACAAKAJsNgJcIAAoAgAQNgsgACAAKAJsQQFqNgJsIAAgACgCdEF/ajYCdCAAKAIAKAIQDQJBAA8FIABBATYCaCAAIAAoAmxBAWo2AmwgACAAKAJ0QX9qNgJ0DAILAAsLIAAoAmgEQCAAKAJsIAAoAjhqQX9qLQAAIQIgACgCpC0gACgCoC0iA0EBdGpBADsBACAAIANBAWo2AqAtIAMgACgCmC1qIAI6AAAgACACQQJ0aiICQZQBaiACLwGUAUEBajsBACAAQQA2AmgLIAAgACgCbCIDQQIgA0ECSRs2ArQtIAFBBEYEQEEAIQQgACAAKAJcIgFBAE4EfyAAKAI4IAFqBSAECyADIAFrQQEQRCAAIAAoAmw2AlwgACgCABA2QQNBAiAAKAIAKAIQGw8LIAAoAqAtBEBBACECQQAhBCAAIAAoAlwiAUEATgR/IAAoAjggAWoFIAQLIAMgAWtBABBEIAAgACgCbDYCXCAAKAIAEDYgACgCACgCEEUNAQtBASECCyACC7wIAQ1/AkADQAJAAkACQCAAKAJ0QYUCTQRAIAAQdiABIAAoAnQiAkGGAk9yRQRAQQAPCyACRQ0DIAJBA0kNAQsgACAAKAJUIAAoAmwiBCAAKAI4ai0AAiAAKAJIIAAoAlh0c3EiAjYCSCAAKAJAIAQgACgCNHFBAXRqIAAoAkQgAkEBdGoiAi8BACIDOwEAIAIgBDsBACADRQ0AIAQgA2sgACgCLEH6fWpLDQAgACAAIAMQjwIiAzYCYAwBCyAAKAJgIQMLAkAgA0EDTwRAIAAoAqQtIAAoAqAtIgJBAXRqIAAoAmwgACgCcGsiBDsBACAAIAJBAWo2AqAtIAIgACgCmC1qIANBfWoiAjoAACACQf8BcUGg5QBqLQAAQQJ0QYAIciAAaiICQZgBaiACLwGYAUEBajsBACAAIARBf2pB//8DcSICIAJBB3ZBgAJqIAJBgAJJG0Gg6ABqLQAAQQJ0akGIE2oiAiACLwEAQQFqOwEAIAAgACgCdCAAKAJgIgNrIgI2AnQgACgCnC1Bf2ohByAAKAKgLSEIAkAgAkEDSQ0AIAMgACgCgAFLDQAgACADQX9qIgU2AmAgACgCSCEGIAAoAmwhAyAAKAI0IQkgACgCQCEKIAAoAkQhCyAAKAJUIQwgACgCOCENIAAoAlghDgNAIAAgAyICQQFqIgM2AmwgACACIA1qLQADIAYgDnRzIAxxIgY2AkggCiADIAlxQQF0aiALIAZBAXRqIgQvAQA7AQAgBCADOwEAIAAgBUF/aiIFNgJgIAUNAAsgACACQQJqIgM2AmwgByAIRw0EDAILIABBADYCYCAAIAAoAmwgA2oiAzYCbCAAIAAoAjggA2oiBC0AACICNgJIIAAgACgCVCAELQABIAIgACgCWHRzcTYCSCAHIAhHDQMMAQsgACgCOCAAKAJsai0AACEDIAAoAqQtIAAoAqAtIgJBAXRqQQA7AQAgACACQQFqNgKgLSACIAAoApgtaiADOgAAIAAgA0ECdGoiAkGUAWogAi8BlAFBAWo7AQAgACAAKAJ0QX9qNgJ0IAAgACgCbEEBaiIDNgJsIAAoAqAtIAAoApwtQX9qRw0CC0EAIQRBACEGIAAgACgCXCICQQBOBH8gACgCOCACagUgBgsgAyACa0EAEEQgACAAKAJsNgJcIAAoAgAQNiAAKAIAKAIQDQEMAgsLIAAgACgCbCICQQIgAkECSRs2ArQtIAFBBEYEQEEAIQUgACAAKAJcIgFBAE4EfyAAKAI4IAFqBSAFCyACIAFrQQEQRCAAIAAoAmw2AlwgACgCABA2QQNBAiAAKAIAKAIQGw8LIAAoAqAtBEBBACEEQQAhBSAAIAAoAlwiAUEATgR/IAAoAjggAWoFIAULIAIgAWtBABBEIAAgACgCbDYCXCAAKAIAEDYgACgCACgCEEUNAQtBASEECyAEC7YBAQF/IwBBQGoiAyQAIAMgATYCECADIAA2AgwgA0G8CDYCCCADIAI2AhwgAyACNgIYIANCADcAMSADQgA3AiwgAyADQQhqNgIoQQAhACADQQA2AiQCQCADQShqIANBJGoQrQRFDQAgAyACIAMoAiRqNgIgIANBKGogA0EYahCbBCADLQA4RQ0AIAMoAhwgAygCIEYhAAsgAygCKCIBIAMoAjQgASgCACgCEBEEACADQUBrJAAgAAvYAwEFfyAAKAIMQXtqIgJB//8DIAJB//8DSRshBQJAA0ACQCAAKAJ0IgJBAU0EQCAAEHYgACgCdCICIAFyRQRAQQAPCyACRQ0BCyAAQQA2AnQgACAAKAJsIAJqIgI2AmwgAkEAIAIgACgCXCIDIAVqIgRJGwR/IAIFIAAgBDYCbCAAIAIgBGs2AnRBACEEQQAhAiAAIANBAE4EfyAAKAI4IANqBSACCyAFQQAQRCAAIAAoAmw2AlwgACgCABA2IAAoAgAoAhBFDQMgACgCXCEDIAAoAmwLIANrIgYgACgCLEH6fWpJDQFBACEEQQAhAiAAIANBAE4EfyAAKAI4IANqBSACCyAGQQAQRCAAIAAoAmw2AlwgACgCABA2IAAoAgAoAhANAQwCCwtBACECIABBADYCtC0gAUEERgRAIAAgACgCXCIBQQBOBH8gACgCOCABagUgAgsgACgCbCABa0EBEEQgACAAKAJsNgJcIAAoAgAQNkEDQQIgACgCACgCEBsPCyAAKAJsIgMgACgCXCIBSgRAQQAhBCAAIAFBAE4EfyAAKAI4IAFqBSACCyADIAFrQQAQRCAAIAAoAmw2AlwgACgCABA2IAAoAgAoAhBFDQELQQEhBAsgBAtiACAAQQA2ArwtIABBADsBuC0gAEG4FmpBwOkBNgIAIAAgAEH8FGo2ArAWIABBrBZqQazpATYCACAAIABBiBNqNgKkFiAAQaAWakGY6QE2AgAgACAAQZQBajYCmBYgABCNAguoAQECfyAAIAAoAixBAXQ2AjwgACgCRCIBIAAoAkxBAXRBfmoiAmpBADsBACABQQAgAhAoGiAAQQA2ArQtIABCgICAgCA3AnQgAEIANwJoIABCgICAgCA3AlwgAEEANgJIIAAgACgChAFBDGwiAUG01wBqLwEANgKQASAAIAFBsNcAai8BADYCjAEgACABQbLXAGovAQA2AoABIAAgAUG21wBqLwEANgJ8C6oBAQJ/QX4hAgJAIABFDQAgACgCHCIBRQ0AIAAoAiBFDQAgACgCJEUNACAAQQI2AiwgAEEANgIIIABCADcCFCABQQA2AhQgASABKAIINgIQIAEoAhgiAkF/TARAIAFBACACayICNgIYCyABQSpB8QAgAhs2AgQgAAJ/IAJBAkYEQEEAQQBBABA1DAELQQBBAEEAEGULNgIwQQAhAiABQQA2AiggARCjBAsgAgsGACABEDgLCQAgASACbBBMC9ADAQN/QXohAgJAQaCEAS0AAEExRw0AQX4hAiAARQ0AIABBADYCGCAAKAIgIgNFBEAgAEEANgIoIABBGzYCIEEbIQMLIAAoAiRFBEAgAEEcNgIkC0EGIAEgAUF/RhsiBEEJSw0AQXwhAiAAKAIoQQFBxC0gAxEBACIBRQ0AIAAgATYCHCABQgE3AhggASAANgIAIAFB//8BNgI0IAFCgICCgPABNwIsIAFC//+BgNAANwJUIAFCgICCgPABNwJMIAEgACgCKEGAgAJBAiAAKAIgEQEANgI4IAEgACgCKCABKAIsQQIgACgCIBEBADYCQCAAKAIoIAEoAkxBAiAAKAIgEQEAIQIgAUEANgLALSABIAI2AkQgAUGAgAE2ApwtIAEgACgCKEGAgAFBBCAAKAIgEQEAIgI2AgggASABKAKcLSIDQQJ0NgIMAkACQCABKAI4RQ0AIAEoAkBFIAJFcg0AIAEoAkQNAQsgAUGaBTYCBCAAQbOEATYCGCAAEK8BGkF8DwsgAUEANgKIASABIAQ2AoQBIAFBCDoAJCABIAIgA0EDbGo2ApgtIAEgAiADQX5xajYCpC0gABClBCIBRQRAIAAoAhwQpAQLIAEhAgsgAgvhBgAgAEF/cyEAAkAgAkUgAUEDcUVyDQADQCABLQAAIABB/wFxc0ECdEGwF2ooAgAgAEEIdnMhACABQQFqIQEgAkF/aiICRQ0BIAFBA3ENAAsLIAJBH0sEQANAIAEoAhwgASgCGCABKAIUIAEoAhAgASgCDCABKAIIIAEoAgQgASgCACAAcyIAQQZ2QfwHcUGwJ2ooAgAgAEH/AXFBAnRBsC9qKAIAcyAAQQ52QfwHcUGwH2ooAgBzIABBFnZB/AdxQbAXaigCAHNzIgBBBnZB/AdxQbAnaigCACAAQf8BcUECdEGwL2ooAgBzIABBDnZB/AdxQbAfaigCAHMgAEEWdkH8B3FBsBdqKAIAc3MiAEEGdkH8B3FBsCdqKAIAIABB/wFxQQJ0QbAvaigCAHMgAEEOdkH8B3FBsB9qKAIAcyAAQRZ2QfwHcUGwF2ooAgBzcyIAQQZ2QfwHcUGwJ2ooAgAgAEH/AXFBAnRBsC9qKAIAcyAAQQ52QfwHcUGwH2ooAgBzIABBFnZB/AdxQbAXaigCAHNzIgBBBnZB/AdxQbAnaigCACAAQf8BcUECdEGwL2ooAgBzIABBDnZB/AdxQbAfaigCAHMgAEEWdkH8B3FBsBdqKAIAc3MiAEEGdkH8B3FBsCdqKAIAIABB/wFxQQJ0QbAvaigCAHMgAEEOdkH8B3FBsB9qKAIAcyAAQRZ2QfwHcUGwF2ooAgBzcyIAQQZ2QfwHcUGwJ2ooAgAgAEH/AXFBAnRBsC9qKAIAcyAAQQ52QfwHcUGwH2ooAgBzIABBFnZB/AdxQbAXaigCAHNzIgBBBnZB/AdxQbAnaigCACAAQf8BcUECdEGwL2ooAgBzIABBDnZB/AdxQbAfaigCAHMgAEEWdkH8B3FBsBdqKAIAcyEAIAFBIGohASACQWBqIgJBH0sNAAsLIAJBA0sEQANAIAEoAgAgAHMiAEEGdkH8B3FBsCdqKAIAIABB/wFxQQJ0QbAvaigCAHMgAEEOdkH8B3FBsB9qKAIAcyAAQRZ2QfwHcUGwF2ooAgBzIQAgAUEEaiEBIAJBfGoiAkEDSw0ACwsgAgRAA0AgAS0AACAAQf8BcXNBAnRBsBdqKAIAIABBCHZzIQAgAUEBaiEBIAJBf2oiAg0ACwsgAEF/cwvTBQELfyMAQaAQayICJAAgASACQZsQagJ/IAAgACgCACgCCBEAACIDQf8ATQRAIAIgAzoAmxAgAkGcEGoMAQsgA0H//wBNBEAgAiADQQd2OgCcECACIANBgAFyOgCbECACQZ0QagwBCyADQf///wBNBEAgAiADQQ52OgCdECACIANBgAFyOgCbECACIANBB3ZBgAFyOgCcECACQZ4QagwBCyACIANBgAFyOgCbECACIANBDnZBgAFyOgCdECACIANBB3ZBgAFyOgCcECADQRV2IQQgA0H/////AE0EQCACIAQ6AJ4QIAJBnxBqDAELIAIgA0EcdjoAnxAgAiAEQYABcjoAnhAgAkGgEGoLIAJBmxBqayILIAEoAgAoAggRBgAgAkEANgKQEAJAIANFDQADQCAAIAJBDGogACgCACgCDBEDACEIAn8gAigCDCIEIANBgIAEIANBgIAESRsiBk8EQCAGDAELAn8gCUUEQCAGEG0hCQsgCQsgCCAEECohCCAAIAQgACgCACgCEBEEAANAIAQgCGogACACQQxqIAAoAgAoAgwRAwAgBiAEayIFIAIoAgwiByAFIAdJGyIFECoaIAAgBSAAKAIAKAIQEQQAIAYgBCAFaiIESw0AC0EACyEMIAIgBjYCDEGAAiEFA0ACQCAFIgRBAXQhBSAEQf//AEsNACAEIAZJDQELCyACQRBqIQcCQCAEQYEISQ0AIAIoApAQIgcNACACQYCAAhBtIgc2ApAQCyAHQQAgBRAoIQcgASABIAYgBkEGbmpBIGoiBQJ/IApFBEAgBRBtIQoLIAoLIAEoAgAoAgwRAQAiBSAIIAIoAgwgBSAHIAQQtQQgBWsiBCABKAIAKAIIEQYAIAAgDCAAKAIAKAIQEQQAIAQgC2ohCyADIAZrIgMNAAsgCQRAIAkQOAsgChA4IAIoApAQIgBFDQAgABA4CyACQaAQaiQAC8wWAQh/QX4hAgJAAkACQCAARQ0AIAAoAhwiAUUNAAJAAkAgACgCDEUNACAAKAIARQRAIAAoAgQNAQsgASgCBCICQZoFR0EBcg0BCyAAQaaEATYCGEF+DwsgACgCEEUNASABIAA2AgAgASgCKBogAUEENgIoAkACQAJAAkACQAJAAkACQAJAAkACQCACQSpGBEAgASgCGEECRgRAIABBAEEAQQAQNTYCMCABIAEoAhQiAkEBajYCFCACIAEoAghqQR86AAAgASABKAIUIgJBAWo2AhQgAiABKAIIakGLAToAACABIAEoAhQiAkEBajYCFCACIAEoAghqQQg6AAAgASgCHCICRQRAIAEgASgCFCICQQFqNgIUIAIgASgCCGpBADoAACABIAEoAhQiAkEBajYCFCACIAEoAghqQQA6AAAgASABKAIUIgJBAWo2AhQgAiABKAIIakEAOgAAIAEgASgCFCICQQFqNgIUIAIgASgCCGpBADoAACABIAEoAhQiAkEBajYCFCACIAEoAghqQQA6AABBAiECIAEoAoQBIgNBCUcEQEEEIAEoAogBQQFKQQJ0IANBAkgbIQILIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAjoAACABIAEoAhQiAkEBajYCFCACIAEoAghqQQM6AAAgAUHxADYCBAwNCyACKAIkIQMgAigCHCEEIAIoAhAhBSACKAIsIQYgAigCACEHIAEgASgCFCIIQQFqNgIUQQIhAiAIIAEoAghqIAZBAEdBAXQgB0EAR3IgBUEAR0ECdHIgBEEAR0EDdHIgA0EAR0EEdHI6AAAgASgCHCgCBCEDIAEgASgCFCIEQQFqNgIUIAQgASgCCGogAzoAACABKAIcKAIEIQMgASABKAIUIgRBAWo2AhQgBCABKAIIaiADQQh2OgAAIAEoAhwvAQYhAyABIAEoAhQiBEEBajYCFCAEIAEoAghqIAM6AAAgASgCHC0AByEDIAEgASgCFCIEQQFqNgIUIAQgASgCCGogAzoAACABKAKEASIDQQlHBEBBBCABKAKIAUEBSkECdCADQQJIGyECCyABIAEoAhQiA0EBajYCFCADIAEoAghqIAI6AAAgASgCHCgCDCECIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAjoAAAJ/IAEoAhwiBCgCEARAIAQoAhQhAiABIAEoAhQiA0EBajYCFCADIAEoAghqIAI6AAAgASgCHCgCFCECIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAkEIdjoAACABKAIcIQQLIAQoAiwLBEAgACAAKAIwIAEoAgggASgCFBA1NgIwCyABQcUANgIEIAFBADYCIAwCCyABKAIwQQx0QYCQfmohBEEAIQICQCABKAKIAUEBSg0AIAEoAoQBIgNBAkgNAEHAACECIANBBkgNAEGAAUHAASADQQZGGyECCyABQfEANgIEIAEgAiAEciICQSByIAIgASgCbBsiAkEfcCACckEfcxB1IAEoAmwEQCABIAAvATIQdSABIAAvATAQdQsgAEEAQQBBABBlNgIwIAEoAgQhAgsgAkHFAEcNASABKAIcIQQLAkAgBCgCEARAIAEoAhQhAiABKAIgIgUgBC8BFE8NASACIQMDQCABKAIMIAJGBEACQCACIANNDQAgBCgCLEUNACAAIAAoAjAgASgCCCADaiACIANrEDU2AjALIAAQNiABKAIcIQQgASgCFCICIAEoAgxGDQMgASgCICEFIAIhAwsgBCgCECAFai0AACEEIAEgAkEBajYCFCABKAIIIAJqIAQ6AAAgASABKAIgQQFqIgU2AiAgBSABKAIcIgQvARRPBEAgAyECDAMFIAEoAhQhAgwBCwALAAsgAUHJADYCBAwCCwJAIAQoAixFDQAgASgCFCIDIAJNDQAgACAAKAIwIAEoAgggAmogAyACaxA1NgIwCyABKAIgIAQoAhRGBEAgAUHJADYCBCABQQA2AiAMAgsgASgCBCECCyACQckARw0BIAEoAhwhBAsgBCgCHEUNAiABKAIUIgIhAwJAA0ACQCABKAIMIAJGBEACQCACIANNDQAgASgCHCgCLEUNACAAIAAoAjAgASgCCCADaiACIANrEDU2AjALIAAQNiABKAIUIgIgASgCDEYNASACIQMLQQEhBSABKAIcKAIcIQQgASABKAIgIgZBAWo2AiAgBCAGai0AACEEIAEgAkEBajYCFCABKAIIIAJqIAQ6AAAgBARAIAEoAhQhAgwCBSADIQIMAwsACwtBACEFCwJAIAEoAhwiBCgCLEUNACABKAIUIgMgAk0NACAAIAAoAjAgASgCCCACaiADIAJrEDU2AjALIAUNASABKAIEIQILIAJB2wBHDQMgASgCHCEEDAILIAFBADYCIAsgAUHbADYCBAsgBCgCJEUNASABKAIUIgIhAwJAA0ACQCABKAIMIAJGBEACQCACIANNDQAgASgCHCgCLEUNACAAIAAoAjAgASgCCCADaiACIANrEDU2AjALIAAQNiABKAIUIgIgASgCDEYNASACIQMLQQEhBSABKAIcKAIkIQQgASABKAIgIgZBAWo2AiAgBCAGai0AACEEIAEgAkEBajYCFCABKAIIIAJqIAQ6AAAgBARAIAEoAhQhAgwCBSADIQIMAwsACwtBACEFCwJAIAEoAhwiBCgCLEUNACABKAIUIgMgAk0NACAAIAAoAjAgASgCCCACaiADIAJrEDU2AjALIAUNASABKAIEIQILIAJB5wBHDQIgASgCHCEEDAELIAFB5wA2AgQLIAQoAiwEQCABKAIUIgVBAmoiAiABKAIMIgRLBH8gABA2IAEoAgwhBCABKAIUIgVBAmoFIAILIARLDQEgACgCMCECIAEgBUEBajYCFCABKAIIIAVqIAI6AAAgACgCMCECIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAkEIdjoAACAAQQBBAEEAEDU2AjAgAUHxADYCBAwBCyABQfEANgIECwJAIAEoAhQEQCAAEDYgACgCEARAIAAoAgQhAgwCCwwECyAAKAIEIgINAEEAIQILAkACQAJAIAEoAgQiA0GaBUYEQCACRQ0BDAULIAINAQsgA0GaBUcNACABKAJ0RQ0BCwJ/AkACQAJAIAEoAogBQX5qDgIAAQILIAEQnQQMAgsgARCcBAwBCyABQQQgASgChAFBDGxBuNcAaigCABEDAAsiAkF+cUECRgRAIAFBmgU2AgQLIAJBfXFFBEBBACECIAAoAhANAgwECyACQQFHDQAgAUEAQQBBABCOAiAAEDYgACgCEA0ADAMLQQEhAiABKAIYIgNBAUgNACAAKAIwIQICQCADQQJGBEAgASABKAIUIgNBAWo2AhQgAyABKAIIaiACOgAAIAAoAjAhAiABIAEoAhQiA0EBajYCFCADIAEoAghqIAJBCHY6AAAgAC8BMiECIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAjoAACAALQAzIQIgASABKAIUIgNBAWo2AhQgAyABKAIIaiACOgAAIAAoAgghAiABIAEoAhQiA0EBajYCFCADIAEoAghqIAI6AAAgACgCCCECIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAkEIdjoAACAALwEKIQIgASABKAIUIgNBAWo2AhQgAyABKAIIaiACOgAAIAAtAAshAiABIAEoAhQiA0EBajYCFCADIAEoAghqIAI6AAAMAQsgASACQRB2EHUgASAALwEwEHULIAAQNiABKAIYIgBBAU4EQCABQQAgAGs2AhgLIAEoAhRFIQILIAIPCyAAQceEATYCGEF7DwsgAUF/NgIoQQAL3QEBBn8CQCAAKAKAgBAiBSAAKAKEgBAiAyAAKAKMgBAiBGpBBGpJDQAgACgClIAQIgIgBSADa0F9aiIGTw0AA0AgACACQf//A3FBAXRqQYCACGogAiAAIAIgA2oQOkECdGoiBCgCAGsiB0H//wMgB0H//wNJGzsBACAEIAI2AgAgAkEBaiICIAZJDQALIAAoAoyAECEECyAAIAQ2ApCAECAAIAM2AoiAECAAQQA2ApyAECAAIAE2AoCAECAAIAUgA2siAjYCjIAQIAAgAjYClIAQIAAgASACazYChIAQC9kDAQR/IwBBEGsiAyQAIAFBADYCACAAKAIAIgIgA0EMaiACKAIAKAIMEQMAIQICQCADKAIMRQ0AIAIsAAAhAiAAKAIAIgRBASAEKAIAKAIQEQQAIAEgASgCACACQf8AcXI2AgACQCACQX9KDQAgACgCACICIANBDGogAigCACgCDBEDACECIAMoAgxFDQEgAiwAACECIAAoAgAiBEEBIAQoAgAoAhARBAAgASABKAIAIAJB/wBxQQd0cjYCACACQX9KDQAgACgCACICIANBDGogAigCACgCDBEDACECIAMoAgxFDQEgAiwAACECIAAoAgAiBEEBIAQoAgAoAhARBAAgASABKAIAIAJB/wBxQQ50cjYCACACQX9KDQAgACgCACICIANBDGogAigCACgCDBEDACECIAMoAgxFDQEgAiwAACECIAAoAgAiBEEBIAQoAgAoAhARBAAgASABKAIAIAJB/wBxQRV0cjYCACACQX9KDQAgACgCACICIANBDGogAigCACgCDBEDACECIAMoAgxFDQEgAiwAACEFIAAoAgAiAEEBIAAoAgAoAhARBAAgASABKAIAIAVBHHRyNgIAIAVBf0oNAEEAIQUMAQtBASEFCyADQRBqJAAgBQvhSQE3fwJAIAAoAoCAECIJIAAoAoSAECILayAAKAKQgBBrIghBgIAETwRAIABBADYCnIAQDAELAkAgCA0AIAMoAgBBgSBIDQAgACAAKAKcgBBBoIAQECoiACABEKwEIAAgBTsBmIAQDAELAkAgBEEATEEAIAZBAkYbDQAgAygCACIIQYCAgPAHSw0AIAAgCCAJajYCgIAQQQkgBSAFQQFIGyIFQQwgBUEMSBsiG0EMbCIJQZQWaigCACEuAkACfyAbQQlNBEAgA0EANgIAIAIgBGoiOkF7aiA6IAZBAkYiOxshKSABIAhqITMgASEoIAIhCQJAIAhBDUgNACAzQXRqIjIgAUkNAEGANCAbdkEBcSE0IDNBe2oiGEF/aiEvIBhBfWohIkEAIRsDQCAAKAKUgBAhBCAAKAKIgBAhEyAAKAKcgBAhFCAoIQwDQCAAKAKQgBAiBSAMIAtrIh9BgYB8aiAFQYCABGogH0sbIRUgACgC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BEADQCADKAAAIAQoAABzIgkEQCAJECUgBGogAGsMBAsgA0EEaiEDIARBBGoiBCAUSQ0ACwsCQCAEIBhPDQAgAy8AACAELwAARw0AIANBAmohAyAEQQJqIQQLIAQgF0kEfyAEQQFqIAQgAy0AACAELQAARhsFIAQLIABrDAELIAMQJQsiAEHwAWpB/wFuakEIaiAPSw0EIAdBAmohAyAAIAZqQQRqIQYgBS0AACEEAn8gAEEPTwRAIAUgBEEPajoAACADQX8QNCAAQXFqIgRB/AdPBEADQCADQQRqIgNBfxA0IARBhHhqIgRB+wdLDQALCyADIARB//8DcUH/AW4iAGoiAyAAQYF+bCAEajoAACADQQFqDAELIAUgACAEajoAACADCyEFIAYgEU8NASAGQX5qIgAgACgAACALEDAgCCALIAwQSSAGKAAAIQACQAJAIBZFBEAgAEEBEDAiACAIEIUBIQQgBiAAIAhBASAMEEkgBEH//wNqIAZJDQEgBCgAACAGKAAARw0BDAILIAAgCxAwIgMgCCALEEghACAGIAxrIgQgAyAIIAsQXCAAQf//A2ogBEkNACAAIAxqIgQoAAAgBigAAEYNAQsgBkEBaiIDKAAAIAsQMCEEDAMLIAVBADoAACAFQQFqIQcMAAsACwtBACETIAUgECAGayIBaiABQfABakH/AW5qQQFqIA9LDQECQCABQQ9PBEAgBUHwAToAACAFQQFqIQAgAUFxaiIDQf8BSQRAIAAiBSADOgAADAILIABB/wEgAUHyfWoiAEH/AW5BAWoQKBogAEH/AW4iAyAFakECaiIFIANBgX5sIABqOgAADAELIAUgAUEEdDoAAAsgBUEBaiAGIAEQKiABaiACayETDAELIANBgICA8AdLDQAgASADaiIPQXVqIRAgD0F0aiEUIAgoAoCAASEAIAhBAUECIAFB//8DSxsiCzsBhoABIAggACADajYCgIABIAggCCgCkIABIANqNgKQgAEgASABKAAAIAsQMCAIIAsgASAAayIMEEkgD0F7aiITQX9qIRcgE0F9aiERIAZBBnQiCkEBciENIAFBAWoiAygAACALEDAhBCABQYCABEkhFSACIQUgASEGA0ACQCAVRQRAIAMgFEsNBCADQQFqIQ4gCiEJIA0hBwNAIAQgCBCFASEAIA4oAABBARAwIRIgAyAE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IAJBCE8EQANAIAMEQCADIAVsIQcgBUEHciIIIANsIQkgBUEGciIKIANsIQsgBUEFciIMIANsIQ0gBUEEciIOIANsIQ8gBUEDciIQIANsIREgBUECciISIANsIRMgBUEBciIUIANsIRVBACEEA0AgASAFIAIgBGwiBmpqIAAgBCAHamotAAA6AAAgASAGIBRqaiAAIAQgFWpqLQAAOgAAIAEgBiASamogACAEIBNqai0AADoAACABIAYgEGpqIAAgBCARamotAAA6AAAgASAGIA5qaiAAIAQgD2pqLQAAOgAAIAEgBiAMamogACAEIA1qai0AADoAACABIAYgCmpqIAAgBCALamotAAA6AAAgASAGIAhqaiAAIAQgCWpqLQAAOgAAIARBAWoiBCADRw0ACwsgBUEPaiEEIAVBCGohBSAEIAJJDQALCyACQXhxIgUgAk8NAANAIAMEQCADIAVsIQZBACEEA0AgASACIARsIAVqaiAAIAQgBmpqLQAAOgAAIARBAWoiBCADRw0ACwsgBUEBaiIFIAJHDQALCyACIANsrQuCAQEGfyABIAEgAG4iBiAAbGshByAAIAFNBEAgBkEBIAZBAUsbIQgDQCAABEAgACAEbCEJQQAhBQNAIAMgBSAJamogAiAFIAZsIARqai0AADoAACAFQQFqIgUgAEcNAAsLIARBAWoiBCAIRw0ACwsgAyABIAdrIgBqIAAgAmogBxAqGgsNACAAIAEgAiADEL0EC4IBAQZ/IAEgASAAbiIGIABsayEHIAAEQCAGQQEgBkEBSxshCANAIAAgAU0EQCAEIAZsIQlBACEFA0AgAyAFIAlqaiACIAAgBWwgBGpqLQAAOgAAIAVBAWoiBSAIRw0ACwsgBEEBaiIEIABHDQALCyADIAEgB2siAGogACACaiAHECoaC7gBAQN/AkAgAUEBSA0AIAAsAAAiBEH/AHEhAwJAIARBf0oNACABQQJIDQEgACwAASIEQQd0QYD/AHEgA3IhAyAEQX9KDQAgAUEDSA0BIAAsAAIiBEEOdEGAgP8AcSADciEDIARBf0oNACABQQRIDQEgACwAAyIEQRV0QYCAgP8AcSADciEDIARBf0oNACABQQVIDQEgAC0ABCIAQQ9LDQEgAEEcdCADciEDCyACIAM2AgBBASEFCyAFCw0AIAAgASACIAMQvwQLlAIB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CA0tEC0gLgAJDS4QLiAvAAoNLxAvIDAACw0wEDAgMQAEDjEQMSAyAAUOMhAyIDMABg4zEDMgNAAHDjQQNCA1AAgONRA1IDYACQ42EDYgNwAKDjcQNyA4AAsOOBA4IDkABA85EDkgOgAFDzoQOiA7AAYPOxA7IDwABw88EDwgAQgIDz0QPSABEAkPPhA+IAEYCg8/ED8gASALD0AQQCAAAAAA/wAAAP//AAD///8A/////2RlY29tcHJlc3MAY29tcHJlc3MAZnJlZV9yZXN1bHQAdmkAAHhzAABpaWlpaWlpAEGQDgvUBigHAAAwBwAAMAcAAMxzAADMcwAAzHMAABh0AAC2BwAAQHQAAEgHAAAAAAAAAQAAAIgHAAAAAAAATlN0M19fMjEyYmFzaWNfc3RyaW5nSWNOU18xMWNoYXJfdHJhaXRzSWNFRU5TXzlhbGxvY2F0b3JJY0VFRUUAABh0AACQBwAATlN0M19fMjIxX19iYXNpY19zdHJpbmdfY29tbW9uSUxiMUVFRQBOMTBlbXNjcmlwdGVuM3ZhbEUAAAAAGHQAANQHAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0loRUUAaWlpAAAoBwAAMAcAABgIAAAgCAAAJAgAACoIAAAxCAAANggAAGJsb3NjbHoAbHo0AGx6NGhjAHNuYXBweQB6bGliAHpzdGQARXJyb3IuICBudGhyZWFkcyBjYW5ub3QgYmUgbGFyZ2VyIHRoYW4gQkxPU0NfTUFYX1RIUkVBRFMgKCVkKQBFcnJvci4gIG50aHJlYWRzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyAEVSUk9SOyByZXR1cm4gY29kZSBmcm9tIHB0aHJlYWRfY3JlYXRlKCkgaXMgJWQKAAlFcnJvciBkZXRhaWw6ICVzCgBCbG9zYyBoYXMgbm90IGJlZW4gY29tcGlsZWQgd2l0aCAnJXMnIABjb21wcmVzc2lvbiBzdXBwb3J0LiAgUGxlYXNlIHVzZSBvbmUgaGF2aW5nIGl0LgBFcnJvciBhbGxvY2F0aW5nIG1lbW9yeSEARVJST1I7IHJldHVybiBjb2RlIGZyb20gcHRocmVhZF9qb2luKCkgaXMgJWQKAElucHV0IGJ1ZmZlciBzaXplIGNhbm5vdCBleGNlZWQgJWQgYnl0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AAAIAAAACQAAAAkAAAAKAAAACgAAAAsAAAALAAAADAAAAAwAAAANAAAADQBBgNsAC/8IDAAIAIwACABMAAgAzAAIACwACACsAAgAbAAIAOwACAAcAAgAnAAIAFwACADcAAgAPAAIALwACAB8AAgA/AAIAAIACACCAAgAQgAIAMIACAAiAAgAogAIAGIACADiAAgAEgAIAJIACABSAAgA0gAIADIACACyAAgAcgAIAPIACAAKAAgAigAIAEoACADKAAgAKgAIAKoACABqAAgA6gAIABoACACaAAgAWgAIANoACAA6AAgAugAIAHoACAD6AAgABgAIAIYACABGAAgAxgAIACYACACmAAgAZgAIAOYACAAWAAgAlgAIAFYACADWAAgANgAIALYACAB2AAgA9gAIAA4ACACOAAgATgAIAM4ACAAuAAgArgAIAG4ACADuAAgAHgAIAJ4ACABeAAgA3gAIAD4ACAC+AAgAfgAIAP4ACAABAAgAgQAIAEEACADBAAgAIQAIAKEACABhAAgA4QAIABEACACRAAgAUQAIANEACAAxAAgAsQAIAHEACADxAAgACQAIAIkACABJAAgAyQAIACkACACpAAgAaQAIAOkACAAZAAgAmQAIAFkACADZAAgAOQAIALkACAB5AAgA+QAIAAUACACFAAgARQAIAMUACAAlAAgApQAIAGUACADlAAgAFQAIAJUACABVAAgA1QAIADUACAC1AAgAdQAIAPUACAANAAgAjQAIAE0ACADNAAgALQAIAK0ACABtAAgA7QAIAB0ACACdAAgAXQAIAN0ACAA9AAgAvQAIAH0ACAD9AAgAEwAJABMBCQCTAAkAkwEJAFMACQBTAQkA0wAJANMBCQAzAAkAMwEJALMACQCzAQkAcwAJAHMBCQDzAAkA8wEJAAsACQALAQkAiwAJAIsBCQBLAAkASwEJAMsACQDLAQkAKwAJACsBCQCrAAkAqwEJAGsACQBrAQkA6wAJAOsBCQAbAAkAGwEJAJsACQCbAQkAWwAJAFsBCQDbAAkA2wEJADsACQA7AQkAuwAJALsBCQB7AAkAewEJAPsACQD7AQkABwAJAAcBCQCHAAkAhwEJAEcACQBHAQkAxwAJAMcBCQAnAAkAJwEJAKcACQCnAQkAZwAJAGcBCQDnAAkA5wEJABcACQAXAQkAlwAJAJcBCQBX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AAAJ/ABgBwAAAAhRAAAIEQAVCIMAEgcfAAAIcQAACDEAAAnCABAHCgAACGEAAAghAAAJogAACAEAAAiBAAAIQQAACeIAEAcGAAAIWQAACBkAAAmSABMHOwAACHkAAAg5AAAJ0gARBxEAAAhpAAAIKQAACbIAAAgJAAAIiQAACEkAAAnyABAHBAAACFUAAAgVABAIAgETBysAAAh1AAAINQAACcoAEQcNAAAIZQAACCUAAAmqAAAIBQAACIUAAAhFAAAJ6gAQBwgAAAhdAAAIHQAACZoAFAdTAAAIfQAACD0AAAnaABIHFwAACG0AAAgtAAAJugAACA0AAAiNAAAITQAACfoAEAcDAAAIUwAACBMAFQjDABMHIwAACHMAAAgzAAAJxgARBwsAAAhjAAAIIwAACaYAAAgDAAAIgwAACEMAAAnmABAHBwAACFsAAAgbAAAJlgAUB0MAAAh7AAAIOwAACdYAEgcTAAAIawAACCsAAAm2AAAICwAACIsAAAhLAAAJ9gAQBwUAAAhXAAAIFwBACAAAEwczAAAIdwAACDcAAAnOABEHDwAACGcAAAgnAAAJrgAACAcAAAiHAAAIRwAACe4AEAcJAAAIXwAACB8AAAmeABQHYwAACH8AAAg/AAAJ3gASBxsAAAhvAAAILwAACb4AAAgPAAAIjwAACE8AAAn+AGAHAAAACFAAAAgQABQIcwASBx8AAAhwAAAIMAAACcEAEAcKAAAIYAAACCAAAAmhAAAIAAAACIAAAAhAAAAJ4QAQBwYAAAhYAAAIGAAACZEAEwc7AAAIeAAACDgAAAnRABEHEQAACGgAAAgoAAAJsQAACAgAAAiIAAAISAAACfEAEAcEAAAIVAAACBQAFQjjABMHKwAACHQAAAg0AAAJyQARBw0AAAhkAAAIJAAACakAAAgEAAAIhAAACEQAAAnpABAHCAAACFwAAAgcAAAJmQAUB1MAAAh8AAAIPAAACdkAEgcXAAAIbAAACCwAAAm5AAAIDAAACIwAAAhMAAAJ+QAQBwMAAAhSAAAIEgAVCKMAEwcjAAAIcgAACDIAAAnFABEHCwAACGIAAAgiAAAJpQAACAIAAAiCAAAIQgAACeUAEAcHAAAIWgAACBoAAAmVABQHQwAACHoAAAg6AAAJ1QASBxMAAAhqAAAIKgAACbUAAAgKAAAIigAACEoAAAn1ABAHBQAACFYAAAgWAEAIAAATBzMAAAh2AAAINgAACc0AEQcPAAAIZgAACCYAAAmtAAAIBgAACIYAAAhGAAAJ7QAQBwkAAAheAAAIHgAACZ0AFAdjAAAIfgAACD4AAAndABIHGwAACG4AAAguAAAJvQAACA4AAAiOAAAITgAACf0AYAcAAAAIUQAACBEAFQiDABIHHwAACHEAAAgxAAAJwwAQBwoAAAhhAAAIIQAACaMAAAgBAAAIgQAACEEAAAnjABAHBgAACFkAAAgZAAAJkwATBzsAAAh5AAAIOQAACdMAEQcRAAAIaQAACCkAAAmzAAAICQAACIkAAAhJAAAJ8wAQBwQAAAhVAAAIFQAQCAIBEwcrAAAIdQAACDUAAAnLABEHDQAACGUAAAglAAAJqwAACAUAAAiFAAAIRQAACesAEAcIAAAIXQAACB0AAAmbABQHUwAACH0AAAg9AAAJ2wASBxcAAAhtAAAILQAACbsAAAgNAAAIjQAACE0AAAn7ABAHAwAACFMAAAgTABUIwwATByMAAAhzAAAIMwAACccAEQcLAAAIYwAACCMAAAmnAAAIAwAACIMAAAhDAAAJ5wAQBwcAAAhbAAAIGwAACZcAFAdDAAAIewAACDsAAAnXABIHEwAACGsAAAgrAAAJtwAACAsAAAiLAAAISwAACfcAEAcFAAAIVwAACBcAQAgAABMHMwAACHcAAAg3AAAJzwARBw8AAAhnAAAIJwAACa8AAAgHAAAIhwAACEcAAAnvABAHCQAACF8AAAgfAAAJnwAUB2MAAAh/AAAIPwAACd8AEgcbAAAIbwAACC8AAAm/AAAIDwAACI8AAAhPAAAJ/wAQBQEAFwUBARMFEQAbBQEQEQUFABkFAQQVBUEAHQUBQBAFAwAYBQECFAUhABwFASASBQkAGgUBCBYFgQBABQAAEAUCABcFgQETBRkAGwUBGBEFBwAZBQEGFQVhAB0FAWAQBQQAGAUBAxQFMQAcBQEwEgUNABoFAQwWBcEAQAUAADEuMi44AHN0cmVhbSBlcnJvcgBpbnN1ZmZpY2llbnQgbWVtb3J5AGJ1ZmZlciBlcnJvcgBB5IQBC6EVazgHAA2yBwCc8gcAcGQIAGCuCgCwcQsAMKoMABMAAAAMAAAADQAAAAEAAAAGAAAAAQAAAAEAAAATAAAADQAAAA4AAAABAAAABwAAAAAAAAABAAAAFAAAAA8AAAAQAAAAAQAAAAYAAAAAAAAAAQAAABUAAAAQAAAAEQAAAAEAAAAFAAAAAAAAAAIAAAAVAAAAEgAAABIAAAABAAAABQAAAAAAAAACAAAAFQAAABIAAAATAAAAAgAAAAUAAAACAAAAAwAAABUAAAATAAAAEwAAAAMAAAAFAAAABAAAAAMAAAAVAAAAEwAAABMAAAADAAAABQAAAAgAAAAEAAAAFQAAABMAAAATAAAAAwAAAAUAAAAQAAAABQAAABUAAAATAAAAFAAAAAQAAAAFAAAAEAAAAAUAAAAWAAAAFAAAABUAAAAEAAAABQAAABAAAAAFAAAAFgAAABUAAAAWAAAABAAAAAUAAAAQAAAABQAAABYAAAAVAAAAFgAAAAUAAAAFAAAAEAAAAAUAAAAWAAAAFQAAABYAAAAFAAAABQAAACAAAAAGAAAAFgAAABYAAAAXAAAABQAAAAUAAAAgAAAABgAAABYAAAAXAAAAFwAAAAYAAAAFAAAAIAAAAAYAAAAWAAAAFgAAABYAAAAFAAAABQAAADAAAAAHAAAAFwAAABcAAAAWAAAABQAAAAQAAABAAAAABwAAABcAAAAXAAAAFgAAAAYAAAADAAAAQAAAAAgAAAAXAAAAGAAAABYAAAAHAAAAAwAAAAABAAAJAAAAGQAAABkAAAAXAAAABwAAAAMAAAAAAQAACQAAABoAAAAaAAAAGAAAAAcAAAADAAAAAAIAAAkAAAAbAAAAGwAAABkAAAAJAAAAAwAAAOcDAAAJAAAAEgAAAAwAAAANAAAAAQAAAAUAAAABAAAAAQAAABIAAAANAAAADgAAAAEAAAAGAAAAAAAAAAEAAAASAAAADgAAAA4AAAABAAAABQAAAAAAAAACAAAAEgAAABAAAAAQAAAAAQAAAAQAAAAAAAAAAgAAABIAAAAQAAAAEQAAAAIAAAAFAAAAAgAAAAMAAAASAAAAEgAAABIAAAADAAAABQAAAAIAAAADAAAAEgAAABIAAAATAAAAAwAAAAUAAAAEAAAABAAAABIAAAASAAAAEwAAAAQAAAAEAAAABAAAAAQAAAASAAAAEgAAABMAAAAEAAAABAAAAAgAAAAFAAAAEgAAABIAAAATAAAABQAAAAQAAAAIAAAABQAAABIAAAASAAAAEwAAAAYAAAAEAAAACAAAAAUAAAASAAAAEgAAABMAAAAFAAAABAAAAAwAAAAGAAAAEgAAABMAAAATAAAABwAAAAQAAAAMAAAABgAAABIAAAASAAAAEwAAAAQAAAAEAAAAEAAAAAcAAAASAAAAEgAAABMAAAAEAAAAAwAAACAAAAAHAAAAEgAAABIAAAATAAAABgAAAAMAAACAAAAABwAAABIAAAATAAAAEwAAAAYAAAADAAAAgAAAAAgAAAASAAAAEwAAABMAAAAIAAAAAwAAAAABAAAIAAAAEgAAABMAAAATAAAABgAAAAMAAACAAAAACQAAABIAAAATAAAAEwAAAAgAAAADAAAAAAEAAAkAAAASAAAAEwAAABMAAAAKAAAAAwAAAAACAAAJAAAAEgAAABMAAAATAAAADAAAAAMAAAAAAgAACQAAABIAAAATAAAAEwAAAA0AAAADAAAA5wMAAAkAAAARAAAADAAAAAwAAAABAAAABQAAAAEAAAABAAAAEQAAAAwAAAANAAAAAQAAAAYAAAAAAAAAAQAAABEAAAANAAAADwAAAAEAAAAFAAAAAAAAAAEAAAARAAAADwAAABAAAAACAAAABQAAAAAAAAACAAAAEQAAABEAAAARAAAAAgAAAAQAAAAAAAAAAgAAABEAAAAQAAAAEQAAAAMAAAAEAAAAAgAAAAMAAAARAAAAEQAAABEAAAADAAAABAAAAAQAAAAEAAAAEQAAABEAAAARAAAAAwAAAAQAAAAIAAAABQAAABEAAAARAAAAEQAAAAQAAAAEAAAACAAAAAUAAAARAAAAEQAAABEAAAAFAAAABAAAAAgAAAAFAAAAEQAAABEAAAARAAAABgAAAAQAAAAIAAAABQAAABEAAAARAAAAEQAAAAUAAAAEAAAACAAAAAYAAAARAAAAEgAAABEAAAAHAAAABAAAAAwAAAAGAAAAEQAAABIAAAARAAAAAwAAAAQAAAAMAAAABwAAABEAAAASAAAAEQAAAAQAAAADAAAAIAAAAAcAAAARAAAAEgAAABEAAAAGAAAAAwAAAAABAAAHAAAAEQAAABIAAAARAAAABgAAAAMAAACAAAAACAAAABEAAAASAAAAEQAAAAgAAAADAAAAAAEAAAgAAAARAAAAEgAAABEAAAAKAAAAAwAAAAACAAAIAAAAEQAAABIAAAARAAAABQAAAAMAAAAAAQAACQAAABEAAAASAAAAEQAAAAcAAAADAAAAAAIAAAkAAAARAAAAEgAAABEAAAAJAAAAAwAAAAACAAAJAAAAEQAAABIAAAARAAAACwAAAAMAAADnAwAACQAAAA4AAAAMAAAADQAAAAEAAAAFAAAAAQAAAAEAAAAOAAAADgAAAA8AAAABAAAABQAAAAAAAAABAAAADgAAAA4AAAAPAAAAAQAAAAQAAAAAAAAAAQAAAA4AAAAOAAAADwAAAAIAAAAEAAAAAAAAAAIAAAAOAAAADgAAAA4AAAAEAAAABAAAAAIAAAADAAAADgAAAA4AAAAOAAAAAwAAAAQAAAAEAAAABAAAAA4AAAAOAAAADgAAAAQAAAAEAAAACAAAAAUAAAAOAAAADgAAAA4AAAAGAAAABAAAAAgAAAAFAAAADgAAAA4AAAAOAAAACAAAAAQAAAAIAAAABQAAAA4AAAAPAAAADgAAAAUAAAAEAAAACAAAAAYAAAAOAAAADwAAAA4AAAAJAAAABAAAAAgAAAAGAAAADgAAAA8AAAAOAAAAAwAAAAQAAAAMAAAABwAAAA4AAAAPAAAADgAAAAQAAAADAAAAGAAAAAcAAAAOAAAADwAAAA4AAAAFAAAAAwAAACAAAAAIAAAADgAAAA8AAAAPAAAABgAAAAMAAABAAAAACAAAAA4AAAAPAAAADwAAAAcAAAADAAAAAAEAAAgAAAAOAAAADwAAAA8AAAAFAAAAAwAAADAAAAAJAAAADgAAAA8AAAAPAAAABgAAAAMAAACAAAAACQAAAA4AAAAPAAAADwAAAAcAAAADAAAAAAEAAAkAAAAOAAAADwAAAA8AAAAIAAAAAwAAAAABAAAJAAAADgAAAA8AAAAPAAAACAAAAAMAAAAAAgAACQAAAA4AAAAPAAAADwAAAAkAAAADAAAAAAIAAAkAAAAOAAAADwAAAA8AAAAKAAAAAwAAAOcDAAAJAAAAIAAAACAAAAAhAAAAIgAAACMAAAAkAAAAJQAAACYAAAAnAAAAKAAAACkAAAApAAAAKgAAACsAAAAsAAAALQAAAC4AAAAvAAAAMAAAADAAAAAxAAAAMQAAADIAAAAzAAAANAAAADUAAAA2AAAANwAAADgAAAA4AEGQmgEL+gEEAAMAAgACAAIAAgACAAIAAgACAAIAAgACAAEAAQABAAIAAgACAAIAAgACAAIAAgACAAMAAgABAAEAAQABAAEA//////////8AAAAAAAAAAAEAAQABAAEAAQABAAIAAgACAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAP////////////8AAAAAAAABAAQAAwACAAIAAgACAAIAAgABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAP//////////////////AEGVnAEL+AcIAAAABwAAagYAAAAGAACtBQAAagUAADEFAAAABQAA1AQAAK0EAACKBAAAagQAAEwEAAAxBAAAFwQAAAAEAADpAwAA1AMAAMADAACtAwAAmwMAAIoDAAB5AwAAagMAAFsDAABMAwAAPgMAADEDAAAkAwAAFwMAAAsDAAAAAwAA9AIAAOkCAADeAgAA1AIAAMoCAADAAgAAtgIAAK0CAACkAgAAmwIAAJICAACKAgAAggIAAHkCAAByAgAAagIAAGICAABbAgAAUwIAAEwCAABFAgAAPgIAADcCAAAxAgAAKgIAACQCAAAeAgAAFwIAABECAAALAgAABQIAAAACAAD6AQAA9AEAAO8BAADpAQAA5AEAAN4BAADZAQAA1AEAAM8BAADKAQAAxQEAAMABAAC7AQAAtgEAALIBAACtAQAAqAEAAKQBAACfAQAAmwEAAJcBAACSAQAAjgEAAIoBAACGAQAAggEAAH4BAAB5AQAAdQEAAHIBAABuAQAAagEAAGYBAABiAQAAXgEAAFsBAABXAQAAUwEAAFABAABMAQAASQEAAEUBAABCAQAAPgEAADsBAAA3AQAANAEAADEBAAAuAQAAKgEAACcBAAAkAQAAIQEAAB4BAAAaAQAAFwEAABQBAAARAQAADgEAAAsBAAAIAQAABQEAAAIBAAAAAQAA/QAAAPoAAAD3AAAA9AAAAPEAAADvAAAA7AAAAOkAAADmAAAA5AAAAOEAAADeAAAA3AAAANkAAADXAAAA1AAAANEAAADPAAAAzAAAAMoAAADHAAAAxQAAAMIAAADAAAAAvgAAALsAAAC5AAAAtgAAALQAAACyAAAArwAAAK0AAACrAAAAqAAAAKYAAACkAAAAogAAAJ8AAACdAAAAmwAAAJkAAACXAAAAlQAAAJIA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AAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBsLIBC9YEAQAAAAEAAAABAAAAAQAAAAIAAAACAAAAAwAAAAMAAAAEAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBlLcBC4MEAQAAAAEAAAAFAAAADQAAAB0AAAA9AAAAfQAAAP0AAAD9AQAA/QMAAP0HAAD9DwAA/R8AAP0/AAD9fwAA/f8AAP3/AQD9/wMA/f8HAP3/DwD9/x8A/f8/AP3/fwD9//8A/f//Af3//wP9//8H/f//D/3//x/9//8//f//fwAAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAAQABAQUAAAAAAAAFAAAAAAAABgQ9AAAAAAAJBf0BAAAAAA8F/X8AAAAAFQX9/x8AAAADBQUAAAAAAAcEfQAAAAAADAX9DwAAAAASBf3/AwAAABcF/f9/AAAABQUdAAAAAAAIBP0AAAAAAA4F/T8AAAAAFAX9/w8AAAACBQEAAAAQAAcEfQAAAAAACwX9BwAAAAARBf3/AQAAABYF/f8/AAAABAUNAAAAEAAIBP0AAAAAAA0F/R8AAAAAEwX9/wcAAAABBQEAAAAQAAYEPQAAAAAACgX9AwAAAAAQBf3/AAAAABwF/f//DwAAGwX9//8HAAAaBf3//wMAABkF/f//AQAAGAX9//8AQaC7AQvTAQMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQYC+AQtRAQAAAAEAAAABAAAAAQAAAAIAAAACAAAAAwAAAAMAAAAEAAAABAAAAAUAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAEHgvgELhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABB8MIBC5EOCAAAAAgAAAAIAAAABwAAAAgAAAAJAAAACgAAAAsAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAAAAAABAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/dm9pZABib29sAGNoYXIAc2lnbmVkIGNoYXIAdW5zaWduZWQgY2hhcgBzaG9ydAB1bnNpZ25lZCBzaG9ydABpbnQAdW5zaWduZWQgaW50AGxvbmcAdW5zaWduZWQgbG9uZwBmbG9hdABkb3VibGUAc3RkOjpzdHJpbmcAc3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4Ac3RkOjp3c3RyaW5nAHN0ZDo6dTE2c3RyaW5nAHN0ZDo6dTMyc3RyaW5nAGVtc2NyaXB0ZW46OnZhbABlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8bG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgbG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxkb3VibGU+AAAAGHQAAFBlAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lkRUUAABh0AAB4ZQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZkVFAAAYdAAAoGUAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SW1FRQAAGHQAAMhlAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lsRUUAABh0AADwZQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJakVFAAAYdAAAGGYAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWlFRQAAGHQAAEBmAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l0RUUAABh0AABoZgAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJc0VFAAAYdAAAkGYAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWFFRQAAGHQAALhmAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ljRUUAAEB0AADwZgAAAAAAAAEAAACIBwAAAAAAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEaU5TXzExY2hhcl90cmFpdHNJRGlFRU5TXzlhbGxvY2F0b3JJRGlFRUVFAAAAQHQAAExnAAAAAAAAAQAAAIgHAAAAAAAATlN0M19fMjEyYmFzaWNfc3RyaW5nSURzTlNfMTFjaGFyX3RyYWl0c0lEc0VFTlNfOWFsbG9jYXRvcklEc0VFRUUAAABAdAAAqGcAAAAAAAABAAAAiAcAAAAAAABOU3QzX18yMTJiYXNpY19zdHJpbmdJd05TXzExY2hhcl90cmFpdHNJd0VFTlNfOWFsbG9jYXRvckl3RUVFRQAAQHQAAABoAAAAAAAAAQAAAIgHAAAAAAAATlN0M19fMjEyYmFzaWNfc3RyaW5nSWhOU18xMWNoYXJfdHJhaXRzSWhFRU5TXzlhbGxvY2F0b3JJaEVFRUUAABEACgAREREAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAEQAPChEREQMKBwABAAkLCwAACQYLAAALAAYRAAAAERERAEGR0QELIQsAAAAAAAAAABEACgoREREACgAAAgAJCwAAAAkACwAACwBBy9EBCwEMAEHX0QELFQwAAAAADAAAAAAJDAAAAAAADAAADABBhdIBCwEOAEGR0gELFQ0AAAAEDQAAAAAJDgAAAAAADgAADgBBv9IBCwEQAEHL0gELHg8AAAAADwAAAAAJEAAAAAAAEAAAEAAAEgAAABISEgBBgtMBCw4SAAAAEhISAAAAAAAACQBBs9MBCwELAEG/0wELFQoAAAAACgAAAAAJCwAAAAAACwAACwBB7dMBCwEMAEH50wELJwwAAAAADAAAAAAJDAAAAAAADAAADAAALSsgICAwWDB4AChudWxsKQBBsNQBC2cwMTIzNDU2Nzg5QUJDREVGGRJEOwI/LEcUPTMwChsGRktFNw9JDo4XA0AdPGkrNh9KLRwBICUpIQgMFRYiLhA4Pgs0MRhkdHV2L0EJfzkRI0MyQomKiwUEJignDSoeNYwHGkiTE5SVAEGg1QEL9hNJbGxlZ2FsIGJ5dGUgc2VxdWVuY2UARG9tYWluIGVycm9yAFJlc3VsdCBub3QgcmVwcmVzZW50YWJsZQBOb3QgYSB0dHkAUGVybWlzc2lvbiBkZW5pZWQAT3BlcmF0aW9uIG5vdCBwZXJtaXR0ZWQATm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeQBObyBzdWNoIHByb2Nlc3MARmlsZSBleGlzdHMAVmFsdWUgdG9vIGxhcmdlIGZvciBkYXRhIHR5cGUATm8gc3BhY2UgbGVmdCBvbiBkZXZpY2UAT3V0IG9mIG1lbW9yeQBSZXNvdXJjZSBidXN5AEludGVycnVwdGVkIHN5c3RlbSBjYWxsAFJlc291cmNlIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlAEludmFsaWQgc2VlawBDcm9zcy1kZXZpY2UgbGluawBSZWFkLW9ubHkgZmlsZSBzeXN0ZW0ARGlyZWN0b3J5IG5vdCBlbXB0eQBDb25uZWN0aW9uIHJlc2V0IGJ5IHBlZXIAT3BlcmF0aW9uIHRpbWVkIG91dABDb25uZWN0aW9uIHJlZnVzZWQASG9zdCBpcyBkb3duAEhvc3QgaXMgdW5yZWFjaGFibGUAQWRkcmVzcyBpbiB1c2UAQnJva2VuIHBpcGUASS9PIGVycm9yAE5vIHN1Y2ggZGV2aWNlIG9yIGFkZHJlc3MAQmxvY2sgZGV2aWNlIHJlcXVpcmVkAE5vIHN1Y2ggZGV2aWNlAE5vdCBhIGRpcmVjdG9yeQBJcyBhIGRpcmVjdG9yeQBUZXh0IGZpbGUgYnVzeQBFeGVjIGZvcm1hdCBlcnJvcgBJbnZhbGlkIGFyZ3VtZW50AEFyZ3VtZW50IGxpc3QgdG9vIGxvbmcAU3ltYm9saWMgbGluayBsb29wAEZpbGVuYW1lIHRvbyBsb25nAFRvbyBtYW55IG9wZW4gZmlsZXMgaW4gc3lzdGVtAE5vIGZpbGUgZGVzY3JpcHRvcnMgYXZhaWxhYmxlAEJhZCBmaWxlIGRlc2NyaXB0b3IATm8gY2hpbGQgcHJvY2VzcwBCYWQgYWRkcmVzcwBGaWxlIHRvbyBsYXJnZQBUb28gbWFueSBsaW5rcwBObyBsb2NrcyBhdmFpbGFibGUAUmVzb3VyY2UgZGVhZGxvY2sgd291bGQgb2NjdXIAU3RhdGUgbm90IHJlY292ZXJhYmxlAFByZXZpb3VzIG93bmVyIGRpZWQAT3BlcmF0aW9uIGNhbmNlbGVkAEZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZABObyBtZXNzYWdlIG9mIGRlc2lyZWQgdHlwZQBJZGVudGlmaWVyIHJlbW92ZWQARGV2aWNlIG5vdCBhIHN0cmVhbQBObyBkYXRhIGF2YWlsYWJsZQBEZXZpY2UgdGltZW91dABPdXQgb2Ygc3RyZWFtcyByZXNvdXJjZXMATGluayBoYXMgYmVlbiBzZXZlcmVkAFByb3RvY29sIGVycm9yAEJhZCBtZXNzYWdlAEZpbGUgZGVzY3JpcHRvciBpbiBiYWQgc3RhdGUATm90IGEgc29ja2V0AERlc3RpbmF0aW9uIGFkZHJlc3MgcmVxdWlyZWQATWVzc2FnZSB0b28gbGFyZ2UAUHJvdG9jb2wgd3JvbmcgdHlwZSBmb3Igc29ja2V0AFByb3RvY29sIG5vdCBhdmFpbGFibGUAUHJvdG9jb2wgbm90IHN1cHBvcnRlZABTb2NrZXQgdHlwZSBub3Qgc3VwcG9ydGVkAE5vdCBzdXBwb3J0ZWQAUHJvdG9jb2wgZmFtaWx5IG5vdCBzdXBwb3J0ZWQAQWRkcmVzcyBmYW1pbHkgbm90IHN1cHBvcnRlZCBieSBwcm90b2NvbABBZGRyZXNzIG5vdCBhdmFpbGFibGUATmV0d29yayBpcyBkb3duAE5ldHdvcmsgdW5yZWFjaGFibGUAQ29ubmVjdGlvbiByZXNldCBieSBuZXR3b3JrAENvbm5lY3Rpb24gYWJvcnRlZABObyBidWZmZXIgc3BhY2UgYXZhaWxhYmxlAFNvY2tldCBpcyBjb25uZWN0ZWQAU29ja2V0IG5vdCBjb25uZWN0ZWQAQ2Fubm90IHNlbmQgYWZ0ZXIgc29ja2V0IHNodXRkb3duAE9wZXJhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzAE9wZXJhdGlvbiBpbiBwcm9ncmVzcwBTdGFsZSBmaWxlIGhhbmRsZQBSZW1vdGUgSS9PIGVycm9yAFF1b3RhIGV4Y2VlZGVkAE5vIG1lZGl1bSBmb3VuZABXcm9uZyBtZWRpdW0gdHlwZQBObyBlcnJvciBpbmZvcm1hdGlvbgAAYmFzaWNfc3RyaW5nAHN0ZDo6ZXhjZXB0aW9uAAAAAADccQAAPAAAAD0AAAA+AAAAGHQAAORxAABTdDlleGNlcHRpb24AAAAAAAAAAAhyAAAQAAAAPwAAAEAAAACMcgAAFHIAANxxAABTdDExbG9naWNfZXJyb3IAAAAAADhyAAAQAAAAQQAAAEAAAACMcgAARHIAAAhyAABTdDEybGVuZ3RoX2Vycm9yAFN0OXR5cGVfaW5mbwAAABh0AABVcgAAjHIAAAFzAABkcgAAjHIAAKxyAABscgAAAAAAANByAABCAAAAQwAAAEQAAABFAAAARgAAAEcAAABIAAAASQAAAE4xMF9fY3h4YWJpdjExN19fY2xhc3NfdHlwZV9pbmZvRQAAAIxyAADccgAAeHIAAE4xMF9fY3h4YWJpdjEyMF9fc2lfY2xhc3NfdHlwZV9pbmZvRQBOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQAAAAAAAABAcwAAQgAAAEoAAABEAAAARQAAAEsAAACMcgAATHMAAGxyAABOMTBfX2N4eGFiaXYxMjNfX2Z1bmRhbWVudGFsX3R5cGVfaW5mb0UAdgAAACxzAAB0cwAAYgAAACxzAACAcwAAYwAAACxzAACMcwAAaAAAACxzAACYcwAAYQAAACxzAACkcwAAcwAAACxzAACwcwAAdAAAACxzAAC8cwAAaQAAACxzAADIcwAAagAAACxzAADUcwAAbAAAACxzAADgcwAAbQAAACxzAADscwAAZgAAACxzAAD4cwAAZAAAACxzAAAEdAAAAAAAAHhyAABCAAAATAAAAEQAAABFAAAARgAAAE0AAABOAAAATwAAAAAAAABgdAAAQgAAAFAAAABEAAAARQAAAEYAAABRAAAAUgAAAFMAAACMcgAAbHQAAHhyAABOMTBfX2N4eGFiaXYxMjFfX3ZtaV9jbGFzc190eXBlX2luZm9FAAAAcHUAQZjpAQtBgC0AAAAyAAABAQAAHgEAAA8AAACALAAAAC0AAAAAAAAeAAAADwAAAAAAAAAwLAAAAAAAABMAAAAHAAAAAAAAAAUAQeTpAQsBOQBB/OkBCwo6AAAAOwAAAC12AEGU6gELAQIAQaPqAQsF//////8AQejqAQsJoH5QAAAAAAAFAEH86gELAVQAQZTrAQsOOgAAAFUAAACYegAAAAQAQazrAQsBAQBBu+sBCwUK/////w==\");\n\nvar _a;\nvar BloscShuffle;\n(function(BloscShuffle2) {\n  BloscShuffle2[BloscShuffle2[\"NOSHUFFLE\"] = 0] = \"NOSHUFFLE\";\n  BloscShuffle2[BloscShuffle2[\"SHUFFLE\"] = 1] = \"SHUFFLE\";\n  BloscShuffle2[BloscShuffle2[\"BITSHUFFLE\"] = 2] = \"BITSHUFFLE\";\n  BloscShuffle2[BloscShuffle2[\"AUTOSHUFFLE\"] = -1] = \"AUTOSHUFFLE\";\n})(BloscShuffle || (BloscShuffle = {}));\nconst COMPRESSORS = new Set([\"blosclz\", \"lz4\", \"lz4hc\", \"snappy\", \"zlib\", \"zstd\"]);\nlet emscriptenModule;\nconst init = () => blosc_codec({ noInitialRun: true, wasmBinary });\nconst Blosc = (_a = class {\n  constructor(clevel = 5, cname = \"lz4\", shuffle = 1, blocksize = 0) {\n    if (clevel < 0 || clevel > 9) {\n      throw new Error(`Invalid compression level: '${clevel}'. It should be between 0 and 9`);\n    }\n    if (!COMPRESSORS.has(cname)) {\n      throw new Error(`Invalid compressor '${cname}'. Valid compressors include\n        'blosclz', 'lz4', 'lz4hc','snappy', 'zlib', 'zstd'.`);\n    }\n    if (shuffle < -1 || shuffle > 2) {\n      throw new Error(`Invalid shuffle ${shuffle}. Must be one of 0 (NOSHUFFLE),\n        1 (SHUFFLE), 2 (BITSHUFFLE), -1 (AUTOSHUFFLE).`);\n    }\n    this.blocksize = blocksize;\n    this.clevel = clevel;\n    this.cname = cname;\n    this.shuffle = shuffle;\n  }\n  static fromConfig({ blocksize, clevel, cname, shuffle }) {\n    return new _a(clevel, cname, shuffle, blocksize);\n  }\n  async encode(data) {\n    if (!emscriptenModule) {\n      emscriptenModule = init();\n    }\n    const module = await emscriptenModule;\n    const view = module.compress(data, this.cname, this.clevel, this.shuffle, this.blocksize);\n    const result = new Uint8Array(view);\n    module.free_result();\n    return result;\n  }\n  async decode(data, out) {\n    if (!emscriptenModule) {\n      emscriptenModule = init();\n    }\n    const module = await emscriptenModule;\n    const view = module.decompress(data);\n    const result = new Uint8Array(view);\n    module.free_result();\n    if (out !== void 0) {\n      out.set(result);\n      return out;\n    }\n    return result;\n  }\n}, _a.codecId = \"blosc\", _a.COMPRESSORS = [...COMPRESSORS], _a.NOSHUFFLE = 0, _a.SHUFFLE = 1, _a.BITSHUFFLE = 2, _a.AUTOSHUFFLE = -1, _a);\n\nvar Blosc$1 = Blosc;\n\n(0,_core_mjs__WEBPACK_IMPORTED_MODULE_0__.addCodec)(Zlib$1.codecId, () => Zlib$1);\r\n(0,_core_mjs__WEBPACK_IMPORTED_MODULE_0__.addCodec)(GZip$1.codecId, () => GZip$1);\r\n(0,_core_mjs__WEBPACK_IMPORTED_MODULE_0__.addCodec)(Blosc$1.codecId, () => Blosc$1);\n//# sourceMappingURL=zarr.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEIsd0JBQXdCOztBQUV4QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7O0FBRXBFO0FBQ0EsMERBQTBEO0FBQzFEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUIsMkJBQTJCOztBQUUzQjs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIseUJBQXlCOztBQUV6Qjs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTtBQUNyRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCO0FBQ3RCLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsK0JBQStCO0FBQy9CLDhCQUE4QjtBQUM5QixnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsNEJBQTRCO0FBQzVCLDBCQUEwQjs7QUFFMUIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCOztBQUV0Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qix3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QixzQkFBc0I7O0FBRXRCO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2Qjs7QUFFQTs7QUFFQSw4Q0FBOEM7QUFDOUMsOENBQThDO0FBQzlDLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQyxtREFBbUQ7QUFDbkQ7O0FBRUEsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUEsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7OztBQUcxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSw4QkFBOEI7QUFDOUIsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCOztBQUV2Qix1Q0FBdUM7O0FBRXZDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEIsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QjtBQUNBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCO0FBQ0EsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUI7OztBQUdBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxJQUFJO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxJQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qyw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLDJDQUEyQztBQUMzQztBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qiw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QixrQ0FBa0M7QUFDbEMsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsd0JBQXdCO0FBQ3hCLHVCQUF1QjtBQUN2QjtBQUNBLHFCQUFxQjtBQUNyQiw4QkFBOEI7QUFDOUIsOENBQThDLGtCQUFrQjtBQUNoRSw2Q0FBNkMsbUJBQW1CO0FBQ2hFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEMsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLHdDQUF3Qyw2QkFBNkI7QUFDckUsMENBQTBDO0FBQzFDLDJDQUEyQztBQUMzQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksMEJBQTBCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsbUNBQW1DO0FBQ25DLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsK0JBQStCO0FBQy9CLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QixpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsMkJBQTJCO0FBQzNCLHlCQUF5QjtBQUN6Qix5QkFBeUI7O0FBRXpCOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSw2QkFBNkI7QUFDN0IsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7O0FBRTlCO0FBQ0EsOEJBQThCO0FBQzlCLDhCQUE4Qjs7QUFFOUI7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCOztBQUU5QjtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQSxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLDhCQUE4QjtBQUM5Qiw4QkFBOEI7O0FBRTlCO0FBQ0EsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLGlDQUFpQzs7QUFFakMsb0NBQW9DO0FBQ3BDLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQzs7O0FBR0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLGVBQWU7QUFDZix1Q0FBdUM7O0FBRXZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjs7O0FBR3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qix3QkFBd0I7O0FBRXhCLHFFQUFxRSxTQUFTOztBQUU5RTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QixxRUFBcUUsU0FBUzs7QUFFOUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QjtBQUNBLDhCQUE4QjtBQUM5QixvQ0FBb0M7QUFDcEMsZ0NBQWdDO0FBQ2hDLG9DQUFvQztBQUNwQyw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLHFDQUFxQztBQUNyQzs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLDBCQUEwQjs7O0FBR3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNB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QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxpRkFB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QUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQSxpQ0FBaUMsZ0NBQWdDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxPQUFPO0FBQzVEO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQ0FBbUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsbURBQVE7QUFDUixtREFBUTtBQUNSLG1EQUFRO0FBQ1IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWljcy93ZWItM2Qtdmlld2VyLy4vbm9kZV9tb2R1bGVzL3phcnIvemFyci5tanM/YmQ2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhZGRDb2RlYyB9IGZyb20gJy4vY29yZS5tanMnO1xuZXhwb3J0IHsgQXJyYXlOb3RGb3VuZEVycm9yLCBCb3VuZHNDaGVja0Vycm9yLCBDb250YWluc0FycmF5RXJyb3IsIENvbnRhaW5zR3JvdXBFcnJvciwgR3JvdXAsIEdyb3VwTm90Rm91bmRFcnJvciwgSFRUUEVycm9yLCBIVFRQU3RvcmUsIEludmFsaWRTbGljZUVycm9yLCBLZXlFcnJvciwgTWVtb3J5U3RvcmUsIE5lZ2F0aXZlU3RlcEVycm9yLCBOZXN0ZWRBcnJheSwgT2JqZWN0U3RvcmUsIFBhdGhOb3RGb3VuZEVycm9yLCBQZXJtaXNzaW9uRXJyb3IsIFRvb01hbnlJbmRpY2VzRXJyb3IsIFZhbHVlRXJyb3IsIFphcnJBcnJheSwgYWRkQ29kZWMsIGFycmF5LCBjcmVhdGUsIGNyZWF0ZVByb3h5LCBlbXB0eSwgZnVsbCwgZ2V0Q29kZWMsIGdldFR5cGVkQXJyYXlDdHIsIGdldFR5cGVkQXJyYXlEdHlwZVN0cmluZywgZ3JvdXAsIGlzS2V5RXJyb3IsIG5vcm1hbGl6ZVN0b3JlQXJndW1lbnQsIG9uZXMsIG9wZW5BcnJheSwgb3Blbkdyb3VwLCByYW5nZVR5cGVkQXJyYXksIHNsaWNlLCBzbGljZUluZGljZXMsIHplcm9zIH0gZnJvbSAnLi9jb3JlLm1qcyc7XG5cbi8qISBwYWtvIDIuMC4zIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGFrbyBAbGljZW5zZSAoTUlUIEFORCBabGliKSAqL1xuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBzcGFjZS11bmFyeS1vcHMgKi9cblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLy9jb25zdCBaX0ZJTFRFUkVEICAgICAgICAgID0gMTtcbi8vY29uc3QgWl9IVUZGTUFOX09OTFkgICAgICA9IDI7XG4vL2NvbnN0IFpfUkxFICAgICAgICAgICAgICAgPSAzO1xuY29uc3QgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbi8vY29uc3QgWl9ERUZBVUxUX1NUUkFURUdZICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbmNvbnN0IFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG5jb25zdCBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy9jb25zdCBaX0FTQ0lJICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbmNvbnN0IFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuZnVuY3Rpb24gemVybyhidWYpIHsgbGV0IGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cbi8vIEZyb20genV0aWwuaFxuXG5jb25zdCBTVE9SRURfQkxPQ0sgPSAwO1xuY29uc3QgU1RBVElDX1RSRUVTID0gMTtcbmNvbnN0IERZTl9UUkVFUyAgICA9IDI7XG4vKiBUaGUgdGhyZWUga2luZHMgb2YgYmxvY2sgdHlwZSAqL1xuXG5jb25zdCBNSU5fTUFUQ0ggICAgPSAzO1xuY29uc3QgTUFYX01BVENIICAgID0gMjU4O1xuLyogVGhlIG1pbmltdW0gYW5kIG1heGltdW0gbWF0Y2ggbGVuZ3RocyAqL1xuXG4vLyBGcm9tIGRlZmxhdGUuaFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbnRlcm5hbCBjb21wcmVzc2lvbiBzdGF0ZS5cbiAqL1xuXG5jb25zdCBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cblxuY29uc3QgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuXG5jb25zdCBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG5cbmNvbnN0IERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuXG5jb25zdCBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cblxuY29uc3QgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG5cbmNvbnN0IE1BWF9CSVRTICAgICAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG5jb25zdCBCdWZfc2l6ZSAgICAgID0gMTY7XG4vKiBzaXplIG9mIGJpdCBidWZmZXIgaW4gYmlfYnVmICovXG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBNQVhfQkxfQklUUyA9IDc7XG4vKiBCaXQgbGVuZ3RoIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQkxfQklUUyBiaXRzICovXG5cbmNvbnN0IEVORF9CTE9DSyAgID0gMjU2O1xuLyogZW5kIG9mIGJsb2NrIGxpdGVyYWwgY29kZSAqL1xuXG5jb25zdCBSRVBfM182ICAgICA9IDE2O1xuLyogcmVwZWF0IHByZXZpb3VzIGJpdCBsZW5ndGggMy02IHRpbWVzICgyIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG5jb25zdCBSRVBaXzNfMTAgICA9IDE3O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMy0xMCB0aW1lcyAgKDMgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbmNvbnN0IFJFUFpfMTFfMTM4ID0gMTg7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAxMS0xMzggdGltZXMgICg3IGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuY29uc3QgZXh0cmFfbGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggbGVuZ3RoIGNvZGUgKi9cbiAgbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMF0pO1xuXG5jb25zdCBleHRyYV9kYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBkaXN0YW5jZSBjb2RlICovXG4gIG5ldyBVaW50OEFycmF5KFswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzXSk7XG5cbmNvbnN0IGV4dHJhX2JsYml0cyA9ICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGJpdCBsZW5ndGggY29kZSAqL1xuICBuZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDMsN10pO1xuXG5jb25zdCBibF9vcmRlciA9XG4gIG5ldyBVaW50OEFycmF5KFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XSk7XG4vKiBlc2xpbnQtZW5hYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG5cbi8qIFRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzIGFyZSBzZW50IGluIG9yZGVyIG9mIGRlY3JlYXNpbmdcbiAqIHByb2JhYmlsaXR5LCB0byBhdm9pZCB0cmFuc21pdHRpbmcgdGhlIGxlbmd0aHMgZm9yIHVudXNlZCBiaXQgbGVuZ3RoIGNvZGVzLlxuICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogTG9jYWwgZGF0YS4gVGhlc2UgYXJlIGluaXRpYWxpemVkIG9ubHkgb25jZS5cbiAqL1xuXG4vLyBXZSBwcmUtZmlsbCBhcnJheXMgd2l0aCAwIHRvIGF2b2lkIHVuaW5pdGlhbGl6ZWQgZ2Fwc1xuXG5jb25zdCBESVNUX0NPREVfTEVOID0gNTEyOyAvKiBzZWUgZGVmaW5pdGlvbiBvZiBhcnJheSBkaXN0X2NvZGUgYmVsb3cgKi9cblxuLy8gISEhISBVc2UgZmxhdCBhcnJheSBpbnN0ZWFkIG9mIHN0cnVjdHVyZSwgRnJlcSA9IGkqMiwgTGVuID0gaSoyKzFcbmNvbnN0IHN0YXRpY19sdHJlZSAgPSBuZXcgQXJyYXkoKExfQ09ERVMgKyAyKSAqIDIpO1xuemVybyhzdGF0aWNfbHRyZWUpO1xuLyogVGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUuIFNpbmNlIHRoZSBiaXQgbGVuZ3RocyBhcmUgaW1wb3NlZCwgdGhlcmUgaXMgbm9cbiAqIG5lZWQgZm9yIHRoZSBMX0NPREVTIGV4dHJhIGNvZGVzIHVzZWQgZHVyaW5nIGhlYXAgY29uc3RydWN0aW9uLiBIb3dldmVyXG4gKiBUaGUgY29kZXMgMjg2IGFuZCAyODcgYXJlIG5lZWRlZCB0byBidWlsZCBhIGNhbm9uaWNhbCB0cmVlIChzZWUgX3RyX2luaXRcbiAqIGJlbG93KS5cbiAqL1xuXG5jb25zdCBzdGF0aWNfZHRyZWUgID0gbmV3IEFycmF5KERfQ09ERVMgKiAyKTtcbnplcm8oc3RhdGljX2R0cmVlKTtcbi8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZS4gKEFjdHVhbGx5IGEgdHJpdmlhbCB0cmVlIHNpbmNlIGFsbCBjb2RlcyB1c2VcbiAqIDUgYml0cy4pXG4gKi9cblxuY29uc3QgX2Rpc3RfY29kZSAgICA9IG5ldyBBcnJheShESVNUX0NPREVfTEVOKTtcbnplcm8oX2Rpc3RfY29kZSk7XG4vKiBEaXN0YW5jZSBjb2Rlcy4gVGhlIGZpcnN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgZGlzdGFuY2VzXG4gKiAzIC4uIDI1OCwgdGhlIGxhc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSB0b3AgOCBiaXRzIG9mXG4gKiB0aGUgMTUgYml0IGRpc3RhbmNlcy5cbiAqL1xuXG5jb25zdCBfbGVuZ3RoX2NvZGUgID0gbmV3IEFycmF5KE1BWF9NQVRDSCAtIE1JTl9NQVRDSCArIDEpO1xuemVybyhfbGVuZ3RoX2NvZGUpO1xuLyogbGVuZ3RoIGNvZGUgZm9yIGVhY2ggbm9ybWFsaXplZCBtYXRjaCBsZW5ndGggKDAgPT0gTUlOX01BVENIKSAqL1xuXG5jb25zdCBiYXNlX2xlbmd0aCAgID0gbmV3IEFycmF5KExFTkdUSF9DT0RFUyk7XG56ZXJvKGJhc2VfbGVuZ3RoKTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgbGVuZ3RoIGZvciBlYWNoIGNvZGUgKDAgPSBNSU5fTUFUQ0gpICovXG5cbmNvbnN0IGJhc2VfZGlzdCAgICAgPSBuZXcgQXJyYXkoRF9DT0RFUyk7XG56ZXJvKGJhc2VfZGlzdCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGRpc3RhbmNlIGZvciBlYWNoIGNvZGUgKDAgPSBkaXN0YW5jZSBvZiAxKSAqL1xuXG5cbmZ1bmN0aW9uIFN0YXRpY1RyZWVEZXNjKHN0YXRpY190cmVlLCBleHRyYV9iaXRzLCBleHRyYV9iYXNlLCBlbGVtcywgbWF4X2xlbmd0aCkge1xuXG4gIHRoaXMuc3RhdGljX3RyZWUgID0gc3RhdGljX3RyZWU7ICAvKiBzdGF0aWMgdHJlZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYml0cyAgID0gZXh0cmFfYml0czsgICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGNvZGUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2Jhc2UgICA9IGV4dHJhX2Jhc2U7ICAgLyogYmFzZSBpbmRleCBmb3IgZXh0cmFfYml0cyAqL1xuICB0aGlzLmVsZW1zICAgICAgICA9IGVsZW1zOyAgICAgICAgLyogbWF4IG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgdHJlZSAqL1xuICB0aGlzLm1heF9sZW5ndGggICA9IG1heF9sZW5ndGg7ICAgLyogbWF4IGJpdCBsZW5ndGggZm9yIHRoZSBjb2RlcyAqL1xuXG4gIC8vIHNob3cgaWYgYHN0YXRpY190cmVlYCBoYXMgZGF0YSBvciBkdW1teSAtIG5lZWRlZCBmb3IgbW9ub21vcnBoaWMgb2JqZWN0c1xuICB0aGlzLmhhc19zdHJlZSAgICA9IHN0YXRpY190cmVlICYmIHN0YXRpY190cmVlLmxlbmd0aDtcbn1cblxuXG5sZXQgc3RhdGljX2xfZGVzYztcbmxldCBzdGF0aWNfZF9kZXNjO1xubGV0IHN0YXRpY19ibF9kZXNjO1xuXG5cbmZ1bmN0aW9uIFRyZWVEZXNjKGR5bl90cmVlLCBzdGF0X2Rlc2MpIHtcbiAgdGhpcy5keW5fdHJlZSA9IGR5bl90cmVlOyAgICAgLyogdGhlIGR5bmFtaWMgdHJlZSAqL1xuICB0aGlzLm1heF9jb2RlID0gMDsgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdGhpcy5zdGF0X2Rlc2MgPSBzdGF0X2Rlc2M7ICAgLyogdGhlIGNvcnJlc3BvbmRpbmcgc3RhdGljIHRyZWUgKi9cbn1cblxuXG5cbmNvbnN0IGRfY29kZSA9IChkaXN0KSA9PiB7XG5cbiAgcmV0dXJuIGRpc3QgPCAyNTYgPyBfZGlzdF9jb2RlW2Rpc3RdIDogX2Rpc3RfY29kZVsyNTYgKyAoZGlzdCA+Pj4gNyldO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIE91dHB1dCBhIHNob3J0IExTQiBmaXJzdCBvbiB0aGUgc3RyZWFtLlxuICogSU4gYXNzZXJ0aW9uOiB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpbiBwZW5kaW5nQnVmLlxuICovXG5jb25zdCBwdXRfc2hvcnQgPSAocywgdykgPT4ge1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHcpICYgMHhmZikpO1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHVzaCkodykgPj4gOCkpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcgPj4+IDgpICYgMHhmZjtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgdmFsdWUgb24gYSBnaXZlbiBudW1iZXIgb2YgYml0cy5cbiAqIElOIGFzc2VydGlvbjogbGVuZ3RoIDw9IDE2IGFuZCB2YWx1ZSBmaXRzIGluIGxlbmd0aCBiaXRzLlxuICovXG5jb25zdCBzZW5kX2JpdHMgPSAocywgdmFsdWUsIGxlbmd0aCkgPT4ge1xuXG4gIGlmIChzLmJpX3ZhbGlkID4gKEJ1Zl9zaXplIC0gbGVuZ3RoKSkge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gdmFsdWUgPj4gKEJ1Zl9zaXplIC0gcy5iaV92YWxpZCk7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGggLSBCdWZfc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGg7XG4gIH1cbn07XG5cblxuY29uc3Qgc2VuZF9jb2RlID0gKHMsIGMsIHRyZWUpID0+IHtcblxuICBzZW5kX2JpdHMocywgdHJlZVtjICogMl0vKi5Db2RlKi8sIHRyZWVbYyAqIDIgKyAxXS8qLkxlbiovKTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXZlcnNlIHRoZSBmaXJzdCBsZW4gYml0cyBvZiBhIGNvZGUsIHVzaW5nIHN0cmFpZ2h0Zm9yd2FyZCBjb2RlIChhIGZhc3RlclxuICogbWV0aG9kIHdvdWxkIHVzZSBhIHRhYmxlKVxuICogSU4gYXNzZXJ0aW9uOiAxIDw9IGxlbiA8PSAxNVxuICovXG5jb25zdCBiaV9yZXZlcnNlID0gKGNvZGUsIGxlbikgPT4ge1xuXG4gIGxldCByZXMgPSAwO1xuICBkbyB7XG4gICAgcmVzIHw9IGNvZGUgJiAxO1xuICAgIGNvZGUgPj4+PSAxO1xuICAgIHJlcyA8PD0gMTtcbiAgfSB3aGlsZSAoLS1sZW4gPiAwKTtcbiAgcmV0dXJuIHJlcyA+Pj4gMTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciwga2VlcGluZyBhdCBtb3N0IDcgYml0cyBpbiBpdC5cbiAqL1xuY29uc3QgYmlfZmx1c2ggPSAocykgPT4ge1xuXG4gIGlmIChzLmJpX3ZhbGlkID09PSAxNikge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSAwO1xuICAgIHMuYmlfdmFsaWQgPSAwO1xuXG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+PSA4KSB7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZiAmIDB4ZmY7XG4gICAgcy5iaV9idWYgPj49IDg7XG4gICAgcy5iaV92YWxpZCAtPSA4O1xuICB9XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyBmb3IgYSB0cmVlIGFuZCB1cGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGhcbiAqIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldCwgaGVhcFtoZWFwX21heF0gYW5kXG4gKiAgICBhYm92ZSBhcmUgdGhlIHRyZWUgbm9kZXMgc29ydGVkIGJ5IGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZCBsZW4gaXMgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGgsIHRoZVxuICogICAgIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBmcmVxdWVuY2llcyBmb3IgZWFjaCBiaXQgbGVuZ3RoLlxuICogICAgIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpc1xuICogICAgIG5vdCBudWxsLlxuICovXG5jb25zdCBnZW5fYml0bGVuID0gKHMsIGRlc2MpID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAgICAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIGNvbnN0IHRyZWUgICAgICAgICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIGNvbnN0IG1heF9jb2RlICAgICAgICA9IGRlc2MubWF4X2NvZGU7XG4gIGNvbnN0IHN0cmVlICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICBjb25zdCBoYXNfc3RyZWUgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIGNvbnN0IGV4dHJhICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2JpdHM7XG4gIGNvbnN0IGJhc2UgICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2Jhc2U7XG4gIGNvbnN0IG1heF9sZW5ndGggICAgICA9IGRlc2Muc3RhdF9kZXNjLm1heF9sZW5ndGg7XG4gIGxldCBoOyAgICAgICAgICAgICAgLyogaGVhcCBpbmRleCAqL1xuICBsZXQgbiwgbTsgICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBlbGVtZW50cyAqL1xuICBsZXQgYml0czsgICAgICAgICAgIC8qIGJpdCBsZW5ndGggKi9cbiAgbGV0IHhiaXRzOyAgICAgICAgICAvKiBleHRyYSBiaXRzICovXG4gIGxldCBmOyAgICAgICAgICAgICAgLyogZnJlcXVlbmN5ICovXG4gIGxldCBvdmVyZmxvdyA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIHdpdGggYml0IGxlbmd0aCB0b28gbGFyZ2UgKi9cblxuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBzLmJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIC8qIEluIGEgZmlyc3QgcGFzcywgY29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyAod2hpY2ggbWF5XG4gICAqIG92ZXJmbG93IGluIHRoZSBjYXNlIG9mIHRoZSBiaXQgbGVuZ3RoIHRyZWUpLlxuICAgKi9cbiAgdHJlZVtzLmhlYXBbcy5oZWFwX21heF0gKiAyICsgMV0vKi5MZW4qLyA9IDA7IC8qIHJvb3Qgb2YgdGhlIGhlYXAgKi9cblxuICBmb3IgKGggPSBzLmhlYXBfbWF4ICsgMTsgaCA8IEhFQVBfU0laRTsgaCsrKSB7XG4gICAgbiA9IHMuaGVhcFtoXTtcbiAgICBiaXRzID0gdHJlZVt0cmVlW24gKiAyICsgMV0vKi5EYWQqLyAqIDIgKyAxXS8qLkxlbiovICsgMTtcbiAgICBpZiAoYml0cyA+IG1heF9sZW5ndGgpIHtcbiAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoO1xuICAgICAgb3ZlcmZsb3crKztcbiAgICB9XG4gICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgIC8qIFdlIG92ZXJ3cml0ZSB0cmVlW25dLkRhZCB3aGljaCBpcyBubyBsb25nZXIgbmVlZGVkICovXG5cbiAgICBpZiAobiA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9IC8qIG5vdCBhIGxlYWYgbm9kZSAqL1xuXG4gICAgcy5ibF9jb3VudFtiaXRzXSsrO1xuICAgIHhiaXRzID0gMDtcbiAgICBpZiAobiA+PSBiYXNlKSB7XG4gICAgICB4Yml0cyA9IGV4dHJhW24gLSBiYXNlXTtcbiAgICB9XG4gICAgZiA9IHRyZWVbbiAqIDJdLyouRnJlcSovO1xuICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7XG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbiAqIDIgKyAxXS8qLkxlbiovICsgeGJpdHMpO1xuICAgIH1cbiAgfVxuICBpZiAob3ZlcmZsb3cgPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgLy8gVHJhY2UoKHN0ZGVycixcIlxcbmJpdCBsZW5ndGggb3ZlcmZsb3dcXG5cIikpO1xuICAvKiBUaGlzIGhhcHBlbnMgZm9yIGV4YW1wbGUgb24gb2JqMiBhbmQgcGljIG9mIHRoZSBDYWxnYXJ5IGNvcnB1cyAqL1xuXG4gIC8qIEZpbmQgdGhlIGZpcnN0IGJpdCBsZW5ndGggd2hpY2ggY291bGQgaW5jcmVhc2U6ICovXG4gIGRvIHtcbiAgICBiaXRzID0gbWF4X2xlbmd0aCAtIDE7XG4gICAgd2hpbGUgKHMuYmxfY291bnRbYml0c10gPT09IDApIHsgYml0cy0tOyB9XG4gICAgcy5ibF9jb3VudFtiaXRzXS0tOyAgICAgIC8qIG1vdmUgb25lIGxlYWYgZG93biB0aGUgdHJlZSAqL1xuICAgIHMuYmxfY291bnRbYml0cyArIDFdICs9IDI7IC8qIG1vdmUgb25lIG92ZXJmbG93IGl0ZW0gYXMgaXRzIGJyb3RoZXIgKi9cbiAgICBzLmJsX2NvdW50W21heF9sZW5ndGhdLS07XG4gICAgLyogVGhlIGJyb3RoZXIgb2YgdGhlIG92ZXJmbG93IGl0ZW0gYWxzbyBtb3ZlcyBvbmUgc3RlcCB1cCxcbiAgICAgKiBidXQgdGhpcyBkb2VzIG5vdCBhZmZlY3QgYmxfY291bnRbbWF4X2xlbmd0aF1cbiAgICAgKi9cbiAgICBvdmVyZmxvdyAtPSAyO1xuICB9IHdoaWxlIChvdmVyZmxvdyA+IDApO1xuXG4gIC8qIE5vdyByZWNvbXB1dGUgYWxsIGJpdCBsZW5ndGhzLCBzY2FubmluZyBpbiBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAgICogaCBpcyBzdGlsbCBlcXVhbCB0byBIRUFQX1NJWkUuIChJdCBpcyBzaW1wbGVyIHRvIHJlY29uc3RydWN0IGFsbFxuICAgKiBsZW5ndGhzIGluc3RlYWQgb2YgZml4aW5nIG9ubHkgdGhlIHdyb25nIG9uZXMuIFRoaXMgaWRlYSBpcyB0YWtlblxuICAgKiBmcm9tICdhcicgd3JpdHRlbiBieSBIYXJ1aGlrbyBPa3VtdXJhLilcbiAgICovXG4gIGZvciAoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT09IDA7IGJpdHMtLSkge1xuICAgIG4gPSBzLmJsX2NvdW50W2JpdHNdO1xuICAgIHdoaWxlIChuICE9PSAwKSB7XG4gICAgICBtID0gcy5oZWFwWy0taF07XG4gICAgICBpZiAobSA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9XG4gICAgICBpZiAodHJlZVttICogMiArIDFdLyouTGVuKi8gIT09IGJpdHMpIHtcbiAgICAgICAgLy8gVHJhY2UoKHN0ZGVycixcImNvZGUgJWQgYml0cyAlZC0+JWRcXG5cIiwgbSwgdHJlZVttXS5MZW4sIGJpdHMpKTtcbiAgICAgICAgcy5vcHRfbGVuICs9IChiaXRzIC0gdHJlZVttICogMiArIDFdLyouTGVuKi8pICogdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgICAgIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAgIH1cbiAgICAgIG4tLTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBHZW5lcmF0ZSB0aGUgY29kZXMgZm9yIGEgZ2l2ZW4gdHJlZSBhbmQgYml0IGNvdW50cyAod2hpY2ggbmVlZCBub3QgYmVcbiAqIG9wdGltYWwpLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGJpdCBsZW5ndGggc3RhdGlzdGljcyBmb3JcbiAqIHRoZSBnaXZlbiB0cmVlIGFuZCB0aGUgZmllbGQgbGVuIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgZmllbGQgY29kZSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzIG9mIG5vblxuICogICAgIHplcm8gY29kZSBsZW5ndGguXG4gKi9cbmNvbnN0IGdlbl9jb2RlcyA9ICh0cmVlLCBtYXhfY29kZSwgYmxfY291bnQpID0+XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgICAgICAgICAgICAvKiB0aGUgdHJlZSB0byBkZWNvcmF0ZSAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4vLyAgICB1c2hmICpibF9jb3VudDsgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoICovXG57XG4gIGNvbnN0IG5leHRfY29kZSA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpOyAvKiBuZXh0IGNvZGUgdmFsdWUgZm9yIGVhY2ggYml0IGxlbmd0aCAqL1xuICBsZXQgY29kZSA9IDA7ICAgICAgICAgICAgICAvKiBydW5uaW5nIGNvZGUgdmFsdWUgKi9cbiAgbGV0IGJpdHM7ICAgICAgICAgICAgICAgICAgLyogYml0IGluZGV4ICovXG4gIGxldCBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgaW5kZXggKi9cblxuICAvKiBUaGUgZGlzdHJpYnV0aW9uIGNvdW50cyBhcmUgZmlyc3QgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY29kZSB2YWx1ZXNcbiAgICogd2l0aG91dCBiaXQgcmV2ZXJzYWwuXG4gICAqL1xuICBmb3IgKGJpdHMgPSAxOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBuZXh0X2NvZGVbYml0c10gPSBjb2RlID0gKGNvZGUgKyBibF9jb3VudFtiaXRzIC0gMV0pIDw8IDE7XG4gIH1cbiAgLyogQ2hlY2sgdGhhdCB0aGUgYml0IGNvdW50cyBpbiBibF9jb3VudCBhcmUgY29uc2lzdGVudC4gVGhlIGxhc3QgY29kZVxuICAgKiBtdXN0IGJlIGFsbCBvbmVzLlxuICAgKi9cbiAgLy9Bc3NlcnQgKGNvZGUgKyBibF9jb3VudFtNQVhfQklUU10tMSA9PSAoMTw8TUFYX0JJVFMpLTEsXG4gIC8vICAgICAgICBcImluY29uc2lzdGVudCBiaXQgY291bnRzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLFwiXFxuZ2VuX2NvZGVzOiBtYXhfY29kZSAlZCBcIiwgbWF4X2NvZGUpKTtcblxuICBmb3IgKG4gPSAwOyAgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgbGV0IGxlbiA9IHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovO1xuICAgIGlmIChsZW4gPT09IDApIHsgY29udGludWU7IH1cbiAgICAvKiBOb3cgcmV2ZXJzZSB0aGUgYml0cyAqL1xuICAgIHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuZXh0X2NvZGVbbGVuXSsrLCBsZW4pO1xuXG4gICAgLy9UcmFjZWN2KHRyZWUgIT0gc3RhdGljX2x0cmVlLCAoc3RkZXJyLFwiXFxubiAlM2QgJWMgbCAlMmQgYyAlNHggKCV4KSBcIixcbiAgICAvLyAgICAgbiwgKGlzZ3JhcGgobikgPyBuIDogJyAnKSwgbGVuLCB0cmVlW25dLkNvZGUsIG5leHRfY29kZVtsZW5dLTEpKTtcbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHZhcmlvdXMgJ2NvbnN0YW50JyB0YWJsZXMuXG4gKi9cbmNvbnN0IHRyX3N0YXRpY19pbml0ID0gKCkgPT4ge1xuXG4gIGxldCBuOyAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG4gIGxldCBiaXRzOyAgICAgLyogYml0IGNvdW50ZXIgKi9cbiAgbGV0IGxlbmd0aDsgICAvKiBsZW5ndGggdmFsdWUgKi9cbiAgbGV0IGNvZGU7ICAgICAvKiBjb2RlIHZhbHVlICovXG4gIGxldCBkaXN0OyAgICAgLyogZGlzdGFuY2UgaW5kZXggKi9cbiAgY29uc3QgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy8gZG8gY2hlY2sgaW4gX3RyX2luaXQoKVxuICAvL2lmIChzdGF0aWNfaW5pdF9kb25lKSByZXR1cm47XG5cbiAgLyogRm9yIHNvbWUgZW1iZWRkZWQgdGFyZ2V0cywgZ2xvYmFsIHZhcmlhYmxlcyBhcmUgbm90IGluaXRpYWxpemVkOiAqL1xuLyojaWZkZWYgTk9fSU5JVF9HTE9CQUxfUE9JTlRFUlNcbiAgc3RhdGljX2xfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19sdHJlZTtcbiAgc3RhdGljX2xfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfbGJpdHM7XG4gIHN0YXRpY19kX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfZHRyZWU7XG4gIHN0YXRpY19kX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2RiaXRzO1xuICBzdGF0aWNfYmxfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfYmxiaXRzO1xuI2VuZGlmKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGxlbmd0aCAoMC4uMjU1KSAtPiBsZW5ndGggY29kZSAoMC4uMjgpICovXG4gIGxlbmd0aCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCBMRU5HVEhfQ09ERVMgLSAxOyBjb2RlKyspIHtcbiAgICBiYXNlX2xlbmd0aFtjb2RlXSA9IGxlbmd0aDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfbGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9sZW5ndGhfY29kZVtsZW5ndGgrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAobGVuZ3RoID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogbGVuZ3RoICE9IDI1NlwiKTtcbiAgLyogTm90ZSB0aGF0IHRoZSBsZW5ndGggMjU1IChtYXRjaCBsZW5ndGggMjU4KSBjYW4gYmUgcmVwcmVzZW50ZWRcbiAgICogaW4gdHdvIGRpZmZlcmVudCB3YXlzOiBjb2RlIDI4NCArIDUgYml0cyBvciBjb2RlIDI4NSwgc28gd2VcbiAgICogb3ZlcndyaXRlIGxlbmd0aF9jb2RlWzI1NV0gdG8gdXNlIHRoZSBiZXN0IGVuY29kaW5nOlxuICAgKi9cbiAgX2xlbmd0aF9jb2RlW2xlbmd0aCAtIDFdID0gY29kZTtcblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGRpc3QgKDAuLjMySykgLT4gZGlzdCBjb2RlICgwLi4yOSkgKi9cbiAgZGlzdCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCAxNjsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfZGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogZGlzdCAhPSAyNTZcIik7XG4gIGRpc3QgPj49IDc7IC8qIGZyb20gbm93IG9uLCBhbGwgZGlzdGFuY2VzIGFyZSBkaXZpZGVkIGJ5IDEyOCAqL1xuICBmb3IgKDsgY29kZSA8IERfQ09ERVM7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3QgPDwgNztcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgKGV4dHJhX2RiaXRzW2NvZGVdIC0gNykpOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbMjU2ICsgZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogMjU2K2Rpc3QgIT0gNTEyXCIpO1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgY29kZXMgb2YgdGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUgKi9cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgbiA9IDA7XG4gIHdoaWxlIChuIDw9IDE0Mykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI1NSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA5O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs5XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI3OSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA3O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs3XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI4Nykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIC8qIENvZGVzIDI4NiBhbmQgMjg3IGRvIG5vdCBleGlzdCwgYnV0IHdlIG11c3QgaW5jbHVkZSB0aGVtIGluIHRoZVxuICAgKiB0cmVlIGNvbnN0cnVjdGlvbiB0byBnZXQgYSBjYW5vbmljYWwgSHVmZm1hbiB0cmVlIChsb25nZXN0IGNvZGVcbiAgICogYWxsIG9uZXMpXG4gICAqL1xuICBnZW5fY29kZXMoc3RhdGljX2x0cmVlLCBMX0NPREVTICsgMSwgYmxfY291bnQpO1xuXG4gIC8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZSBpcyB0cml2aWFsOiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgbisrKSB7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDU7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobiwgNSk7XG4gIH1cblxuICAvLyBOb3cgZGF0YSByZWFkeSBhbmQgd2UgY2FuIGluaXQgc3RhdGljIHRyZWVzXG4gIHN0YXRpY19sX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2x0cmVlLCBleHRyYV9sYml0cywgTElURVJBTFMgKyAxLCBMX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2R0cmVlLCBleHRyYV9kYml0cywgMCwgICAgICAgICAgRF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfYmxfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhuZXcgQXJyYXkoMCksIGV4dHJhX2JsYml0cywgMCwgICAgICAgICBCTF9DT0RFUywgTUFYX0JMX0JJVFMpO1xuXG4gIC8vc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSBhIG5ldyBibG9jay5cbiAqL1xuY29uc3QgaW5pdF9ibG9jayA9IChzKSA9PiB7XG5cbiAgbGV0IG47IC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIHRyZWVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgTF9DT0RFUzsgIG4rKykgeyBzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyAgbisrKSB7IHMuZHluX2R0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IEJMX0NPREVTOyBuKyspIHsgcy5ibF90cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cblxuICBzLmR5bl9sdHJlZVtFTkRfQkxPQ0sgKiAyXS8qLkZyZXEqLyA9IDE7XG4gIHMub3B0X2xlbiA9IHMuc3RhdGljX2xlbiA9IDA7XG4gIHMubGFzdF9saXQgPSBzLm1hdGNoZXMgPSAwO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyIGFuZCBhbGlnbiB0aGUgb3V0cHV0IG9uIGEgYnl0ZSBib3VuZGFyeVxuICovXG5jb25zdCBiaV93aW5kdXAgPSAocykgPT5cbntcbiAgaWYgKHMuYmlfdmFsaWQgPiA4KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID4gMCkge1xuICAgIC8vcHV0X2J5dGUocywgKEJ5dGUpcy0+YmlfYnVmKTtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmO1xuICB9XG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgYSBzdG9yZWQgYmxvY2ssIHN0b3JpbmcgZmlyc3QgdGhlIGxlbmd0aCBhbmQgaXRzXG4gKiBvbmUncyBjb21wbGVtZW50IGlmIHJlcXVlc3RlZC5cbiAqL1xuY29uc3QgY29weV9ibG9jayA9IChzLCBidWYsIGxlbiwgaGVhZGVyKSA9PlxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICAgICpidWY7ICAgIC8qIHRoZSBpbnB1dCBkYXRhICovXG4vL3Vuc2lnbmVkIGxlbjsgICAgIC8qIGl0cyBsZW5ndGggKi9cbi8vaW50ICAgICAgaGVhZGVyOyAgLyogdHJ1ZSBpZiBibG9jayBoZWFkZXIgbXVzdCBiZSB3cml0dGVuICovXG57XG4gIGJpX3dpbmR1cChzKTsgICAgICAgIC8qIGFsaWduIG9uIGJ5dGUgYm91bmRhcnkgKi9cblxuICBpZiAoaGVhZGVyKSB7XG4gICAgcHV0X3Nob3J0KHMsIGxlbik7XG4gICAgcHV0X3Nob3J0KHMsIH5sZW4pO1xuICB9XG4vLyAgd2hpbGUgKGxlbi0tKSB7XG4vLyAgICBwdXRfYnl0ZShzLCAqYnVmKyspO1xuLy8gIH1cbiAgcy5wZW5kaW5nX2J1Zi5zZXQocy53aW5kb3cuc3ViYXJyYXkoYnVmLCBidWYgKyBsZW4pLCBzLnBlbmRpbmcpO1xuICBzLnBlbmRpbmcgKz0gbGVuO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wYXJlcyB0byBzdWJ0cmVlcywgdXNpbmcgdGhlIHRyZWUgZGVwdGggYXMgdGllIGJyZWFrZXIgd2hlblxuICogdGhlIHN1YnRyZWVzIGhhdmUgZXF1YWwgZnJlcXVlbmN5LiBUaGlzIG1pbmltaXplcyB0aGUgd29yc3QgY2FzZSBsZW5ndGguXG4gKi9cbmNvbnN0IHNtYWxsZXIgPSAodHJlZSwgbiwgbSwgZGVwdGgpID0+IHtcblxuICBjb25zdCBfbjIgPSBuICogMjtcbiAgY29uc3QgX20yID0gbSAqIDI7XG4gIHJldHVybiAodHJlZVtfbjJdLyouRnJlcSovIDwgdHJlZVtfbTJdLyouRnJlcSovIHx8XG4gICAgICAgICAodHJlZVtfbjJdLyouRnJlcSovID09PSB0cmVlW19tMl0vKi5GcmVxKi8gJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV0pKTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVzdG9yZSB0aGUgaGVhcCBwcm9wZXJ0eSBieSBtb3ZpbmcgZG93biB0aGUgdHJlZSBzdGFydGluZyBhdCBub2RlIGssXG4gKiBleGNoYW5naW5nIGEgbm9kZSB3aXRoIHRoZSBzbWFsbGVzdCBvZiBpdHMgdHdvIHNvbnMgaWYgbmVjZXNzYXJ5LCBzdG9wcGluZ1xuICogd2hlbiB0aGUgaGVhcCBwcm9wZXJ0eSBpcyByZS1lc3RhYmxpc2hlZCAoZWFjaCBmYXRoZXIgc21hbGxlciB0aGFuIGl0c1xuICogdHdvIHNvbnMpLlxuICovXG5jb25zdCBwcWRvd25oZWFwID0gKHMsIHRyZWUsIGspID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgIC8qIHRoZSB0cmVlIHRvIHJlc3RvcmUgKi9cbi8vICAgIGludCBrOyAgICAgICAgICAgICAgIC8qIG5vZGUgdG8gbW92ZSBkb3duICovXG57XG4gIGNvbnN0IHYgPSBzLmhlYXBba107XG4gIGxldCBqID0gayA8PCAxOyAgLyogbGVmdCBzb24gb2YgayAqL1xuICB3aGlsZSAoaiA8PSBzLmhlYXBfbGVuKSB7XG4gICAgLyogU2V0IGogdG8gdGhlIHNtYWxsZXN0IG9mIHRoZSB0d28gc29uczogKi9cbiAgICBpZiAoaiA8IHMuaGVhcF9sZW4gJiZcbiAgICAgIHNtYWxsZXIodHJlZSwgcy5oZWFwW2ogKyAxXSwgcy5oZWFwW2pdLCBzLmRlcHRoKSkge1xuICAgICAgaisrO1xuICAgIH1cbiAgICAvKiBFeGl0IGlmIHYgaXMgc21hbGxlciB0aGFuIGJvdGggc29ucyAqL1xuICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsgYnJlYWs7IH1cblxuICAgIC8qIEV4Y2hhbmdlIHYgd2l0aCB0aGUgc21hbGxlc3Qgc29uICovXG4gICAgcy5oZWFwW2tdID0gcy5oZWFwW2pdO1xuICAgIGsgPSBqO1xuXG4gICAgLyogQW5kIGNvbnRpbnVlIGRvd24gdGhlIHRyZWUsIHNldHRpbmcgaiB0byB0aGUgbGVmdCBzb24gb2YgayAqL1xuICAgIGogPDw9IDE7XG4gIH1cbiAgcy5oZWFwW2tdID0gdjtcbn07XG5cblxuLy8gaW5saW5lZCBtYW51YWxseVxuLy8gY29uc3QgU01BTExFU1QgPSAxO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGJsb2NrIGRhdGEgY29tcHJlc3NlZCB1c2luZyB0aGUgZ2l2ZW4gSHVmZm1hbiB0cmVlc1xuICovXG5jb25zdCBjb21wcmVzc19ibG9jayA9IChzLCBsdHJlZSwgZHRyZWUpID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY29uc3QgY3RfZGF0YSAqbHRyZWU7IC8qIGxpdGVyYWwgdHJlZSAqL1xuLy8gICAgY29uc3QgY3RfZGF0YSAqZHRyZWU7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbntcbiAgbGV0IGRpc3Q7ICAgICAgICAgICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuICBsZXQgbGM7ICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdCA9PSAwKSAqL1xuICBsZXQgbHggPSAwOyAgICAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cbiAgbGV0IGNvZGU7ICAgICAgICAgICAvKiB0aGUgY29kZSB0byBzZW5kICovXG4gIGxldCBleHRyYTsgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgdG8gc2VuZCAqL1xuXG4gIGlmIChzLmxhc3RfbGl0ICE9PSAwKSB7XG4gICAgZG8ge1xuICAgICAgZGlzdCA9IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDJdIDw8IDgpIHwgKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMiArIDFdKTtcbiAgICAgIGxjID0gcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgbHhdO1xuICAgICAgbHgrKztcblxuICAgICAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGxjLCBsdHJlZSk7IC8qIHNlbmQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgICAgLy9UcmFjZWN2KGlzZ3JhcGgobGMpLCAoc3RkZXJyLFwiICclYycgXCIsIGxjKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgICAgIGNvZGUgPSBfbGVuZ3RoX2NvZGVbbGNdO1xuICAgICAgICBzZW5kX2NvZGUocywgY29kZSArIExJVEVSQUxTICsgMSwgbHRyZWUpOyAvKiBzZW5kIHRoZSBsZW5ndGggY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2xiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBsYyAtPSBiYXNlX2xlbmd0aFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgbGMsIGV4dHJhKTsgICAgICAgLyogc2VuZCB0aGUgZXh0cmEgbGVuZ3RoIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgICBkaXN0LS07IC8qIGRpc3QgaXMgbm93IHRoZSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAgICAgY29kZSA9IGRfY29kZShkaXN0KTtcbiAgICAgICAgLy9Bc3NlcnQgKGNvZGUgPCBEX0NPREVTLCBcImJhZCBkX2NvZGVcIik7XG5cbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUsIGR0cmVlKTsgICAgICAgLyogc2VuZCB0aGUgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2RiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBkaXN0IC09IGJhc2VfZGlzdFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgZGlzdCwgZXh0cmEpOyAgIC8qIHNlbmQgdGhlIGV4dHJhIGRpc3RhbmNlIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgfSAvKiBsaXRlcmFsIG9yIG1hdGNoIHBhaXIgPyAqL1xuXG4gICAgICAvKiBDaGVjayB0aGF0IHRoZSBvdmVybGF5IGJldHdlZW4gcGVuZGluZ19idWYgYW5kIGRfYnVmK2xfYnVmIGlzIG9rOiAqL1xuICAgICAgLy9Bc3NlcnQoKHVJbnQpKHMtPnBlbmRpbmcpIDwgcy0+bGl0X2J1ZnNpemUgKyAyKmx4LFxuICAgICAgLy8gICAgICAgXCJwZW5kaW5nQnVmIG92ZXJmbG93XCIpO1xuXG4gICAgfSB3aGlsZSAobHggPCBzLmxhc3RfbGl0KTtcbiAgfVxuXG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIGx0cmVlKTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3Qgb25lIEh1ZmZtYW4gdHJlZSBhbmQgYXNzaWducyB0aGUgY29kZSBiaXQgc3RyaW5ncyBhbmQgbGVuZ3Rocy5cbiAqIFVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aCBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZCBmcmVxIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkcyBsZW4gYW5kIGNvZGUgYXJlIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoXG4gKiAgICAgYW5kIGNvcnJlc3BvbmRpbmcgY29kZS4gVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXNcbiAqICAgICBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXMgbm90IG51bGwuIFRoZSBmaWVsZCBtYXhfY29kZSBpcyBzZXQuXG4gKi9cbmNvbnN0IGJ1aWxkX3RyZWUgPSAocywgZGVzYykgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7IC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgY29uc3QgdHJlZSAgICAgPSBkZXNjLmR5bl90cmVlO1xuICBjb25zdCBzdHJlZSAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICBjb25zdCBoYXNfc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIGNvbnN0IGVsZW1zICAgID0gZGVzYy5zdGF0X2Rlc2MuZWxlbXM7XG4gIGxldCBuLCBtOyAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgaGVhcCBlbGVtZW50cyAqL1xuICBsZXQgbWF4X2NvZGUgPSAtMTsgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIGxldCBub2RlOyAgICAgICAgICAvKiBuZXcgbm9kZSBiZWluZyBjcmVhdGVkICovXG5cbiAgLyogQ29uc3RydWN0IHRoZSBpbml0aWFsIGhlYXAsIHdpdGggbGVhc3QgZnJlcXVlbnQgZWxlbWVudCBpblxuICAgKiBoZWFwW1NNQUxMRVNUXS4gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS5cbiAgICogaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICovXG4gIHMuaGVhcF9sZW4gPSAwO1xuICBzLmhlYXBfbWF4ID0gSEVBUF9TSVpFO1xuXG4gIGZvciAobiA9IDA7IG4gPCBlbGVtczsgbisrKSB7XG4gICAgaWYgKHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlID0gbjtcbiAgICAgIHMuZGVwdGhbbl0gPSAwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gMDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGUgcGt6aXAgZm9ybWF0IHJlcXVpcmVzIHRoYXQgYXQgbGVhc3Qgb25lIGRpc3RhbmNlIGNvZGUgZXhpc3RzLFxuICAgKiBhbmQgdGhhdCBhdCBsZWFzdCBvbmUgYml0IHNob3VsZCBiZSBzZW50IGV2ZW4gaWYgdGhlcmUgaXMgb25seSBvbmVcbiAgICogcG9zc2libGUgY29kZS4gU28gdG8gYXZvaWQgc3BlY2lhbCBjaGVja3MgbGF0ZXIgb24gd2UgZm9yY2UgYXQgbGVhc3RcbiAgICogdHdvIGNvZGVzIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeS5cbiAgICovXG4gIHdoaWxlIChzLmhlYXBfbGVuIDwgMikge1xuICAgIG5vZGUgPSBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IChtYXhfY29kZSA8IDIgPyArK21heF9jb2RlIDogMCk7XG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSAxO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAwO1xuICAgIHMub3B0X2xlbi0tO1xuXG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuIC09IHN0cmVlW25vZGUgKiAyICsgMV0vKi5MZW4qLztcbiAgICB9XG4gICAgLyogbm9kZSBpcyAwIG9yIDEgc28gaXQgZG9lcyBub3QgaGF2ZSBleHRyYSBiaXRzICovXG4gIH1cbiAgZGVzYy5tYXhfY29kZSA9IG1heF9jb2RlO1xuXG4gIC8qIFRoZSBlbGVtZW50cyBoZWFwW2hlYXBfbGVuLzIrMSAuLiBoZWFwX2xlbl0gYXJlIGxlYXZlcyBvZiB0aGUgdHJlZSxcbiAgICogZXN0YWJsaXNoIHN1Yi1oZWFwcyBvZiBpbmNyZWFzaW5nIGxlbmd0aHM6XG4gICAqL1xuICBmb3IgKG4gPSAocy5oZWFwX2xlbiA+PiAxLyppbnQgLzIqLyk7IG4gPj0gMTsgbi0tKSB7IHBxZG93bmhlYXAocywgdHJlZSwgbik7IH1cblxuICAvKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBieSByZXBlYXRlZGx5IGNvbWJpbmluZyB0aGUgbGVhc3QgdHdvXG4gICAqIGZyZXF1ZW50IG5vZGVzLlxuICAgKi9cbiAgbm9kZSA9IGVsZW1zOyAgICAgICAgICAgICAgLyogbmV4dCBpbnRlcm5hbCBub2RlIG9mIHRoZSB0cmVlICovXG4gIGRvIHtcbiAgICAvL3BxcmVtb3ZlKHMsIHRyZWUsIG4pOyAgLyogbiA9IG5vZGUgb2YgbGVhc3QgZnJlcXVlbmN5ICovXG4gICAgLyoqKiBwcXJlbW92ZSAqKiovXG4gICAgbiA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBzLmhlYXBbcy5oZWFwX2xlbi0tXTtcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuICAgIC8qKiovXG5cbiAgICBtID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dOyAvKiBtID0gbm9kZSBvZiBuZXh0IGxlYXN0IGZyZXF1ZW5jeSAqL1xuXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOyAvKiBrZWVwIHRoZSBub2RlcyBzb3J0ZWQgYnkgZnJlcXVlbmN5ICovXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBtO1xuXG4gICAgLyogQ3JlYXRlIGEgbmV3IG5vZGUgZmF0aGVyIG9mIG4gYW5kIG0gKi9cbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IHRyZWVbbiAqIDJdLyouRnJlcSovICsgdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgcy5kZXB0aFtub2RlXSA9IChzLmRlcHRoW25dID49IHMuZGVwdGhbbV0gPyBzLmRlcHRoW25dIDogcy5kZXB0aFttXSkgKyAxO1xuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkRhZCovID0gdHJlZVttICogMiArIDFdLyouRGFkKi8gPSBub2RlO1xuXG4gICAgLyogYW5kIGluc2VydCB0aGUgbmV3IG5vZGUgaW4gdGhlIGhlYXAgKi9cbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBub2RlKys7XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcblxuICB9IHdoaWxlIChzLmhlYXBfbGVuID49IDIpO1xuXG4gIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuXG4gIC8qIEF0IHRoaXMgcG9pbnQsIHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQuIFdlIGNhbiBub3dcbiAgICogZ2VuZXJhdGUgdGhlIGJpdCBsZW5ndGhzLlxuICAgKi9cbiAgZ2VuX2JpdGxlbihzLCBkZXNjKTtcblxuICAvKiBUaGUgZmllbGQgbGVuIGlzIG5vdyBzZXQsIHdlIGNhbiBnZW5lcmF0ZSB0aGUgYml0IGNvZGVzICovXG4gIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgcy5ibF9jb3VudCk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2NhbiBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSB0byBkZXRlcm1pbmUgdGhlIGZyZXF1ZW5jaWVzIG9mIHRoZSBjb2Rlc1xuICogaW4gdGhlIGJpdCBsZW5ndGggdHJlZS5cbiAqL1xuY29uc3Qgc2Nhbl90cmVlID0gKHMsIHRyZWUsIG1heF9jb2RlKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgbGV0IG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICBsZXQgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIGxldCBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICBsZXQgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgbGV0IGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgbGV0IG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICBsZXQgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuICB0cmVlWyhtYXhfY29kZSArIDEpICogMiArIDFdLyouTGVuKi8gPSAweGZmZmY7IC8qIGd1YXJkICovXG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovICs9IGNvdW50O1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcblxuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikgeyBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8rKzsgfVxuICAgICAgcy5ibF90cmVlW1JFUF8zXzYgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgcy5ibF90cmVlW1JFUFpfM18xMCAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcy5ibF90cmVlW1JFUFpfMTFfMTM4ICogMl0vKi5GcmVxKi8rKztcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcblxuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgaW4gY29tcHJlc3NlZCBmb3JtLCB1c2luZyB0aGUgY29kZXMgaW5cbiAqIGJsX3RyZWUuXG4gKi9cbmNvbnN0IHNlbmRfdHJlZSA9IChzLCB0cmVlLCBtYXhfY29kZSkgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICBsZXQgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIGxldCBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgbGV0IGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIGxldCBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICBsZXQgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICBsZXQgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIGxldCBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICAvKiB0cmVlW21heF9jb2RlKzFdLkxlbiA9IC0xOyAqLyAgLyogZ3VhcmQgYWxyZWFkeSBzZXQgKi9cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIGRvIHsgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsgfSB3aGlsZSAoLS1jb3VudCAhPT0gMCk7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikge1xuICAgICAgICBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpO1xuICAgICAgICBjb3VudC0tO1xuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoY291bnQgPj0gMyAmJiBjb3VudCA8PSA2LCBcIiAzXzY/XCIpO1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUF8zXzYsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAyKTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzNfMTAsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8xMV8xMzgsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAxMSwgNyk7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgZm9yIHRoZSBiaXQgbGVuZ3RocyBhbmQgcmV0dXJuIHRoZSBpbmRleCBpblxuICogYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gKi9cbmNvbnN0IGJ1aWxkX2JsX3RyZWUgPSAocykgPT4ge1xuXG4gIGxldCBtYXhfYmxpbmRleDsgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIGJpdCBsZW5ndGggZnJlcXVlbmNpZXMgZm9yIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gIHNjYW5fdHJlZShzLCBzLmR5bl9sdHJlZSwgcy5sX2Rlc2MubWF4X2NvZGUpO1xuICBzY2FuX3RyZWUocywgcy5keW5fZHRyZWUsIHMuZF9kZXNjLm1heF9jb2RlKTtcblxuICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlOiAqL1xuICBidWlsZF90cmVlKHMsIHMuYmxfZGVzYyk7XG4gIC8qIG9wdF9sZW4gbm93IGluY2x1ZGVzIHRoZSBsZW5ndGggb2YgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLCBleGNlcHRcbiAgICogdGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGhzIGNvZGVzIGFuZCB0aGUgNSs1KzQgYml0cyBmb3IgdGhlIGNvdW50cy5cbiAgICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYml0IGxlbmd0aCBjb2RlcyB0byBzZW5kLiBUaGUgcGt6aXAgZm9ybWF0XG4gICAqIHJlcXVpcmVzIHRoYXQgYXQgbGVhc3QgNCBiaXQgbGVuZ3RoIGNvZGVzIGJlIHNlbnQuIChhcHBub3RlLnR4dCBzYXlzXG4gICAqIDMgYnV0IHRoZSBhY3R1YWwgdmFsdWUgdXNlZCBpcyA0LilcbiAgICovXG4gIGZvciAobWF4X2JsaW5kZXggPSBCTF9DT0RFUyAtIDE7IG1heF9ibGluZGV4ID49IDM7IG1heF9ibGluZGV4LS0pIHtcbiAgICBpZiAocy5ibF90cmVlW2JsX29yZGVyW21heF9ibGluZGV4XSAqIDIgKyAxXS8qLkxlbiovICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLyogVXBkYXRlIG9wdF9sZW4gdG8gaW5jbHVkZSB0aGUgYml0IGxlbmd0aCB0cmVlIGFuZCBjb3VudHMgKi9cbiAgcy5vcHRfbGVuICs9IDMgKiAobWF4X2JsaW5kZXggKyAxKSArIDUgKyA1ICsgNDtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5keW4gdHJlZXM6IGR5biAlbGQsIHN0YXQgJWxkXCIsXG4gIC8vICAgICAgICBzLT5vcHRfbGVuLCBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgcmV0dXJuIG1heF9ibGluZGV4O1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGhlYWRlciBmb3IgYSBibG9jayB1c2luZyBkeW5hbWljIEh1ZmZtYW4gdHJlZXM6IHRoZSBjb3VudHMsIHRoZVxuICogbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcywgdGhlIGxpdGVyYWwgdHJlZSBhbmQgdGhlIGRpc3RhbmNlIHRyZWUuXG4gKiBJTiBhc3NlcnRpb246IGxjb2RlcyA+PSAyNTcsIGRjb2RlcyA+PSAxLCBibGNvZGVzID49IDQuXG4gKi9cbmNvbnN0IHNlbmRfYWxsX3RyZWVzID0gKHMsIGxjb2RlcywgZGNvZGVzLCBibGNvZGVzKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGludCBsY29kZXMsIGRjb2RlcywgYmxjb2RlczsgLyogbnVtYmVyIG9mIGNvZGVzIGZvciBlYWNoIHRyZWUgKi9cbntcbiAgbGV0IHJhbms7ICAgICAgICAgICAgICAgICAgICAvKiBpbmRleCBpbiBibF9vcmRlciAqL1xuXG4gIC8vQXNzZXJ0IChsY29kZXMgPj0gMjU3ICYmIGRjb2RlcyA+PSAxICYmIGJsY29kZXMgPj0gNCwgXCJub3QgZW5vdWdoIGNvZGVzXCIpO1xuICAvL0Fzc2VydCAobGNvZGVzIDw9IExfQ09ERVMgJiYgZGNvZGVzIDw9IERfQ09ERVMgJiYgYmxjb2RlcyA8PSBCTF9DT0RFUyxcbiAgLy8gICAgICAgIFwidG9vIG1hbnkgY29kZXNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY291bnRzOiBcIikpO1xuICBzZW5kX2JpdHMocywgbGNvZGVzIC0gMjU3LCA1KTsgLyogbm90ICsyNTUgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIHNlbmRfYml0cyhzLCBkY29kZXMgLSAxLCAgIDUpO1xuICBzZW5kX2JpdHMocywgYmxjb2RlcyAtIDQsICA0KTsgLyogbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBmb3IgKHJhbmsgPSAwOyByYW5rIDwgYmxjb2RlczsgcmFuaysrKSB7XG4gICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb2RlICUyZCBcIiwgYmxfb3JkZXJbcmFua10pKTtcbiAgICBzZW5kX2JpdHMocywgcy5ibF90cmVlW2JsX29yZGVyW3JhbmtdICogMiArIDFdLyouTGVuKi8sIDMpO1xuICB9XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2x0cmVlLCBsY29kZXMgLSAxKTsgLyogbGl0ZXJhbCB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9kdHJlZSwgZGNvZGVzIC0gMSk7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENoZWNrIGlmIHRoZSBkYXRhIHR5cGUgaXMgVEVYVCBvciBCSU5BUlksIHVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICogLSBURVhUIGlmIHRoZSB0d28gY29uZGl0aW9ucyBiZWxvdyBhcmUgc2F0aXNmaWVkOlxuICogICAgYSkgVGhlcmUgYXJlIG5vIG5vbi1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJibGFjayBsaXN0XCIgKDAuLjYsIDE0Li4yNSwgMjguLjMxKS5cbiAqICAgIGIpIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwcmludGFibGUgY2hhcmFjdGVyIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwid2hpdGUgbGlzdFwiICg5IHtUQUJ9LCAxMCB7TEZ9LCAxMyB7Q1J9LCAzMi4uMjU1KS5cbiAqIC0gQklOQVJZIG90aGVyd2lzZS5cbiAqIC0gVGhlIGZvbGxvd2luZyBwYXJ0aWFsbHktcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGZvcm0gYVxuICogICBcImdyYXkgbGlzdFwiIHRoYXQgaXMgaWdub3JlZCBpbiB0aGlzIGRldGVjdGlvbiBhbGdvcml0aG06XG4gKiAgICg3IHtCRUx9LCA4IHtCU30sIDExIHtWVH0sIDEyIHtGRn0sIDI2IHtTVUJ9LCAyNyB7RVNDfSkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgRnJlcSBvZiBkeW5fbHRyZWUgYXJlIHNldC5cbiAqL1xuY29uc3QgZGV0ZWN0X2RhdGFfdHlwZSA9IChzKSA9PiB7XG4gIC8qIGJsYWNrX21hc2sgaXMgdGhlIGJpdCBtYXNrIG9mIGJsYWNrLWxpc3RlZCBieXRlc1xuICAgKiBzZXQgYml0cyAwLi42LCAxNC4uMjUsIGFuZCAyOC4uMzFcbiAgICogMHhmM2ZmYzA3ZiA9IGJpbmFyeSAxMTExMDAxMTExMTExMTExMTEwMDAwMDAwMTExMTExMVxuICAgKi9cbiAgbGV0IGJsYWNrX21hc2sgPSAweGYzZmZjMDdmO1xuICBsZXQgbjtcblxuICAvKiBDaGVjayBmb3Igbm9uLXRleHR1YWwgKFwiYmxhY2stbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDw9IDMxOyBuKyssIGJsYWNrX21hc2sgPj4+PSAxKSB7XG4gICAgaWYgKChibGFja19tYXNrICYgMSkgJiYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkpIHtcbiAgICAgIHJldHVybiBaX0JJTkFSWTtcbiAgICB9XG4gIH1cblxuICAvKiBDaGVjayBmb3IgdGV4dHVhbCAoXCJ3aGl0ZS1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGlmIChzLmR5bl9sdHJlZVs5ICogMl0vKi5GcmVxKi8gIT09IDAgfHwgcy5keW5fbHRyZWVbMTAgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fFxuICAgICAgcy5keW5fbHRyZWVbMTMgKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgIHJldHVybiBaX1RFWFQ7XG4gIH1cbiAgZm9yIChuID0gMzI7IG4gPCBMSVRFUkFMUzsgbisrKSB7XG4gICAgaWYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcmV0dXJuIFpfVEVYVDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGVyZSBhcmUgbm8gXCJibGFjay1saXN0ZWRcIiBvciBcIndoaXRlLWxpc3RlZFwiIGJ5dGVzOlxuICAgKiB0aGlzIHN0cmVhbSBlaXRoZXIgaXMgZW1wdHkgb3IgaGFzIHRvbGVyYXRlZCAoXCJncmF5LWxpc3RlZFwiKSBieXRlcyBvbmx5LlxuICAgKi9cbiAgcmV0dXJuIFpfQklOQVJZO1xufTtcblxuXG5sZXQgc3RhdGljX2luaXRfZG9uZSA9IGZhbHNlO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHRyZWUgZGF0YSBzdHJ1Y3R1cmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbS5cbiAqL1xuY29uc3QgX3RyX2luaXQgPSAocykgPT5cbntcblxuICBpZiAoIXN0YXRpY19pbml0X2RvbmUpIHtcbiAgICB0cl9zdGF0aWNfaW5pdCgpO1xuICAgIHN0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xuICB9XG5cbiAgcy5sX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2x0cmVlLCBzdGF0aWNfbF9kZXNjKTtcbiAgcy5kX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2R0cmVlLCBzdGF0aWNfZF9kZXNjKTtcbiAgcy5ibF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuYmxfdHJlZSwgc3RhdGljX2JsX2Rlc2MpO1xuXG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgZmlyc3QgYmxvY2sgb2YgdGhlIGZpcnN0IGZpbGU6ICovXG4gIGluaXRfYmxvY2socyk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHN0b3JlZCBibG9ja1xuICovXG5jb25zdCBfdHJfc3RvcmVkX2Jsb2NrID0gKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCkgPT5cbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jayAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICBzZW5kX2JpdHMocywgKFNUT1JFRF9CTE9DSyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsgICAgLyogc2VuZCBibG9jayB0eXBlICovXG4gIGNvcHlfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCB0cnVlKTsgLyogd2l0aCBoZWFkZXIgKi9cbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIG9uZSBlbXB0eSBzdGF0aWMgYmxvY2sgdG8gZ2l2ZSBlbm91Z2ggbG9va2FoZWFkIGZvciBpbmZsYXRlLlxuICogVGhpcyB0YWtlcyAxMCBiaXRzLCBvZiB3aGljaCA3IG1heSByZW1haW4gaW4gdGhlIGJpdCBidWZmZXIuXG4gKi9cbmNvbnN0IF90cl9hbGlnbiA9IChzKSA9PiB7XG4gIHNlbmRfYml0cyhzLCBTVEFUSUNfVFJFRVMgPDwgMSwgMyk7XG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIHN0YXRpY19sdHJlZSk7XG4gIGJpX2ZsdXNoKHMpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZyBmb3IgdGhlIGN1cnJlbnQgYmxvY2s6IGR5bmFtaWMgdHJlZXMsIHN0YXRpY1xuICogdHJlZXMgb3Igc3RvcmUsIGFuZCBvdXRwdXQgdGhlIGVuY29kZWQgYmxvY2sgdG8gdGhlIHppcCBmaWxlLlxuICovXG5jb25zdCBfdHJfZmx1c2hfYmxvY2sgPSAocywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KSA9PlxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrLCBvciBOVUxMIGlmIHRvbyBvbGQgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgbGV0IG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsgIC8qIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gaW4gYnl0ZXMgKi9cbiAgbGV0IG1heF9ibGluZGV4ID0gMDsgICAgICAgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBCdWlsZCB0aGUgSHVmZm1hbiB0cmVlcyB1bmxlc3MgYSBzdG9yZWQgYmxvY2sgaXMgZm9yY2VkICovXG4gIGlmIChzLmxldmVsID4gMCkge1xuXG4gICAgLyogQ2hlY2sgaWYgdGhlIGZpbGUgaXMgYmluYXJ5IG9yIHRleHQgKi9cbiAgICBpZiAocy5zdHJtLmRhdGFfdHlwZSA9PT0gWl9VTktOT1dOKSB7XG4gICAgICBzLnN0cm0uZGF0YV90eXBlID0gZGV0ZWN0X2RhdGFfdHlwZShzKTtcbiAgICB9XG5cbiAgICAvKiBDb25zdHJ1Y3QgdGhlIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gICAgYnVpbGRfdHJlZShzLCBzLmxfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcblxuICAgIGJ1aWxkX3RyZWUocywgcy5kX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuICAgIC8qIEF0IHRoaXMgcG9pbnQsIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gYXJlIHRoZSB0b3RhbCBiaXQgbGVuZ3RocyBvZlxuICAgICAqIHRoZSBjb21wcmVzc2VkIGJsb2NrIGRhdGEsIGV4Y2x1ZGluZyB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG5cbiAgICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlIGZvciB0aGUgYWJvdmUgdHdvIHRyZWVzLCBhbmQgZ2V0IHRoZSBpbmRleFxuICAgICAqIGluIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICAgICAqL1xuICAgIG1heF9ibGluZGV4ID0gYnVpbGRfYmxfdHJlZShzKTtcblxuICAgIC8qIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZy4gQ29tcHV0ZSB0aGUgYmxvY2sgbGVuZ3RocyBpbiBieXRlcy4gKi9cbiAgICBvcHRfbGVuYiA9IChzLm9wdF9sZW4gKyAzICsgNykgPj4+IDM7XG4gICAgc3RhdGljX2xlbmIgPSAocy5zdGF0aWNfbGVuICsgMyArIDcpID4+PiAzO1xuXG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxub3B0ICVsdSglbHUpIHN0YXQgJWx1KCVsdSkgc3RvcmVkICVsdSBsaXQgJXUgXCIsXG4gICAgLy8gICAgICAgIG9wdF9sZW5iLCBzLT5vcHRfbGVuLCBzdGF0aWNfbGVuYiwgcy0+c3RhdGljX2xlbiwgc3RvcmVkX2xlbixcbiAgICAvLyAgICAgICAgcy0+bGFzdF9saXQpKTtcblxuICAgIGlmIChzdGF0aWNfbGVuYiA8PSBvcHRfbGVuYikgeyBvcHRfbGVuYiA9IHN0YXRpY19sZW5iOyB9XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBBc3NlcnQoYnVmICE9IChjaGFyKikwLCBcImxvc3QgYnVmXCIpO1xuICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsgLyogZm9yY2UgYSBzdG9yZWQgYmxvY2sgKi9cbiAgfVxuXG4gIGlmICgoc3RvcmVkX2xlbiArIDQgPD0gb3B0X2xlbmIpICYmIChidWYgIT09IC0xKSkge1xuICAgIC8qIDQ6IHR3byB3b3JkcyBmb3IgdGhlIGxlbmd0aHMgKi9cblxuICAgIC8qIFRoZSB0ZXN0IGJ1ZiAhPSBOVUxMIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIExJVF9CVUZTSVpFID4gV1NJWkUuXG4gICAgICogT3RoZXJ3aXNlIHdlIGNhbid0IGhhdmUgcHJvY2Vzc2VkIG1vcmUgdGhhbiBXU0laRSBpbnB1dCBieXRlcyBzaW5jZVxuICAgICAqIHRoZSBsYXN0IGJsb2NrIGZsdXNoLCBiZWNhdXNlIGNvbXByZXNzaW9uIHdvdWxkIGhhdmUgYmVlblxuICAgICAqIHN1Y2Nlc3NmdWwuIElmIExJVF9CVUZTSVpFIDw9IFdTSVpFLCBpdCBpcyBuZXZlciB0b28gbGF0ZSB0b1xuICAgICAqIHRyYW5zZm9ybSBhIGJsb2NrIGludG8gYSBzdG9yZWQgYmxvY2suXG4gICAgICovXG4gICAgX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpO1xuXG4gIH0gZWxzZSBpZiAocy5zdHJhdGVneSA9PT0gWl9GSVhFRCB8fCBzdGF0aWNfbGVuYiA9PT0gb3B0X2xlbmIpIHtcblxuICAgIHNlbmRfYml0cyhzLCAoU1RBVElDX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHN0YXRpY19sdHJlZSwgc3RhdGljX2R0cmVlKTtcblxuICB9IGVsc2Uge1xuICAgIHNlbmRfYml0cyhzLCAoRFlOX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIHNlbmRfYWxsX3RyZWVzKHMsIHMubF9kZXNjLm1heF9jb2RlICsgMSwgcy5kX2Rlc2MubWF4X2NvZGUgKyAxLCBtYXhfYmxpbmRleCArIDEpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHMuZHluX2x0cmVlLCBzLmR5bl9kdHJlZSk7XG4gIH1cbiAgLy8gQXNzZXJ0IChzLT5jb21wcmVzc2VkX2xlbiA9PSBzLT5iaXRzX3NlbnQsIFwiYmFkIGNvbXByZXNzZWQgc2l6ZVwiKTtcbiAgLyogVGhlIGFib3ZlIGNoZWNrIGlzIG1hZGUgbW9kIDJeMzIsIGZvciBmaWxlcyBsYXJnZXIgdGhhbiA1MTIgTUJcbiAgICogYW5kIHVMb25nIGltcGxlbWVudGVkIG9uIDMyIGJpdHMuXG4gICAqL1xuICBpbml0X2Jsb2NrKHMpO1xuXG4gIGlmIChsYXN0KSB7XG4gICAgYmlfd2luZHVwKHMpO1xuICB9XG4gIC8vIFRyYWNldigoc3RkZXJyLFwiXFxuY29tcHJsZW4gJWx1KCVsdSkgXCIsIHMtPmNvbXByZXNzZWRfbGVuPj4zLFxuICAvLyAgICAgICBzLT5jb21wcmVzc2VkX2xlbi03Kmxhc3QpKTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2F2ZSB0aGUgbWF0Y2ggaW5mbyBhbmQgdGFsbHkgdGhlIGZyZXF1ZW5jeSBjb3VudHMuIFJldHVybiB0cnVlIGlmXG4gKiB0aGUgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQuXG4gKi9cbmNvbnN0IF90cl90YWxseSA9IChzLCBkaXN0LCBsYykgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB1bnNpZ25lZCBkaXN0OyAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbi8vICAgIHVuc2lnbmVkIGxjOyAgICAvKiBtYXRjaCBsZW5ndGgtTUlOX01BVENIIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0PT0wKSAqL1xue1xuICAvL2xldCBvdXRfbGVuZ3RoLCBpbl9sZW5ndGgsIGRjb2RlO1xuXG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyXSAgICAgPSAoZGlzdCA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMiArIDFdID0gZGlzdCAmIDB4ZmY7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgcy5sYXN0X2xpdF0gPSBsYyAmIDB4ZmY7XG4gIHMubGFzdF9saXQrKztcblxuICBpZiAoZGlzdCA9PT0gMCkge1xuICAgIC8qIGxjIGlzIHRoZSB1bm1hdGNoZWQgY2hhciAqL1xuICAgIHMuZHluX2x0cmVlW2xjICogMl0vKi5GcmVxKi8rKztcbiAgfSBlbHNlIHtcbiAgICBzLm1hdGNoZXMrKztcbiAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgZGlzdC0tOyAgICAgICAgICAgICAvKiBkaXN0ID0gbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgLy9Bc3NlcnQoKHVzaClkaXN0IDwgKHVzaClNQVhfRElTVChzKSAmJlxuICAgIC8vICAgICAgICh1c2gpbGMgPD0gKHVzaCkoTUFYX01BVENILU1JTl9NQVRDSCkgJiZcbiAgICAvLyAgICAgICAodXNoKWRfY29kZShkaXN0KSA8ICh1c2gpRF9DT0RFUywgIFwiX3RyX3RhbGx5OiBiYWQgbWF0Y2hcIik7XG5cbiAgICBzLmR5bl9sdHJlZVsoX2xlbmd0aF9jb2RlW2xjXSArIExJVEVSQUxTICsgMSkgKiAyXS8qLkZyZXEqLysrO1xuICAgIHMuZHluX2R0cmVlW2RfY29kZShkaXN0KSAqIDJdLyouRnJlcSovKys7XG4gIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcblxuLy8jaWZkZWYgVFJVTkNBVEVfQkxPQ0tcbi8vICAvKiBUcnkgdG8gZ3Vlc3MgaWYgaXQgaXMgcHJvZml0YWJsZSB0byBzdG9wIHRoZSBjdXJyZW50IGJsb2NrIGhlcmUgKi9cbi8vICBpZiAoKHMubGFzdF9saXQgJiAweDFmZmYpID09PSAwICYmIHMubGV2ZWwgPiAyKSB7XG4vLyAgICAvKiBDb21wdXRlIGFuIHVwcGVyIGJvdW5kIGZvciB0aGUgY29tcHJlc3NlZCBsZW5ndGggKi9cbi8vICAgIG91dF9sZW5ndGggPSBzLmxhc3RfbGl0Kjg7XG4vLyAgICBpbl9sZW5ndGggPSBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydDtcbi8vXG4vLyAgICBmb3IgKGRjb2RlID0gMDsgZGNvZGUgPCBEX0NPREVTOyBkY29kZSsrKSB7XG4vLyAgICAgIG91dF9sZW5ndGggKz0gcy5keW5fZHRyZWVbZGNvZGUqMl0vKi5GcmVxKi8gKiAoNSArIGV4dHJhX2RiaXRzW2Rjb2RlXSk7XG4vLyAgICB9XG4vLyAgICBvdXRfbGVuZ3RoID4+Pj0gMztcbi8vICAgIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5sYXN0X2xpdCAldSwgaW4gJWxkLCBvdXQgfiVsZCglbGQlJSkgXCIsXG4vLyAgICAvLyAgICAgICBzLT5sYXN0X2xpdCwgaW5fbGVuZ3RoLCBvdXRfbGVuZ3RoLFxuLy8gICAgLy8gICAgICAgMTAwTCAtIG91dF9sZW5ndGgqMTAwTC9pbl9sZW5ndGgpKTtcbi8vICAgIGlmIChzLm1hdGNoZXMgPCAocy5sYXN0X2xpdD4+MSkvKmludCAvMiovICYmIG91dF9sZW5ndGggPCAoaW5fbGVuZ3RoPj4xKS8qaW50IC8yKi8pIHtcbi8vICAgICAgcmV0dXJuIHRydWU7XG4vLyAgICB9XG4vLyAgfVxuLy8jZW5kaWZcblxuICByZXR1cm4gKHMubGFzdF9saXQgPT09IHMubGl0X2J1ZnNpemUgLSAxKTtcbiAgLyogV2UgYXZvaWQgZXF1YWxpdHkgd2l0aCBsaXRfYnVmc2l6ZSBiZWNhdXNlIG9mIHdyYXBhcm91bmQgYXQgNjRLXG4gICAqIG9uIDE2IGJpdCBtYWNoaW5lcyBhbmQgYmVjYXVzZSBzdG9yZWQgYmxvY2tzIGFyZSByZXN0cmljdGVkIHRvXG4gICAqIDY0Sy0xIGJ5dGVzLlxuICAgKi9cbn07XG5cbnZhciBfdHJfaW5pdF8xICA9IF90cl9pbml0O1xudmFyIF90cl9zdG9yZWRfYmxvY2tfMSA9IF90cl9zdG9yZWRfYmxvY2s7XG52YXIgX3RyX2ZsdXNoX2Jsb2NrXzEgID0gX3RyX2ZsdXNoX2Jsb2NrO1xudmFyIF90cl90YWxseV8xID0gX3RyX3RhbGx5O1xudmFyIF90cl9hbGlnbl8xID0gX3RyX2FsaWduO1xuXG52YXIgdHJlZXMgPSB7XG5cdF90cl9pbml0OiBfdHJfaW5pdF8xLFxuXHRfdHJfc3RvcmVkX2Jsb2NrOiBfdHJfc3RvcmVkX2Jsb2NrXzEsXG5cdF90cl9mbHVzaF9ibG9jazogX3RyX2ZsdXNoX2Jsb2NrXzEsXG5cdF90cl90YWxseTogX3RyX3RhbGx5XzEsXG5cdF90cl9hbGlnbjogX3RyX2FsaWduXzFcbn07XG5cbi8vIE5vdGU6IGFkbGVyMzIgdGFrZXMgMTIlIGZvciBsZXZlbCAwIGFuZCAyJSBmb3IgbGV2ZWwgNi5cbi8vIEl0IGlzbid0IHdvcnRoIGl0IHRvIG1ha2UgYWRkaXRpb25hbCBvcHRpbWl6YXRpb25zIGFzIGluIG9yaWdpbmFsLlxuLy8gU21hbGwgc2l6ZSBpcyBwcmVmZXJhYmxlLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmNvbnN0IGFkbGVyMzIgPSAoYWRsZXIsIGJ1ZiwgbGVuLCBwb3MpID0+IHtcbiAgbGV0IHMxID0gKGFkbGVyICYgMHhmZmZmKSB8MCxcbiAgICAgIHMyID0gKChhZGxlciA+Pj4gMTYpICYgMHhmZmZmKSB8MCxcbiAgICAgIG4gPSAwO1xuXG4gIHdoaWxlIChsZW4gIT09IDApIHtcbiAgICAvLyBTZXQgbGltaXQgfiB0d2ljZSBsZXNzIHRoYW4gNTU1MiwgdG8ga2VlcFxuICAgIC8vIHMyIGluIDMxLWJpdHMsIGJlY2F1c2Ugd2UgZm9yY2Ugc2lnbmVkIGludHMuXG4gICAgLy8gaW4gb3RoZXIgY2FzZSAlPSB3aWxsIGZhaWwuXG4gICAgbiA9IGxlbiA+IDIwMDAgPyAyMDAwIDogbGVuO1xuICAgIGxlbiAtPSBuO1xuXG4gICAgZG8ge1xuICAgICAgczEgPSAoczEgKyBidWZbcG9zKytdKSB8MDtcbiAgICAgIHMyID0gKHMyICsgczEpIHwwO1xuICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICBzMSAlPSA2NTUyMTtcbiAgICBzMiAlPSA2NTUyMTtcbiAgfVxuXG4gIHJldHVybiAoczEgfCAoczIgPDwgMTYpKSB8MDtcbn07XG5cblxudmFyIGFkbGVyMzJfMSA9IGFkbGVyMzI7XG5cbi8vIE5vdGU6IHdlIGNhbid0IGdldCBzaWduaWZpY2FudCBzcGVlZCBib29zdCBoZXJlLlxuLy8gU28gd3JpdGUgY29kZSB0byBtaW5pbWl6ZSBzaXplIC0gbm8gcHJlZ2VuZXJhdGVkIHRhYmxlc1xuLy8gYW5kIGFycmF5IHRvb2xzIGRlcGVuZGVuY2llcy5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuY29uc3QgbWFrZVRhYmxlID0gKCkgPT4ge1xuICBsZXQgYywgdGFibGUgPSBbXTtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDI1NjsgbisrKSB7XG4gICAgYyA9IG47XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGMgPSAoKGMgJiAxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgfVxuICAgIHRhYmxlW25dID0gYztcbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn07XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG5jb25zdCBjcmNUYWJsZSA9IG5ldyBVaW50MzJBcnJheShtYWtlVGFibGUoKSk7XG5cblxuY29uc3QgY3JjMzIgPSAoY3JjLCBidWYsIGxlbiwgcG9zKSA9PiB7XG4gIGNvbnN0IHQgPSBjcmNUYWJsZTtcbiAgY29uc3QgZW5kID0gcG9zICsgbGVuO1xuXG4gIGNyYyBePSAtMTtcblxuICBmb3IgKGxldCBpID0gcG9zOyBpIDwgZW5kOyBpKyspIHtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgfVxuXG4gIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufTtcblxuXG52YXIgY3JjMzJfMSA9IGNyYzMyO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciBtZXNzYWdlcyA9IHtcbiAgMjogICAgICAnbmVlZCBkaWN0aW9uYXJ5JywgICAgIC8qIFpfTkVFRF9ESUNUICAgICAgIDIgICovXG4gIDE6ICAgICAgJ3N0cmVhbSBlbmQnLCAgICAgICAgICAvKiBaX1NUUkVBTV9FTkQgICAgICAxICAqL1xuICAwOiAgICAgICcnLCAgICAgICAgICAgICAgICAgICAgLyogWl9PSyAgICAgICAgICAgICAgMCAgKi9cbiAgJy0xJzogICAnZmlsZSBlcnJvcicsICAgICAgICAgIC8qIFpfRVJSTk8gICAgICAgICAoLTEpICovXG4gICctMic6ICAgJ3N0cmVhbSBlcnJvcicsICAgICAgICAvKiBaX1NUUkVBTV9FUlJPUiAgKC0yKSAqL1xuICAnLTMnOiAgICdkYXRhIGVycm9yJywgICAgICAgICAgLyogWl9EQVRBX0VSUk9SICAgICgtMykgKi9cbiAgJy00JzogICAnaW5zdWZmaWNpZW50IG1lbW9yeScsIC8qIFpfTUVNX0VSUk9SICAgICAoLTQpICovXG4gICctNSc6ICAgJ2J1ZmZlciBlcnJvcicsICAgICAgICAvKiBaX0JVRl9FUlJPUiAgICAgKC01KSAqL1xuICAnLTYnOiAgICdpbmNvbXBhdGlibGUgdmVyc2lvbicgLyogWl9WRVJTSU9OX0VSUk9SICgtNikgKi9cbn07XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIGNvbnN0YW50cyA9IHtcblxuICAvKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4gIFpfTk9fRkxVU0g6ICAgICAgICAgMCxcbiAgWl9QQVJUSUFMX0ZMVVNIOiAgICAxLFxuICBaX1NZTkNfRkxVU0g6ICAgICAgIDIsXG4gIFpfRlVMTF9GTFVTSDogICAgICAgMyxcbiAgWl9GSU5JU0g6ICAgICAgICAgICA0LFxuICBaX0JMT0NLOiAgICAgICAgICAgIDUsXG4gIFpfVFJFRVM6ICAgICAgICAgICAgNixcblxuICAvKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICAqL1xuICBaX09LOiAgICAgICAgICAgICAgIDAsXG4gIFpfU1RSRUFNX0VORDogICAgICAgMSxcbiAgWl9ORUVEX0RJQ1Q6ICAgICAgICAyLFxuICBaX0VSUk5POiAgICAgICAgICAgLTEsXG4gIFpfU1RSRUFNX0VSUk9SOiAgICAtMixcbiAgWl9EQVRBX0VSUk9SOiAgICAgIC0zLFxuICBaX01FTV9FUlJPUjogICAgICAgLTQsXG4gIFpfQlVGX0VSUk9SOiAgICAgICAtNSxcbiAgLy9aX1ZFUlNJT05fRVJST1I6IC02LFxuXG4gIC8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuICBaX05PX0NPTVBSRVNTSU9OOiAgICAgICAgIDAsXG4gIFpfQkVTVF9TUEVFRDogICAgICAgICAgICAgMSxcbiAgWl9CRVNUX0NPTVBSRVNTSU9OOiAgICAgICA5LFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT046ICAgLTEsXG5cblxuICBaX0ZJTFRFUkVEOiAgICAgICAgICAgICAgIDEsXG4gIFpfSFVGRk1BTl9PTkxZOiAgICAgICAgICAgMixcbiAgWl9STEU6ICAgICAgICAgICAgICAgICAgICAzLFxuICBaX0ZJWEVEOiAgICAgICAgICAgICAgICAgIDQsXG4gIFpfREVGQVVMVF9TVFJBVEVHWTogICAgICAgMCxcblxuICAvKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4gIFpfQklOQVJZOiAgICAgICAgICAgICAgICAgMCxcbiAgWl9URVhUOiAgICAgICAgICAgICAgICAgICAxLFxuICAvL1pfQVNDSUk6ICAgICAgICAgICAgICAgIDEsIC8vID0gWl9URVhUIChkZXByZWNhdGVkKVxuICBaX1VOS05PV046ICAgICAgICAgICAgICAgIDIsXG5cbiAgLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG4gIFpfREVGTEFURUQ6ICAgICAgICAgICAgICAgOFxuICAvL1pfTlVMTDogICAgICAgICAgICAgICAgIG51bGwgLy8gVXNlIC0xIG9yIG51bGwgaW5saW5lLCBkZXBlbmRpbmcgb24gdmFyIHR5cGVcbn07XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuY29uc3QgeyBfdHJfaW5pdDogX3RyX2luaXQkMSwgX3RyX3N0b3JlZF9ibG9jazogX3RyX3N0b3JlZF9ibG9jayQxLCBfdHJfZmx1c2hfYmxvY2s6IF90cl9mbHVzaF9ibG9jayQxLCBfdHJfdGFsbHk6IF90cl90YWxseSQxLCBfdHJfYWxpZ246IF90cl9hbGlnbiQxIH0gPSB0cmVlcztcblxuXG5cblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmNvbnN0IHtcbiAgWl9OT19GTFVTSCwgWl9QQVJUSUFMX0ZMVVNILCBaX0ZVTExfRkxVU0gsIFpfRklOSVNILCBaX0JMT0NLLFxuICBaX09LLCBaX1NUUkVBTV9FTkQsIFpfU1RSRUFNX0VSUk9SLCBaX0RBVEFfRVJST1IsIFpfQlVGX0VSUk9SLFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gIFpfRklMVEVSRUQsIFpfSFVGRk1BTl9PTkxZLCBaX1JMRSwgWl9GSVhFRDogWl9GSVhFRCQxLCBaX0RFRkFVTFRfU1RSQVRFR1ksXG4gIFpfVU5LTk9XTjogWl9VTktOT1dOJDEsXG4gIFpfREVGTEFURURcbn0gPSBjb25zdGFudHM7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuY29uc3QgTUFYX01FTV9MRVZFTCA9IDk7XG4vKiBNYXhpbXVtIHZhbHVlIGZvciBtZW1MZXZlbCBpbiBkZWZsYXRlSW5pdDIgKi9cbmNvbnN0IE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG5jb25zdCBERUZfTUVNX0xFVkVMID0gODtcblxuXG5jb25zdCBMRU5HVEhfQ09ERVMkMSAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xuY29uc3QgTElURVJBTFMkMSAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG5jb25zdCBMX0NPREVTJDEgICAgICAgPSBMSVRFUkFMUyQxICsgMSArIExFTkdUSF9DT0RFUyQxO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG5jb25zdCBEX0NPREVTJDEgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuY29uc3QgQkxfQ09ERVMkMSAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cbmNvbnN0IEhFQVBfU0laRSQxICAgICA9IDIgKiBMX0NPREVTJDEgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cbmNvbnN0IE1BWF9CSVRTJDEgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxuY29uc3QgTUlOX01BVENIJDEgPSAzO1xuY29uc3QgTUFYX01BVENIJDEgPSAyNTg7XG5jb25zdCBNSU5fTE9PS0FIRUFEID0gKE1BWF9NQVRDSCQxICsgTUlOX01BVENIJDEgKyAxKTtcblxuY29uc3QgUFJFU0VUX0RJQ1QgPSAweDIwO1xuXG5jb25zdCBJTklUX1NUQVRFID0gNDI7XG5jb25zdCBFWFRSQV9TVEFURSA9IDY5O1xuY29uc3QgTkFNRV9TVEFURSA9IDczO1xuY29uc3QgQ09NTUVOVF9TVEFURSA9IDkxO1xuY29uc3QgSENSQ19TVEFURSA9IDEwMztcbmNvbnN0IEJVU1lfU1RBVEUgPSAxMTM7XG5jb25zdCBGSU5JU0hfU1RBVEUgPSA2NjY7XG5cbmNvbnN0IEJTX05FRURfTU9SRSAgICAgID0gMTsgLyogYmxvY2sgbm90IGNvbXBsZXRlZCwgbmVlZCBtb3JlIGlucHV0IG9yIG1vcmUgb3V0cHV0ICovXG5jb25zdCBCU19CTE9DS19ET05FICAgICA9IDI7IC8qIGJsb2NrIGZsdXNoIHBlcmZvcm1lZCAqL1xuY29uc3QgQlNfRklOSVNIX1NUQVJURUQgPSAzOyAvKiBmaW5pc2ggc3RhcnRlZCwgbmVlZCBvbmx5IG1vcmUgb3V0cHV0IGF0IG5leHQgZGVmbGF0ZSAqL1xuY29uc3QgQlNfRklOSVNIX0RPTkUgICAgPSA0OyAvKiBmaW5pc2ggZG9uZSwgYWNjZXB0IG5vIG1vcmUgaW5wdXQgb3Igb3V0cHV0ICovXG5cbmNvbnN0IE9TX0NPREUgPSAweDAzOyAvLyBVbml4IDopIC4gRG9uJ3QgZGV0ZWN0LCB1c2UgdGhpcyBkZWZhdWx0LlxuXG5jb25zdCBlcnIgPSAoc3RybSwgZXJyb3JDb2RlKSA9PiB7XG4gIHN0cm0ubXNnID0gbWVzc2FnZXNbZXJyb3JDb2RlXTtcbiAgcmV0dXJuIGVycm9yQ29kZTtcbn07XG5cbmNvbnN0IHJhbmsgPSAoZikgPT4ge1xuICByZXR1cm4gKChmKSA8PCAxKSAtICgoZikgPiA0ID8gOSA6IDApO1xufTtcblxuY29uc3QgemVybyQxID0gKGJ1ZikgPT4ge1xuICBsZXQgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9XG59O1xuXG5cbi8qIGVzbGludC1kaXNhYmxlIG5ldy1jYXAgKi9cbmxldCBIQVNIX1pMSUIgPSAocywgcHJldiwgZGF0YSkgPT4gKChwcmV2IDw8IHMuaGFzaF9zaGlmdCkgXiBkYXRhKSAmIHMuaGFzaF9tYXNrO1xuLy8gVGhpcyBoYXNoIGNhdXNlcyBsZXNzIGNvbGxpc2lvbnMsIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGFrby9pc3N1ZXMvMTM1XG4vLyBCdXQgYnJlYWtzIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vL2xldCBIQVNIX0ZBU1QgPSAocywgcHJldiwgZGF0YSkgPT4gKChwcmV2IDw8IDgpICsgKHByZXYgPj4gOCkgKyAoZGF0YSA8PCA0KSkgJiBzLmhhc2hfbWFzaztcbmxldCBIQVNIID0gSEFTSF9aTElCO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXG4gKiB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+b3V0cHV0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxuICogKFNlZSBhbHNvIHJlYWRfYnVmKCkpLlxuICovXG5jb25zdCBmbHVzaF9wZW5kaW5nID0gKHN0cm0pID0+IHtcbiAgY29uc3QgcyA9IHN0cm0uc3RhdGU7XG5cbiAgLy9fdHJfZmx1c2hfYml0cyhzKTtcbiAgbGV0IGxlbiA9IHMucGVuZGluZztcbiAgaWYgKGxlbiA+IHN0cm0uYXZhaWxfb3V0KSB7XG4gICAgbGVuID0gc3RybS5hdmFpbF9vdXQ7XG4gIH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm47IH1cblxuICBzdHJtLm91dHB1dC5zZXQocy5wZW5kaW5nX2J1Zi5zdWJhcnJheShzLnBlbmRpbmdfb3V0LCBzLnBlbmRpbmdfb3V0ICsgbGVuKSwgc3RybS5uZXh0X291dCk7XG4gIHN0cm0ubmV4dF9vdXQgKz0gbGVuO1xuICBzLnBlbmRpbmdfb3V0ICs9IGxlbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gbGVuO1xuICBzdHJtLmF2YWlsX291dCAtPSBsZW47XG4gIHMucGVuZGluZyAtPSBsZW47XG4gIGlmIChzLnBlbmRpbmcgPT09IDApIHtcbiAgICBzLnBlbmRpbmdfb3V0ID0gMDtcbiAgfVxufTtcblxuXG5jb25zdCBmbHVzaF9ibG9ja19vbmx5ID0gKHMsIGxhc3QpID0+IHtcbiAgX3RyX2ZsdXNoX2Jsb2NrJDEocywgKHMuYmxvY2tfc3RhcnQgPj0gMCA/IHMuYmxvY2tfc3RhcnQgOiAtMSksIHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0LCBsYXN0KTtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIGZsdXNoX3BlbmRpbmcocy5zdHJtKTtcbn07XG5cblxuY29uc3QgcHV0X2J5dGUgPSAocywgYikgPT4ge1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGI7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFB1dCBhIHNob3J0IGluIHRoZSBwZW5kaW5nIGJ1ZmZlci4gVGhlIDE2LWJpdCB2YWx1ZSBpcyBwdXQgaW4gTVNCIG9yZGVyLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgc3RyZWFtIHN0YXRlIGlzIGNvcnJlY3QgYW5kIHRoZXJlIGlzIGVub3VnaCByb29tIGluXG4gKiBwZW5kaW5nX2J1Zi5cbiAqL1xuY29uc3QgcHV0U2hvcnRNU0IgPSAocywgYikgPT4ge1xuXG4gIC8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiA+PiA4KSk7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgJiAweGZmKSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKGIgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiICYgMHhmZjtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZWFkIGEgbmV3IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IGlucHV0IHN0cmVhbSwgdXBkYXRlIHRoZSBhZGxlcjMyXG4gKiBhbmQgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuICBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxuICogdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcbiAqIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5pbnB1dCBidWZmZXIgYW5kIGNvcHlpbmcgZnJvbSBpdC5cbiAqIChTZWUgYWxzbyBmbHVzaF9wZW5kaW5nKCkpLlxuICovXG5jb25zdCByZWFkX2J1ZiA9IChzdHJtLCBidWYsIHN0YXJ0LCBzaXplKSA9PiB7XG5cbiAgbGV0IGxlbiA9IHN0cm0uYXZhaWxfaW47XG5cbiAgaWYgKGxlbiA+IHNpemUpIHsgbGVuID0gc2l6ZTsgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybiAwOyB9XG5cbiAgc3RybS5hdmFpbF9pbiAtPSBsZW47XG5cbiAgLy8gem1lbWNweShidWYsIHN0cm0tPm5leHRfaW4sIGxlbik7XG4gIGJ1Zi5zZXQoc3RybS5pbnB1dC5zdWJhcnJheShzdHJtLm5leHRfaW4sIHN0cm0ubmV4dF9pbiArIGxlbiksIHN0YXJ0KTtcbiAgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMSkge1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyXzEoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIGVsc2UgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMikge1xuICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gKz0gbGVuO1xuICBzdHJtLnRvdGFsX2luICs9IGxlbjtcblxuICByZXR1cm4gbGVuO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNldCBtYXRjaF9zdGFydCB0byB0aGUgbG9uZ2VzdCBtYXRjaCBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gc3RyaW5nIGFuZFxuICogcmV0dXJuIGl0cyBsZW5ndGguIE1hdGNoZXMgc2hvcnRlciBvciBlcXVhbCB0byBwcmV2X2xlbmd0aCBhcmUgZGlzY2FyZGVkLFxuICogaW4gd2hpY2ggY2FzZSB0aGUgcmVzdWx0IGlzIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFuZCBtYXRjaF9zdGFydCBpc1xuICogZ2FyYmFnZS5cbiAqIElOIGFzc2VydGlvbnM6IGN1cl9tYXRjaCBpcyB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiBmb3IgdGhlIGN1cnJlbnRcbiAqICAgc3RyaW5nIChzdHJzdGFydCkgYW5kIGl0cyBkaXN0YW5jZSBpcyA8PSBNQVhfRElTVCwgYW5kIHByZXZfbGVuZ3RoID49IDFcbiAqIE9VVCBhc3NlcnRpb246IHRoZSBtYXRjaCBsZW5ndGggaXMgbm90IGdyZWF0ZXIgdGhhbiBzLT5sb29rYWhlYWQuXG4gKi9cbmNvbnN0IGxvbmdlc3RfbWF0Y2ggPSAocywgY3VyX21hdGNoKSA9PiB7XG5cbiAgbGV0IGNoYWluX2xlbmd0aCA9IHMubWF4X2NoYWluX2xlbmd0aDsgICAgICAvKiBtYXggaGFzaCBjaGFpbiBsZW5ndGggKi9cbiAgbGV0IHNjYW4gPSBzLnN0cnN0YXJ0OyAvKiBjdXJyZW50IHN0cmluZyAqL1xuICBsZXQgbWF0Y2g7ICAgICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaGVkIHN0cmluZyAqL1xuICBsZXQgbGVuOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IG1hdGNoICovXG4gIGxldCBiZXN0X2xlbiA9IHMucHJldl9sZW5ndGg7ICAgICAgICAgICAgICAvKiBiZXN0IG1hdGNoIGxlbmd0aCBzbyBmYXIgKi9cbiAgbGV0IG5pY2VfbWF0Y2ggPSBzLm5pY2VfbWF0Y2g7ICAgICAgICAgICAgIC8qIHN0b3AgaWYgbWF0Y2ggbG9uZyBlbm91Z2ggKi9cbiAgY29uc3QgbGltaXQgPSAocy5zdHJzdGFydCA+IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSA/XG4gICAgICBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwLypOSUwqLztcblxuICBjb25zdCBfd2luID0gcy53aW5kb3c7IC8vIHNob3J0Y3V0XG5cbiAgY29uc3Qgd21hc2sgPSBzLndfbWFzaztcbiAgY29uc3QgcHJldiAgPSBzLnByZXY7XG5cbiAgLyogU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcbiAgICogd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZyBvZiB3aW5kb3cgaW5kZXggMC5cbiAgICovXG5cbiAgY29uc3Qgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSCQxO1xuICBsZXQgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gIGxldCBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuXG4gIC8qIFRoZSBjb2RlIGlzIG9wdGltaXplZCBmb3IgSEFTSF9CSVRTID49IDggYW5kIE1BWF9NQVRDSC0yIG11bHRpcGxlIG9mIDE2LlxuICAgKiBJdCBpcyBlYXN5IHRvIGdldCByaWQgb2YgdGhpcyBvcHRpbWl6YXRpb24gaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgLy8gQXNzZXJ0KHMtPmhhc2hfYml0cyA+PSA4ICYmIE1BWF9NQVRDSCA9PSAyNTgsIFwiQ29kZSB0b28gY2xldmVyXCIpO1xuXG4gIC8qIERvIG5vdCB3YXN0ZSB0b28gbXVjaCB0aW1lIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGdvb2QgbWF0Y2g6ICovXG4gIGlmIChzLnByZXZfbGVuZ3RoID49IHMuZ29vZF9tYXRjaCkge1xuICAgIGNoYWluX2xlbmd0aCA+Pj0gMjtcbiAgfVxuICAvKiBEbyBub3QgbG9vayBmb3IgbWF0Y2hlcyBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuIFRoaXMgaXMgbmVjZXNzYXJ5XG4gICAqIHRvIG1ha2UgZGVmbGF0ZSBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgaWYgKG5pY2VfbWF0Y2ggPiBzLmxvb2thaGVhZCkgeyBuaWNlX21hdGNoID0gcy5sb29rYWhlYWQ7IH1cblxuICAvLyBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFELCBcIm5lZWQgbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICAvLyBBc3NlcnQoY3VyX21hdGNoIDwgcy0+c3Ryc3RhcnQsIFwibm8gZnV0dXJlXCIpO1xuICAgIG1hdGNoID0gY3VyX21hdGNoO1xuXG4gICAgLyogU2tpcCB0byBuZXh0IG1hdGNoIGlmIHRoZSBtYXRjaCBsZW5ndGggY2Fubm90IGluY3JlYXNlXG4gICAgICogb3IgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBsZXNzIHRoYW4gMi4gIE5vdGUgdGhhdCB0aGUgY2hlY2tzIGJlbG93XG4gICAgICogZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBvY2N1ciBvY2Nhc2lvbmFsbHkgZm9yIHBlcmZvcm1hbmNlXG4gICAgICogcmVhc29ucy4gIFRoZXJlZm9yZSB1bmluaXRpYWxpemVkIG1lbW9yeSB3aWxsIGJlIGFjY2Vzc2VkLCBhbmRcbiAgICAgKiBjb25kaXRpb25hbCBqdW1wcyB3aWxsIGJlIG1hZGUgdGhhdCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzLlxuICAgICAqIEhvd2V2ZXIgdGhlIGxlbmd0aCBvZiB0aGUgbWF0Y2ggaXMgbGltaXRlZCB0byB0aGUgbG9va2FoZWFkLCBzb1xuICAgICAqIHRoZSBvdXRwdXQgb2YgZGVmbGF0ZSBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIHVuaW5pdGlhbGl6ZWQgdmFsdWVzLlxuICAgICAqL1xuXG4gICAgaWYgKF93aW5bbWF0Y2ggKyBiZXN0X2xlbl0gICAgICE9PSBzY2FuX2VuZCAgfHxcbiAgICAgICAgX3dpblttYXRjaCArIGJlc3RfbGVuIC0gMV0gIT09IHNjYW5fZW5kMSB8fFxuICAgICAgICBfd2luW21hdGNoXSAgICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuXSB8fFxuICAgICAgICBfd2luWysrbWF0Y2hdICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuICsgMV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qIFRoZSBjaGVjayBhdCBiZXN0X2xlbi0xIGNhbiBiZSByZW1vdmVkIGJlY2F1c2UgaXQgd2lsbCBiZSBtYWRlXG4gICAgICogYWdhaW4gbGF0ZXIuIChUaGlzIGhldXJpc3RpYyBpcyBub3QgYWx3YXlzIGEgd2luLilcbiAgICAgKiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXBhcmUgc2NhblsyXSBhbmQgbWF0Y2hbMl0gc2luY2UgdGhleVxuICAgICAqIGFyZSBhbHdheXMgZXF1YWwgd2hlbiB0aGUgb3RoZXIgYnl0ZXMgbWF0Y2gsIGdpdmVuIHRoYXRcbiAgICAgKiB0aGUgaGFzaCBrZXlzIGFyZSBlcXVhbCBhbmQgdGhhdCBIQVNIX0JJVFMgPj0gOC5cbiAgICAgKi9cbiAgICBzY2FuICs9IDI7XG4gICAgbWF0Y2grKztcbiAgICAvLyBBc3NlcnQoKnNjYW4gPT0gKm1hdGNoLCBcIm1hdGNoWzJdP1wiKTtcblxuICAgIC8qIFdlIGNoZWNrIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgZXZlcnkgOHRoIGNvbXBhcmlzb247XG4gICAgICogdGhlIDI1NnRoIGNoZWNrIHdpbGwgYmUgbWFkZSBhdCBzdHJzdGFydCsyNTguXG4gICAgICovXG4gICAgZG8ge1xuICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgfSB3aGlsZSAoX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuXG4gICAgLy8gQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1bnNpZ25lZCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuXG4gICAgbGVuID0gTUFYX01BVENIJDEgLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgc2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSCQxO1xuXG4gICAgaWYgKGxlbiA+IGJlc3RfbGVuKSB7XG4gICAgICBzLm1hdGNoX3N0YXJ0ID0gY3VyX21hdGNoO1xuICAgICAgYmVzdF9sZW4gPSBsZW47XG4gICAgICBpZiAobGVuID49IG5pY2VfbWF0Y2gpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgICAgIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG4gICAgfVxuICB9IHdoaWxlICgoY3VyX21hdGNoID0gcHJldltjdXJfbWF0Y2ggJiB3bWFza10pID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApO1xuXG4gIGlmIChiZXN0X2xlbiA8PSBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBiZXN0X2xlbjtcbiAgfVxuICByZXR1cm4gcy5sb29rYWhlYWQ7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmlsbCB0aGUgd2luZG93IHdoZW4gdGhlIGxvb2thaGVhZCBiZWNvbWVzIGluc3VmZmljaWVudC5cbiAqIFVwZGF0ZXMgc3Ryc3RhcnQgYW5kIGxvb2thaGVhZC5cbiAqXG4gKiBJTiBhc3NlcnRpb246IGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQURcbiAqIE9VVCBhc3NlcnRpb25zOiBzdHJzdGFydCA8PSB3aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFEXG4gKiAgICBBdCBsZWFzdCBvbmUgYnl0ZSBoYXMgYmVlbiByZWFkLCBvciBhdmFpbF9pbiA9PSAwOyByZWFkcyBhcmVcbiAqICAgIHBlcmZvcm1lZCBmb3IgYXQgbGVhc3QgdHdvIGJ5dGVzIChyZXF1aXJlZCBmb3IgdGhlIHppcCB0cmFuc2xhdGVfZW9sXG4gKiAgICBvcHRpb24gLS0gbm90IHN1cHBvcnRlZCBoZXJlKS5cbiAqL1xuY29uc3QgZmlsbF93aW5kb3cgPSAocykgPT4ge1xuXG4gIGNvbnN0IF93X3NpemUgPSBzLndfc2l6ZTtcbiAgbGV0IHAsIG4sIG0sIG1vcmUsIHN0cjtcblxuICAvL0Fzc2VydChzLT5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFELCBcImFscmVhZHkgZW5vdWdoIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgbW9yZSA9IHMud2luZG93X3NpemUgLSBzLmxvb2thaGVhZCAtIHMuc3Ryc3RhcnQ7XG5cbiAgICAvLyBKUyBpbnRzIGhhdmUgMzIgYml0LCBibG9jayBiZWxvdyBub3QgbmVlZGVkXG4gICAgLyogRGVhbCB3aXRoICFAIyQlIDY0SyBsaW1pdDogKi9cbiAgICAvL2lmIChzaXplb2YoaW50KSA8PSAyKSB7XG4gICAgLy8gICAgaWYgKG1vcmUgPT0gMCAmJiBzLT5zdHJzdGFydCA9PSAwICYmIHMtPmxvb2thaGVhZCA9PSAwKSB7XG4gICAgLy8gICAgICAgIG1vcmUgPSB3c2l6ZTtcbiAgICAvL1xuICAgIC8vICB9IGVsc2UgaWYgKG1vcmUgPT0gKHVuc2lnbmVkKSgtMSkpIHtcbiAgICAvLyAgICAgICAgLyogVmVyeSB1bmxpa2VseSwgYnV0IHBvc3NpYmxlIG9uIDE2IGJpdCBtYWNoaW5lIGlmXG4gICAgLy8gICAgICAgICAqIHN0cnN0YXJ0ID09IDAgJiYgbG9va2FoZWFkID09IDEgKGlucHV0IGRvbmUgYSBieXRlIGF0IHRpbWUpXG4gICAgLy8gICAgICAgICAqL1xuICAgIC8vICAgICAgICBtb3JlLS07XG4gICAgLy8gICAgfVxuICAgIC8vfVxuXG5cbiAgICAvKiBJZiB0aGUgd2luZG93IGlzIGFsbW9zdCBmdWxsIGFuZCB0aGVyZSBpcyBpbnN1ZmZpY2llbnQgbG9va2FoZWFkLFxuICAgICAqIG1vdmUgdGhlIHVwcGVyIGhhbGYgdG8gdGhlIGxvd2VyIG9uZSB0byBtYWtlIHJvb20gaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgPj0gX3dfc2l6ZSArIChfd19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcblxuICAgICAgcy53aW5kb3cuc2V0KHMud2luZG93LnN1YmFycmF5KF93X3NpemUsIF93X3NpemUgKyBfd19zaXplKSwgMCk7XG4gICAgICBzLm1hdGNoX3N0YXJ0IC09IF93X3NpemU7XG4gICAgICBzLnN0cnN0YXJ0IC09IF93X3NpemU7XG4gICAgICAvKiB3ZSBub3cgaGF2ZSBzdHJzdGFydCA+PSBNQVhfRElTVCAqL1xuICAgICAgcy5ibG9ja19zdGFydCAtPSBfd19zaXplO1xuXG4gICAgICAvKiBTbGlkZSB0aGUgaGFzaCB0YWJsZSAoY291bGQgYmUgYXZvaWRlZCB3aXRoIDMyIGJpdCB2YWx1ZXNcbiAgICAgICBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkgdXNhZ2UpLiBXZSBzbGlkZSBldmVuIHdoZW4gbGV2ZWwgPT0gMFxuICAgICAgIHRvIGtlZXAgdGhlIGhhc2ggdGFibGUgY29uc2lzdGVudCBpZiB3ZSBzd2l0Y2ggYmFjayB0byBsZXZlbCA+IDBcbiAgICAgICBsYXRlci4gKFVzaW5nIGxldmVsIDAgcGVybWFuZW50bHkgaXMgbm90IGFuIG9wdGltYWwgdXNhZ2Ugb2ZcbiAgICAgICB6bGliLCBzbyB3ZSBkb24ndCBjYXJlIGFib3V0IHRoaXMgcGF0aG9sb2dpY2FsIGNhc2UuKVxuICAgICAgICovXG5cbiAgICAgIG4gPSBzLmhhc2hfc2l6ZTtcbiAgICAgIHAgPSBuO1xuXG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLmhlYWRbLS1wXTtcbiAgICAgICAgcy5oZWFkW3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBuID0gX3dfc2l6ZTtcbiAgICAgIHAgPSBuO1xuXG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLnByZXZbLS1wXTtcbiAgICAgICAgcy5wcmV2W3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICAgIC8qIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XG4gICAgICAgICAqIGl0cyB2YWx1ZSB3aWxsIG5ldmVyIGJlIHVzZWQuXG4gICAgICAgICAqL1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbW9yZSArPSBfd19zaXplO1xuICAgIH1cbiAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBJZiB0aGVyZSB3YXMgbm8gc2xpZGluZzpcbiAgICAgKiAgICBzdHJzdGFydCA8PSBXU0laRStNQVhfRElTVC0xICYmIGxvb2thaGVhZCA8PSBNSU5fTE9PS0FIRUFEIC0gMSAmJlxuICAgICAqICAgIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAoTUlOX0xPT0tBSEVBRC0xICsgV1NJWkUgKyBNQVhfRElTVC0xKVxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAyKldTSVpFICsgMlxuICAgICAqIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxuICAgICAqICAgd2luZG93X3NpemUgPT0gaW5wdXRfc2l6ZSArIE1JTl9MT09LQUhFQUQgICYmXG4gICAgICogICBzdHJzdGFydCArIHMtPmxvb2thaGVhZCA8PSBpbnB1dF9zaXplID0+IG1vcmUgPj0gTUlOX0xPT0tBSEVBRC5cbiAgICAgKiBPdGhlcndpc2UsIHdpbmRvd19zaXplID09IDIqV1NJWkUgc28gbW9yZSA+PSAyLlxuICAgICAqIElmIHRoZXJlIHdhcyBzbGlkaW5nLCBtb3JlID49IFdTSVpFLiBTbyBpbiBhbGwgY2FzZXMsIG1vcmUgPj0gMi5cbiAgICAgKi9cbiAgICAvL0Fzc2VydChtb3JlID49IDIsIFwibW9yZSA8IDJcIik7XG4gICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7XG4gICAgcy5sb29rYWhlYWQgKz0gbjtcblxuICAgIC8qIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCQxKSB7XG4gICAgICBzdHIgPSBzLnN0cnN0YXJ0IC0gcy5pbnNlcnQ7XG4gICAgICBzLmluc19oID0gcy53aW5kb3dbc3RyXTtcblxuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyAxXSk7ICovXG4gICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzdHIgKyAxXSk7XG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgIENhbGwgdXBkYXRlX2hhc2goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgd2hpbGUgKHMuaW5zZXJ0KSB7XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbc3RyICsgTUlOX01BVENIJDEgLSAxXSk7XG5cbiAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgICBzdHIrKztcbiAgICAgICAgcy5pbnNlcnQtLTtcbiAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPCBNSU5fTUFUQ0gkMSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZSB3aG9sZSBpbnB1dCBoYXMgbGVzcyB0aGFuIE1JTl9NQVRDSCBieXRlcywgaW5zX2ggaXMgZ2FyYmFnZSxcbiAgICAgKiBidXQgdGhpcyBpcyBub3QgaW1wb3J0YW50IHNpbmNlIG9ubHkgbGl0ZXJhbCBieXRlcyB3aWxsIGJlIGVtaXR0ZWQuXG4gICAgICovXG5cbiAgfSB3aGlsZSAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIHMuc3RybS5hdmFpbF9pbiAhPT0gMCk7XG5cbiAgLyogSWYgdGhlIFdJTl9JTklUIGJ5dGVzIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgZGF0YSBoYXZlIG5ldmVyIGJlZW5cbiAgICogd3JpdHRlbiwgdGhlbiB6ZXJvIHRob3NlIGJ5dGVzIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayByZXBvcnRzIG9mXG4gICAqIHRoZSB1c2Ugb2YgdW5pbml0aWFsaXplZCAob3IgdW5pbml0aWFsaXNlZCBhcyBKdWxpYW4gd3JpdGVzKSBieXRlcyBieVxuICAgKiB0aGUgbG9uZ2VzdCBtYXRjaCByb3V0aW5lcy4gIFVwZGF0ZSB0aGUgaGlnaCB3YXRlciBtYXJrIGZvciB0aGUgbmV4dFxuICAgKiB0aW1lIHRocm91Z2ggaGVyZS4gIFdJTl9JTklUIGlzIHNldCB0byBNQVhfTUFUQ0ggc2luY2UgdGhlIGxvbmdlc3QgbWF0Y2hcbiAgICogcm91dGluZXMgYWxsb3cgc2Nhbm5pbmcgdG8gc3Ryc3RhcnQgKyBNQVhfTUFUQ0gsIGlnbm9yaW5nIGxvb2thaGVhZC5cbiAgICovXG4vLyAgaWYgKHMuaGlnaF93YXRlciA8IHMud2luZG93X3NpemUpIHtcbi8vICAgIGNvbnN0IGN1cnIgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQ7XG4vLyAgICBsZXQgaW5pdCA9IDA7XG4vL1xuLy8gICAgaWYgKHMuaGlnaF93YXRlciA8IGN1cnIpIHtcbi8vICAgICAgLyogUHJldmlvdXMgaGlnaCB3YXRlciBtYXJrIGJlbG93IGN1cnJlbnQgZGF0YSAtLSB6ZXJvIFdJTl9JTklUXG4vLyAgICAgICAqIGJ5dGVzIG9yIHVwIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9IHMud2luZG93X3NpemUgLSBjdXJyO1xuLy8gICAgICBpZiAoaW5pdCA+IFdJTl9JTklUKVxuLy8gICAgICAgIGluaXQgPSBXSU5fSU5JVDtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgY3VyciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyID0gY3VyciArIGluaXQ7XG4vLyAgICB9XG4vLyAgICBlbHNlIGlmIChzLT5oaWdoX3dhdGVyIDwgKHVsZyljdXJyICsgV0lOX0lOSVQpIHtcbi8vICAgICAgLyogSGlnaCB3YXRlciBtYXJrIGF0IG9yIGFib3ZlIGN1cnJlbnQgZGF0YSwgYnV0IGJlbG93IGN1cnJlbnQgZGF0YVxuLy8gICAgICAgKiBwbHVzIFdJTl9JTklUIC0tIHplcm8gb3V0IHRvIGN1cnJlbnQgZGF0YSBwbHVzIFdJTl9JTklULCBvciB1cFxuLy8gICAgICAgKiB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSAodWxnKWN1cnIgKyBXSU5fSU5JVCAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIGlmIChpbml0ID4gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyKVxuLy8gICAgICAgIGluaXQgPSBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIHMtPmhpZ2hfd2F0ZXIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciArPSBpbml0O1xuLy8gICAgfVxuLy8gIH1cbi8vXG4vLyAgQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUgLSBNSU5fTE9PS0FIRUFELFxuLy8gICAgXCJub3QgZW5vdWdoIHJvb20gZm9yIHNlYXJjaFwiKTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSB3aXRob3V0IGNvbXByZXNzaW9uIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm5cbiAqIHRoZSBjdXJyZW50IGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBpbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgc2luY2VcbiAqIHVuY29tcHJlc3NpYmxlIGRhdGEgaXMgcHJvYmFibHkgbm90IHVzZWZ1bC4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkXG4gKiBvbmx5IGZvciB0aGUgbGV2ZWw9MCBjb21wcmVzc2lvbiBvcHRpb24uXG4gKiBOT1RFOiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBvcHRpbWl6ZWQgdG8gYXZvaWQgZXh0cmEgY29weWluZyBmcm9tXG4gKiB3aW5kb3cgdG8gcGVuZGluZ19idWYuXG4gKi9cbmNvbnN0IGRlZmxhdGVfc3RvcmVkID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgLyogU3RvcmVkIGJsb2NrcyBhcmUgbGltaXRlZCB0byAweGZmZmYgYnl0ZXMsIHBlbmRpbmdfYnVmIGlzIGxpbWl0ZWRcbiAgICogdG8gcGVuZGluZ19idWZfc2l6ZSwgYW5kIGVhY2ggc3RvcmVkIGJsb2NrIGhhcyBhIDUgYnl0ZSBoZWFkZXI6XG4gICAqL1xuICBsZXQgbWF4X2Jsb2NrX3NpemUgPSAweGZmZmY7XG5cbiAgaWYgKG1heF9ibG9ja19zaXplID4gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNSkge1xuICAgIG1heF9ibG9ja19zaXplID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTtcbiAgfVxuXG4gIC8qIENvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIGlucHV0IHRvIG91dHB1dDogKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIEZpbGwgdGhlIHdpbmRvdyBhcyBtdWNoIGFzIHBvc3NpYmxlOiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7XG5cbiAgICAgIC8vQXNzZXJ0KHMtPnN0cnN0YXJ0IDwgcy0+d19zaXplK01BWF9ESVNUKHMpIHx8XG4gICAgICAvLyAgcy0+YmxvY2tfc3RhcnQgPj0gKGxvbmcpcy0+d19zaXplLCBcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICBpZiAoIShzLnN0cnN0YXJ0IDwgcy53X3NpemUgKyAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB8fFxuLy8gICAgICAgIHMuYmxvY2tfc3RhcnQgPj0gcy53X3NpemUpKSB7XG4vLyAgICAgICAgdGhyb3cgIG5ldyBFcnJvcihcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICB9XG5cbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuICAgIC8vQXNzZXJ0KHMtPmJsb2NrX3N0YXJ0ID49IDBMLCBcImJsb2NrIGdvbmVcIik7XG4vLyAgICBpZiAocy5ibG9ja19zdGFydCA8IDApIHRocm93IG5ldyBFcnJvcihcImJsb2NrIGdvbmVcIik7XG5cbiAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICAgIHMubG9va2FoZWFkID0gMDtcblxuICAgIC8qIEVtaXQgYSBzdG9yZWQgYmxvY2sgaWYgcGVuZGluZ19idWYgd2lsbCBiZSBmdWxsOiAqL1xuICAgIGNvbnN0IG1heF9zdGFydCA9IHMuYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTtcblxuICAgIGlmIChzLnN0cnN0YXJ0ID09PSAwIHx8IHMuc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7XG4gICAgICAvKiBzdHJzdGFydCA9PSAwIGlzIHBvc3NpYmxlIHdoZW4gd3JhcGFyb3VuZCBvbiAxNi1iaXQgbWFjaGluZSAqL1xuICAgICAgcy5sb29rYWhlYWQgPSBzLnN0cnN0YXJ0IC0gbWF4X3N0YXJ0O1xuICAgICAgcy5zdHJzdGFydCA9IG1heF9zdGFydDtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG5cblxuICAgIH1cbiAgICAvKiBGbHVzaCBpZiB3ZSBtYXkgaGF2ZSB0byBzbGlkZSwgb3RoZXJ3aXNlIGJsb2NrX3N0YXJ0IG1heSBiZWNvbWVcbiAgICAgKiBuZWdhdGl2ZSBhbmQgdGhlIGRhdGEgd2lsbCBiZSBnb25lOlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCA+PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cblxuICBzLmluc2VydCA9IDA7XG5cbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG5cbiAgaWYgKHMuc3Ryc3RhcnQgPiBzLmJsb2NrX3N0YXJ0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX05FRURfTU9SRTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxuICogYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcbiAqIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxuICogbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxuICovXG5jb25zdCBkZWZsYXRlX2Zhc3QgPSAocywgZmx1c2gpID0+IHtcblxuICBsZXQgaGFzaF9oZWFkOyAgICAgICAgLyogaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiAqL1xuICBsZXQgYmZsdXNoOyAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhazsgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCQxKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCQxIC0gMV0pO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhbHdheXMgbWF0Y2hfbGVuZ3RoIDwgTUlOX01BVENIXG4gICAgICovXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgKChzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkKSA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkpIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuICAgIH1cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIJDEpIHtcbiAgICAgIC8vIGNoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoKTsgLy8gZm9yIGRlYnVnIG9ubHlcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkkMShzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gkMSk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuXG4gICAgICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoXG4gICAgICAgKiBpcyBub3QgdG9vIGxhcmdlLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgICAgICovXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gcy5tYXhfbGF6eV9tYXRjaC8qbWF4X2luc2VydF9sZW5ndGgqLyAmJiBzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gkMSkge1xuICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOyAvKiBzdHJpbmcgYXQgc3Ryc3RhcnQgYWxyZWFkeSBpbiB0YWJsZSAqL1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCQxIC0gMV0pO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgICAvKiBzdHJzdGFydCBuZXZlciBleGNlZWRzIFdTSVpFLU1BWF9NQVRDSCwgc28gdGhlcmUgYXJlXG4gICAgICAgICAgICogYWx3YXlzIE1JTl9NQVRDSCBieXRlcyBhaGVhZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7XG4gICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIH0gZWxzZVxuICAgICAge1xuICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCsxXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyAxXSk7XG5cbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgICAgICAgICBDYWxsIFVQREFURV9IQVNIKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgICAgLyogSWYgbG9va2FoZWFkIDwgTUlOX01BVENILCBpbnNfaCBpcyBnYXJiYWdlLCBidXQgaXQgZG9lcyBub3RcbiAgICAgICAgICogbWF0dGVyIHNpbmNlIGl0IHdpbGwgYmUgcmVjb21wdXRlZCBhdCBuZXh0IGRlZmxhdGUgY2FsbC5cbiAgICAgICAgICovXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy53aW5kb3dbcy5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5JDEocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9ICgocy5zdHJzdGFydCA8IChNSU5fTUFUQ0gkMSAtIDEpKSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0gkMSAtIDEpO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhbWUgYXMgYWJvdmUsIGJ1dCBhY2hpZXZlcyBiZXR0ZXIgY29tcHJlc3Npb24uIFdlIHVzZSBhIGxhenlcbiAqIGV2YWx1YXRpb24gZm9yIG1hdGNoZXM6IGEgbWF0Y2ggaXMgZmluYWxseSBhZG9wdGVkIG9ubHkgaWYgdGhlcmUgaXNcbiAqIG5vIGJldHRlciBtYXRjaCBhdCB0aGUgbmV4dCB3aW5kb3cgcG9zaXRpb24uXG4gKi9cbmNvbnN0IGRlZmxhdGVfc2xvdyA9IChzLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBoYXNoX2hlYWQ7ICAgICAgICAgIC8qIGhlYWQgb2YgaGFzaCBjaGFpbiAqL1xuICBsZXQgYmZsdXNoOyAgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgbGV0IG1heF9pbnNlcnQ7XG5cbiAgLyogUHJvY2VzcyB0aGUgaW5wdXQgYmxvY2suICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCQxKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCQxIC0gMV0pO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqL1xuICAgIHMucHJldl9sZW5ndGggPSBzLm1hdGNoX2xlbmd0aDtcbiAgICBzLnByZXZfbWF0Y2ggPSBzLm1hdGNoX3N0YXJ0O1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIJDEgLSAxO1xuXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgcy5wcmV2X2xlbmd0aCA8IHMubWF4X2xhenlfbWF0Y2ggJiZcbiAgICAgICAgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKS8qTUFYX0RJU1QocykqLykge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG5cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSA1ICYmXG4gICAgICAgICAocy5zdHJhdGVneSA9PT0gWl9GSUxURVJFRCB8fCAocy5tYXRjaF9sZW5ndGggPT09IE1JTl9NQVRDSCQxICYmIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0ID4gNDA5Ni8qVE9PX0ZBUiovKSkpIHtcblxuICAgICAgICAvKiBJZiBwcmV2X21hdGNoIGlzIGFsc28gTUlOX01BVENILCBtYXRjaF9zdGFydCBpcyBnYXJiYWdlXG4gICAgICAgICAqIGJ1dCB3ZSB3aWxsIGlnbm9yZSB0aGUgY3VycmVudCBtYXRjaCBhbnl3YXkuXG4gICAgICAgICAqL1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCQxIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHN0ZXAgYW5kIHRoZSBjdXJyZW50XG4gICAgICogbWF0Y2ggaXMgbm90IGJldHRlciwgb3V0cHV0IHRoZSBwcmV2aW91cyBtYXRjaDpcbiAgICAgKi9cbiAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0gkMSAmJiBzLm1hdGNoX2xlbmd0aCA8PSBzLnByZXZfbGVuZ3RoKSB7XG4gICAgICBtYXhfaW5zZXJ0ID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkIC0gTUlOX01BVENIJDE7XG4gICAgICAvKiBEbyBub3QgaW5zZXJ0IHN0cmluZ3MgaW4gaGFzaCB0YWJsZSBiZXlvbmQgdGhpcy4gKi9cblxuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LTEsIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCk7XG5cbiAgICAgIC8qKipfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7KioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5JDEocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gkMSk7XG4gICAgICAvKiBJbnNlcnQgaW4gaGFzaCB0YWJsZSBhbGwgc3RyaW5ncyB1cCB0byB0aGUgZW5kIG9mIHRoZSBtYXRjaC5cbiAgICAgICAqIHN0cnN0YXJ0LTEgYW5kIHN0cnN0YXJ0IGFyZSBhbHJlYWR5IGluc2VydGVkLiBJZiB0aGVyZSBpcyBub3RcbiAgICAgICAqIGVub3VnaCBsb29rYWhlYWQsIHRoZSBsYXN0IHR3byBzdHJpbmdzIGFyZSBub3QgaW5zZXJ0ZWQgaW5cbiAgICAgICAqIHRoZSBoYXNoIHRhYmxlLlxuICAgICAgICovXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLnByZXZfbGVuZ3RoIC0gMTtcbiAgICAgIHMucHJldl9sZW5ndGggLT0gMjtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCsrcy5zdHJzdGFydCA8PSBtYXhfaW5zZXJ0KSB7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIJDEgLSAxXSk7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApO1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0gkMSAtIDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIC8qKiovXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgICAvKiBJZiB0aGVyZSB3YXMgbm8gbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHBvc2l0aW9uLCBvdXRwdXQgYVxuICAgICAgICogc2luZ2xlIGxpdGVyYWwuIElmIHRoZXJlIHdhcyBhIG1hdGNoIGJ1dCB0aGUgY3VycmVudCBtYXRjaFxuICAgICAgICogaXMgbG9uZ2VyLCB0cnVuY2F0ZSB0aGUgcHJldmlvdXMgbWF0Y2ggdG8gYSBzaW5nbGUgbGl0ZXJhbC5cbiAgICAgICAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkkMShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0tfT05MWShzLCAwKSAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICAvKioqL1xuICAgICAgfVxuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIFRoZXJlIGlzIG5vIHByZXZpb3VzIG1hdGNoIHRvIGNvbXBhcmUgd2l0aCwgd2FpdCBmb3JcbiAgICAgICAqIHRoZSBuZXh0IHN0ZXAgdG8gZGVjaWRlLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZmx1c2ggIT0gWl9OT19GTFVTSCwgXCJubyBmbHVzaD9cIik7XG4gIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSBfdHJfdGFsbHkkMShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICB9XG4gIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCQxIC0gMSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0gkMSAtIDE7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX1JMRSwgc2ltcGx5IGxvb2sgZm9yIHJ1bnMgb2YgYnl0ZXMsIGdlbmVyYXRlIG1hdGNoZXMgb25seSBvZiBkaXN0YW5jZVxuICogb25lLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS4gIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mXG4gKiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBaX1JMRS4pXG4gKi9cbmNvbnN0IGRlZmxhdGVfcmxlID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgbGV0IGJmbHVzaDsgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cbiAgbGV0IHByZXY7ICAgICAgICAgICAgICAvKiBieXRlIGF0IGRpc3RhbmNlIG9uZSB0byBtYXRjaCAqL1xuICBsZXQgc2Nhbiwgc3RyZW5kOyAgICAgIC8qIHNjYW4gZ29lcyB1cCB0byBzdHJlbmQgZm9yIGxlbmd0aCBvZiBydW4gKi9cblxuICBjb25zdCBfd2luID0gcy53aW5kb3c7XG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBsb25nZXN0IHJ1biwgcGx1cyBvbmUgZm9yIHRoZSB1bnJvbGxlZCBsb29wLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0gkMSkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIJDEgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIFNlZSBob3cgbWFueSB0aW1lcyB0aGUgcHJldmlvdXMgYnl0ZSByZXBlYXRzICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gkMSAmJiBzLnN0cnN0YXJ0ID4gMCkge1xuICAgICAgc2NhbiA9IHMuc3Ryc3RhcnQgLSAxO1xuICAgICAgcHJldiA9IF93aW5bc2Nhbl07XG4gICAgICBpZiAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0pIHtcbiAgICAgICAgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSCQxO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgICAgIH0gd2hpbGUgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUFYX01BVENIJDEgLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+IHMubG9va2FoZWFkKSB7XG4gICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLmxvb2thaGVhZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVJbnQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcbiAgICB9XG5cbiAgICAvKiBFbWl0IG1hdGNoIGlmIGhhdmUgcnVuIG9mIE1JTl9NQVRDSCBvciBsb25nZXIsIGVsc2UgZW1pdCBsaXRlcmFsICovXG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCQxKSB7XG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMuc3Ryc3RhcnQgLSAxLCBzLm1hdGNoX2xlbmd0aCk7XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3QocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IF90cl90YWxseSQxKHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIJDEpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkkMShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9IVUZGTUFOX09OTFksIGRvIG5vdCBsb29rIGZvciBtYXRjaGVzLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS5cbiAqIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIEh1ZmZtYW4uKVxuICovXG5jb25zdCBkZWZsYXRlX2h1ZmYgPSAocywgZmx1c2gpID0+IHtcblxuICBsZXQgYmZsdXNoOyAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSBhIGxpdGVyYWwgdG8gd3JpdGUuICovXG4gICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrOyAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogT3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IF90cl90YWxseSQxKHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcbiAgICBzLmxvb2thaGVhZC0tO1xuICAgIHMuc3Ryc3RhcnQrKztcbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn07XG5cbi8qIFZhbHVlcyBmb3IgbWF4X2xhenlfbWF0Y2gsIGdvb2RfbWF0Y2ggYW5kIG1heF9jaGFpbl9sZW5ndGgsIGRlcGVuZGluZyBvblxuICogdGhlIGRlc2lyZWQgcGFjayBsZXZlbCAoMC4uOSkuIFRoZSB2YWx1ZXMgZ2l2ZW4gYmVsb3cgaGF2ZSBiZWVuIHR1bmVkIHRvXG4gKiBleGNsdWRlIHdvcnN0IGNhc2UgcGVyZm9ybWFuY2UgZm9yIHBhdGhvbG9naWNhbCBmaWxlcy4gQmV0dGVyIHZhbHVlcyBtYXkgYmVcbiAqIGZvdW5kIGZvciBzcGVjaWZpYyBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gQ29uZmlnKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykge1xuXG4gIHRoaXMuZ29vZF9sZW5ndGggPSBnb29kX2xlbmd0aDtcbiAgdGhpcy5tYXhfbGF6eSA9IG1heF9sYXp5O1xuICB0aGlzLm5pY2VfbGVuZ3RoID0gbmljZV9sZW5ndGg7XG4gIHRoaXMubWF4X2NoYWluID0gbWF4X2NoYWluO1xuICB0aGlzLmZ1bmMgPSBmdW5jO1xufVxuXG5jb25zdCBjb25maWd1cmF0aW9uX3RhYmxlID0gW1xuICAvKiAgICAgIGdvb2QgbGF6eSBuaWNlIGNoYWluICovXG4gIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLCAgICAgICAgICAvKiAwIHN0b3JlIG9ubHkgKi9cbiAgbmV3IENvbmZpZyg0LCA0LCA4LCA0LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgIC8qIDEgbWF4IHNwZWVkLCBubyBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgIC8qIDIgKi9cbiAgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIGRlZmxhdGVfZmFzdCksICAgICAgICAgIC8qIDMgKi9cblxuICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAgLyogNCBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgIC8qIDUgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDYgKi9cbiAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDcgKi9cbiAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksICAgIC8qIDggKi9cbiAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykgICAgIC8qIDkgbWF4IGNvbXByZXNzaW9uICovXG5dO1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgXCJsb25nZXN0IG1hdGNoXCIgcm91dGluZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtXG4gKi9cbmNvbnN0IGxtX2luaXQgPSAocykgPT4ge1xuXG4gIHMud2luZG93X3NpemUgPSAyICogcy53X3NpemU7XG5cbiAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gIHplcm8kMShzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gIC8qIFNldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnM6XG4gICAqL1xuICBzLm1heF9sYXp5X21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfbGF6eTtcbiAgcy5nb29kX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5nb29kX2xlbmd0aDtcbiAgcy5uaWNlX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5uaWNlX2xlbmd0aDtcbiAgcy5tYXhfY2hhaW5fbGVuZ3RoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfY2hhaW47XG5cbiAgcy5zdHJzdGFydCA9IDA7XG4gIHMuYmxvY2tfc3RhcnQgPSAwO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMuaW5zZXJ0ID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIJDEgLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHMuaW5zX2ggPSAwO1xufTtcblxuXG5mdW5jdGlvbiBEZWZsYXRlU3RhdGUoKSB7XG4gIHRoaXMuc3RybSA9IG51bGw7ICAgICAgICAgICAgLyogcG9pbnRlciBiYWNrIHRvIHRoaXMgemxpYiBzdHJlYW0gKi9cbiAgdGhpcy5zdGF0dXMgPSAwOyAgICAgICAgICAgIC8qIGFzIHRoZSBuYW1lIGltcGxpZXMgKi9cbiAgdGhpcy5wZW5kaW5nX2J1ZiA9IG51bGw7ICAgICAgLyogb3V0cHV0IHN0aWxsIHBlbmRpbmcgKi9cbiAgdGhpcy5wZW5kaW5nX2J1Zl9zaXplID0gMDsgIC8qIHNpemUgb2YgcGVuZGluZ19idWYgKi9cbiAgdGhpcy5wZW5kaW5nX291dCA9IDA7ICAgICAgIC8qIG5leHQgcGVuZGluZyBieXRlIHRvIG91dHB1dCB0byB0aGUgc3RyZWFtICovXG4gIHRoaXMucGVuZGluZyA9IDA7ICAgICAgICAgICAvKiBuYiBvZiBieXRlcyBpbiB0aGUgcGVuZGluZyBidWZmZXIgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5nemhlYWQgPSBudWxsOyAgICAgICAgIC8qIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uIHRvIHdyaXRlICovXG4gIHRoaXMuZ3ppbmRleCA9IDA7ICAgICAgICAgICAvKiB3aGVyZSBpbiBleHRyYSwgbmFtZSwgb3IgY29tbWVudCAqL1xuICB0aGlzLm1ldGhvZCA9IFpfREVGTEFURUQ7IC8qIGNhbiBvbmx5IGJlIERFRkxBVEVEICovXG4gIHRoaXMubGFzdF9mbHVzaCA9IC0xOyAgIC8qIHZhbHVlIG9mIGZsdXNoIHBhcmFtIGZvciBwcmV2aW91cyBkZWZsYXRlIGNhbGwgKi9cblxuICB0aGlzLndfc2l6ZSA9IDA7ICAvKiBMWjc3IHdpbmRvdyBzaXplICgzMksgYnkgZGVmYXVsdCkgKi9cbiAgdGhpcy53X2JpdHMgPSAwOyAgLyogbG9nMih3X3NpemUpICAoOC4uMTYpICovXG4gIHRoaXMud19tYXNrID0gMDsgIC8qIHdfc2l6ZSAtIDEgKi9cblxuICB0aGlzLndpbmRvdyA9IG51bGw7XG4gIC8qIFNsaWRpbmcgd2luZG93LiBJbnB1dCBieXRlcyBhcmUgcmVhZCBpbnRvIHRoZSBzZWNvbmQgaGFsZiBvZiB0aGUgd2luZG93LFxuICAgKiBhbmQgbW92ZSB0byB0aGUgZmlyc3QgaGFsZiBsYXRlciB0byBrZWVwIGEgZGljdGlvbmFyeSBvZiBhdCBsZWFzdCB3U2l6ZVxuICAgKiBieXRlcy4gV2l0aCB0aGlzIG9yZ2FuaXphdGlvbiwgbWF0Y2hlcyBhcmUgbGltaXRlZCB0byBhIGRpc3RhbmNlIG9mXG4gICAqIHdTaXplLU1BWF9NQVRDSCBieXRlcywgYnV0IHRoaXMgZW5zdXJlcyB0aGF0IElPIGlzIGFsd2F5c1xuICAgKiBwZXJmb3JtZWQgd2l0aCBhIGxlbmd0aCBtdWx0aXBsZSBvZiB0aGUgYmxvY2sgc2l6ZS5cbiAgICovXG5cbiAgdGhpcy53aW5kb3dfc2l6ZSA9IDA7XG4gIC8qIEFjdHVhbCBzaXplIG9mIHdpbmRvdzogMip3U2l6ZSwgZXhjZXB0IHdoZW4gdGhlIHVzZXIgaW5wdXQgYnVmZmVyXG4gICAqIGlzIGRpcmVjdGx5IHVzZWQgYXMgc2xpZGluZyB3aW5kb3cuXG4gICAqL1xuXG4gIHRoaXMucHJldiA9IG51bGw7XG4gIC8qIExpbmsgdG8gb2xkZXIgc3RyaW5nIHdpdGggc2FtZSBoYXNoIGluZGV4LiBUbyBsaW1pdCB0aGUgc2l6ZSBvZiB0aGlzXG4gICAqIGFycmF5IHRvIDY0SywgdGhpcyBsaW5rIGlzIG1haW50YWluZWQgb25seSBmb3IgdGhlIGxhc3QgMzJLIHN0cmluZ3MuXG4gICAqIEFuIGluZGV4IGluIHRoaXMgYXJyYXkgaXMgdGh1cyBhIHdpbmRvdyBpbmRleCBtb2R1bG8gMzJLLlxuICAgKi9cblxuICB0aGlzLmhlYWQgPSBudWxsOyAgIC8qIEhlYWRzIG9mIHRoZSBoYXNoIGNoYWlucyBvciBOSUwuICovXG5cbiAgdGhpcy5pbnNfaCA9IDA7ICAgICAgIC8qIGhhc2ggaW5kZXggb2Ygc3RyaW5nIHRvIGJlIGluc2VydGVkICovXG4gIHRoaXMuaGFzaF9zaXplID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gaGFzaCB0YWJsZSAqL1xuICB0aGlzLmhhc2hfYml0cyA9IDA7ICAgLyogbG9nMihoYXNoX3NpemUpICovXG4gIHRoaXMuaGFzaF9tYXNrID0gMDsgICAvKiBoYXNoX3NpemUtMSAqL1xuXG4gIHRoaXMuaGFzaF9zaGlmdCA9IDA7XG4gIC8qIE51bWJlciBvZiBiaXRzIGJ5IHdoaWNoIGluc19oIG11c3QgYmUgc2hpZnRlZCBhdCBlYWNoIGlucHV0XG4gICAqIHN0ZXAuIEl0IG11c3QgYmUgc3VjaCB0aGF0IGFmdGVyIE1JTl9NQVRDSCBzdGVwcywgdGhlIG9sZGVzdFxuICAgKiBieXRlIG5vIGxvbmdlciB0YWtlcyBwYXJ0IGluIHRoZSBoYXNoIGtleSwgdGhhdCBpczpcbiAgICogICBoYXNoX3NoaWZ0ICogTUlOX01BVENIID49IGhhc2hfYml0c1xuICAgKi9cblxuICB0aGlzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgLyogV2luZG93IHBvc2l0aW9uIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGN1cnJlbnQgb3V0cHV0IGJsb2NrLiBHZXRzXG4gICAqIG5lZ2F0aXZlIHdoZW4gdGhlIHdpbmRvdyBpcyBtb3ZlZCBiYWNrd2FyZHMuXG4gICAqL1xuXG4gIHRoaXMubWF0Y2hfbGVuZ3RoID0gMDsgICAgICAvKiBsZW5ndGggb2YgYmVzdCBtYXRjaCAqL1xuICB0aGlzLnByZXZfbWF0Y2ggPSAwOyAgICAgICAgLyogcHJldmlvdXMgbWF0Y2ggKi9cbiAgdGhpcy5tYXRjaF9hdmFpbGFibGUgPSAwOyAgIC8qIHNldCBpZiBwcmV2aW91cyBtYXRjaCBleGlzdHMgKi9cbiAgdGhpcy5zdHJzdGFydCA9IDA7ICAgICAgICAgIC8qIHN0YXJ0IG9mIHN0cmluZyB0byBpbnNlcnQgKi9cbiAgdGhpcy5tYXRjaF9zdGFydCA9IDA7ICAgICAgIC8qIHN0YXJ0IG9mIG1hdGNoaW5nIHN0cmluZyAqL1xuICB0aGlzLmxvb2thaGVhZCA9IDA7ICAgICAgICAgLyogbnVtYmVyIG9mIHZhbGlkIGJ5dGVzIGFoZWFkIGluIHdpbmRvdyAqL1xuXG4gIHRoaXMucHJldl9sZW5ndGggPSAwO1xuICAvKiBMZW5ndGggb2YgdGhlIGJlc3QgbWF0Y2ggYXQgcHJldmlvdXMgc3RlcC4gTWF0Y2hlcyBub3QgZ3JlYXRlciB0aGFuIHRoaXNcbiAgICogYXJlIGRpc2NhcmRlZC4gVGhpcyBpcyB1c2VkIGluIHRoZSBsYXp5IG1hdGNoIGV2YWx1YXRpb24uXG4gICAqL1xuXG4gIHRoaXMubWF4X2NoYWluX2xlbmd0aCA9IDA7XG4gIC8qIFRvIHNwZWVkIHVwIGRlZmxhdGlvbiwgaGFzaCBjaGFpbnMgYXJlIG5ldmVyIHNlYXJjaGVkIGJleW9uZCB0aGlzXG4gICAqIGxlbmd0aC4gIEEgaGlnaGVyIGxpbWl0IGltcHJvdmVzIGNvbXByZXNzaW9uIHJhdGlvIGJ1dCBkZWdyYWRlcyB0aGVcbiAgICogc3BlZWQuXG4gICAqL1xuXG4gIHRoaXMubWF4X2xhenlfbWF0Y2ggPSAwO1xuICAvKiBBdHRlbXB0IHRvIGZpbmQgYSBiZXR0ZXIgbWF0Y2ggb25seSB3aGVuIHRoZSBjdXJyZW50IG1hdGNoIGlzIHN0cmljdGx5XG4gICAqIHNtYWxsZXIgdGhhbiB0aGlzIHZhbHVlLiBUaGlzIG1lY2hhbmlzbSBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uXG4gICAqIGxldmVscyA+PSA0LlxuICAgKi9cbiAgLy8gVGhhdCdzIGFsaWFzIHRvIG1heF9sYXp5X21hdGNoLCBkb24ndCB1c2UgZGlyZWN0bHlcbiAgLy90aGlzLm1heF9pbnNlcnRfbGVuZ3RoID0gMDtcbiAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBub3RcbiAgICogZ3JlYXRlciB0aGFuIHRoaXMgbGVuZ3RoLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgKiBtYXhfaW5zZXJ0X2xlbmd0aCBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uIGxldmVscyA8PSAzLlxuICAgKi9cblxuICB0aGlzLmxldmVsID0gMDsgICAgIC8qIGNvbXByZXNzaW9uIGxldmVsICgxLi45KSAqL1xuICB0aGlzLnN0cmF0ZWd5ID0gMDsgIC8qIGZhdm9yIG9yIGZvcmNlIEh1ZmZtYW4gY29kaW5nKi9cblxuICB0aGlzLmdvb2RfbWF0Y2ggPSAwO1xuICAvKiBVc2UgYSBmYXN0ZXIgc2VhcmNoIHdoZW4gdGhlIHByZXZpb3VzIG1hdGNoIGlzIGxvbmdlciB0aGFuIHRoaXMgKi9cblxuICB0aGlzLm5pY2VfbWF0Y2ggPSAwOyAvKiBTdG9wIHNlYXJjaGluZyB3aGVuIGN1cnJlbnQgbWF0Y2ggZXhjZWVkcyB0aGlzICovXG5cbiAgICAgICAgICAgICAgLyogdXNlZCBieSB0cmVlcy5jOiAqL1xuXG4gIC8qIERpZG4ndCB1c2UgY3RfZGF0YSB0eXBlZGVmIGJlbG93IHRvIHN1cHByZXNzIGNvbXBpbGVyIHdhcm5pbmcgKi9cblxuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9sdHJlZVtIRUFQX1NJWkVdOyAgIC8qIGxpdGVyYWwgYW5kIGxlbmd0aCB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2R0cmVlWzIqRF9DT0RFUysxXTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGJsX3RyZWVbMipCTF9DT0RFUysxXTsgIC8qIEh1ZmZtYW4gdHJlZSBmb3IgYml0IGxlbmd0aHMgKi9cblxuICAvLyBVc2UgZmxhdCBhcnJheSBvZiBET1VCTEUgc2l6ZSwgd2l0aCBpbnRlcmxlYXZlZCBmYXRhLFxuICAvLyBiZWNhdXNlIEpTIGRvZXMgbm90IHN1cHBvcnQgZWZmZWN0aXZlXG4gIHRoaXMuZHluX2x0cmVlICA9IG5ldyBVaW50MTZBcnJheShIRUFQX1NJWkUkMSAqIDIpO1xuICB0aGlzLmR5bl9kdHJlZSAgPSBuZXcgVWludDE2QXJyYXkoKDIgKiBEX0NPREVTJDEgKyAxKSAqIDIpO1xuICB0aGlzLmJsX3RyZWUgICAgPSBuZXcgVWludDE2QXJyYXkoKDIgKiBCTF9DT0RFUyQxICsgMSkgKiAyKTtcbiAgemVybyQxKHRoaXMuZHluX2x0cmVlKTtcbiAgemVybyQxKHRoaXMuZHluX2R0cmVlKTtcbiAgemVybyQxKHRoaXMuYmxfdHJlZSk7XG5cbiAgdGhpcy5sX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGxpdGVyYWwgdHJlZSAqL1xuICB0aGlzLmRfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgZGlzdGFuY2UgdHJlZSAqL1xuICB0aGlzLmJsX2Rlc2MgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgYml0IGxlbmd0aCB0cmVlICovXG5cbiAgLy91c2ggYmxfY291bnRbTUFYX0JJVFMrMV07XG4gIHRoaXMuYmxfY291bnQgPSBuZXcgVWludDE2QXJyYXkoTUFYX0JJVFMkMSArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvL2ludCBoZWFwWzIqTF9DT0RFUysxXTsgICAgICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgdGhpcy5oZWFwID0gbmV3IFVpbnQxNkFycmF5KDIgKiBMX0NPREVTJDEgKyAxKTsgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB6ZXJvJDEodGhpcy5oZWFwKTtcblxuICB0aGlzLmhlYXBfbGVuID0gMDsgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGhlYXAgKi9cbiAgdGhpcy5oZWFwX21heCA9IDA7ICAgICAgICAgICAgICAgLyogZWxlbWVudCBvZiBsYXJnZXN0IGZyZXF1ZW5jeSAqL1xuICAvKiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKiBUaGUgc2FtZSBoZWFwIGFycmF5IGlzIHVzZWQgdG8gYnVpbGQgYWxsIHRyZWVzLlxuICAgKi9cblxuICB0aGlzLmRlcHRoID0gbmV3IFVpbnQxNkFycmF5KDIgKiBMX0NPREVTJDEgKyAxKTsgLy91Y2ggZGVwdGhbMipMX0NPREVTKzFdO1xuICB6ZXJvJDEodGhpcy5kZXB0aCk7XG4gIC8qIERlcHRoIG9mIGVhY2ggc3VidHJlZSB1c2VkIGFzIHRpZSBicmVha2VyIGZvciB0cmVlcyBvZiBlcXVhbCBmcmVxdWVuY3lcbiAgICovXG5cbiAgdGhpcy5sX2J1ZiA9IDA7ICAgICAgICAgIC8qIGJ1ZmZlciBpbmRleCBmb3IgbGl0ZXJhbHMgb3IgbGVuZ3RocyAqL1xuXG4gIHRoaXMubGl0X2J1ZnNpemUgPSAwO1xuICAvKiBTaXplIG9mIG1hdGNoIGJ1ZmZlciBmb3IgbGl0ZXJhbHMvbGVuZ3Rocy4gIFRoZXJlIGFyZSA0IHJlYXNvbnMgZm9yXG4gICAqIGxpbWl0aW5nIGxpdF9idWZzaXplIHRvIDY0SzpcbiAgICogICAtIGZyZXF1ZW5jaWVzIGNhbiBiZSBrZXB0IGluIDE2IGJpdCBjb3VudGVyc1xuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIHRoZSBmaXJzdCBibG9jaywgYWxsIGlucHV0XG4gICAqICAgICBkYXRhIGlzIHN0aWxsIGluIHRoZSB3aW5kb3cgc28gd2UgY2FuIHN0aWxsIGVtaXQgYSBzdG9yZWQgYmxvY2sgZXZlblxuICAgKiAgICAgd2hlbiBpbnB1dCBjb21lcyBmcm9tIHN0YW5kYXJkIGlucHV0LiAgKFRoaXMgY2FuIGFsc28gYmUgZG9uZSBmb3JcbiAgICogICAgIGFsbCBibG9ja3MgaWYgbGl0X2J1ZnNpemUgaXMgbm90IGdyZWF0ZXIgdGhhbiAzMksuKVxuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIGEgZmlsZSBzbWFsbGVyIHRoYW4gNjRLLCB3ZSBjYW5cbiAgICogICAgIGV2ZW4gZW1pdCBhIHN0b3JlZCBmaWxlIGluc3RlYWQgb2YgYSBzdG9yZWQgYmxvY2sgKHNhdmluZyA1IGJ5dGVzKS5cbiAgICogICAgIFRoaXMgaXMgYXBwbGljYWJsZSBvbmx5IGZvciB6aXAgKG5vdCBnemlwIG9yIHpsaWIpLlxuICAgKiAgIC0gY3JlYXRpbmcgbmV3IEh1ZmZtYW4gdHJlZXMgbGVzcyBmcmVxdWVudGx5IG1heSBub3QgcHJvdmlkZSBmYXN0XG4gICAqICAgICBhZGFwdGF0aW9uIHRvIGNoYW5nZXMgaW4gdGhlIGlucHV0IGRhdGEgc3RhdGlzdGljcy4gKFRha2UgZm9yXG4gICAqICAgICBleGFtcGxlIGEgYmluYXJ5IGZpbGUgd2l0aCBwb29ybHkgY29tcHJlc3NpYmxlIGNvZGUgZm9sbG93ZWQgYnlcbiAgICogICAgIGEgaGlnaGx5IGNvbXByZXNzaWJsZSBzdHJpbmcgdGFibGUuKSBTbWFsbGVyIGJ1ZmZlciBzaXplcyBnaXZlXG4gICAqICAgICBmYXN0IGFkYXB0YXRpb24gYnV0IGhhdmUgb2YgY291cnNlIHRoZSBvdmVyaGVhZCBvZiB0cmFuc21pdHRpbmdcbiAgICogICAgIHRyZWVzIG1vcmUgZnJlcXVlbnRseS5cbiAgICogICAtIEkgY2FuJ3QgY291bnQgYWJvdmUgNFxuICAgKi9cblxuICB0aGlzLmxhc3RfbGl0ID0gMDsgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG5cbiAgdGhpcy5kX2J1ZiA9IDA7XG4gIC8qIEJ1ZmZlciBpbmRleCBmb3IgZGlzdGFuY2VzLiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgZF9idWYgYW5kIGxfYnVmIGhhdmVcbiAgICogdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLiBUbyB1c2UgZGlmZmVyZW50IGxlbmd0aHMsIGFuIGV4dHJhIGZsYWdcbiAgICogYXJyYXkgd291bGQgYmUgbmVjZXNzYXJ5LlxuICAgKi9cblxuICB0aGlzLm9wdF9sZW4gPSAwOyAgICAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBvcHRpbWFsIHRyZWVzICovXG4gIHRoaXMuc3RhdGljX2xlbiA9IDA7ICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIHN0YXRpYyB0cmVlcyAqL1xuICB0aGlzLm1hdGNoZXMgPSAwOyAgICAgICAvKiBudW1iZXIgb2Ygc3RyaW5nIG1hdGNoZXMgaW4gY3VycmVudCBibG9jayAqL1xuICB0aGlzLmluc2VydCA9IDA7ICAgICAgICAvKiBieXRlcyBhdCBlbmQgb2Ygd2luZG93IGxlZnQgdG8gaW5zZXJ0ICovXG5cblxuICB0aGlzLmJpX2J1ZiA9IDA7XG4gIC8qIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0XG4gICAqIHNpZ25pZmljYW50IGJpdHMpLlxuICAgKi9cbiAgdGhpcy5iaV92YWxpZCA9IDA7XG4gIC8qIE51bWJlciBvZiB2YWxpZCBiaXRzIGluIGJpX2J1Zi4gIEFsbCBiaXRzIGFib3ZlIHRoZSBsYXN0IHZhbGlkIGJpdFxuICAgKiBhcmUgYWx3YXlzIHplcm8uXG4gICAqL1xuXG4gIC8vIFVzZWQgZm9yIHdpbmRvdyBtZW1vcnkgaW5pdC4gV2Ugc2FmZWx5IGlnbm9yZSBpdCBmb3IgSlMuIFRoYXQgbWFrZXNcbiAgLy8gc2Vuc2Ugb25seSBmb3IgcG9pbnRlcnMgYW5kIG1lbW9yeSBjaGVjayB0b29scy5cbiAgLy90aGlzLmhpZ2hfd2F0ZXIgPSAwO1xuICAvKiBIaWdoIHdhdGVyIG1hcmsgb2Zmc2V0IGluIHdpbmRvdyBmb3IgaW5pdGlhbGl6ZWQgYnl0ZXMgLS0gYnl0ZXMgYWJvdmVcbiAgICogdGhpcyBhcmUgc2V0IHRvIHplcm8gaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHdhcm5pbmdzIHdoZW5cbiAgICogbG9uZ2VzdCBtYXRjaCByb3V0aW5lcyBhY2Nlc3MgYnl0ZXMgcGFzdCB0aGUgaW5wdXQuICBUaGlzIGlzIHRoZW5cbiAgICogdXBkYXRlZCB0byB0aGUgbmV3IGhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG59XG5cblxuY29uc3QgZGVmbGF0ZVJlc2V0S2VlcCA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSAwO1xuICBzdHJtLmRhdGFfdHlwZSA9IFpfVU5LTk9XTiQxO1xuXG4gIGNvbnN0IHMgPSBzdHJtLnN0YXRlO1xuICBzLnBlbmRpbmcgPSAwO1xuICBzLnBlbmRpbmdfb3V0ID0gMDtcblxuICBpZiAocy53cmFwIDwgMCkge1xuICAgIHMud3JhcCA9IC1zLndyYXA7XG4gICAgLyogd2FzIG1hZGUgbmVnYXRpdmUgYnkgZGVmbGF0ZSguLi4sIFpfRklOSVNIKTsgKi9cbiAgfVxuICBzLnN0YXR1cyA9IChzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURSk7XG4gIHN0cm0uYWRsZXIgPSAocy53cmFwID09PSAyKSA/XG4gICAgMCAgLy8gY3JjMzIoMCwgWl9OVUxMLCAwKVxuICA6XG4gICAgMTsgLy8gYWRsZXIzMigwLCBaX05VTEwsIDApXG4gIHMubGFzdF9mbHVzaCA9IFpfTk9fRkxVU0g7XG4gIF90cl9pbml0JDEocyk7XG4gIHJldHVybiBaX09LO1xufTtcblxuXG5jb25zdCBkZWZsYXRlUmVzZXQgPSAoc3RybSkgPT4ge1xuXG4gIGNvbnN0IHJldCA9IGRlZmxhdGVSZXNldEtlZXAoc3RybSk7XG4gIGlmIChyZXQgPT09IFpfT0spIHtcbiAgICBsbV9pbml0KHN0cm0uc3RhdGUpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5cbmNvbnN0IGRlZmxhdGVTZXRIZWFkZXIgPSAoc3RybSwgaGVhZCkgPT4ge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgaWYgKHN0cm0uc3RhdGUud3JhcCAhPT0gMikgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RybS5zdGF0ZS5nemhlYWQgPSBoZWFkO1xuICByZXR1cm4gWl9PSztcbn07XG5cblxuY29uc3QgZGVmbGF0ZUluaXQyID0gKHN0cm0sIGxldmVsLCBtZXRob2QsIHdpbmRvd0JpdHMsIG1lbUxldmVsLCBzdHJhdGVneSkgPT4ge1xuXG4gIGlmICghc3RybSkgeyAvLyA9PT0gWl9OVUxMXG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIGxldCB3cmFwID0gMTtcblxuICBpZiAobGV2ZWwgPT09IFpfREVGQVVMVF9DT01QUkVTU0lPTikge1xuICAgIGxldmVsID0gNjtcbiAgfVxuXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkgeyAvKiBzdXBwcmVzcyB6bGliIHdyYXBwZXIgKi9cbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmICh3aW5kb3dCaXRzID4gMTUpIHtcbiAgICB3cmFwID0gMjsgICAgICAgICAgIC8qIHdyaXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkICovXG4gICAgd2luZG93Qml0cyAtPSAxNjtcbiAgfVxuXG5cbiAgaWYgKG1lbUxldmVsIDwgMSB8fCBtZW1MZXZlbCA+IE1BWF9NRU1fTEVWRUwgfHwgbWV0aG9kICE9PSBaX0RFRkxBVEVEIHx8XG4gICAgd2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1IHx8IGxldmVsIDwgMCB8fCBsZXZlbCA+IDkgfHxcbiAgICBzdHJhdGVneSA8IDAgfHwgc3RyYXRlZ3kgPiBaX0ZJWEVEJDEpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG5cbiAgaWYgKHdpbmRvd0JpdHMgPT09IDgpIHtcbiAgICB3aW5kb3dCaXRzID0gOTtcbiAgfVxuICAvKiB1bnRpbCAyNTYtYnl0ZSB3aW5kb3cgYnVnIGZpeGVkICovXG5cbiAgY29uc3QgcyA9IG5ldyBEZWZsYXRlU3RhdGUoKTtcblxuICBzdHJtLnN0YXRlID0gcztcbiAgcy5zdHJtID0gc3RybTtcblxuICBzLndyYXAgPSB3cmFwO1xuICBzLmd6aGVhZCA9IG51bGw7XG4gIHMud19iaXRzID0gd2luZG93Qml0cztcbiAgcy53X3NpemUgPSAxIDw8IHMud19iaXRzO1xuICBzLndfbWFzayA9IHMud19zaXplIC0gMTtcblxuICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNztcbiAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzO1xuICBzLmhhc2hfbWFzayA9IHMuaGFzaF9zaXplIC0gMTtcbiAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIJDEgLSAxKSAvIE1JTl9NQVRDSCQxKTtcblxuICBzLndpbmRvdyA9IG5ldyBVaW50OEFycmF5KHMud19zaXplICogMik7XG4gIHMuaGVhZCA9IG5ldyBVaW50MTZBcnJheShzLmhhc2hfc2l6ZSk7XG4gIHMucHJldiA9IG5ldyBVaW50MTZBcnJheShzLndfc2l6ZSk7XG5cbiAgLy8gRG9uJ3QgbmVlZCBtZW0gaW5pdCBtYWdpYyBmb3IgSlMuXG4gIC8vcy5oaWdoX3dhdGVyID0gMDsgIC8qIG5vdGhpbmcgd3JpdHRlbiB0byBzLT53aW5kb3cgeWV0ICovXG5cbiAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgKG1lbUxldmVsICsgNik7IC8qIDE2SyBlbGVtZW50cyBieSBkZWZhdWx0ICovXG5cbiAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7XG5cbiAgLy9vdmVybGF5ID0gKHVzaGYgKikgWkFMTE9DKHN0cm0sIHMtPmxpdF9idWZzaXplLCBzaXplb2YodXNoKSsyKTtcbiAgLy9zLT5wZW5kaW5nX2J1ZiA9ICh1Y2hmICopIG92ZXJsYXk7XG4gIHMucGVuZGluZ19idWYgPSBuZXcgVWludDhBcnJheShzLnBlbmRpbmdfYnVmX3NpemUpO1xuXG4gIC8vIEl0IGlzIG9mZnNldCBmcm9tIGBzLnBlbmRpbmdfYnVmYCAoc2l6ZSBpcyBgcy5saXRfYnVmc2l6ZSAqIDJgKVxuICAvL3MtPmRfYnVmID0gb3ZlcmxheSArIHMtPmxpdF9idWZzaXplL3NpemVvZih1c2gpO1xuICBzLmRfYnVmID0gMSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgLy9zLT5sX2J1ZiA9IHMtPnBlbmRpbmdfYnVmICsgKDErc2l6ZW9mKHVzaCkpKnMtPmxpdF9idWZzaXplO1xuICBzLmxfYnVmID0gKDEgKyAyKSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgcy5sZXZlbCA9IGxldmVsO1xuICBzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gIHMubWV0aG9kID0gbWV0aG9kO1xuXG4gIHJldHVybiBkZWZsYXRlUmVzZXQoc3RybSk7XG59O1xuXG5jb25zdCBkZWZsYXRlSW5pdCA9IChzdHJtLCBsZXZlbCkgPT4ge1xuXG4gIHJldHVybiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIFpfREVGTEFURUQsIE1BWF9XQklUUywgREVGX01FTV9MRVZFTCwgWl9ERUZBVUxUX1NUUkFURUdZKTtcbn07XG5cblxuY29uc3QgZGVmbGF0ZSA9IChzdHJtLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBiZWcsIHZhbDsgLy8gZm9yIGd6aXAgaGVhZGVyIHdyaXRlIG9ubHlcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHxcbiAgICBmbHVzaCA+IFpfQkxPQ0sgfHwgZmx1c2ggPCAwKSB7XG4gICAgcmV0dXJuIHN0cm0gPyBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpIDogWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBjb25zdCBzID0gc3RybS5zdGF0ZTtcblxuICBpZiAoIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkgfHxcbiAgICAgIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9PSBaX0ZJTklTSCkpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIChzdHJtLmF2YWlsX291dCA9PT0gMCkgPyBaX0JVRl9FUlJPUiA6IFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHMuc3RybSA9IHN0cm07IC8qIGp1c3QgaW4gY2FzZSAqL1xuICBjb25zdCBvbGRfZmx1c2ggPSBzLmxhc3RfZmx1c2g7XG4gIHMubGFzdF9mbHVzaCA9IGZsdXNoO1xuXG4gIC8qIFdyaXRlIHRoZSBoZWFkZXIgKi9cbiAgaWYgKHMuc3RhdHVzID09PSBJTklUX1NUQVRFKSB7XG5cbiAgICBpZiAocy53cmFwID09PSAyKSB7IC8vIEdaSVAgaGVhZGVyXG4gICAgICBzdHJtLmFkbGVyID0gMDsgIC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICBwdXRfYnl0ZShzLCAzMSk7XG4gICAgICBwdXRfYnl0ZShzLCAxMzkpO1xuICAgICAgcHV0X2J5dGUocywgOCk7XG4gICAgICBpZiAoIXMuZ3poZWFkKSB7IC8vIHMtPmd6aGVhZCA9PSBaX05VTExcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIE9TX0NPREUpO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRleHQgPyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAocy5nemhlYWQuaGNyYyA/IDIgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuZXh0cmEgPyAwIDogNCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLm5hbWUgPyAwIDogOCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmNvbW1lbnQgPyAwIDogMTYpXG4gICAgICAgICk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMTYpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDI0KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLm9zICYgMHhmZik7XG4gICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSAmJiBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmKTtcbiAgICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDgpICYgMHhmZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcsIDApO1xuICAgICAgICB9XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gRVhUUkFfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgLy8gREVGTEFURSBoZWFkZXJcbiAgICB7XG4gICAgICBsZXQgaGVhZGVyID0gKFpfREVGTEFURUQgKyAoKHMud19iaXRzIC0gOCkgPDwgNCkpIDw8IDg7XG4gICAgICBsZXQgbGV2ZWxfZmxhZ3MgPSAtMTtcblxuICAgICAgaWYgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsIDwgNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPT09IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAzO1xuICAgICAgfVxuICAgICAgaGVhZGVyIHw9IChsZXZlbF9mbGFncyA8PCA2KTtcbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7IGhlYWRlciB8PSBQUkVTRVRfRElDVDsgfVxuICAgICAgaGVhZGVyICs9IDMxIC0gKGhlYWRlciAlIDMxKTtcblxuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgcHV0U2hvcnRNU0IocywgaGVhZGVyKTtcblxuICAgICAgLyogU2F2ZSB0aGUgYWRsZXIzMiBvZiB0aGUgcHJlc2V0IGRpY3Rpb25hcnk6ICovXG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkge1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IDE7IC8vIGFkbGVyMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgfVxuICB9XG5cbi8vI2lmZGVmIEdaSVBcbiAgaWYgKHMuc3RhdHVzID09PSBFWFRSQV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5leHRyYS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG5cbiAgICAgIHdoaWxlIChzLmd6aW5kZXggPCAocy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZmZmKSkge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmFbcy5nemluZGV4XSAmIDB4ZmYpO1xuICAgICAgICBzLmd6aW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAocy5nemluZGV4ID09PSBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBOQU1FX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLm5hbWUvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLm5hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQubmFtZS5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBDT01NRU5UX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmNvbW1lbnQvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLmNvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICB9XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA8PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBzdHJtLmFkbGVyID0gMDsgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICB9XG4gIH1cbi8vI2VuZGlmXG5cbiAgLyogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZSAqL1xuICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIC8qIFNpbmNlIGF2YWlsX291dCBpcyAwLCBkZWZsYXRlIHdpbGwgYmUgY2FsbGVkIGFnYWluIHdpdGhcbiAgICAgICAqIG1vcmUgb3V0cHV0IHNwYWNlLCBidXQgcG9zc2libHkgd2l0aCBib3RoIHBlbmRpbmcgYW5kXG4gICAgICAgKiBhdmFpbF9pbiBlcXVhbCB0byB6ZXJvLiBUaGVyZSB3b24ndCBiZSBhbnl0aGluZyB0byBkbyxcbiAgICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBhbiBlcnJvciBzaXR1YXRpb24gc28gbWFrZSBzdXJlIHdlXG4gICAgICAgKiByZXR1cm4gT0sgaW5zdGVhZCBvZiBCVUZfRVJST1IgYXQgbmV4dCBjYWxsIG9mIGRlZmxhdGU6XG4gICAgICAgKi9cbiAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgfVxuXG4gICAgLyogTWFrZSBzdXJlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbyBhbmQgYXZvaWQgZHVwbGljYXRlIGNvbnNlY3V0aXZlXG4gICAgICogZmx1c2hlcy4gRm9yIHJlcGVhdGVkIGFuZCB1c2VsZXNzIGNhbGxzIHdpdGggWl9GSU5JU0gsIHdlIGtlZXBcbiAgICAgKiByZXR1cm5pbmcgWl9TVFJFQU1fRU5EIGluc3RlYWQgb2YgWl9CVUZfRVJST1IuXG4gICAgICovXG4gIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiByYW5rKGZsdXNoKSA8PSByYW5rKG9sZF9mbHVzaCkgJiZcbiAgICBmbHVzaCAhPT0gWl9GSU5JU0gpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFVzZXIgbXVzdCBub3QgcHJvdmlkZSBtb3JlIGlucHV0IGFmdGVyIHRoZSBmaXJzdCBGSU5JU0g6ICovXG4gIGlmIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFN0YXJ0IGEgbmV3IGJsb2NrIG9yIGNvbnRpbnVlIHRoZSBjdXJyZW50IG9uZS5cbiAgICovXG4gIGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMubG9va2FoZWFkICE9PSAwIHx8XG4gICAgKGZsdXNoICE9PSBaX05PX0ZMVVNIICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpKSB7XG4gICAgbGV0IGJzdGF0ZSA9IChzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSkgPyBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIDpcbiAgICAgIChzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6XG4gICAgICAgIGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCkpO1xuXG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfRE9ORSkge1xuICAgICAgcy5zdGF0dXMgPSBGSU5JU0hfU1RBVEU7XG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX05FRURfTU9SRSB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEKSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICAgIC8qIGF2b2lkIEJVRl9FUlJPUiBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgfVxuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICAvKiBJZiBmbHVzaCAhPSBaX05PX0ZMVVNIICYmIGF2YWlsX291dCA9PSAwLCB0aGUgbmV4dCBjYWxsXG4gICAgICAgKiBvZiBkZWZsYXRlIHNob3VsZCB1c2UgdGhlIHNhbWUgZmx1c2ggcGFyYW1ldGVyIHRvIG1ha2Ugc3VyZVxuICAgICAgICogdGhhdCB0aGUgZmx1c2ggaXMgY29tcGxldGUuIFNvIHdlIGRvbid0IGhhdmUgdG8gb3V0cHV0IGFuXG4gICAgICAgKiBlbXB0eSBibG9jayBoZXJlLCB0aGlzIHdpbGwgYmUgZG9uZSBhdCBuZXh0IGNhbGwuIFRoaXMgYWxzb1xuICAgICAgICogZW5zdXJlcyB0aGF0IGZvciBhIHZlcnkgc21hbGwgb3V0cHV0IGJ1ZmZlciwgd2UgZW1pdCBhdCBtb3N0XG4gICAgICAgKiBvbmUgZW1wdHkgYmxvY2suXG4gICAgICAgKi9cbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfQkxPQ0tfRE9ORSkge1xuICAgICAgaWYgKGZsdXNoID09PSBaX1BBUlRJQUxfRkxVU0gpIHtcbiAgICAgICAgX3RyX2FsaWduJDEocyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmbHVzaCAhPT0gWl9CTE9DSykgeyAvKiBGVUxMX0ZMVVNIIG9yIFNZTkNfRkxVU0ggKi9cblxuICAgICAgICBfdHJfc3RvcmVkX2Jsb2NrJDEocywgMCwgMCwgZmFsc2UpO1xuICAgICAgICAvKiBGb3IgYSBmdWxsIGZsdXNoLCB0aGlzIGVtcHR5IGJsb2NrIHdpbGwgYmUgcmVjb2duaXplZFxuICAgICAgICAgKiBhcyBhIHNwZWNpYWwgbWFya2VyIGJ5IGluZmxhdGVfc3luYygpLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZVTExfRkxVU0gpIHtcbiAgICAgICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi8gICAgICAgICAgICAgLyogZm9yZ2V0IGhpc3RvcnkgKi9cbiAgICAgICAgICB6ZXJvJDEocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7IC8qIGF2b2lkIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgICByZXR1cm4gWl9PSztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQoc3RybS0+YXZhaWxfb3V0ID4gMCwgXCJidWcyXCIpO1xuICAvL2lmIChzdHJtLmF2YWlsX291dCA8PSAwKSB7IHRocm93IG5ldyBFcnJvcihcImJ1ZzJcIik7fVxuXG4gIGlmIChmbHVzaCAhPT0gWl9GSU5JU0gpIHsgcmV0dXJuIFpfT0s7IH1cbiAgaWYgKHMud3JhcCA8PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FTkQ7IH1cblxuICAvKiBXcml0ZSB0aGUgdHJhaWxlciAqL1xuICBpZiAocy53cmFwID09PSAyKSB7XG4gICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMjQpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMjQpICYgMHhmZik7XG4gIH1cbiAgZWxzZVxuICB7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICB9XG5cbiAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgLyogSWYgYXZhaWxfb3V0IGlzIHplcm8sIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGNhbGwgZGVmbGF0ZSBhZ2FpblxuICAgKiB0byBmbHVzaCB0aGUgcmVzdC5cbiAgICovXG4gIGlmIChzLndyYXAgPiAwKSB7IHMud3JhcCA9IC1zLndyYXA7IH1cbiAgLyogd3JpdGUgdGhlIHRyYWlsZXIgb25seSBvbmNlISAqL1xuICByZXR1cm4gcy5wZW5kaW5nICE9PSAwID8gWl9PSyA6IFpfU1RSRUFNX0VORDtcbn07XG5cblxuY29uc3QgZGVmbGF0ZUVuZCA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBjb25zdCBzdGF0dXMgPSBzdHJtLnN0YXRlLnN0YXR1cztcbiAgaWYgKHN0YXR1cyAhPT0gSU5JVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRVhUUkFfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IE5BTUVfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IENPTU1FTlRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEhDUkNfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEJVU1lfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEZJTklTSF9TVEFURVxuICApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuXG4gIHJldHVybiBzdGF0dXMgPT09IEJVU1lfU1RBVEUgPyBlcnIoc3RybSwgWl9EQVRBX0VSUk9SKSA6IFpfT0s7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemVzIHRoZSBjb21wcmVzc2lvbiBkaWN0aW9uYXJ5IGZyb20gdGhlIGdpdmVuIGJ5dGVcbiAqIHNlcXVlbmNlIHdpdGhvdXQgcHJvZHVjaW5nIGFueSBjb21wcmVzc2VkIG91dHB1dC5cbiAqL1xuY29uc3QgZGVmbGF0ZVNldERpY3Rpb25hcnkgPSAoc3RybSwgZGljdGlvbmFyeSkgPT4ge1xuXG4gIGxldCBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBjb25zdCBzID0gc3RybS5zdGF0ZTtcbiAgY29uc3Qgd3JhcCA9IHMud3JhcDtcblxuICBpZiAod3JhcCA9PT0gMiB8fCAod3JhcCA9PT0gMSAmJiBzLnN0YXR1cyAhPT0gSU5JVF9TVEFURSkgfHwgcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiB3aGVuIHVzaW5nIHpsaWIgd3JhcHBlcnMsIGNvbXB1dGUgQWRsZXItMzIgZm9yIHByb3ZpZGVkIGRpY3Rpb25hcnkgKi9cbiAgaWYgKHdyYXAgPT09IDEpIHtcbiAgICAvKiBhZGxlcjMyKHN0cm0tPmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMl8xKHN0cm0uYWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICB9XG5cbiAgcy53cmFwID0gMDsgICAvKiBhdm9pZCBjb21wdXRpbmcgQWRsZXItMzIgaW4gcmVhZF9idWYgKi9cblxuICAvKiBpZiBkaWN0aW9uYXJ5IHdvdWxkIGZpbGwgd2luZG93LCBqdXN0IHJlcGxhY2UgdGhlIGhpc3RvcnkgKi9cbiAgaWYgKGRpY3RMZW5ndGggPj0gcy53X3NpemUpIHtcbiAgICBpZiAod3JhcCA9PT0gMCkgeyAgICAgICAgICAgIC8qIGFscmVhZHkgZW1wdHkgb3RoZXJ3aXNlICovXG4gICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgICAgIHplcm8kMShzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICB9XG4gICAgLyogdXNlIHRoZSB0YWlsICovXG4gICAgLy8gZGljdGlvbmFyeSA9IGRpY3Rpb25hcnkuc2xpY2UoZGljdExlbmd0aCAtIHMud19zaXplKTtcbiAgICBsZXQgdG1wRGljdCA9IG5ldyBVaW50OEFycmF5KHMud19zaXplKTtcbiAgICB0bXBEaWN0LnNldChkaWN0aW9uYXJ5LnN1YmFycmF5KGRpY3RMZW5ndGggLSBzLndfc2l6ZSwgZGljdExlbmd0aCksIDApO1xuICAgIGRpY3Rpb25hcnkgPSB0bXBEaWN0O1xuICAgIGRpY3RMZW5ndGggPSBzLndfc2l6ZTtcbiAgfVxuICAvKiBpbnNlcnQgZGljdGlvbmFyeSBpbnRvIHdpbmRvdyBhbmQgaGFzaCAqL1xuICBjb25zdCBhdmFpbCA9IHN0cm0uYXZhaWxfaW47XG4gIGNvbnN0IG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGNvbnN0IGlucHV0ID0gc3RybS5pbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGRpY3RMZW5ndGg7XG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uaW5wdXQgPSBkaWN0aW9uYXJ5O1xuICBmaWxsX3dpbmRvdyhzKTtcbiAgd2hpbGUgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCQxKSB7XG4gICAgbGV0IHN0ciA9IHMuc3Ryc3RhcnQ7XG4gICAgbGV0IG4gPSBzLmxvb2thaGVhZCAtIChNSU5fTUFUQ0gkMSAtIDEpO1xuICAgIGRvIHtcbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCQxIC0gMV0pO1xuXG4gICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuXG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICBzdHIrKztcbiAgICB9IHdoaWxlICgtLW4pO1xuICAgIHMuc3Ryc3RhcnQgPSBzdHI7XG4gICAgcy5sb29rYWhlYWQgPSBNSU5fTUFUQ0gkMSAtIDE7XG4gICAgZmlsbF93aW5kb3cocyk7XG4gIH1cbiAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIHMuaW5zZXJ0ID0gcy5sb29rYWhlYWQ7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIJDEgLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uaW5wdXQgPSBpbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGF2YWlsO1xuICBzLndyYXAgPSB3cmFwO1xuICByZXR1cm4gWl9PSztcbn07XG5cblxudmFyIGRlZmxhdGVJbml0XzEgPSBkZWZsYXRlSW5pdDtcbnZhciBkZWZsYXRlSW5pdDJfMSA9IGRlZmxhdGVJbml0MjtcbnZhciBkZWZsYXRlUmVzZXRfMSA9IGRlZmxhdGVSZXNldDtcbnZhciBkZWZsYXRlUmVzZXRLZWVwXzEgPSBkZWZsYXRlUmVzZXRLZWVwO1xudmFyIGRlZmxhdGVTZXRIZWFkZXJfMSA9IGRlZmxhdGVTZXRIZWFkZXI7XG52YXIgZGVmbGF0ZV8yID0gZGVmbGF0ZTtcbnZhciBkZWZsYXRlRW5kXzEgPSBkZWZsYXRlRW5kO1xudmFyIGRlZmxhdGVTZXREaWN0aW9uYXJ5XzEgPSBkZWZsYXRlU2V0RGljdGlvbmFyeTtcbnZhciBkZWZsYXRlSW5mbyA9ICdwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlQm91bmQgPSBkZWZsYXRlQm91bmQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlQ29weSA9IGRlZmxhdGVDb3B5O1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZVBhcmFtcyA9IGRlZmxhdGVQYXJhbXM7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlUGVuZGluZyA9IGRlZmxhdGVQZW5kaW5nO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZVByaW1lID0gZGVmbGF0ZVByaW1lO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZVR1bmUgPSBkZWZsYXRlVHVuZTtcbiovXG5cbnZhciBkZWZsYXRlXzEgPSB7XG5cdGRlZmxhdGVJbml0OiBkZWZsYXRlSW5pdF8xLFxuXHRkZWZsYXRlSW5pdDI6IGRlZmxhdGVJbml0Ml8xLFxuXHRkZWZsYXRlUmVzZXQ6IGRlZmxhdGVSZXNldF8xLFxuXHRkZWZsYXRlUmVzZXRLZWVwOiBkZWZsYXRlUmVzZXRLZWVwXzEsXG5cdGRlZmxhdGVTZXRIZWFkZXI6IGRlZmxhdGVTZXRIZWFkZXJfMSxcblx0ZGVmbGF0ZTogZGVmbGF0ZV8yLFxuXHRkZWZsYXRlRW5kOiBkZWZsYXRlRW5kXzEsXG5cdGRlZmxhdGVTZXREaWN0aW9uYXJ5OiBkZWZsYXRlU2V0RGljdGlvbmFyeV8xLFxuXHRkZWZsYXRlSW5mbzogZGVmbGF0ZUluZm9cbn07XG5cbmNvbnN0IF9oYXMgPSAob2JqLCBrZXkpID0+IHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59O1xuXG52YXIgYXNzaWduID0gZnVuY3Rpb24gKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7XG4gIGNvbnN0IHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7XG4gICAgaWYgKCFzb3VyY2UpIHsgY29udGludWU7IH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAnbXVzdCBiZSBub24tb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBwIGluIHNvdXJjZSkge1xuICAgICAgaWYgKF9oYXMoc291cmNlLCBwKSkge1xuICAgICAgICBvYmpbcF0gPSBzb3VyY2VbcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cblxuLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxudmFyIGZsYXR0ZW5DaHVua3MgPSAoY2h1bmtzKSA9PiB7XG4gIC8vIGNhbGN1bGF0ZSBkYXRhIGxlbmd0aFxuICBsZXQgbGVuID0gMDtcblxuICBmb3IgKGxldCBpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgfVxuXG4gIC8vIGpvaW4gY2h1bmtzXG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG5cbiAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGV0IGNodW5rID0gY2h1bmtzW2ldO1xuICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7XG4gICAgcG9zICs9IGNodW5rLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgY29tbW9uID0ge1xuXHRhc3NpZ246IGFzc2lnbixcblx0ZmxhdHRlbkNodW5rczogZmxhdHRlbkNodW5rc1xufTtcblxuLy8gU3RyaW5nIGVuY29kZS9kZWNvZGUgaGVscGVyc1xuXG5cbi8vIFF1aWNrIGNoZWNrIGlmIHdlIGNhbiB1c2UgZmFzdCBhcnJheSB0byBiaW4gc3RyaW5nIGNvbnZlcnNpb25cbi8vXG4vLyAtIGFwcGx5KEFycmF5KSBjYW4gZmFpbCBvbiBBbmRyb2lkIDIuMlxuLy8gLSBhcHBseShVaW50OEFycmF5KSBjYW4gZmFpbCBvbiBpT1MgNS4xIFNhZmFyaVxuLy9cbmxldCBTVFJfQVBQTFlfVUlBX09LID0gdHJ1ZTtcblxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9VSUFfT0sgPSBmYWxzZTsgfVxuXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxuY29uc3QgX3V0ZjhsZW4gPSBuZXcgVWludDhBcnJheSgyNTYpO1xuZm9yIChsZXQgcSA9IDA7IHEgPCAyNTY7IHErKykge1xuICBfdXRmOGxlbltxXSA9IChxID49IDI1MiA/IDYgOiBxID49IDI0OCA/IDUgOiBxID49IDI0MCA/IDQgOiBxID49IDIyNCA/IDMgOiBxID49IDE5MiA/IDIgOiAxKTtcbn1cbl91dGY4bGVuWzI1NF0gPSBfdXRmOGxlblsyNTRdID0gMTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG5cbi8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5ICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbnZhciBzdHJpbmcyYnVmID0gKHN0cikgPT4ge1xuICBsZXQgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDtcblxuICAvLyBjb3VudCBiaW5hcnkgc2l6ZVxuICBmb3IgKG1fcG9zID0gMDsgbV9wb3MgPCBzdHJfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBidWZfbGVuICs9IGMgPCAweDgwID8gMSA6IGMgPCAweDgwMCA/IDIgOiBjIDwgMHgxMDAwMCA/IDMgOiA0O1xuICB9XG5cbiAgLy8gYWxsb2NhdGUgYnVmZmVyXG4gIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGJ1Zl9sZW4pO1xuXG4gIC8vIGNvbnZlcnRcbiAgZm9yIChpID0gMCwgbV9wb3MgPSAwOyBpIDwgYnVmX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAvKiBvbmUgYnl0ZSAqL1xuICAgICAgYnVmW2krK10gPSBjO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAvKiB0d28gYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhDMCB8IChjID4+PiA2KTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgLyogdGhyZWUgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhFMCB8IChjID4+PiAxMik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogZm91ciBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweGYwIHwgKGMgPj4+IDE4KTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiAxMiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cbi8vIEhlbHBlclxuY29uc3QgYnVmMmJpbnN0cmluZyA9IChidWYsIGxlbikgPT4ge1xuICAvLyBPbiBDaHJvbWUsIHRoZSBhcmd1bWVudHMgaW4gYSBmdW5jdGlvbiBjYWxsIHRoYXQgYXJlIGFsbG93ZWQgaXMgYDY1NTM0YC5cbiAgLy8gSWYgdGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyIGlzIHNtYWxsZXIgdGhhbiB0aGF0LCB3ZSBjYW4gdXNlIHRoaXMgb3B0aW1pemF0aW9uLFxuICAvLyBvdGhlcndpc2Ugd2Ugd2lsbCB0YWtlIGEgc2xvd2VyIHBhdGguXG4gIGlmIChsZW4gPCA2NTUzNCkge1xuICAgIGlmIChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSykge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnVmLmxlbmd0aCA9PT0gbGVuID8gYnVmIDogYnVmLnN1YmFycmF5KDAsIGxlbikpO1xuICAgIH1cbiAgfVxuXG4gIGxldCByZXN1bHQgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLy8gY29udmVydCBhcnJheSB0byBzdHJpbmdcbnZhciBidWYyc3RyaW5nID0gKGJ1ZiwgbWF4KSA9PiB7XG4gIGxldCBpLCBvdXQ7XG4gIGNvbnN0IGxlbiA9IG1heCB8fCBidWYubGVuZ3RoO1xuXG4gIC8vIFJlc2VydmUgbWF4IHBvc3NpYmxlIGxlbmd0aCAoMiB3b3JkcyBwZXIgY2hhcilcbiAgLy8gTkI6IGJ5IHVua25vd24gcmVhc29ucywgQXJyYXkgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgZm9yXG4gIC8vICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5IHRoYW4gVWludDE2QXJyYXkuXG4gIGNvbnN0IHV0ZjE2YnVmID0gbmV3IEFycmF5KGxlbiAqIDIpO1xuXG4gIGZvciAob3V0ID0gMCwgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgbGV0IGMgPSBidWZbaSsrXTtcbiAgICAvLyBxdWljayBwcm9jZXNzIGFzY2lpXG4gICAgaWYgKGMgPCAweDgwKSB7IHV0ZjE2YnVmW291dCsrXSA9IGM7IGNvbnRpbnVlOyB9XG5cbiAgICBsZXQgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAvLyBza2lwIDUgJiA2IGJ5dGUgY29kZXNcbiAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbiAtIDE7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBhcHBseSBtYXNrIG9uIGZpcnN0IGJ5dGVcbiAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7XG4gICAgLy8gam9pbiB0aGUgcmVzdFxuICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikge1xuICAgICAgYyA9IChjIDw8IDYpIHwgKGJ1ZltpKytdICYgMHgzZik7XG4gICAgICBjX2xlbi0tO1xuICAgIH1cblxuICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICBpZiAoY19sZW4gPiAxKSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgY29udGludWU7IH1cblxuICAgIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYyYmluc3RyaW5nKHV0ZjE2YnVmLCBvdXQpO1xufTtcblxuXG4vLyBDYWxjdWxhdGUgbWF4IHBvc3NpYmxlIHBvc2l0aW9uIGluIHV0ZjggYnVmZmVyLFxuLy8gdGhhdCB3aWxsIG5vdCBicmVhayBzZXF1ZW5jZS4gSWYgdGhhdCdzIG5vdCBwb3NzaWJsZVxuLy8gLSAodmVyeSBzbWFsbCBsaW1pdHMpIHJldHVybiBtYXggc2l6ZSBhcyBpcy5cbi8vXG4vLyBidWZbXSAtIHV0ZjggYnl0ZXMgYXJyYXlcbi8vIG1heCAgIC0gbGVuZ3RoIGxpbWl0IChtYW5kYXRvcnkpO1xudmFyIHV0Zjhib3JkZXIgPSAoYnVmLCBtYXgpID0+IHtcblxuICBtYXggPSBtYXggfHwgYnVmLmxlbmd0aDtcbiAgaWYgKG1heCA+IGJ1Zi5sZW5ndGgpIHsgbWF4ID0gYnVmLmxlbmd0aDsgfVxuXG4gIC8vIGdvIGJhY2sgZnJvbSBsYXN0IHBvc2l0aW9uLCB1bnRpbCBzdGFydCBvZiBzZXF1ZW5jZSBmb3VuZFxuICBsZXQgcG9zID0gbWF4IC0gMTtcbiAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgLy8gVmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAvLyByZXR1cm4gbWF4LCBiZWNhdXNlIHdlIHNob3VsZCByZXR1cm4gc29tZXRoaW5nIGFueXdheS5cbiAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyBidWZmZXIgaXMgdG9vIHNtYWxsLFxuICAvLyByZXR1cm4gbWF4IHRvby5cbiAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcblxudmFyIHN0cmluZ3MgPSB7XG5cdHN0cmluZzJidWY6IHN0cmluZzJidWYsXG5cdGJ1ZjJzdHJpbmc6IGJ1ZjJzdHJpbmcsXG5cdHV0Zjhib3JkZXI6IHV0Zjhib3JkZXJcbn07XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gWlN0cmVhbSgpIHtcbiAgLyogbmV4dCBpbnB1dCBieXRlICovXG4gIHRoaXMuaW5wdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9pbiA9IDA7XG4gIC8qIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUgYXQgaW5wdXQgKi9cbiAgdGhpcy5hdmFpbF9pbiA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBpbnB1dCBieXRlcyByZWFkIHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX2luID0gMDtcbiAgLyogbmV4dCBvdXRwdXQgYnl0ZSBzaG91bGQgYmUgcHV0IHRoZXJlICovXG4gIHRoaXMub3V0cHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfb3V0ID0gMDtcbiAgLyogcmVtYWluaW5nIGZyZWUgc3BhY2UgYXQgb3V0cHV0ICovXG4gIHRoaXMuYXZhaWxfb3V0ID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGJ5dGVzIG91dHB1dCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9vdXQgPSAwO1xuICAvKiBsYXN0IGVycm9yIG1lc3NhZ2UsIE5VTEwgaWYgbm8gZXJyb3IgKi9cbiAgdGhpcy5tc2cgPSAnJy8qWl9OVUxMKi87XG4gIC8qIG5vdCB2aXNpYmxlIGJ5IGFwcGxpY2F0aW9ucyAqL1xuICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgLyogYmVzdCBndWVzcyBhYm91dCB0aGUgZGF0YSB0eXBlOiBiaW5hcnkgb3IgdGV4dCAqL1xuICB0aGlzLmRhdGFfdHlwZSA9IDIvKlpfVU5LTk9XTiovO1xuICAvKiBhZGxlcjMyIHZhbHVlIG9mIHRoZSB1bmNvbXByZXNzZWQgZGF0YSAqL1xuICB0aGlzLmFkbGVyID0gMDtcbn1cblxudmFyIHpzdHJlYW0gPSBaU3RyZWFtO1xuXG5jb25zdCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5jb25zdCB7XG4gIFpfTk9fRkxVU0g6IFpfTk9fRkxVU0gkMSwgWl9TWU5DX0ZMVVNILCBaX0ZVTExfRkxVU0g6IFpfRlVMTF9GTFVTSCQxLCBaX0ZJTklTSDogWl9GSU5JU0gkMSxcbiAgWl9PSzogWl9PSyQxLCBaX1NUUkVBTV9FTkQ6IFpfU1RSRUFNX0VORCQxLFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT046IFpfREVGQVVMVF9DT01QUkVTU0lPTiQxLFxuICBaX0RFRkFVTFRfU1RSQVRFR1k6IFpfREVGQVVMVF9TVFJBVEVHWSQxLFxuICBaX0RFRkxBVEVEOiBaX0RFRkxBVEVEJDFcbn0gPSBjb25zdGFudHM7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyoqXG4gKiBjbGFzcyBEZWZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbZGVmbGF0ZV1dLFxuICogW1tkZWZsYXRlUmF3XV0gYW5kIFtbZ3ppcF1dLlxuICoqL1xuXG4vKiBpbnRlcm5hbFxuICogRGVmbGF0ZS5jaHVua3MgLT4gQXJyYXlcbiAqXG4gKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbRGVmbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGRlbi5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLnJlc3VsdCAtPiBVaW50OEFycmF5XG4gKlxuICogQ29tcHJlc3NlZCByZXN1bHQsIGdlbmVyYXRlZCBieSBkZWZhdWx0IFtbRGVmbGF0ZSNvbkRhdGFdXVxuICogYW5kIFtbRGVmbGF0ZSNvbkVuZF1dIGhhbmRsZXJzLiBGaWxsZWQgYWZ0ZXIgeW91IHB1c2ggbGFzdCBjaHVua1xuICogKGNhbGwgW1tEZWZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUuZXJyIC0+IE51bWJlclxuICpcbiAqIEVycm9yIGNvZGUgYWZ0ZXIgZGVmbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy5cbiAqIFlvdSB3aWxsIG5vdCBuZWVkIGl0IGluIHJlYWwgbGlmZSwgYmVjYXVzZSBkZWZsYXRlIGVycm9yc1xuICogYXJlIHBvc3NpYmxlIG9ubHkgb24gd3Jvbmcgb3B0aW9ucyBvciBiYWQgYG9uRGF0YWAgLyBgb25FbmRgXG4gKiBjdXN0b20gaGFuZGxlcnMuXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5tc2cgLT4gU3RyaW5nXG4gKlxuICogRXJyb3IgbWVzc2FnZSwgaWYgW1tEZWZsYXRlLmVycl1dICE9IDBcbiAqKi9cblxuXG4vKipcbiAqIG5ldyBEZWZsYXRlKG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIENyZWF0ZXMgbmV3IGRlZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvblxuICogb24gYmFkIHBhcmFtcy4gU3VwcG9ydGVkIG9wdGlvbnM6XG4gKlxuICogLSBgbGV2ZWxgXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgbWVtTGV2ZWxgXG4gKiAtIGBzdHJhdGVneWBcbiAqIC0gYGRpY3Rpb25hcnlgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGRlZmxhdGVcbiAqIC0gYGd6aXBgIChCb29sZWFuKSAtIGNyZWF0ZSBnemlwIHdyYXBwZXJcbiAqIC0gYGhlYWRlcmAgKE9iamVjdCkgLSBjdXN0b20gaGVhZGVyIGZvciBnemlwXG4gKiAgIC0gYHRleHRgIChCb29sZWFuKSAtIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHRcbiAqICAgLSBgdGltZWAgKE51bWJlcikgLSBtb2RpZmljYXRpb24gdGltZSwgdW5peCB0aW1lc3RhbXBcbiAqICAgLSBgb3NgIChOdW1iZXIpIC0gb3BlcmF0aW9uIHN5c3RlbSBjb2RlXG4gKiAgIC0gYGV4dHJhYCAoQXJyYXkpIC0gYXJyYXkgb2YgYnl0ZXMgd2l0aCBleHRyYSBkYXRhIChtYXggNjU1MzYpXG4gKiAgIC0gYG5hbWVgIChTdHJpbmcpIC0gZmlsZSBuYW1lIChiaW5hcnkgc3RyaW5nKVxuICogICAtIGBjb21tZW50YCAoU3RyaW5nKSAtIGNvbW1lbnQgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGhjcmNgIChCb29sZWFuKSAtIHRydWUgaWYgaGVhZGVyIGNyYyBzaG91bGQgYmUgYWRkZWRcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBuZXcgVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIGNodW5rMiA9IG5ldyBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIGNvbnN0IGRlZmxhdGUgPSBuZXcgcGFrby5EZWZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBkZWZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBkZWZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChkZWZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoZGVmbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coZGVmbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBEZWZsYXRlKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gY29tbW9uLmFzc2lnbih7XG4gICAgbGV2ZWw6IFpfREVGQVVMVF9DT01QUkVTU0lPTiQxLFxuICAgIG1ldGhvZDogWl9ERUZMQVRFRCQxLFxuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMTUsXG4gICAgbWVtTGV2ZWw6IDgsXG4gICAgc3RyYXRlZ3k6IFpfREVGQVVMVF9TVFJBVEVHWSQxXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIGxldCBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKG9wdC5nemlwICYmIChvcHQud2luZG93Qml0cyA+IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDE2O1xuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtID0gbmV3IHpzdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgbGV0IHN0YXR1cyA9IGRlZmxhdGVfMS5kZWZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC5sZXZlbCxcbiAgICBvcHQubWV0aG9kLFxuICAgIG9wdC53aW5kb3dCaXRzLFxuICAgIG9wdC5tZW1MZXZlbCxcbiAgICBvcHQuc3RyYXRlZ3lcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBaX09LJDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXNbc3RhdHVzXSk7XG4gIH1cblxuICBpZiAob3B0LmhlYWRlcikge1xuICAgIGRlZmxhdGVfMS5kZWZsYXRlU2V0SGVhZGVyKHRoaXMuc3RybSwgb3B0LmhlYWRlcik7XG4gIH1cblxuICBpZiAob3B0LmRpY3Rpb25hcnkpIHtcbiAgICBsZXQgZGljdDtcbiAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIElmIHdlIG5lZWQgdG8gY29tcHJlc3MgdGV4dCwgY2hhbmdlIGVuY29kaW5nIHRvIHV0ZjguXG4gICAgICBkaWN0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBkaWN0ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWN0ID0gb3B0LmRpY3Rpb25hcnk7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gZGVmbGF0ZV8xLmRlZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdCk7XG5cbiAgICBpZiAoc3RhdHVzICE9PSBaX09LJDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlc1tzdGF0dXNdKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaWN0X3NldCA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZsYXRlI3B1c2goZGF0YVssIGZsdXNoX21vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YS4gU3RyaW5ncyB3aWxsIGJlXG4gKiAgIGNvbnZlcnRlZCB0byB1dGY4IGJ5dGUgc2VxdWVuY2UuXG4gKiAtIGZsdXNoX21vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBkZWZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tEZWZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBjb21wcmVzc2VkIGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0XG4gKiBoYXZlIGBmbHVzaF9tb2RlYCBaX0ZJTklTSCAob3IgYHRydWVgKS4gVGhhdCB3aWxsIGZsdXNoIGludGVybmFsIHBlbmRpbmdcbiAqIGJ1ZmZlcnMgYW5kIGNhbGwgW1tEZWZsYXRlI29uRW5kXV0uXG4gKlxuICogT24gZmFpbCBjYWxsIFtbRGVmbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgZmx1c2hfbW9kZSkge1xuICBjb25zdCBzdHJtID0gdGhpcy5zdHJtO1xuICBjb25zdCBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICBsZXQgc3RhdHVzLCBfZmx1c2hfbW9kZTtcblxuICBpZiAodGhpcy5lbmRlZCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoZmx1c2hfbW9kZSA9PT0gfn5mbHVzaF9tb2RlKSBfZmx1c2hfbW9kZSA9IGZsdXNoX21vZGU7XG4gIGVsc2UgX2ZsdXNoX21vZGUgPSBmbHVzaF9tb2RlID09PSB0cnVlID8gWl9GSU5JU0gkMSA6IFpfTk9fRkxVU0gkMTtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBmb3IgKDs7KSB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyBVaW50OEFycmF5KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSBhdmFpbF9vdXQgPiA2IHRvIGF2b2lkIHJlcGVhdGluZyBtYXJrZXJzXG4gICAgaWYgKChfZmx1c2hfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIIHx8IF9mbHVzaF9tb2RlID09PSBaX0ZVTExfRkxVU0gkMSkgJiYgc3RybS5hdmFpbF9vdXQgPD0gNikge1xuICAgICAgdGhpcy5vbkRhdGEoc3RybS5vdXRwdXQuc3ViYXJyYXkoMCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gZGVmbGF0ZV8xLmRlZmxhdGUoc3RybSwgX2ZsdXNoX21vZGUpO1xuXG4gICAgLy8gRW5kZWQgPT4gZmx1c2ggYW5kIGZpbmlzaFxuICAgIGlmIChzdGF0dXMgPT09IFpfU1RSRUFNX0VORCQxKSB7XG4gICAgICBpZiAoc3RybS5uZXh0X291dCA+IDApIHtcbiAgICAgICAgdGhpcy5vbkRhdGEoc3RybS5vdXRwdXQuc3ViYXJyYXkoMCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgfVxuICAgICAgc3RhdHVzID0gZGVmbGF0ZV8xLmRlZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHN0YXR1cyA9PT0gWl9PSyQxO1xuICAgIH1cblxuICAgIC8vIEZsdXNoIGlmIG91dCBidWZmZXIgZnVsbFxuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgdGhpcy5vbkRhdGEoc3RybS5vdXRwdXQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gRmx1c2ggaWYgcmVxdWVzdGVkIGFuZCBoYXMgZGF0YVxuICAgIGlmIChfZmx1c2hfbW9kZSA+IDAgJiYgc3RybS5uZXh0X291dCA+IDApIHtcbiAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0LnN1YmFycmF5KDAsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzdHJtLmF2YWlsX2luID09PSAwKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkXG4gKiAtIGNodW5rIChVaW50OEFycmF5KTogb3V0cHV0IGRhdGEuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBkZWZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBvbmNlIGFmdGVyIHlvdSB0ZWxsIGRlZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBaX09LJDEpIHtcbiAgICB0aGlzLnJlc3VsdCA9IGNvbW1vbi5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuICB0aGlzLmVyciA9IHN0YXR1cztcbiAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xufTtcblxuXG4vKipcbiAqIGRlZmxhdGUoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5XG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ29tcHJlc3MgYGRhdGFgIHdpdGggZGVmbGF0ZSBhbGdvcml0aG0gYW5kIGBvcHRpb25zYC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSBsZXZlbFxuICogLSB3aW5kb3dCaXRzXG4gKiAtIG1lbUxldmVsXG4gKiAtIHN0cmF0ZWd5XG4gKiAtIGRpY3Rpb25hcnlcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSk7XG4gKlxuICogY29uc29sZS5sb2cocGFrby5kZWZsYXRlKGRhdGEpKTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZSQxKGlucHV0LCBvcHRpb25zKSB7XG4gIGNvbnN0IGRlZmxhdG9yID0gbmV3IERlZmxhdGUob3B0aW9ucyk7XG5cbiAgZGVmbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGRlZmxhdG9yLmVycikgeyB0aHJvdyBkZWZsYXRvci5tc2cgfHwgbWVzc2FnZXNbZGVmbGF0b3IuZXJyXTsgfVxuXG4gIHJldHVybiBkZWZsYXRvci5yZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBkZWZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheVxuICogLSBkYXRhIChVaW50OEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbZGVmbGF0ZV1dLCBidXQgY3JlYXRlcyByYXcgZGF0YSwgd2l0aG91dCB3cmFwcGVyXG4gKiAoaGVhZGVyIGFuZCBhZGxlcjMyIGNyYykuXG4gKiovXG5mdW5jdGlvbiBkZWZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnJhdyA9IHRydWU7XG4gIHJldHVybiBkZWZsYXRlJDEoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXlcbiAqIC0gZGF0YSAoVWludDhBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2RlZmxhdGVdXSwgYnV0IGNyZWF0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCBvZlxuICogZGVmbGF0ZSBvbmUuXG4gKiovXG5mdW5jdGlvbiBnemlwKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmd6aXAgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZSQxKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG52YXIgRGVmbGF0ZV8xID0gRGVmbGF0ZTtcbnZhciBkZWZsYXRlXzIkMSA9IGRlZmxhdGUkMTtcbnZhciBkZWZsYXRlUmF3XzEgPSBkZWZsYXRlUmF3O1xudmFyIGd6aXBfMSA9IGd6aXA7XG52YXIgY29uc3RhbnRzJDEgPSBjb25zdGFudHM7XG5cbnZhciBkZWZsYXRlXzEkMSA9IHtcblx0RGVmbGF0ZTogRGVmbGF0ZV8xLFxuXHRkZWZsYXRlOiBkZWZsYXRlXzIkMSxcblx0ZGVmbGF0ZVJhdzogZGVmbGF0ZVJhd18xLFxuXHRnemlwOiBnemlwXzEsXG5cdGNvbnN0YW50czogY29uc3RhbnRzJDFcbn07XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gU2VlIHN0YXRlIGRlZnMgZnJvbSBpbmZsYXRlLmpzXG5jb25zdCBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xuY29uc3QgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cblxuLypcbiAgIERlY29kZSBsaXRlcmFsLCBsZW5ndGgsIGFuZCBkaXN0YW5jZSBjb2RlcyBhbmQgd3JpdGUgb3V0IHRoZSByZXN1bHRpbmdcbiAgIGxpdGVyYWwgYW5kIG1hdGNoIGJ5dGVzIHVudGlsIGVpdGhlciBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dCBpc1xuICAgYXZhaWxhYmxlLCBhbiBlbmQtb2YtYmxvY2sgaXMgZW5jb3VudGVyZWQsIG9yIGEgZGF0YSBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAgIFdoZW4gbGFyZ2UgZW5vdWdoIGlucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBhcmUgc3VwcGxpZWQgdG8gaW5mbGF0ZSgpLCBmb3JcbiAgIGV4YW1wbGUsIGEgMTZLIGlucHV0IGJ1ZmZlciBhbmQgYSA2NEsgb3V0cHV0IGJ1ZmZlciwgbW9yZSB0aGFuIDk1JSBvZiB0aGVcbiAgIGluZmxhdGUgZXhlY3V0aW9uIHRpbWUgaXMgc3BlbnQgaW4gdGhpcyByb3V0aW5lLlxuXG4gICBFbnRyeSBhc3N1bXB0aW9uczpcblxuICAgICAgICBzdGF0ZS5tb2RlID09PSBMRU5cbiAgICAgICAgc3RybS5hdmFpbF9pbiA+PSA2XG4gICAgICAgIHN0cm0uYXZhaWxfb3V0ID49IDI1OFxuICAgICAgICBzdGFydCA+PSBzdHJtLmF2YWlsX291dFxuICAgICAgICBzdGF0ZS5iaXRzIDwgOFxuXG4gICBPbiByZXR1cm4sIHN0YXRlLm1vZGUgaXMgb25lIG9mOlxuXG4gICAgICAgIExFTiAtLSByYW4gb3V0IG9mIGVub3VnaCBvdXRwdXQgc3BhY2Ugb3IgZW5vdWdoIGF2YWlsYWJsZSBpbnB1dFxuICAgICAgICBUWVBFIC0tIHJlYWNoZWQgZW5kIG9mIGJsb2NrIGNvZGUsIGluZmxhdGUoKSB0byBpbnRlcnByZXQgbmV4dCBibG9ja1xuICAgICAgICBCQUQgLS0gZXJyb3IgaW4gYmxvY2sgZGF0YVxuXG4gICBOb3RlczpcblxuICAgIC0gVGhlIG1heGltdW0gaW5wdXQgYml0cyB1c2VkIGJ5IGEgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgaXMgMTUgYml0cyBmb3IgdGhlXG4gICAgICBsZW5ndGggY29kZSwgNSBiaXRzIGZvciB0aGUgbGVuZ3RoIGV4dHJhLCAxNSBiaXRzIGZvciB0aGUgZGlzdGFuY2UgY29kZSxcbiAgICAgIGFuZCAxMyBiaXRzIGZvciB0aGUgZGlzdGFuY2UgZXh0cmEuICBUaGlzIHRvdGFscyA0OCBiaXRzLCBvciBzaXggYnl0ZXMuXG4gICAgICBUaGVyZWZvcmUgaWYgc3RybS5hdmFpbF9pbiA+PSA2LCB0aGVuIHRoZXJlIGlzIGVub3VnaCBpbnB1dCB0byBhdm9pZFxuICAgICAgY2hlY2tpbmcgZm9yIGF2YWlsYWJsZSBpbnB1dCB3aGlsZSBkZWNvZGluZy5cblxuICAgIC0gVGhlIG1heGltdW0gYnl0ZXMgdGhhdCBhIHNpbmdsZSBsZW5ndGgvZGlzdGFuY2UgcGFpciBjYW4gb3V0cHV0IGlzIDI1OFxuICAgICAgYnl0ZXMsIHdoaWNoIGlzIHRoZSBtYXhpbXVtIGxlbmd0aCB0aGF0IGNhbiBiZSBjb2RlZC4gIGluZmxhdGVfZmFzdCgpXG4gICAgICByZXF1aXJlcyBzdHJtLmF2YWlsX291dCA+PSAyNTggZm9yIGVhY2ggbG9vcCB0byBhdm9pZCBjaGVja2luZyBmb3JcbiAgICAgIG91dHB1dCBzcGFjZS5cbiAqL1xudmFyIGluZmZhc3QgPSBmdW5jdGlvbiBpbmZsYXRlX2Zhc3Qoc3RybSwgc3RhcnQpIHtcbiAgbGV0IF9pbjsgICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaW5wdXQgKi9cbiAgbGV0IGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIGhhdmUgZW5vdWdoIGlucHV0IHdoaWxlIGluIDwgbGFzdCAqL1xuICBsZXQgX291dDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5vdXRwdXQgKi9cbiAgbGV0IGJlZzsgICAgICAgICAgICAgICAgICAgIC8qIGluZmxhdGUoKSdzIGluaXRpYWwgc3RybS5vdXRwdXQgKi9cbiAgbGV0IGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHdoaWxlIG91dCA8IGVuZCwgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSAqL1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgbGV0IGRtYXg7ICAgICAgICAgICAgICAgICAgIC8qIG1heGltdW0gZGlzdGFuY2UgZnJvbSB6bGliIGhlYWRlciAqL1xuLy8jZW5kaWZcbiAgbGV0IHdzaXplOyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICBsZXQgd2hhdmU7ICAgICAgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICBsZXQgd25leHQ7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIC8vIFVzZSBgc193aW5kb3dgIGluc3RlYWQgYHdpbmRvd2AsIGF2b2lkIGNvbmZsaWN0IHdpdGggaW5zdHJ1bWVudGF0aW9uIHRvb2xzXG4gIGxldCBzX3dpbmRvdzsgICAgICAgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIHdzaXplICE9IDAgKi9cbiAgbGV0IGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaG9sZCAqL1xuICBsZXQgYml0czsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5iaXRzICovXG4gIGxldCBsY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmxlbmNvZGUgKi9cbiAgbGV0IGRjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uZGlzdGNvZGUgKi9cbiAgbGV0IGxtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGxlbmd0aCBjb2RlcyAqL1xuICBsZXQgZG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgZGlzdGFuY2UgY29kZXMgKi9cbiAgbGV0IGhlcmU7ICAgICAgICAgICAgICAgICAgIC8qIHJldHJpZXZlZCB0YWJsZSBlbnRyeSAqL1xuICBsZXQgb3A7ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBiaXRzLCBvcGVyYXRpb24sIGV4dHJhIGJpdHMsIG9yICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgd2luZG93IHBvc2l0aW9uLCB3aW5kb3cgYnl0ZXMgdG8gY29weSAqL1xuICBsZXQgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoLCB1bnVzZWQgYnl0ZXMgKi9cbiAgbGV0IGRpc3Q7ICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGRpc3RhbmNlICovXG4gIGxldCBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGZyb20gKi9cbiAgbGV0IGZyb21fc291cmNlO1xuXG5cbiAgbGV0IGlucHV0LCBvdXRwdXQ7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcblxuICAvKiBjb3B5IHN0YXRlIHRvIGxvY2FsIHZhcmlhYmxlcyAqL1xuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIC8vaGVyZSA9IHN0YXRlLmhlcmU7XG4gIF9pbiA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBsYXN0ID0gX2luICsgKHN0cm0uYXZhaWxfaW4gLSA1KTtcbiAgX291dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBiZWcgPSBfb3V0IC0gKHN0YXJ0IC0gc3RybS5hdmFpbF9vdXQpO1xuICBlbmQgPSBfb3V0ICsgKHN0cm0uYXZhaWxfb3V0IC0gMjU3KTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIGRtYXggPSBzdGF0ZS5kbWF4O1xuLy8jZW5kaWZcbiAgd3NpemUgPSBzdGF0ZS53c2l6ZTtcbiAgd2hhdmUgPSBzdGF0ZS53aGF2ZTtcbiAgd25leHQgPSBzdGF0ZS53bmV4dDtcbiAgc193aW5kb3cgPSBzdGF0ZS53aW5kb3c7XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgbGNvZGUgPSBzdGF0ZS5sZW5jb2RlO1xuICBkY29kZSA9IHN0YXRlLmRpc3Rjb2RlO1xuICBsbWFzayA9ICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMTtcbiAgZG1hc2sgPSAoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxO1xuXG5cbiAgLyogZGVjb2RlIGxpdGVyYWxzIGFuZCBsZW5ndGgvZGlzdGFuY2VzIHVudGlsIGVuZC1vZi1ibG9jayBvciBub3QgZW5vdWdoXG4gICAgIGlucHV0IGRhdGEgb3Igb3V0cHV0IHNwYWNlICovXG5cbiAgdG9wOlxuICBkbyB7XG4gICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgfVxuXG4gICAgaGVyZSA9IGxjb2RlW2hvbGQgJiBsbWFza107XG5cbiAgICBkb2xlbjpcbiAgICBmb3IgKDs7KSB7IC8vIEdvdG8gZW11bGF0aW9uXG4gICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgIGJpdHMgLT0gb3A7XG4gICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG4gICAgICBpZiAob3AgPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxpdGVyYWwgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgb3V0cHV0W19vdXQrK10gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBiYXNlICovXG4gICAgICAgIGxlbiA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgIGlmIChvcCkge1xuICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbiArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIGxlbikpO1xuICAgICAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgaGVyZSA9IGRjb2RlW2hvbGQgJiBkbWFza107XG5cbiAgICAgICAgZG9kaXN0OlxuICAgICAgICBmb3IgKDs7KSB7IC8vIGdvdG8gZW11bGF0aW9uXG4gICAgICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuXG4gICAgICAgICAgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFzZSAqL1xuICAgICAgICAgICAgZGlzdCA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXN0ICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICAgICAgaWYgKGRpc3QgPiBkbWF4KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIGRpc3QpKTtcbiAgICAgICAgICAgIG9wID0gX291dCAtIGJlZzsgICAgICAgICAgICAgICAgLyogbWF4IGRpc3RhbmNlIGluIG91dHB1dCAqL1xuICAgICAgICAgICAgaWYgKGRpc3QgPiBvcCkgeyAgICAgICAgICAgICAgICAvKiBzZWUgaWYgY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBvcCA9IGRpc3QgLSBvcDsgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBpZiAob3AgPiB3aGF2ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgICAgICAgaWYgKGxlbiA8PSBvcCAtIHdoYXZlKSB7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgbGVuIC09IG9wIC0gd2hhdmU7XG4vLyAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3AgPiB3aGF2ZSk7XG4vLyAgICAgICAgICAgICAgICBpZiAob3AgPT09IDApIHtcbi8vICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0O1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZyb20gPSAwOyAvLyB3aW5kb3cgaW5kZXhcbiAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzX3dpbmRvdztcbiAgICAgICAgICAgICAgaWYgKHduZXh0ID09PSAwKSB7ICAgICAgICAgICAvKiB2ZXJ5IGNvbW1vbiBjYXNlICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAod25leHQgPCBvcCkgeyAgICAgIC8qIHdyYXAgYXJvdW5kIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgKyB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIG9wIC09IHduZXh0O1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSBlbmQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7XG4gICAgICAgICAgICAgICAgICBpZiAod25leHQgPCBsZW4pIHsgIC8qIHNvbWUgZnJvbSBzdGFydCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgICAgb3AgPSB3bmV4dDtcbiAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAvKiBjb250aWd1b3VzIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdoaWxlIChsZW4gPiAyKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAgICAgLyogY29weSBkaXJlY3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgIC8qIG1pbmltdW0gbGVuZ3RoIGlzIHRocmVlICovXG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiA+IDIpO1xuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgIC8qIDJuZCBsZXZlbCBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgICAgICBoZXJlID0gZGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIGRvZGlzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgICAgIC8qIDJuZCBsZXZlbCBsZW5ndGggY29kZSAqL1xuICAgICAgICBoZXJlID0gbGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgY29udGludWUgZG9sZW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDMyKSB7ICAgICAgICAgICAgICAgICAgICAgLyogZW5kLW9mLWJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgfVxuICB9IHdoaWxlIChfaW4gPCBsYXN0ICYmIF9vdXQgPCBlbmQpO1xuXG4gIC8qIHJldHVybiB1bnVzZWQgYnl0ZXMgKG9uIGVudHJ5LCBiaXRzIDwgOCwgc28gaW4gd29uJ3QgZ28gdG9vIGZhciBiYWNrKSAqL1xuICBsZW4gPSBiaXRzID4+IDM7XG4gIF9pbiAtPSBsZW47XG4gIGJpdHMgLT0gbGVuIDw8IDM7XG4gIGhvbGQgJj0gKDEgPDwgYml0cykgLSAxO1xuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmV0dXJuICovXG4gIHN0cm0ubmV4dF9pbiA9IF9pbjtcbiAgc3RybS5uZXh0X291dCA9IF9vdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSAoX2luIDwgbGFzdCA/IDUgKyAobGFzdCAtIF9pbikgOiA1IC0gKF9pbiAtIGxhc3QpKTtcbiAgc3RybS5hdmFpbF9vdXQgPSAoX291dCA8IGVuZCA/IDI1NyArIChlbmQgLSBfb3V0KSA6IDI1NyAtIChfb3V0IC0gZW5kKSk7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgcmV0dXJuO1xufTtcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5jb25zdCBNQVhCSVRTID0gMTU7XG5jb25zdCBFTk9VR0hfTEVOUyA9IDg1MjtcbmNvbnN0IEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vY29uc3QgRU5PVUdIID0gKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbmNvbnN0IENPREVTID0gMDtcbmNvbnN0IExFTlMgPSAxO1xuY29uc3QgRElTVFMgPSAyO1xuXG5jb25zdCBsYmFzZSA9IG5ldyBVaW50MTZBcnJheShbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBiYXNlICovXG4gIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTMsIDE1LCAxNywgMTksIDIzLCAyNywgMzEsXG4gIDM1LCA0MywgNTEsIDU5LCA2NywgODMsIDk5LCAxMTUsIDEzMSwgMTYzLCAxOTUsIDIyNywgMjU4LCAwLCAwXG5dKTtcblxuY29uc3QgbGV4dCA9IG5ldyBVaW50OEFycmF5KFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LFxuICAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCwgMjAsIDIxLCAyMSwgMjEsIDIxLCAxNiwgNzIsIDc4XG5dKTtcblxuY29uc3QgZGJhc2UgPSBuZXcgVWludDE2QXJyYXkoWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBiYXNlICovXG4gIDEsIDIsIDMsIDQsIDUsIDcsIDksIDEzLCAxNywgMjUsIDMzLCA0OSwgNjUsIDk3LCAxMjksIDE5MyxcbiAgMjU3LCAzODUsIDUxMywgNzY5LCAxMDI1LCAxNTM3LCAyMDQ5LCAzMDczLCA0MDk3LCA2MTQ1LFxuICA4MTkzLCAxMjI4OSwgMTYzODUsIDI0NTc3LCAwLCAwXG5dKTtcblxuY29uc3QgZGV4dCA9IG5ldyBVaW50OEFycmF5KFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTgsIDE4LCAxOSwgMTksIDIwLCAyMCwgMjEsIDIxLCAyMiwgMjIsXG4gIDIzLCAyMywgMjQsIDI0LCAyNSwgMjUsIDI2LCAyNiwgMjcsIDI3LFxuICAyOCwgMjgsIDI5LCAyOSwgNjQsIDY0XG5dKTtcblxuY29uc3QgaW5mbGF0ZV90YWJsZSA9ICh0eXBlLCBsZW5zLCBsZW5zX2luZGV4LCBjb2RlcywgdGFibGUsIHRhYmxlX2luZGV4LCB3b3JrLCBvcHRzKSA9Plxue1xuICBjb25zdCBiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy9oZXJlID0gb3B0cy5oZXJlOyAvKiB0YWJsZSBlbnRyeSBmb3IgZHVwbGljYXRpb24gKi9cblxuICBsZXQgbGVuID0gMDsgICAgICAgICAgICAgICAvKiBhIGNvZGUncyBsZW5ndGggaW4gYml0cyAqL1xuICBsZXQgc3ltID0gMDsgICAgICAgICAgICAgICAvKiBpbmRleCBvZiBjb2RlIHN5bWJvbHMgKi9cbiAgbGV0IG1pbiA9IDAsIG1heCA9IDA7ICAgICAgICAgIC8qIG1pbmltdW0gYW5kIG1heGltdW0gY29kZSBsZW5ndGhzICovXG4gIGxldCByb290ID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciByb290IHRhYmxlICovXG4gIGxldCBjdXJyID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciBjdXJyZW50IHRhYmxlICovXG4gIGxldCBkcm9wID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgYml0cyB0byBkcm9wIGZvciBzdWItdGFibGUgKi9cbiAgbGV0IGxlZnQgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgcHJlZml4IGNvZGVzIGF2YWlsYWJsZSAqL1xuICBsZXQgdXNlZCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGVudHJpZXMgaW4gdGFibGUgdXNlZCAqL1xuICBsZXQgaHVmZiA9IDA7ICAgICAgICAgICAgICAvKiBIdWZmbWFuIGNvZGUgKi9cbiAgbGV0IGluY3I7ICAgICAgICAgICAgICAvKiBmb3IgaW5jcmVtZW50aW5nIGNvZGUsIGluZGV4ICovXG4gIGxldCBmaWxsOyAgICAgICAgICAgICAgLyogaW5kZXggZm9yIHJlcGxpY2F0aW5nIGVudHJpZXMgKi9cbiAgbGV0IGxvdzsgICAgICAgICAgICAgICAvKiBsb3cgYml0cyBmb3IgY3VycmVudCByb290IGVudHJ5ICovXG4gIGxldCBtYXNrOyAgICAgICAgICAgICAgLyogbWFzayBmb3IgbG93IHJvb3QgYml0cyAqL1xuICBsZXQgbmV4dDsgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gdGFibGUgKi9cbiAgbGV0IGJhc2UgPSBudWxsOyAgICAgLyogYmFzZSB2YWx1ZSB0YWJsZSB0byB1c2UgKi9cbiAgbGV0IGJhc2VfaW5kZXggPSAwO1xuLy8gIGxldCBzaG9leHRyYTsgICAgLyogZXh0cmEgYml0cyB0YWJsZSB0byB1c2UgKi9cbiAgbGV0IGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHVzZSBiYXNlIGFuZCBleHRyYSBmb3Igc3ltYm9sID4gZW5kICovXG4gIGNvbnN0IGNvdW50ID0gbmV3IFVpbnQxNkFycmF5KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgLyogbnVtYmVyIG9mIGNvZGVzIG9mIGVhY2ggbGVuZ3RoICovXG4gIGNvbnN0IG9mZnMgPSBuZXcgVWludDE2QXJyYXkoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAgLyogb2Zmc2V0cyBpbiB0YWJsZSBmb3IgZWFjaCBsZW5ndGggKi9cbiAgbGV0IGV4dHJhID0gbnVsbDtcbiAgbGV0IGV4dHJhX2luZGV4ID0gMDtcblxuICBsZXQgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDtcblxuICAvKlxuICAgUHJvY2VzcyBhIHNldCBvZiBjb2RlIGxlbmd0aHMgdG8gY3JlYXRlIGEgY2Fub25pY2FsIEh1ZmZtYW4gY29kZS4gIFRoZVxuICAgY29kZSBsZW5ndGhzIGFyZSBsZW5zWzAuLmNvZGVzLTFdLiAgRWFjaCBsZW5ndGggY29ycmVzcG9uZHMgdG8gdGhlXG4gICBzeW1ib2xzIDAuLmNvZGVzLTEuICBUaGUgSHVmZm1hbiBjb2RlIGlzIGdlbmVyYXRlZCBieSBmaXJzdCBzb3J0aW5nIHRoZVxuICAgc3ltYm9scyBieSBsZW5ndGggZnJvbSBzaG9ydCB0byBsb25nLCBhbmQgcmV0YWluaW5nIHRoZSBzeW1ib2wgb3JkZXJcbiAgIGZvciBjb2RlcyB3aXRoIGVxdWFsIGxlbmd0aHMuICBUaGVuIHRoZSBjb2RlIHN0YXJ0cyB3aXRoIGFsbCB6ZXJvIGJpdHNcbiAgIGZvciB0aGUgZmlyc3QgY29kZSBvZiB0aGUgc2hvcnRlc3QgbGVuZ3RoLCBhbmQgdGhlIGNvZGVzIGFyZSBpbnRlZ2VyXG4gICBpbmNyZW1lbnRzIGZvciB0aGUgc2FtZSBsZW5ndGgsIGFuZCB6ZXJvcyBhcmUgYXBwZW5kZWQgYXMgdGhlIGxlbmd0aFxuICAgaW5jcmVhc2VzLiAgRm9yIHRoZSBkZWZsYXRlIGZvcm1hdCwgdGhlc2UgYml0cyBhcmUgc3RvcmVkIGJhY2t3YXJkc1xuICAgZnJvbSB0aGVpciBtb3JlIG5hdHVyYWwgaW50ZWdlciBpbmNyZW1lbnQgb3JkZXJpbmcsIGFuZCBzbyB3aGVuIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzIGFyZSBidWlsdCBpbiB0aGUgbGFyZ2UgbG9vcCBiZWxvdywgdGhlIGludGVnZXIgY29kZXNcbiAgIGFyZSBpbmNyZW1lbnRlZCBiYWNrd2FyZHMuXG5cbiAgIFRoaXMgcm91dGluZSBhc3N1bWVzLCBidXQgZG9lcyBub3QgY2hlY2ssIHRoYXQgYWxsIG9mIHRoZSBlbnRyaWVzIGluXG4gICBsZW5zW10gYXJlIGluIHRoZSByYW5nZSAwLi5NQVhCSVRTLiAgVGhlIGNhbGxlciBtdXN0IGFzc3VyZSB0aGlzLlxuICAgMS4uTUFYQklUUyBpcyBpbnRlcnByZXRlZCBhcyB0aGF0IGNvZGUgbGVuZ3RoLiAgemVybyBtZWFucyB0aGF0IHRoYXRcbiAgIHN5bWJvbCBkb2VzIG5vdCBvY2N1ciBpbiB0aGlzIGNvZGUuXG5cbiAgIFRoZSBjb2RlcyBhcmUgc29ydGVkIGJ5IGNvbXB1dGluZyBhIGNvdW50IG9mIGNvZGVzIGZvciBlYWNoIGxlbmd0aCxcbiAgIGNyZWF0aW5nIGZyb20gdGhhdCBhIHRhYmxlIG9mIHN0YXJ0aW5nIGluZGljZXMgZm9yIGVhY2ggbGVuZ3RoIGluIHRoZVxuICAgc29ydGVkIHRhYmxlLCBhbmQgdGhlbiBlbnRlcmluZyB0aGUgc3ltYm9scyBpbiBvcmRlciBpbiB0aGUgc29ydGVkXG4gICB0YWJsZS4gIFRoZSBzb3J0ZWQgdGFibGUgaXMgd29ya1tdLCB3aXRoIHRoYXQgc3BhY2UgYmVpbmcgcHJvdmlkZWQgYnlcbiAgIHRoZSBjYWxsZXIuXG5cbiAgIFRoZSBsZW5ndGggY291bnRzIGFyZSB1c2VkIGZvciBvdGhlciBwdXJwb3NlcyBhcyB3ZWxsLCBpLmUuIGZpbmRpbmdcbiAgIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGxlbmd0aCBjb2RlcywgZGV0ZXJtaW5pbmcgaWYgdGhlcmUgYXJlIGFueVxuICAgY29kZXMgYXQgYWxsLCBjaGVja2luZyBmb3IgYSB2YWxpZCBzZXQgb2YgbGVuZ3RocywgYW5kIGxvb2tpbmcgYWhlYWRcbiAgIGF0IGxlbmd0aCBjb3VudHMgdG8gZGV0ZXJtaW5lIHN1Yi10YWJsZSBzaXplcyB3aGVuIGJ1aWxkaW5nIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzLlxuICAgKi9cblxuICAvKiBhY2N1bXVsYXRlIGxlbmd0aHMgZm9yIGNvZGVzIChhc3N1bWVzIGxlbnNbXSBhbGwgaW4gMC4uTUFYQklUUykgKi9cbiAgZm9yIChsZW4gPSAwOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBjb3VudFtsZW5dID0gMDtcbiAgfVxuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGNvdW50W2xlbnNbbGVuc19pbmRleCArIHN5bV1dKys7XG4gIH1cblxuICAvKiBib3VuZCBjb2RlIGxlbmd0aHMsIGZvcmNlIHJvb3QgdG8gYmUgd2l0aGluIGNvZGUgbGVuZ3RocyAqL1xuICByb290ID0gYml0cztcbiAgZm9yIChtYXggPSBNQVhCSVRTOyBtYXggPj0gMTsgbWF4LS0pIHtcbiAgICBpZiAoY291bnRbbWF4XSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290ID4gbWF4KSB7XG4gICAgcm9vdCA9IG1heDtcbiAgfVxuICBpZiAobWF4ID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgLyogbm8gc3ltYm9scyB0byBjb2RlIGF0IGFsbCAqL1xuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDsgIC8vaGVyZS5vcCA9ICh2YXIgY2hhcik2NDsgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7ICAgLy9oZXJlLmJpdHMgPSAodmFyIGNoYXIpMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDsgICAvL2hlcmUudmFsID0gKHZhciBzaG9ydCkwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cblxuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDtcbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cbiAgICBvcHRzLmJpdHMgPSAxO1xuICAgIHJldHVybiAwOyAgICAgLyogbm8gc3ltYm9scywgYnV0IHdhaXQgZm9yIGRlY29kaW5nIHRvIHJlcG9ydCBlcnJvciAqL1xuICB9XG4gIGZvciAobWluID0gMTsgbWluIDwgbWF4OyBtaW4rKykge1xuICAgIGlmIChjb3VudFttaW5dICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPCBtaW4pIHtcbiAgICByb290ID0gbWluO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGFuIG92ZXItc3Vic2NyaWJlZCBvciBpbmNvbXBsZXRlIHNldCBvZiBsZW5ndGhzICovXG4gIGxlZnQgPSAxO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGxlZnQgPDw9IDE7XG4gICAgbGVmdCAtPSBjb3VudFtsZW5dO1xuICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gICAgICAgIC8qIG92ZXItc3Vic2NyaWJlZCAqL1xuICB9XG4gIGlmIChsZWZ0ID4gMCAmJiAodHlwZSA9PT0gQ09ERVMgfHwgbWF4ICE9PSAxKSkge1xuICAgIHJldHVybiAtMTsgICAgICAgICAgICAgICAgICAgICAgLyogaW5jb21wbGV0ZSBzZXQgKi9cbiAgfVxuXG4gIC8qIGdlbmVyYXRlIG9mZnNldHMgaW50byBzeW1ib2wgdGFibGUgZm9yIGVhY2ggbGVuZ3RoIGZvciBzb3J0aW5nICovXG4gIG9mZnNbMV0gPSAwO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07XG4gIH1cblxuICAvKiBzb3J0IHN5bWJvbHMgYnkgbGVuZ3RoLCBieSBzeW1ib2wgb3JkZXIgd2l0aGluIGVhY2ggbGVuZ3RoICovXG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgaWYgKGxlbnNbbGVuc19pbmRleCArIHN5bV0gIT09IDApIHtcbiAgICAgIHdvcmtbb2Zmc1tsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrXSA9IHN5bTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgQ3JlYXRlIGFuZCBmaWxsIGluIGRlY29kaW5nIHRhYmxlcy4gIEluIHRoaXMgbG9vcCwgdGhlIHRhYmxlIGJlaW5nXG4gICBmaWxsZWQgaXMgYXQgbmV4dCBhbmQgaGFzIGN1cnIgaW5kZXggYml0cy4gIFRoZSBjb2RlIGJlaW5nIHVzZWQgaXMgaHVmZlxuICAgd2l0aCBsZW5ndGggbGVuLiAgVGhhdCBjb2RlIGlzIGNvbnZlcnRlZCB0byBhbiBpbmRleCBieSBkcm9wcGluZyBkcm9wXG4gICBiaXRzIG9mZiBvZiB0aGUgYm90dG9tLiAgRm9yIGNvZGVzIHdoZXJlIGxlbiBpcyBsZXNzIHRoYW4gZHJvcCArIGN1cnIsXG4gICB0aG9zZSB0b3AgZHJvcCArIGN1cnIgLSBsZW4gYml0cyBhcmUgaW5jcmVtZW50ZWQgdGhyb3VnaCBhbGwgdmFsdWVzIHRvXG4gICBmaWxsIHRoZSB0YWJsZSB3aXRoIHJlcGxpY2F0ZWQgZW50cmllcy5cblxuICAgcm9vdCBpcyB0aGUgbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHRoZSByb290IHRhYmxlLiAgV2hlbiBsZW4gZXhjZWVkc1xuICAgcm9vdCwgc3ViLXRhYmxlcyBhcmUgY3JlYXRlZCBwb2ludGVkIHRvIGJ5IHRoZSByb290IGVudHJ5IHdpdGggYW4gaW5kZXhcbiAgIG9mIHRoZSBsb3cgcm9vdCBiaXRzIG9mIGh1ZmYuICBUaGlzIGlzIHNhdmVkIGluIGxvdyB0byBjaGVjayBmb3Igd2hlbiBhXG4gICBuZXcgc3ViLXRhYmxlIHNob3VsZCBiZSBzdGFydGVkLiAgZHJvcCBpcyB6ZXJvIHdoZW4gdGhlIHJvb3QgdGFibGUgaXNcbiAgIGJlaW5nIGZpbGxlZCwgYW5kIGRyb3AgaXMgcm9vdCB3aGVuIHN1Yi10YWJsZXMgYXJlIGJlaW5nIGZpbGxlZC5cblxuICAgV2hlbiBhIG5ldyBzdWItdGFibGUgaXMgbmVlZGVkLCBpdCBpcyBuZWNlc3NhcnkgdG8gbG9vayBhaGVhZCBpbiB0aGVcbiAgIGNvZGUgbGVuZ3RocyB0byBkZXRlcm1pbmUgd2hhdCBzaXplIHN1Yi10YWJsZSBpcyBuZWVkZWQuICBUaGUgbGVuZ3RoXG4gICBjb3VudHMgYXJlIHVzZWQgZm9yIHRoaXMsIGFuZCBzbyBjb3VudFtdIGlzIGRlY3JlbWVudGVkIGFzIGNvZGVzIGFyZVxuICAgZW50ZXJlZCBpbiB0aGUgdGFibGVzLlxuXG4gICB1c2VkIGtlZXBzIHRyYWNrIG9mIGhvdyBtYW55IHRhYmxlIGVudHJpZXMgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHRoZVxuICAgcHJvdmlkZWQgKnRhYmxlIHNwYWNlLiAgSXQgaXMgY2hlY2tlZCBmb3IgTEVOUyBhbmQgRElTVCB0YWJsZXMgYWdhaW5zdFxuICAgdGhlIGNvbnN0YW50cyBFTk9VR0hfTEVOUyBhbmQgRU5PVUdIX0RJU1RTIHRvIGd1YXJkIGFnYWluc3QgY2hhbmdlcyBpblxuICAgdGhlIGluaXRpYWwgcm9vdCB0YWJsZSBzaXplIGNvbnN0YW50cy4gIFNlZSB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cbiAgIHN5bSBpbmNyZW1lbnRzIHRocm91Z2ggYWxsIHN5bWJvbHMsIGFuZCB0aGUgbG9vcCB0ZXJtaW5hdGVzIHdoZW5cbiAgIGFsbCBjb2RlcyBvZiBsZW5ndGggbWF4LCBpLmUuIGFsbCBjb2RlcywgaGF2ZSBiZWVuIHByb2Nlc3NlZC4gIFRoaXNcbiAgIHJvdXRpbmUgcGVybWl0cyBpbmNvbXBsZXRlIGNvZGVzLCBzbyBhbm90aGVyIGxvb3AgYWZ0ZXIgdGhpcyBvbmUgZmlsbHNcbiAgIGluIHRoZSByZXN0IG9mIHRoZSBkZWNvZGluZyB0YWJsZXMgd2l0aCBpbnZhbGlkIGNvZGUgbWFya2Vycy5cbiAgICovXG5cbiAgLyogc2V0IHVwIGZvciBjb2RlIHR5cGUgKi9cbiAgLy8gcG9vciBtYW4gb3B0aW1pemF0aW9uIC0gdXNlIGlmLWVsc2UgaW5zdGVhZCBvZiBzd2l0Y2gsXG4gIC8vIHRvIGF2b2lkIGRlb3B0cyBpbiBvbGQgdjhcbiAgaWYgKHR5cGUgPT09IENPREVTKSB7XG4gICAgYmFzZSA9IGV4dHJhID0gd29yazsgICAgLyogZHVtbXkgdmFsdWUtLW5vdCB1c2VkICovXG4gICAgZW5kID0gMTk7XG5cbiAgfSBlbHNlIGlmICh0eXBlID09PSBMRU5TKSB7XG4gICAgYmFzZSA9IGxiYXNlO1xuICAgIGJhc2VfaW5kZXggLT0gMjU3O1xuICAgIGV4dHJhID0gbGV4dDtcbiAgICBleHRyYV9pbmRleCAtPSAyNTc7XG4gICAgZW5kID0gMjU2O1xuXG4gIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAvKiBESVNUUyAqL1xuICAgIGJhc2UgPSBkYmFzZTtcbiAgICBleHRyYSA9IGRleHQ7XG4gICAgZW5kID0gLTE7XG4gIH1cblxuICAvKiBpbml0aWFsaXplIG9wdHMgZm9yIGxvb3AgKi9cbiAgaHVmZiA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgKi9cbiAgc3ltID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgc3ltYm9sICovXG4gIGxlbiA9IG1pbjsgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIGxlbmd0aCAqL1xuICBuZXh0ID0gdGFibGVfaW5kZXg7ICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIHRvIGZpbGwgaW4gKi9cbiAgY3VyciA9IHJvb3Q7ICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgaW5kZXggYml0cyAqL1xuICBkcm9wID0gMDsgICAgICAgICAgICAgICAgICAgLyogY3VycmVudCBiaXRzIHRvIGRyb3AgZnJvbSBjb2RlIGZvciBpbmRleCAqL1xuICBsb3cgPSAtMTsgICAgICAgICAgICAgICAgICAgLyogdHJpZ2dlciBuZXcgc3ViLXRhYmxlIHdoZW4gbGVuID4gcm9vdCAqL1xuICB1c2VkID0gMSA8PCByb290OyAgICAgICAgICAvKiB1c2Ugcm9vdCB0YWJsZSBlbnRyaWVzICovXG4gIG1hc2sgPSB1c2VkIC0gMTsgICAgICAgICAgICAvKiBtYXNrIGZvciBjb21wYXJpbmcgbG93ICovXG5cbiAgLyogY2hlY2sgYXZhaWxhYmxlIHRhYmxlIHNwYWNlICovXG4gIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvKiBwcm9jZXNzIGFsbCBjb2RlcyBhbmQgbWFrZSB0YWJsZSBlbnRyaWVzICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBjcmVhdGUgdGFibGUgZW50cnkgKi9cbiAgICBoZXJlX2JpdHMgPSBsZW4gLSBkcm9wO1xuICAgIGlmICh3b3JrW3N5bV0gPCBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSAwO1xuICAgICAgaGVyZV92YWwgPSB3b3JrW3N5bV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHdvcmtbc3ltXSA+IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IGV4dHJhW2V4dHJhX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICAgIGhlcmVfdmFsID0gYmFzZVtiYXNlX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBoZXJlX29wID0gMzIgKyA2NDsgICAgICAgICAvKiBlbmQgb2YgYmxvY2sgKi9cbiAgICAgIGhlcmVfdmFsID0gMDtcbiAgICB9XG5cbiAgICAvKiByZXBsaWNhdGUgZm9yIHRob3NlIGluZGljZXMgd2l0aCBsb3cgbGVuIGJpdHMgZXF1YWwgdG8gaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSBkcm9wKTtcbiAgICBmaWxsID0gMSA8PCBjdXJyO1xuICAgIG1pbiA9IGZpbGw7ICAgICAgICAgICAgICAgICAvKiBzYXZlIG9mZnNldCB0byBuZXh0IHRhYmxlICovXG4gICAgZG8ge1xuICAgICAgZmlsbCAtPSBpbmNyO1xuICAgICAgdGFibGVbbmV4dCArIChodWZmID4+IGRyb3ApICsgZmlsbF0gPSAoaGVyZV9iaXRzIDw8IDI0KSB8IChoZXJlX29wIDw8IDE2KSB8IGhlcmVfdmFsIHwwO1xuICAgIH0gd2hpbGUgKGZpbGwgIT09IDApO1xuXG4gICAgLyogYmFja3dhcmRzIGluY3JlbWVudCB0aGUgbGVuLWJpdCBjb2RlIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gMSk7XG4gICAgd2hpbGUgKGh1ZmYgJiBpbmNyKSB7XG4gICAgICBpbmNyID4+PSAxO1xuICAgIH1cbiAgICBpZiAoaW5jciAhPT0gMCkge1xuICAgICAgaHVmZiAmPSBpbmNyIC0gMTtcbiAgICAgIGh1ZmYgKz0gaW5jcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaHVmZiA9IDA7XG4gICAgfVxuXG4gICAgLyogZ28gdG8gbmV4dCBzeW1ib2wsIHVwZGF0ZSBjb3VudCwgbGVuICovXG4gICAgc3ltKys7XG4gICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkge1xuICAgICAgaWYgKGxlbiA9PT0gbWF4KSB7IGJyZWFrOyB9XG4gICAgICBsZW4gPSBsZW5zW2xlbnNfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cblxuICAgIC8qIGNyZWF0ZSBuZXcgc3ViLXRhYmxlIGlmIG5lZWRlZCAqL1xuICAgIGlmIChsZW4gPiByb290ICYmIChodWZmICYgbWFzaykgIT09IGxvdykge1xuICAgICAgLyogaWYgZmlyc3QgdGltZSwgdHJhbnNpdGlvbiB0byBzdWItdGFibGVzICovXG4gICAgICBpZiAoZHJvcCA9PT0gMCkge1xuICAgICAgICBkcm9wID0gcm9vdDtcbiAgICAgIH1cblxuICAgICAgLyogaW5jcmVtZW50IHBhc3QgbGFzdCB0YWJsZSAqL1xuICAgICAgbmV4dCArPSBtaW47ICAgICAgICAgICAgLyogaGVyZSBtaW4gaXMgMSA8PCBjdXJyICovXG5cbiAgICAgIC8qIGRldGVybWluZSBsZW5ndGggb2YgbmV4dCB0YWJsZSAqL1xuICAgICAgY3VyciA9IGxlbiAtIGRyb3A7XG4gICAgICBsZWZ0ID0gMSA8PCBjdXJyO1xuICAgICAgd2hpbGUgKGN1cnIgKyBkcm9wIDwgbWF4KSB7XG4gICAgICAgIGxlZnQgLT0gY291bnRbY3VyciArIGRyb3BdO1xuICAgICAgICBpZiAobGVmdCA8PSAwKSB7IGJyZWFrOyB9XG4gICAgICAgIGN1cnIrKztcbiAgICAgICAgbGVmdCA8PD0gMTtcbiAgICAgIH1cblxuICAgICAgLyogY2hlY2sgZm9yIGVub3VnaCBzcGFjZSAqL1xuICAgICAgdXNlZCArPSAxIDw8IGN1cnI7XG4gICAgICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIC8qIHBvaW50IGVudHJ5IGluIHJvb3QgdGFibGUgdG8gc3ViLXRhYmxlICovXG4gICAgICBsb3cgPSBodWZmICYgbWFzaztcbiAgICAgIC8qdGFibGUub3BbbG93XSA9IGN1cnI7XG4gICAgICB0YWJsZS5iaXRzW2xvd10gPSByb290O1xuICAgICAgdGFibGUudmFsW2xvd10gPSBuZXh0IC0gb3B0cy50YWJsZV9pbmRleDsqL1xuICAgICAgdGFibGVbbG93XSA9IChyb290IDw8IDI0KSB8IChjdXJyIDw8IDE2KSB8IChuZXh0IC0gdGFibGVfaW5kZXgpIHwwO1xuICAgIH1cbiAgfVxuXG4gIC8qIGZpbGwgaW4gcmVtYWluaW5nIHRhYmxlIGVudHJ5IGlmIGNvZGUgaXMgaW5jb21wbGV0ZSAoZ3VhcmFudGVlZCB0byBoYXZlXG4gICBhdCBtb3N0IG9uZSByZW1haW5pbmcgZW50cnksIHNpbmNlIGlmIHRoZSBjb2RlIGlzIGluY29tcGxldGUsIHRoZVxuICAgbWF4aW11bSBjb2RlIGxlbmd0aCB0aGF0IHdhcyBhbGxvd2VkIHRvIGdldCB0aGlzIGZhciBpcyBvbmUgYml0KSAqL1xuICBpZiAoaHVmZiAhPT0gMCkge1xuICAgIC8vdGFibGUub3BbbmV4dCArIGh1ZmZdID0gNjQ7ICAgICAgICAgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tuZXh0ICsgaHVmZl0gPSBsZW4gLSBkcm9wO1xuICAgIC8vdGFibGUudmFsW25leHQgKyBodWZmXSA9IDA7XG4gICAgdGFibGVbbmV4dCArIGh1ZmZdID0gKChsZW4gLSBkcm9wKSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwwO1xuICB9XG5cbiAgLyogc2V0IHJldHVybiBwYXJhbWV0ZXJzICovXG4gIC8vb3B0cy50YWJsZV9pbmRleCArPSB1c2VkO1xuICBvcHRzLmJpdHMgPSByb290O1xuICByZXR1cm4gMDtcbn07XG5cblxudmFyIGluZnRyZWVzID0gaW5mbGF0ZV90YWJsZTtcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5cblxuXG5cblxuY29uc3QgQ09ERVMkMSA9IDA7XG5jb25zdCBMRU5TJDEgPSAxO1xuY29uc3QgRElTVFMkMSA9IDI7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5jb25zdCB7XG4gIFpfRklOSVNIOiBaX0ZJTklTSCQyLCBaX0JMT0NLOiBaX0JMT0NLJDEsIFpfVFJFRVMsXG4gIFpfT0s6IFpfT0skMiwgWl9TVFJFQU1fRU5EOiBaX1NUUkVBTV9FTkQkMiwgWl9ORUVEX0RJQ1QsIFpfU1RSRUFNX0VSUk9SOiBaX1NUUkVBTV9FUlJPUiQxLCBaX0RBVEFfRVJST1I6IFpfREFUQV9FUlJPUiQxLCBaX01FTV9FUlJPUiwgWl9CVUZfRVJST1I6IFpfQlVGX0VSUk9SJDEsXG4gIFpfREVGTEFURUQ6IFpfREVGTEFURUQkMlxufSA9IGNvbnN0YW50cztcblxuXG4vKiBTVEFURVMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5jb25zdCAgICBIRUFEID0gMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbWFnaWMgaGVhZGVyICovXG5jb25zdCAgICBGTEFHUyA9IDI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgbWV0aG9kIGFuZCBmbGFncyAoZ3ppcCkgKi9cbmNvbnN0ICAgIFRJTUUgPSAzOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtb2RpZmljYXRpb24gdGltZSAoZ3ppcCkgKi9cbmNvbnN0ICAgIE9TID0gNDsgICAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBmbGFncyBhbmQgb3BlcmF0aW5nIHN5c3RlbSAoZ3ppcCkgKi9cbmNvbnN0ICAgIEVYTEVOID0gNTsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBsZW5ndGggKGd6aXApICovXG5jb25zdCAgICBFWFRSQSA9IDY7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgYnl0ZXMgKGd6aXApICovXG5jb25zdCAgICBOQU1FID0gNzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGZpbGUgbmFtZSAoZ3ppcCkgKi9cbmNvbnN0ICAgIENPTU1FTlQgPSA4OyAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgY29tbWVudCAoZ3ppcCkgKi9cbmNvbnN0ICAgIEhDUkMgPSA5OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBoZWFkZXIgY3JjIChnemlwKSAqL1xuY29uc3QgICAgRElDVElEID0gMTA7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpY3Rpb25hcnkgY2hlY2sgdmFsdWUgKi9cbmNvbnN0ICAgIERJQ1QgPSAxMTsgICAgICAvKiB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGNhbGwgKi9cbmNvbnN0ICAgICAgICBUWVBFJDEgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG5jb25zdCAgICAgICAgVFlQRURPID0gMTM7ICAgIC8qIGk6IHNhbWUsIGJ1dCBza2lwIGNoZWNrIHRvIGV4aXQgaW5mbGF0ZSBvbiBuZXcgYmxvY2sgKi9cbmNvbnN0ICAgICAgICBTVE9SRUQgPSAxNDsgICAgLyogaTogd2FpdGluZyBmb3Igc3RvcmVkIHNpemUgKGxlbmd0aCBhbmQgY29tcGxlbWVudCkgKi9cbmNvbnN0ICAgICAgICBDT1BZXyA9IDE1OyAgICAgLyogaS9vOiBzYW1lIGFzIENPUFkgYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbmNvbnN0ICAgICAgICBDT1BZID0gMTY7ICAgICAgLyogaS9vOiB3YWl0aW5nIGZvciBpbnB1dCBvciBvdXRwdXQgdG8gY29weSBzdG9yZWQgYmxvY2sgKi9cbmNvbnN0ICAgICAgICBUQUJMRSA9IDE3OyAgICAgLyogaTogd2FpdGluZyBmb3IgZHluYW1pYyBibG9jayB0YWJsZSBsZW5ndGhzICovXG5jb25zdCAgICAgICAgTEVOTEVOUyA9IDE4OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuY29uc3QgICAgICAgIENPREVMRU5TID0gMTk7ICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0IGFuZCBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbmNvbnN0ICAgICAgICAgICAgTEVOXyA9IDIwOyAgICAgIC8qIGk6IHNhbWUgYXMgTEVOIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG5jb25zdCAgICAgICAgICAgIExFTiA9IDIxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0L2VvYiBjb2RlICovXG5jb25zdCAgICAgICAgICAgIExFTkVYVCA9IDIyOyAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGggZXh0cmEgYml0cyAqL1xuY29uc3QgICAgICAgICAgICBESVNUID0gMjM7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgY29kZSAqL1xuY29uc3QgICAgICAgICAgICBESVNURVhUID0gMjQ7ICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgZXh0cmEgYml0cyAqL1xuY29uc3QgICAgICAgICAgICBNQVRDSCA9IDI1OyAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIGNvcHkgc3RyaW5nICovXG5jb25zdCAgICAgICAgICAgIExJVCA9IDI2OyAgICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gd3JpdGUgbGl0ZXJhbCAqL1xuY29uc3QgICAgQ0hFQ0sgPSAyNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBjaGVjayB2YWx1ZSAqL1xuY29uc3QgICAgTEVOR1RIID0gMjg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBsZW5ndGggKGd6aXApICovXG5jb25zdCAgICBET05FID0gMjk7ICAgICAgLyogZmluaXNoZWQgY2hlY2ssIGRvbmUgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbmNvbnN0ICAgIEJBRCQxID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbmNvbnN0ICAgIE1FTSA9IDMxOyAgICAgICAvKiBnb3QgYW4gaW5mbGF0ZSgpIG1lbW9yeSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xuY29uc3QgICAgU1lOQyA9IDMyOyAgICAgIC8qIGxvb2tpbmcgZm9yIHN5bmNocm9uaXphdGlvbiBieXRlcyB0byByZXN0YXJ0IGluZmxhdGUoKSAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cblxuY29uc3QgRU5PVUdIX0xFTlMkMSA9IDg1MjtcbmNvbnN0IEVOT1VHSF9ESVNUUyQxID0gNTkyO1xuLy9jb25zdCBFTk9VR0ggPSAgKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbmNvbnN0IE1BWF9XQklUUyQxID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbmNvbnN0IERFRl9XQklUUyA9IE1BWF9XQklUUyQxO1xuXG5cbmNvbnN0IHpzd2FwMzIgPSAocSkgPT4ge1xuXG4gIHJldHVybiAgKCgocSA+Pj4gMjQpICYgMHhmZikgK1xuICAgICAgICAgICgocSA+Pj4gOCkgJiAweGZmMDApICtcbiAgICAgICAgICAoKHEgJiAweGZmMDApIDw8IDgpICtcbiAgICAgICAgICAoKHEgJiAweGZmKSA8PCAyNCkpO1xufTtcblxuXG5mdW5jdGlvbiBJbmZsYXRlU3RhdGUoKSB7XG4gIHRoaXMubW9kZSA9IDA7ICAgICAgICAgICAgIC8qIGN1cnJlbnQgaW5mbGF0ZSBtb2RlICovXG4gIHRoaXMubGFzdCA9IGZhbHNlOyAgICAgICAgICAvKiB0cnVlIGlmIHByb2Nlc3NpbmcgbGFzdCBibG9jayAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmhhdmVkaWN0ID0gZmFsc2U7ICAgICAgLyogdHJ1ZSBpZiBkaWN0aW9uYXJ5IHByb3ZpZGVkICovXG4gIHRoaXMuZmxhZ3MgPSAwOyAgICAgICAgICAgICAvKiBnemlwIGhlYWRlciBtZXRob2QgYW5kIGZsYWdzICgwIGlmIHpsaWIpICovXG4gIHRoaXMuZG1heCA9IDA7ICAgICAgICAgICAgICAvKiB6bGliIGhlYWRlciBtYXggZGlzdGFuY2UgKElORkxBVEVfU1RSSUNUKSAqL1xuICB0aGlzLmNoZWNrID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2YgY2hlY2sgdmFsdWUgKi9cbiAgdGhpcy50b3RhbCA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIG91dHB1dCBjb3VudCAqL1xuICAvLyBUT0RPOiBtYXkgYmUge31cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAgICAgICAgIC8qIHdoZXJlIHRvIHNhdmUgZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gKi9cblxuICAvKiBzbGlkaW5nIHdpbmRvdyAqL1xuICB0aGlzLndiaXRzID0gMDsgICAgICAgICAgICAgLyogbG9nIGJhc2UgMiBvZiByZXF1ZXN0ZWQgd2luZG93IHNpemUgKi9cbiAgdGhpcy53c2l6ZSA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB0aGlzLndoYXZlID0gMDsgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB0aGlzLnduZXh0ID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIHRoaXMud2luZG93ID0gbnVsbDsgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIG5lZWRlZCAqL1xuXG4gIC8qIGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmhvbGQgPSAwOyAgICAgICAgICAgICAgLyogaW5wdXQgYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuYml0cyA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgYml0cyBpbiBcImluXCIgKi9cblxuICAvKiBmb3Igc3RyaW5nIGFuZCBzdG9yZWQgYmxvY2sgY29weWluZyAqL1xuICB0aGlzLmxlbmd0aCA9IDA7ICAgICAgICAgICAgLyogbGl0ZXJhbCBvciBsZW5ndGggb2YgZGF0YSB0byBjb3B5ICovXG4gIHRoaXMub2Zmc2V0ID0gMDsgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIHRvIGNvcHkgc3RyaW5nIGZyb20gKi9cblxuICAvKiBmb3IgdGFibGUgYW5kIGNvZGUgZGVjb2RpbmcgKi9cbiAgdGhpcy5leHRyYSA9IDA7ICAgICAgICAgICAgIC8qIGV4dHJhIGJpdHMgbmVlZGVkICovXG5cbiAgLyogZml4ZWQgYW5kIGR5bmFtaWMgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5jb2RlID0gbnVsbDsgICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzICovXG4gIHRoaXMuZGlzdGNvZGUgPSBudWxsOyAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAqL1xuICB0aGlzLmxlbmJpdHMgPSAwOyAgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgbGVuY29kZSAqL1xuICB0aGlzLmRpc3RiaXRzID0gMDsgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgZGlzdGNvZGUgKi9cblxuICAvKiBkeW5hbWljIHRhYmxlIGJ1aWxkaW5nICovXG4gIHRoaXMubmNvZGUgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmxlbiA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5kaXN0ID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLmhhdmUgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RocyBpbiBsZW5zW10gKi9cbiAgdGhpcy5uZXh0ID0gbnVsbDsgICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIGNvZGVzW10gKi9cblxuICB0aGlzLmxlbnMgPSBuZXcgVWludDE2QXJyYXkoMzIwKTsgLyogdGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLndvcmsgPSBuZXcgVWludDE2QXJyYXkoMjg4KTsgLyogd29yayBhcmVhIGZvciBjb2RlIHRhYmxlIGJ1aWxkaW5nICovXG5cbiAgLypcbiAgIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBwb2ludGVycyBpbiBqcywgd2UgdXNlIGxlbmNvZGUgYW5kIGRpc3Rjb2RlIGRpcmVjdGx5XG4gICBhcyBidWZmZXJzIHNvIHdlIGRvbid0IG5lZWQgY29kZXNcbiAgKi9cbiAgLy90aGlzLmNvZGVzID0gbmV3IEludDMyQXJyYXkoRU5PVUdIKTsgICAgICAgLyogc3BhY2UgZm9yIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuZHluID0gbnVsbDsgICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5kaXN0ZHluID0gbnVsbDsgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLnNhbmUgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBpZiBmYWxzZSwgYWxsb3cgaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyICovXG4gIHRoaXMuYmFjayA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgYmFjayBvZiBsYXN0IHVucHJvY2Vzc2VkIGxlbmd0aC9saXQgKi9cbiAgdGhpcy53YXMgPSAwOyAgICAgICAgICAgICAgICAgICAgLyogaW5pdGlhbCBsZW5ndGggb2YgbWF0Y2ggKi9cbn1cblxuXG5jb25zdCBpbmZsYXRlUmVzZXRLZWVwID0gKHN0cm0pID0+IHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH1cbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSBzdGF0ZS50b3RhbCA9IDA7XG4gIHN0cm0ubXNnID0gJyc7IC8qWl9OVUxMKi9cbiAgaWYgKHN0YXRlLndyYXApIHsgICAgICAgLyogdG8gc3VwcG9ydCBpbGwtY29uY2VpdmVkIEphdmEgdGVzdCBzdWl0ZSAqL1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS53cmFwICYgMTtcbiAgfVxuICBzdGF0ZS5tb2RlID0gSEVBRDtcbiAgc3RhdGUubGFzdCA9IDA7XG4gIHN0YXRlLmhhdmVkaWN0ID0gMDtcbiAgc3RhdGUuZG1heCA9IDMyNzY4O1xuICBzdGF0ZS5oZWFkID0gbnVsbC8qWl9OVUxMKi87XG4gIHN0YXRlLmhvbGQgPSAwO1xuICBzdGF0ZS5iaXRzID0gMDtcbiAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW4gPSBuZXcgSW50MzJBcnJheShFTk9VR0hfTEVOUyQxKTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluID0gbmV3IEludDMyQXJyYXkoRU5PVUdIX0RJU1RTJDEpO1xuXG4gIHN0YXRlLnNhbmUgPSAxO1xuICBzdGF0ZS5iYWNrID0gLTE7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogcmVzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSyQyO1xufTtcblxuXG5jb25zdCBpbmZsYXRlUmVzZXQgPSAoc3RybSkgPT4ge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsgfVxuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0YXRlLndzaXplID0gMDtcbiAgc3RhdGUud2hhdmUgPSAwO1xuICBzdGF0ZS53bmV4dCA9IDA7XG4gIHJldHVybiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuXG59O1xuXG5cbmNvbnN0IGluZmxhdGVSZXNldDIgPSAoc3RybSwgd2luZG93Qml0cykgPT4ge1xuICBsZXQgd3JhcDtcblxuICAvKiBnZXQgdGhlIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsgfVxuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogZXh0cmFjdCB3cmFwIHJlcXVlc3QgZnJvbSB3aW5kb3dCaXRzIHBhcmFtZXRlciAqL1xuICBpZiAod2luZG93Qml0cyA8IDApIHtcbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cbiAgZWxzZSB7XG4gICAgd3JhcCA9ICh3aW5kb3dCaXRzID4+IDQpICsgMTtcbiAgICBpZiAod2luZG93Qml0cyA8IDQ4KSB7XG4gICAgICB3aW5kb3dCaXRzICY9IDE1O1xuICAgIH1cbiAgfVxuXG4gIC8qIHNldCBudW1iZXIgb2Ygd2luZG93IGJpdHMsIGZyZWUgd2luZG93IGlmIGRpZmZlcmVudCAqL1xuICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICB9XG4gIGlmIChzdGF0ZS53aW5kb3cgIT09IG51bGwgJiYgc3RhdGUud2JpdHMgIT09IHdpbmRvd0JpdHMpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXNldCB0aGUgcmVzdCBvZiBpdCAqL1xuICBzdGF0ZS53cmFwID0gd3JhcDtcbiAgc3RhdGUud2JpdHMgPSB3aW5kb3dCaXRzO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0KHN0cm0pO1xufTtcblxuXG5jb25zdCBpbmZsYXRlSW5pdDIgPSAoc3RybSwgd2luZG93Qml0cykgPT4ge1xuXG4gIGlmICghc3RybSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsgfVxuICAvL3N0cm0ubXNnID0gWl9OVUxMOyAgICAgICAgICAgICAgICAgLyogaW4gY2FzZSB3ZSByZXR1cm4gYW4gZXJyb3IgKi9cblxuICBjb25zdCBzdGF0ZSA9IG5ldyBJbmZsYXRlU3RhdGUoKTtcblxuICAvL2lmIChzdGF0ZSA9PT0gWl9OVUxMKSByZXR1cm4gWl9NRU1fRVJST1I7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogYWxsb2NhdGVkXFxuXCIpKTtcbiAgc3RybS5zdGF0ZSA9IHN0YXRlO1xuICBzdGF0ZS53aW5kb3cgPSBudWxsLypaX05VTEwqLztcbiAgY29uc3QgcmV0ID0gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKTtcbiAgaWYgKHJldCAhPT0gWl9PSyQyKSB7XG4gICAgc3RybS5zdGF0ZSA9IG51bGwvKlpfTlVMTCovO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVJbml0ID0gKHN0cm0pID0+IHtcblxuICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7XG59O1xuXG5cbi8qXG4gUmV0dXJuIHN0YXRlIHdpdGggbGVuZ3RoIGFuZCBkaXN0YW5jZSBkZWNvZGluZyB0YWJsZXMgYW5kIGluZGV4IHNpemVzIHNldCB0b1xuIGZpeGVkIGNvZGUgZGVjb2RpbmcuICBOb3JtYWxseSB0aGlzIHJldHVybnMgZml4ZWQgdGFibGVzIGZyb20gaW5mZml4ZWQuaC5cbiBJZiBCVUlMREZJWEVEIGlzIGRlZmluZWQsIHRoZW4gaW5zdGVhZCB0aGlzIHJvdXRpbmUgYnVpbGRzIHRoZSB0YWJsZXMgdGhlXG4gZmlyc3QgdGltZSBpdCdzIGNhbGxlZCwgYW5kIHJldHVybnMgdGhvc2UgdGFibGVzIHRoZSBmaXJzdCB0aW1lIGFuZFxuIHRoZXJlYWZ0ZXIuICBUaGlzIHJlZHVjZXMgdGhlIHNpemUgb2YgdGhlIGNvZGUgYnkgYWJvdXQgMksgYnl0ZXMsIGluXG4gZXhjaGFuZ2UgZm9yIGEgbGl0dGxlIGV4ZWN1dGlvbiB0aW1lLiAgSG93ZXZlciwgQlVJTERGSVhFRCBzaG91bGQgbm90IGJlXG4gdXNlZCBmb3IgdGhyZWFkZWQgYXBwbGljYXRpb25zLCBzaW5jZSB0aGUgcmV3cml0aW5nIG9mIHRoZSB0YWJsZXMgYW5kIHZpcmdpblxuIG1heSBub3QgYmUgdGhyZWFkLXNhZmUuXG4gKi9cbmxldCB2aXJnaW4gPSB0cnVlO1xuXG5sZXQgbGVuZml4LCBkaXN0Zml4OyAvLyBXZSBoYXZlIG5vIHBvaW50ZXJzIGluIEpTLCBzbyBrZWVwIHRhYmxlcyBzZXBhcmF0ZVxuXG5cbmNvbnN0IGZpeGVkdGFibGVzID0gKHN0YXRlKSA9PiB7XG5cbiAgLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0YWJsZXMgaWYgZmlyc3QgY2FsbCAobWF5IG5vdCBiZSB0aHJlYWQgc2FmZSkgKi9cbiAgaWYgKHZpcmdpbikge1xuICAgIGxlbmZpeCA9IG5ldyBJbnQzMkFycmF5KDUxMik7XG4gICAgZGlzdGZpeCA9IG5ldyBJbnQzMkFycmF5KDMyKTtcblxuICAgIC8qIGxpdGVyYWwvbGVuZ3RoIHRhYmxlICovXG4gICAgbGV0IHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDE0NCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjU2KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gOTsgfVxuICAgIHdoaWxlIChzeW0gPCAyODApIHsgc3RhdGUubGVuc1tzeW0rK10gPSA3OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4OCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cblxuICAgIGluZnRyZWVzKExFTlMkMSwgIHN0YXRlLmxlbnMsIDAsIDI4OCwgbGVuZml4LCAgIDAsIHN0YXRlLndvcmssIHsgYml0czogOSB9KTtcblxuICAgIC8qIGRpc3RhbmNlIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMzIpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA1OyB9XG5cbiAgICBpbmZ0cmVlcyhESVNUUyQxLCBzdGF0ZS5sZW5zLCAwLCAzMiwgICBkaXN0Zml4LCAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDUgfSk7XG5cbiAgICAvKiBkbyB0aGlzIGp1c3Qgb25jZSAqL1xuICAgIHZpcmdpbiA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGUubGVuY29kZSA9IGxlbmZpeDtcbiAgc3RhdGUubGVuYml0cyA9IDk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gZGlzdGZpeDtcbiAgc3RhdGUuZGlzdGJpdHMgPSA1O1xufTtcblxuXG4vKlxuIFVwZGF0ZSB0aGUgd2luZG93IHdpdGggdGhlIGxhc3Qgd3NpemUgKG5vcm1hbGx5IDMySykgYnl0ZXMgd3JpdHRlbiBiZWZvcmVcbiByZXR1cm5pbmcuICBJZiB3aW5kb3cgZG9lcyBub3QgZXhpc3QgeWV0LCBjcmVhdGUgaXQuICBUaGlzIGlzIG9ubHkgY2FsbGVkXG4gd2hlbiBhIHdpbmRvdyBpcyBhbHJlYWR5IGluIHVzZSwgb3Igd2hlbiBvdXRwdXQgaGFzIGJlZW4gd3JpdHRlbiBkdXJpbmcgdGhpc1xuIGluZmxhdGUgY2FsbCwgYnV0IHRoZSBlbmQgb2YgdGhlIGRlZmxhdGUgc3RyZWFtIGhhcyBub3QgYmVlbiByZWFjaGVkIHlldC5cbiBJdCBpcyBhbHNvIGNhbGxlZCB0byBjcmVhdGUgYSB3aW5kb3cgZm9yIGRpY3Rpb25hcnkgZGF0YSB3aGVuIGEgZGljdGlvbmFyeVxuIGlzIGxvYWRlZC5cblxuIFByb3ZpZGluZyBvdXRwdXQgYnVmZmVycyBsYXJnZXIgdGhhbiAzMksgdG8gaW5mbGF0ZSgpIHNob3VsZCBwcm92aWRlIGEgc3BlZWRcbiBhZHZhbnRhZ2UsIHNpbmNlIG9ubHkgdGhlIGxhc3QgMzJLIG9mIG91dHB1dCBpcyBjb3BpZWQgdG8gdGhlIHNsaWRpbmcgd2luZG93XG4gdXBvbiByZXR1cm4gZnJvbSBpbmZsYXRlKCksIGFuZCBzaW5jZSBhbGwgZGlzdGFuY2VzIGFmdGVyIHRoZSBmaXJzdCAzMksgb2ZcbiBvdXRwdXQgd2lsbCBmYWxsIGluIHRoZSBvdXRwdXQgZGF0YSwgbWFraW5nIG1hdGNoIGNvcGllcyBzaW1wbGVyIGFuZCBmYXN0ZXIuXG4gVGhlIGFkdmFudGFnZSBtYXkgYmUgZGVwZW5kZW50IG9uIHRoZSBzaXplIG9mIHRoZSBwcm9jZXNzb3IncyBkYXRhIGNhY2hlcy5cbiAqL1xuY29uc3QgdXBkYXRld2luZG93ID0gKHN0cm0sIHNyYywgZW5kLCBjb3B5KSA9PiB7XG5cbiAgbGV0IGRpc3Q7XG4gIGNvbnN0IHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBpZiBpdCBoYXNuJ3QgYmVlbiBkb25lIGFscmVhZHksIGFsbG9jYXRlIHNwYWNlIGZvciB0aGUgd2luZG93ICovXG4gIGlmIChzdGF0ZS53aW5kb3cgPT09IG51bGwpIHtcbiAgICBzdGF0ZS53c2l6ZSA9IDEgPDwgc3RhdGUud2JpdHM7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gMDtcblxuICAgIHN0YXRlLndpbmRvdyA9IG5ldyBVaW50OEFycmF5KHN0YXRlLndzaXplKTtcbiAgfVxuXG4gIC8qIGNvcHkgc3RhdGUtPndzaXplIG9yIGxlc3Mgb3V0cHV0IGJ5dGVzIGludG8gdGhlIGNpcmN1bGFyIHdpbmRvdyAqL1xuICBpZiAoY29weSA+PSBzdGF0ZS53c2l6ZSkge1xuICAgIHN0YXRlLndpbmRvdy5zZXQoc3JjLnN1YmFycmF5KGVuZCAtIHN0YXRlLndzaXplLCBlbmQpLCAwKTtcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgfVxuICBlbHNlIHtcbiAgICBkaXN0ID0gc3RhdGUud3NpemUgLSBzdGF0ZS53bmV4dDtcbiAgICBpZiAoZGlzdCA+IGNvcHkpIHtcbiAgICAgIGRpc3QgPSBjb3B5O1xuICAgIH1cbiAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdyArIHN0YXRlLT53bmV4dCwgZW5kIC0gY29weSwgZGlzdCk7XG4gICAgc3RhdGUud2luZG93LnNldChzcmMuc3ViYXJyYXkoZW5kIC0gY29weSwgZW5kIC0gY29weSArIGRpc3QpLCBzdGF0ZS53bmV4dCk7XG4gICAgY29weSAtPSBkaXN0O1xuICAgIGlmIChjb3B5KSB7XG4gICAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdywgZW5kIC0gY29weSwgY29weSk7XG4gICAgICBzdGF0ZS53aW5kb3cuc2V0KHNyYy5zdWJhcnJheShlbmQgLSBjb3B5LCBlbmQpLCAwKTtcbiAgICAgIHN0YXRlLnduZXh0ID0gY29weTtcbiAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhdGUud25leHQgKz0gZGlzdDtcbiAgICAgIGlmIChzdGF0ZS53bmV4dCA9PT0gc3RhdGUud3NpemUpIHsgc3RhdGUud25leHQgPSAwOyB9XG4gICAgICBpZiAoc3RhdGUud2hhdmUgPCBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53aGF2ZSArPSBkaXN0OyB9XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufTtcblxuXG5jb25zdCBpbmZsYXRlID0gKHN0cm0sIGZsdXNoKSA9PiB7XG5cbiAgbGV0IHN0YXRlO1xuICBsZXQgaW5wdXQsIG91dHB1dDsgICAgICAgICAgLy8gaW5wdXQvb3V0cHV0IGJ1ZmZlcnNcbiAgbGV0IG5leHQ7ICAgICAgICAgICAgICAgICAgIC8qIG5leHQgaW5wdXQgSU5ERVggKi9cbiAgbGV0IHB1dDsgICAgICAgICAgICAgICAgICAgIC8qIG5leHQgb3V0cHV0IElOREVYICovXG4gIGxldCBoYXZlLCBsZWZ0OyAgICAgICAgICAgICAvKiBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICBsZXQgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogYml0IGJ1ZmZlciAqL1xuICBsZXQgYml0czsgICAgICAgICAgICAgICAgICAgLyogYml0cyBpbiBiaXQgYnVmZmVyICovXG4gIGxldCBfaW4sIF9vdXQ7ICAgICAgICAgICAgICAvKiBzYXZlIHN0YXJ0aW5nIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIGxldCBjb3B5OyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2Ygc3RvcmVkIG9yIG1hdGNoIGJ5dGVzIHRvIGNvcHkgKi9cbiAgbGV0IGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggYnl0ZXMgZnJvbSAqL1xuICBsZXQgZnJvbV9zb3VyY2U7XG4gIGxldCBoZXJlID0gMDsgICAgICAgICAgICAgICAvKiBjdXJyZW50IGRlY29kaW5nIHRhYmxlIGVudHJ5ICovXG4gIGxldCBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsOyAvLyBwYWtlZCBcImhlcmVcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICAvL2xldCBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBwYXJlbnQgdGFibGUgZW50cnkgKi9cbiAgbGV0IGxhc3RfYml0cywgbGFzdF9vcCwgbGFzdF92YWw7IC8vIHBha2VkIFwibGFzdFwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIGxldCBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggdG8gY29weSBmb3IgcmVwZWF0cywgYml0cyB0byBkcm9wICovXG4gIGxldCByZXQ7ICAgICAgICAgICAgICAgICAgICAvKiByZXR1cm4gY29kZSAqL1xuICBjb25zdCBoYnVmID0gbmV3IFVpbnQ4QXJyYXkoNCk7ICAgIC8qIGJ1ZmZlciBmb3IgZ3ppcCBoZWFkZXIgY3JjIGNhbGN1bGF0aW9uICovXG4gIGxldCBvcHRzO1xuXG4gIGxldCBuOyAvLyB0ZW1wb3JhcnkgdmFyaWFibGUgZm9yIE5FRURfQklUU1xuXG4gIGNvbnN0IG9yZGVyID0gLyogcGVybXV0YXRpb24gb2YgY29kZSBsZW5ndGhzICovXG4gICAgbmV3IFVpbnQ4QXJyYXkoWyAxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1IF0pO1xuXG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8ICFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7XG4gIH1cblxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFJDEpIHsgc3RhdGUubW9kZSA9IFRZUEVETzsgfSAgICAvKiBza2lwIGNoZWNrICovXG5cblxuICAvLy0tLSBMT0FEKCkgLS0tXG4gIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgLy8tLS1cblxuICBfaW4gPSBoYXZlO1xuICBfb3V0ID0gbGVmdDtcbiAgcmV0ID0gWl9PSyQyO1xuXG4gIGluZl9sZWF2ZTogLy8gZ290byBlbXVsYXRpb25cbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoc3RhdGUubW9kZSkge1xuICAgICAgY2FzZSBIRUFEOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCA9PT0gMCkge1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoc3RhdGUud3JhcCAmIDIpICYmIGhvbGQgPT09IDB4OGIxZikgeyAgLyogZ3ppcCBoZWFkZXIgKi9cbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IDAvKmNyYzMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuXG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IEZMQUdTO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmZsYWdzID0gMDsgICAgICAgICAgIC8qIGV4cGVjdCB6bGliIGhlYWRlciAqL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHN0YXRlLndyYXAgJiAxKSB8fCAgIC8qIGNoZWNrIGlmIHpsaWIgaGVhZGVyIGFsbG93ZWQgKi9cbiAgICAgICAgICAoKChob2xkICYgMHhmZikvKkJJVFMoOCkqLyA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGhlYWRlciBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gIT09IFpfREVGTEFURUQkMikge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBsZW4gPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA4O1xuICAgICAgICBpZiAoc3RhdGUud2JpdHMgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS53Yml0cyA9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW4gPiBzdGF0ZS53Yml0cykge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgd2luZG93IHNpemUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICEhISBwYWtvIHBhdGNoLiBGb3JjZSB1c2UgYG9wdGlvbnMud2luZG93Qml0c2AgaWYgcGFzc2VkLlxuICAgICAgICAvLyBSZXF1aXJlZCB0byBhbHdheXMgdXNlIG1heCB3aW5kb3cgc2l6ZSBieSBkZWZhdWx0LlxuICAgICAgICBzdGF0ZS5kbWF4ID0gMSA8PCBzdGF0ZS53Yml0cztcbiAgICAgICAgLy9zdGF0ZS5kbWF4ID0gMSA8PCBsZW47XG5cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIHpsaWIgaGVhZGVyIG9rXFxuXCIpKTtcbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDB4MjAwID8gRElDVElEIDogVFlQRSQxO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZMQUdTOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUuZmxhZ3MgPSBob2xkO1xuICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHhmZikgIT09IFpfREVGTEFURUQkMikge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHhlMDAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRleHQgPSAoKGhvbGQgPj4gOCkgJiAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBUSU1FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRJTUU6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQudGltZSA9IGhvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDNChzdGF0ZS5jaGVjaywgaG9sZClcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsyXSA9IChob2xkID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhidWZbM10gPSAoaG9sZCA+Pj4gMjQpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGhidWYsIDQsIDApO1xuICAgICAgICAgIC8vPT09XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBPUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBPUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSAoaG9sZCAmIDB4ZmYpO1xuICAgICAgICAgIHN0YXRlLmhlYWQub3MgPSAoaG9sZCA+PiA4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWExFTjpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkO1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX2xlbiA9IGhvbGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbnVsbC8qWl9OVUxMKi87XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEVYVFJBO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEVYVFJBOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5oZWFkLmV4dHJhX2xlbiAtIHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5oZWFkLmV4dHJhKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHVudHlwZWQgYXJyYXkgZm9yIG1vcmUgY29udmVuaWVudCBwcm9jZXNzaW5nIGxhdGVyXG4gICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG5ldyBVaW50OEFycmF5KHN0YXRlLmhlYWQuZXh0cmFfbGVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhLnNldChcbiAgICAgICAgICAgICAgICBpbnB1dC5zdWJhcnJheShcbiAgICAgICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgICAgICAvLyBleHRyYSBmaWVsZCBpcyBsaW1pdGVkIHRvIDY1NTM2IGJ5dGVzXG4gICAgICAgICAgICAgICAgICAvLyAtIG5vIG5lZWQgZm9yIGFkZGl0aW9uYWwgc2l6ZSBjaGVja1xuICAgICAgICAgICAgICAgICAgbmV4dCArIGNvcHlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIC8qbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuID8gc3RhdGUuaGVhZC5leHRyYV9tYXggOiBjb3B5LCovXG4gICAgICAgICAgICAgICAgbGVuXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIC8vem1lbWNweShzdGF0ZS5oZWFkLmV4dHJhICsgbGVuLCBuZXh0LFxuICAgICAgICAgICAgICAvLyAgICAgICAgbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4ID9cbiAgICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuIDogY29weSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTkFNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBOQU1FOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA4MDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBUT0RPOiAyIG9yIDEgYnl0ZXM/XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLm5hbWVfbWF4Ki8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcblxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5uYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09NTUVOVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT01NRU5UOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDEwMDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLmNvbW1fbWF4Ki8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEhDUkM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgSENSQzpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLmNoZWNrICYgMHhmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaGVhZGVyIGNyYyBtaXNtYXRjaCc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmhjcmMgPSAoKHN0YXRlLmZsYWdzID4+IDkpICYgMSk7XG4gICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRSQxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElDVElEOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0genN3YXAzMihob2xkKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBESUNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJQ1Q6XG4gICAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEUkMTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFJDE6XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9CTE9DSyQxIHx8IGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRZUEVETzpcbiAgICAgICAgaWYgKHN0YXRlLmxhc3QpIHtcbiAgICAgICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBDSEVDSztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygzKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxhc3QgPSAoaG9sZCAmIDB4MDEpLypCSVRTKDEpKi87XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDEpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAxO1xuICAgICAgICBiaXRzIC09IDE7XG4gICAgICAgIC8vLS0tLy9cblxuICAgICAgICBzd2l0Y2ggKChob2xkICYgMHgwMykvKkJJVFMoMikqLykge1xuICAgICAgICAgIGNhc2UgMDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHN0b3JlZCBibG9jayAqL1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgc3RvcmVkIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gU1RPUkVEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZml4ZWQgYmxvY2sgKi9cbiAgICAgICAgICAgIGZpeGVkdGFibGVzKHN0YXRlKTtcbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGZpeGVkIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsgICAgICAgICAgICAgLyogZGVjb2RlIGNvZGVzICovXG4gICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBkeW5hbWljIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBkeW5hbWljIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gVEFCTEU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJsb2NrIHR5cGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNUT1JFRDpcbiAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vLyAvKiBnbyB0byBieXRlIGJvdW5kYXJ5ICovXG4gICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChob2xkICYgMHhmZmZmKSAhPT0gKChob2xkID4+PiAxNikgXiAweGZmZmYpKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Rocyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQgJiAweGZmZmY7XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGxlbmd0aCAldVxcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWV87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT1BZXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFk7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWTpcbiAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgICBpZiAoY29weSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAvLy0tLSB6bWVtY3B5KHB1dCwgbmV4dCwgY29weSk7IC0tLVxuICAgICAgICAgIG91dHB1dC5zZXQoaW5wdXQuc3ViYXJyYXkobmV4dCwgbmV4dCArIGNvcHkpLCBwdXQpO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgICBwdXQgKz0gY29weTtcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBlbmRcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRSQxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVEFCTEU6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE0KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5ubGVuID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMjU3O1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5kaXN0ID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMTtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uY29kZSA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDQ7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgICBiaXRzIC09IDQ7XG4gICAgICAgIC8vLS0tLy9cbi8vI2lmbmRlZiBQS1pJUF9CVUdfV09SS0FST1VORFxuICAgICAgICBpZiAoc3RhdGUubmxlbiA+IDI4NiB8fCBzdGF0ZS5uZGlzdCA+IDMwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndG9vIG1hbnkgbGVuZ3RoIG9yIGRpc3RhbmNlIHN5bWJvbHMnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICB0YWJsZSBzaXplcyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5MRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7XG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy9zdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gICAgICAgIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gNztcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZnRyZWVzKENPREVTJDEsIHN0YXRlLmxlbnMsIDAsIDE5LCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBjb2RlIGxlbmd0aHMgb2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPREVMRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPREVMRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07LypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhlcmVfdmFsIDwgMTYpIHtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMik7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAyO1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUgLSAxXTtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDMpOy8vQklUUygyKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDMpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDcpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgNztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDExICsgKGhvbGQgJiAweDdmKTsvL0JJVFMoNyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDcpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSA3O1xuICAgICAgICAgICAgICBiaXRzIC09IDc7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlICsgY29weSA+IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjb3B5LS0pIHtcbiAgICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGhhbmRsZSBlcnJvciBicmVha3MgaW4gd2hpbGUgKi9cbiAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IEJBRCQxKSB7IGJyZWFrOyB9XG5cbiAgICAgICAgLyogY2hlY2sgZm9yIGVuZC1vZi1ibG9jayBjb2RlIChiZXR0ZXIgaGF2ZSBvbmUpICovXG4gICAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGJ1aWxkIGNvZGUgdGFibGVzIC0tIG5vdGU6IGRvIG5vdCBjaGFuZ2UgdGhlIGxlbmJpdHMgb3IgZGlzdGJpdHNcbiAgICAgICAgICAgdmFsdWVzIGhlcmUgKDkgYW5kIDYpIHdpdGhvdXQgcmVhZGluZyB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgICAgICAgICBjb25jZXJuaW5nIHRoZSBFTk9VR0ggY29uc3RhbnRzLCB3aGljaCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzICovXG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA5O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mdHJlZXMoTEVOUyQxLCBzdGF0ZS5sZW5zLCAwLCBzdGF0ZS5ubGVuLCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAgIC8vIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gNjtcbiAgICAgICAgLy9zdGF0ZS5kaXN0Y29kZS5jb3B5KHN0YXRlLmNvZGVzKTtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5bjtcbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUuZGlzdGJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mdHJlZXMoRElTVFMkMSwgc3RhdGUubGVucywgc3RhdGUubmxlbiwgc3RhdGUubmRpc3QsIHN0YXRlLmRpc3Rjb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2VzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsICdpbmZsYXRlOiAgICAgICBjb2RlcyBva1xcbicpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTl87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5fOlxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTjpcbiAgICAgICAgaWYgKGhhdmUgPj0gNiAmJiBsZWZ0ID49IDI1OCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgaW5mZmFzdChzdHJtLCBfb3V0KTtcbiAgICAgICAgICAvLy0tLSBMT0FEKCkgLS0tXG4gICAgICAgICAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgICAgICAgICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gICAgICAgICAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gICAgICAgICAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gICAgICAgICAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gICAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7XG4gICAgICAgICAgLy8tLS1cblxuICAgICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFJDEpIHtcbiAgICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuYmFjayA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOyAgLypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYmIChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDtcbiAgICAgICAgaWYgKGhlcmVfb3AgPT09IDApIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gTElUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgMzIpIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFJDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmV4dHJhID0gaGVyZV9vcCAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVORVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkVYVDpcbiAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgc3RhdGUud2FzID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNUOlxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5kaXN0Yml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUub2Zmc2V0ID0gaGVyZV92YWw7XG4gICAgICAgIHN0YXRlLmV4dHJhID0gKGhlcmVfb3ApICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNURVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1RFWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUub2Zmc2V0ICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBzdGF0ZS5kbWF4KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBzdGF0ZS5vZmZzZXQpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IE1BVENIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE1BVENIOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgY29weSA9IF9vdXQgLSBsZWZ0O1xuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gY29weSkgeyAgICAgICAgIC8qIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICBjb3B5ID0gc3RhdGUub2Zmc2V0IC0gY29weTtcbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLndoYXZlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICBUcmFjZSgoc3RkZXJyLCBcImluZmxhdGUuYyB0b28gZmFyXFxuXCIpKTtcbi8vICAgICAgICAgIGNvcHkgLT0gc3RhdGUud2hhdmU7XG4vLyAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4vLyAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbi8vICAgICAgICAgIGxlZnQgLT0gY29weTtcbi8vICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuLy8gICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICBvdXRwdXRbcHV0KytdID0gMDtcbi8vICAgICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4vLyAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbi8vICAgICAgICAgIGJyZWFrO1xuLy8jZW5kaWZcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53bmV4dCkge1xuICAgICAgICAgICAgY29weSAtPSBzdGF0ZS53bmV4dDtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53c2l6ZSAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IHN0YXRlLnduZXh0IC0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuICAgICAgICAgIGZyb21fc291cmNlID0gc3RhdGUud2luZG93O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGNvcHkgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICBmcm9tID0gcHV0IC0gc3RhdGUub2Zmc2V0O1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBvdXRwdXRbcHV0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbiAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMSVQ6XG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBvdXRwdXRbcHV0KytdID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBsZWZ0LS07XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDSEVDSzpcbiAgICAgICAgaWYgKHN0YXRlLndyYXApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAvLyBVc2UgJ3wnIGluc3RlYWQgb2YgJysnIHRvIG1ha2Ugc3VyZSB0aGF0IHJlc3VsdCBpcyBzaWduZWRcbiAgICAgICAgICAgIGhvbGQgfD0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgX291dCAtPSBsZWZ0O1xuICAgICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gICAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgICAgICAgICBpZiAoX291dCkge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID1cbiAgICAgICAgICAgICAgICAvKlVQREFURShzdGF0ZS5jaGVjaywgcHV0IC0gX291dCwgX291dCk7Ki9cbiAgICAgICAgICAgICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMl8xKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpIDogYWRsZXIzMl8xKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpKTtcblxuICAgICAgICAgIH1cbiAgICAgICAgICBfb3V0ID0gbGVmdDtcbiAgICAgICAgICAvLyBOQjogY3JjMzIgc3RvcmVkIGFzIHNpZ25lZCAzMi1iaXQgaW50LCB6c3dhcDMyIHJldHVybnMgc2lnbmVkIHRvb1xuICAgICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgPyBob2xkIDogenN3YXAzMihob2xkKSkgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgZGF0YSBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGNoZWNrIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkdUSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5HVEg6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwICYmIHN0YXRlLmZsYWdzKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLnRvdGFsICYgMHhmZmZmZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBsZW5ndGggY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBsZW5ndGggbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRE9ORTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBET05FOlxuICAgICAgICByZXQgPSBaX1NUUkVBTV9FTkQkMjtcbiAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgY2FzZSBCQUQkMTpcbiAgICAgICAgcmV0ID0gWl9EQVRBX0VSUk9SJDE7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgTUVNOlxuICAgICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgICBjYXNlIFNZTkM6XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluZl9sZWF2ZSA8LSBoZXJlIGlzIHJlYWwgcGxhY2UgZm9yIFwiZ290byBpbmZfbGVhdmVcIiwgZW11bGF0ZWQgdmlhIFwiYnJlYWsgaW5mX2xlYXZlXCJcblxuICAvKlxuICAgICBSZXR1cm4gZnJvbSBpbmZsYXRlKCksIHVwZGF0aW5nIHRoZSB0b3RhbCBjb3VudHMgYW5kIHRoZSBjaGVjayB2YWx1ZS5cbiAgICAgSWYgdGhlcmUgd2FzIG5vIHByb2dyZXNzIGR1cmluZyB0aGUgaW5mbGF0ZSgpIGNhbGwsIHJldHVybiBhIGJ1ZmZlclxuICAgICBlcnJvci4gIENhbGwgdXBkYXRld2luZG93KCkgdG8gY3JlYXRlIGFuZC9vciB1cGRhdGUgdGhlIHdpbmRvdyBzdGF0ZS5cbiAgICAgTm90ZTogYSBtZW1vcnkgZXJyb3IgZnJvbSBpbmZsYXRlKCkgaXMgbm9uLXJlY292ZXJhYmxlLlxuICAgKi9cblxuICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgLy8tLS1cblxuICBpZiAoc3RhdGUud3NpemUgfHwgKF9vdXQgIT09IHN0cm0uYXZhaWxfb3V0ICYmIHN0YXRlLm1vZGUgPCBCQUQkMSAmJlxuICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlIDwgQ0hFQ0sgfHwgZmx1c2ggIT09IFpfRklOSVNIJDIpKSkge1xuICAgIGlmICh1cGRhdGV3aW5kb3coc3RybSwgc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQsIF9vdXQgLSBzdHJtLmF2YWlsX291dCkpIDtcbiAgfVxuICBfaW4gLT0gc3RybS5hdmFpbF9pbjtcbiAgX291dCAtPSBzdHJtLmF2YWlsX291dDtcbiAgc3RybS50b3RhbF9pbiArPSBfaW47XG4gIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gIGlmIChzdGF0ZS53cmFwICYmIF9vdXQpIHtcbiAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAvKlVQREFURShzdGF0ZS5jaGVjaywgc3RybS5uZXh0X291dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMl8xKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSA6IGFkbGVyMzJfMShzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkpO1xuICB9XG4gIHN0cm0uZGF0YV90eXBlID0gc3RhdGUuYml0cyArIChzdGF0ZS5sYXN0ID8gNjQgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBUWVBFJDEgPyAxMjggOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBMRU5fIHx8IHN0YXRlLm1vZGUgPT09IENPUFlfID8gMjU2IDogMCk7XG4gIGlmICgoKF9pbiA9PT0gMCAmJiBfb3V0ID09PSAwKSB8fCBmbHVzaCA9PT0gWl9GSU5JU0gkMikgJiYgcmV0ID09PSBaX09LJDIpIHtcbiAgICByZXQgPSBaX0JVRl9FUlJPUiQxO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVFbmQgPSAoc3RybSkgPT4ge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSAvKnx8IHN0cm0tPnpmcmVlID09IChmcmVlX2Z1bmMpMCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7XG4gIH1cblxuICBsZXQgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUud2luZG93KSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuICBzdHJtLnN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIFpfT0skMjtcbn07XG5cblxuY29uc3QgaW5mbGF0ZUdldEhlYWRlciA9IChzdHJtLCBoZWFkKSA9PiB7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUiQxOyB9XG4gIGNvbnN0IHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKChzdGF0ZS53cmFwICYgMikgPT09IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH1cblxuICAvKiBzYXZlIGhlYWRlciBzdHJ1Y3R1cmUgKi9cbiAgc3RhdGUuaGVhZCA9IGhlYWQ7XG4gIGhlYWQuZG9uZSA9IGZhbHNlO1xuICByZXR1cm4gWl9PSyQyO1xufTtcblxuXG5jb25zdCBpbmZsYXRlU2V0RGljdGlvbmFyeSA9IChzdHJtLCBkaWN0aW9uYXJ5KSA9PiB7XG4gIGNvbnN0IGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICBsZXQgc3RhdGU7XG4gIGxldCBkaWN0aWQ7XG4gIGxldCByZXQ7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIC8qID09IFpfTlVMTCAqLyB8fCAhc3RybS5zdGF0ZSAvKiA9PSBaX05VTEwgKi8pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIGlmIChzdGF0ZS53cmFwICE9PSAwICYmIHN0YXRlLm1vZGUgIT09IERJQ1QpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBjb3JyZWN0IGRpY3Rpb25hcnkgaWRlbnRpZmllciAqL1xuICBpZiAoc3RhdGUubW9kZSA9PT0gRElDVCkge1xuICAgIGRpY3RpZCA9IDE7IC8qIGFkbGVyMzIoMCwgbnVsbCwgMCkqL1xuICAgIC8qIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBkaWN0aWQgPSBhZGxlcjMyXzEoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgICBpZiAoZGljdGlkICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUiQxO1xuICAgIH1cbiAgfVxuICAvKiBjb3B5IGRpY3Rpb25hcnkgdG8gd2luZG93IHVzaW5nIHVwZGF0ZXdpbmRvdygpLCB3aGljaCB3aWxsIGFtZW5kIHRoZVxuICAgZXhpc3RpbmcgZGljdGlvbmFyeSBpZiBhcHByb3ByaWF0ZSAqL1xuICByZXQgPSB1cGRhdGV3aW5kb3coc3RybSwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgZGljdExlbmd0aCk7XG4gIGlmIChyZXQpIHtcbiAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgfVxuICBzdGF0ZS5oYXZlZGljdCA9IDE7XG4gIC8vIFRyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgZGljdGlvbmFyeSBzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSyQyO1xufTtcblxuXG52YXIgaW5mbGF0ZVJlc2V0XzEgPSBpbmZsYXRlUmVzZXQ7XG52YXIgaW5mbGF0ZVJlc2V0Ml8xID0gaW5mbGF0ZVJlc2V0MjtcbnZhciBpbmZsYXRlUmVzZXRLZWVwXzEgPSBpbmZsYXRlUmVzZXRLZWVwO1xudmFyIGluZmxhdGVJbml0XzEgPSBpbmZsYXRlSW5pdDtcbnZhciBpbmZsYXRlSW5pdDJfMSA9IGluZmxhdGVJbml0MjtcbnZhciBpbmZsYXRlXzIgPSBpbmZsYXRlO1xudmFyIGluZmxhdGVFbmRfMSA9IGluZmxhdGVFbmQ7XG52YXIgaW5mbGF0ZUdldEhlYWRlcl8xID0gaW5mbGF0ZUdldEhlYWRlcjtcbnZhciBpbmZsYXRlU2V0RGljdGlvbmFyeV8xID0gaW5mbGF0ZVNldERpY3Rpb25hcnk7XG52YXIgaW5mbGF0ZUluZm8gPSAncGFrbyBpbmZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZUNvcHkgPSBpbmZsYXRlQ29weTtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVHZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZUdldERpY3Rpb25hcnk7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlTWFyayA9IGluZmxhdGVNYXJrO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVByaW1lID0gaW5mbGF0ZVByaW1lO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBpbmZsYXRlU3luYztcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVTeW5jUG9pbnQgPSBpbmZsYXRlU3luY1BvaW50O1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVVuZGVybWluZSA9IGluZmxhdGVVbmRlcm1pbmU7XG4qL1xuXG52YXIgaW5mbGF0ZV8xID0ge1xuXHRpbmZsYXRlUmVzZXQ6IGluZmxhdGVSZXNldF8xLFxuXHRpbmZsYXRlUmVzZXQyOiBpbmZsYXRlUmVzZXQyXzEsXG5cdGluZmxhdGVSZXNldEtlZXA6IGluZmxhdGVSZXNldEtlZXBfMSxcblx0aW5mbGF0ZUluaXQ6IGluZmxhdGVJbml0XzEsXG5cdGluZmxhdGVJbml0MjogaW5mbGF0ZUluaXQyXzEsXG5cdGluZmxhdGU6IGluZmxhdGVfMixcblx0aW5mbGF0ZUVuZDogaW5mbGF0ZUVuZF8xLFxuXHRpbmZsYXRlR2V0SGVhZGVyOiBpbmZsYXRlR2V0SGVhZGVyXzEsXG5cdGluZmxhdGVTZXREaWN0aW9uYXJ5OiBpbmZsYXRlU2V0RGljdGlvbmFyeV8xLFxuXHRpbmZsYXRlSW5mbzogaW5mbGF0ZUluZm9cbn07XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gR1poZWFkZXIoKSB7XG4gIC8qIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHQgKi9cbiAgdGhpcy50ZXh0ICAgICAgID0gMDtcbiAgLyogbW9kaWZpY2F0aW9uIHRpbWUgKi9cbiAgdGhpcy50aW1lICAgICAgID0gMDtcbiAgLyogZXh0cmEgZmxhZ3MgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy54ZmxhZ3MgICAgID0gMDtcbiAgLyogb3BlcmF0aW5nIHN5c3RlbSAqL1xuICB0aGlzLm9zICAgICAgICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIGV4dHJhIGZpZWxkIG9yIFpfTlVMTCBpZiBub25lICovXG4gIHRoaXMuZXh0cmEgICAgICA9IG51bGw7XG4gIC8qIGV4dHJhIGZpZWxkIGxlbmd0aCAodmFsaWQgaWYgZXh0cmEgIT0gWl9OVUxMKSAqL1xuICB0aGlzLmV4dHJhX2xlbiAgPSAwOyAvLyBBY3R1YWxseSwgd2UgZG9uJ3QgbmVlZCBpdCBpbiBKUyxcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGxlYXZlIGZvciBmZXcgY29kZSBtb2RpZmljYXRpb25zXG5cbiAgLy9cbiAgLy8gU2V0dXAgbGltaXRzIGlzIG5vdCBuZWNlc3NhcnkgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeVxuICAvLyBmb3IgaW5mbGF0ZSB1c2UgY29uc3RhbnQgbGltaXQgaW4gNjU1MzYgYnl0ZXNcbiAgLy9cblxuICAvKiBzcGFjZSBhdCBleHRyYSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmV4dHJhX21heCAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBmaWxlIG5hbWUgb3IgWl9OVUxMICovXG4gIHRoaXMubmFtZSAgICAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBuYW1lIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMubmFtZV9tYXggICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGNvbW1lbnQgb3IgWl9OVUxMICovXG4gIHRoaXMuY29tbWVudCAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBjb21tZW50IChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuY29tbV9tYXggICA9IDA7XG4gIC8qIHRydWUgaWYgdGhlcmUgd2FzIG9yIHdpbGwgYmUgYSBoZWFkZXIgY3JjICovXG4gIHRoaXMuaGNyYyAgICAgICA9IDA7XG4gIC8qIHRydWUgd2hlbiBkb25lIHJlYWRpbmcgZ3ppcCBoZWFkZXIgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy5kb25lICAgICAgID0gZmFsc2U7XG59XG5cbnZhciBnemhlYWRlciA9IEdaaGVhZGVyO1xuXG5jb25zdCB0b1N0cmluZyQxID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmNvbnN0IHtcbiAgWl9OT19GTFVTSDogWl9OT19GTFVTSCQyLCBaX0ZJTklTSDogWl9GSU5JU0gkMyxcbiAgWl9PSzogWl9PSyQzLCBaX1NUUkVBTV9FTkQ6IFpfU1RSRUFNX0VORCQzLCBaX05FRURfRElDVDogWl9ORUVEX0RJQ1QkMSwgWl9TVFJFQU1fRVJST1I6IFpfU1RSRUFNX0VSUk9SJDIsIFpfREFUQV9FUlJPUjogWl9EQVRBX0VSUk9SJDIsIFpfTUVNX0VSUk9SOiBaX01FTV9FUlJPUiQxXG59ID0gY29uc3RhbnRzO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qKlxuICogY2xhc3MgSW5mbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2luZmxhdGVdXVxuICogYW5kIFtbaW5mbGF0ZVJhd11dLlxuICoqL1xuXG4vKiBpbnRlcm5hbFxuICogaW5mbGF0ZS5jaHVua3MgLT4gQXJyYXlcbiAqXG4gKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbSW5mbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGRlbi5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLnJlc3VsdCAtPiBVaW50OEFycmF5fFN0cmluZ1xuICpcbiAqIFVuY29tcHJlc3NlZCByZXN1bHQsIGdlbmVyYXRlZCBieSBkZWZhdWx0IFtbSW5mbGF0ZSNvbkRhdGFdXVxuICogYW5kIFtbSW5mbGF0ZSNvbkVuZF1dIGhhbmRsZXJzLiBGaWxsZWQgYWZ0ZXIgeW91IHB1c2ggbGFzdCBjaHVua1xuICogKGNhbGwgW1tJbmZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUuZXJyIC0+IE51bWJlclxuICpcbiAqIEVycm9yIGNvZGUgYWZ0ZXIgaW5mbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy5cbiAqIFNob3VsZCBiZSBjaGVja2VkIGlmIGJyb2tlbiBkYXRhIHBvc3NpYmxlLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbSW5mbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgSW5mbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBpbmZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBpbmZsYXRlXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gbm8gb3B0aW9ucyBzZXQsIGF1dG9kZXRlY3QgZGVmbGF0ZS9nemlwIGRhdGEgZm9ybWF0IHZpYVxuICogd3JhcHBlciBoZWFkZXIuXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiBjb25zdCBjaHVuazEgPSBuZXcgVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogY29uc3QgY2h1bmsyID0gbmV3IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogY29uc3QgaW5mbGF0ZSA9IG5ldyBwYWtvLkluZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGluZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGluZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGluZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihpbmZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhpbmZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIEluZmxhdGUob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBjb21tb24uYXNzaWduKHtcbiAgICBjaHVua1NpemU6IDEwMjQgKiA2NCxcbiAgICB3aW5kb3dCaXRzOiAxNSxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgY29uc3Qgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIC8vIEZvcmNlIHdpbmRvdyBzaXplIGZvciBgcmF3YCBkYXRhLCBpZiBub3Qgc2V0IGRpcmVjdGx5LFxuICAvLyBiZWNhdXNlIHdlIGhhdmUgbm8gaGVhZGVyIGZvciBhdXRvZGV0ZWN0LlxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gICAgaWYgKG9wdC53aW5kb3dCaXRzID09PSAwKSB7IG9wdC53aW5kb3dCaXRzID0gLTE1OyB9XG4gIH1cblxuICAvLyBJZiBgd2luZG93Qml0c2Agbm90IGRlZmluZWQgKGFuZCBtb2RlIG5vdCByYXcpIC0gc2V0IGF1dG9kZXRlY3QgZmxhZyBmb3IgZ3ppcC9kZWZsYXRlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpICYmXG4gICAgICAhKG9wdGlvbnMgJiYgb3B0aW9ucy53aW5kb3dCaXRzKSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDMyO1xuICB9XG5cbiAgLy8gR3ppcCBoZWFkZXIgaGFzIG5vIGluZm8gYWJvdXQgd2luZG93cyBzaXplLCB3ZSBjYW4gZG8gYXV0b2RldGVjdCBvbmx5XG4gIC8vIGZvciBkZWZsYXRlLiBTbywgaWYgd2luZG93IHNpemUgbm90IHNldCwgZm9yY2UgaXQgdG8gbWF4IHdoZW4gZ3ppcCBwb3NzaWJsZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID4gMTUpICYmIChvcHQud2luZG93Qml0cyA8IDQ4KSkge1xuICAgIC8vIGJpdCAzICgxNikgLT4gZ3ppcHBlZCBkYXRhXG4gICAgLy8gYml0IDQgKDMyKSAtPiBhdXRvZGV0ZWN0IGd6aXAvZGVmbGF0ZVxuICAgIGlmICgob3B0LndpbmRvd0JpdHMgJiAxNSkgPT09IDApIHtcbiAgICAgIG9wdC53aW5kb3dCaXRzIHw9IDE1O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSAgID0gbmV3IHpzdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgbGV0IHN0YXR1cyAgPSBpbmZsYXRlXzEuaW5mbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQud2luZG93Qml0c1xuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IFpfT0skMykge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlc1tzdGF0dXNdKTtcbiAgfVxuXG4gIHRoaXMuaGVhZGVyID0gbmV3IGd6aGVhZGVyKCk7XG5cbiAgaW5mbGF0ZV8xLmluZmxhdGVHZXRIZWFkZXIodGhpcy5zdHJtLCB0aGlzLmhlYWRlcik7XG5cbiAgLy8gU2V0dXAgZGljdGlvbmFyeVxuICBpZiAob3B0LmRpY3Rpb25hcnkpIHtcbiAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2UgaWYgKHRvU3RyaW5nJDEuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpO1xuICAgIH1cbiAgICBpZiAob3B0LnJhdykgeyAvL0luIHJhdyBtb2RlIHdlIG5lZWQgdG8gc2V0IHRoZSBkaWN0aW9uYXJ5IGVhcmx5XG4gICAgICBzdGF0dXMgPSBpbmZsYXRlXzEuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBvcHQuZGljdGlvbmFyeSk7XG4gICAgICBpZiAoc3RhdHVzICE9PSBaX09LJDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzW3N0YXR1c10pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEluZmxhdGUjcHVzaChkYXRhWywgZmx1c2hfbW9kZV0pIC0+IEJvb2xlYW5cbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheUJ1ZmZlcik6IGlucHV0IGRhdGFcbiAqIC0gZmx1c2hfbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRVxuICogICBmbHVzaCBtb2Rlcy4gU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsXG4gKiAgIGB0cnVlYCBtZWFucyBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGluZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0luZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IG91dHB1dCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIElmIGVuZCBvZiBzdHJlYW0gZGV0ZWN0ZWQsXG4gKiBbW0luZmxhdGUjb25FbmRdXSB3aWxsIGJlIGNhbGxlZC5cbiAqXG4gKiBgZmx1c2hfbW9kZWAgaXMgbm90IG5lZWRlZCBmb3Igbm9ybWFsIG9wZXJhdGlvbiwgYmVjYXVzZSBlbmQgb2Ygc3RyZWFtXG4gKiBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5LiBZb3UgbWF5IHRyeSB0byB1c2UgaXQgZm9yIGFkdmFuY2VkIHRoaW5ncywgYnV0XG4gKiB0aGlzIGZ1bmN0aW9uYWxpdHkgd2FzIG5vdCB0ZXN0ZWQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbSW5mbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgZmx1c2hfbW9kZSkge1xuICBjb25zdCBzdHJtID0gdGhpcy5zdHJtO1xuICBjb25zdCBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICBjb25zdCBkaWN0aW9uYXJ5ID0gdGhpcy5vcHRpb25zLmRpY3Rpb25hcnk7XG4gIGxldCBzdGF0dXMsIF9mbHVzaF9tb2RlLCBsYXN0X2F2YWlsX291dDtcblxuICBpZiAodGhpcy5lbmRlZCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChmbHVzaF9tb2RlID09PSB+fmZsdXNoX21vZGUpIF9mbHVzaF9tb2RlID0gZmx1c2hfbW9kZTtcbiAgZWxzZSBfZmx1c2hfbW9kZSA9IGZsdXNoX21vZGUgPT09IHRydWUgPyBaX0ZJTklTSCQzIDogWl9OT19GTFVTSCQyO1xuXG4gIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgaWYgKHRvU3RyaW5nJDEuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBmb3IgKDs7KSB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyBVaW50OEFycmF5KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIHN0YXR1cyA9IGluZmxhdGVfMS5pbmZsYXRlKHN0cm0sIF9mbHVzaF9tb2RlKTtcblxuICAgIGlmIChzdGF0dXMgPT09IFpfTkVFRF9ESUNUJDEgJiYgZGljdGlvbmFyeSkge1xuICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xLmluZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpO1xuXG4gICAgICBpZiAoc3RhdHVzID09PSBaX09LJDMpIHtcbiAgICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xLmluZmxhdGUoc3RybSwgX2ZsdXNoX21vZGUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IFpfREFUQV9FUlJPUiQyKSB7XG4gICAgICAgIC8vIFJlcGxhY2UgY29kZSB3aXRoIG1vcmUgdmVyYm9zZVxuICAgICAgICBzdGF0dXMgPSBaX05FRURfRElDVCQxO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNraXAgc255YyBtYXJrZXJzIGlmIG1vcmUgZGF0YSBmb2xsb3dzIGFuZCBub3QgcmF3IG1vZGVcbiAgICB3aGlsZSAoc3RybS5hdmFpbF9pbiA+IDAgJiZcbiAgICAgICAgICAgc3RhdHVzID09PSBaX1NUUkVBTV9FTkQkMyAmJlxuICAgICAgICAgICBzdHJtLnN0YXRlLndyYXAgPiAwICYmXG4gICAgICAgICAgIGRhdGFbc3RybS5uZXh0X2luXSAhPT0gMClcbiAgICB7XG4gICAgICBpbmZsYXRlXzEuaW5mbGF0ZVJlc2V0KHN0cm0pO1xuICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xLmluZmxhdGUoc3RybSwgX2ZsdXNoX21vZGUpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICBjYXNlIFpfU1RSRUFNX0VSUk9SJDI6XG4gICAgICBjYXNlIFpfREFUQV9FUlJPUiQyOlxuICAgICAgY2FzZSBaX05FRURfRElDVCQxOlxuICAgICAgY2FzZSBaX01FTV9FUlJPUiQxOlxuICAgICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gUmVtZW1iZXIgcmVhbCBgYXZhaWxfb3V0YCB2YWx1ZSwgYmVjYXVzZSB3ZSBtYXkgcGF0Y2ggb3V0IGJ1ZmZlciBjb250ZW50XG4gICAgLy8gdG8gYWxpZ24gdXRmOCBzdHJpbmdzIGJvdW5kYXJpZXMuXG4gICAgbGFzdF9hdmFpbF9vdXQgPSBzdHJtLmF2YWlsX291dDtcblxuICAgIGlmIChzdHJtLm5leHRfb3V0KSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgc3RhdHVzID09PSBaX1NUUkVBTV9FTkQkMykge1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICBsZXQgbmV4dF9vdXRfdXRmOCA9IHN0cmluZ3MudXRmOGJvcmRlcihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCk7XG5cbiAgICAgICAgICBsZXQgdGFpbCA9IHN0cm0ubmV4dF9vdXQgLSBuZXh0X291dF91dGY4O1xuICAgICAgICAgIGxldCB1dGY4c3RyID0gc3RyaW5ncy5idWYyc3RyaW5nKHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4KTtcblxuICAgICAgICAgIC8vIG1vdmUgdGFpbCAmIHJlYWxpZ24gY291bnRlcnNcbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gdGFpbDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZSAtIHRhaWw7XG4gICAgICAgICAgaWYgKHRhaWwpIHN0cm0ub3V0cHV0LnNldChzdHJtLm91dHB1dC5zdWJhcnJheShuZXh0X291dF91dGY4LCBuZXh0X291dF91dGY4ICsgdGFpbCksIDApO1xuXG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRmOHN0cik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uRGF0YShzdHJtLm91dHB1dC5sZW5ndGggPT09IHN0cm0ubmV4dF9vdXQgPyBzdHJtLm91dHB1dCA6IHN0cm0ub3V0cHV0LnN1YmFycmF5KDAsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE11c3QgcmVwZWF0IGl0ZXJhdGlvbiBpZiBvdXQgYnVmZmVyIGlzIGZ1bGxcbiAgICBpZiAoc3RhdHVzID09PSBaX09LJDMgJiYgbGFzdF9hdmFpbF9vdXQgPT09IDApIGNvbnRpbnVlO1xuXG4gICAgLy8gRmluYWxpemUgaWYgZW5kIG9mIHN0cmVhbSByZWFjaGVkLlxuICAgIGlmIChzdGF0dXMgPT09IFpfU1RSRUFNX0VORCQzKSB7XG4gICAgICBzdGF0dXMgPSBpbmZsYXRlXzEuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxTdHJpbmcpOiBvdXRwdXQgZGF0YS4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgZWFjaCBjaHVuayB3aWxsIGJlIHN0cmluZy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGluZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIGVpdGhlciBhZnRlciB5b3UgdGVsbCBpbmZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKS4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgLy8gT24gc3VjY2VzcyAtIGpvaW5cbiAgaWYgKHN0YXR1cyA9PT0gWl9PSyQzKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gY29tbW9uLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpO1xuICAgIH1cbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuICB0aGlzLmVyciA9IHN0YXR1cztcbiAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xufTtcblxuXG4vKipcbiAqIGluZmxhdGUoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5KTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBEZWNvbXByZXNzIGBkYXRhYCB3aXRoIGluZmxhdGUvdW5nemlwIGFuZCBgb3B0aW9uc2AuIEF1dG9kZXRlY3RcbiAqIGZvcm1hdCB2aWEgd3JhcHBlciBoZWFkZXIgYnkgZGVmYXVsdC4gVGhhdCdzIHdoeSB3ZSBkb24ndCBwcm92aWRlXG4gKiBzZXBhcmF0ZSBgdW5nemlwYCBtZXRob2QuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gd2luZG93Qml0c1xuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKTtcbiAqIGNvbnN0IGlucHV0ID0gcGFrby5kZWZsYXRlKG5ldyBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pKTtcbiAqIGxldCBvdXRwdXQ7XG4gKlxuICogdHJ5IHtcbiAqICAgb3V0cHV0ID0gcGFrby5pbmZsYXRlKGlucHV0KTtcbiAqIH0gY2F0Y2ggKGVycilcbiAqICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH1cbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZSQxKGlucHV0LCBvcHRpb25zKSB7XG4gIGNvbnN0IGluZmxhdG9yID0gbmV3IEluZmxhdGUob3B0aW9ucyk7XG5cbiAgaW5mbGF0b3IucHVzaChpbnB1dCk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGluZmxhdG9yLmVycikgdGhyb3cgaW5mbGF0b3IubXNnIHx8IG1lc3NhZ2VzW2luZmxhdG9yLmVycl07XG5cbiAgcmV0dXJuIGluZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGluZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5KTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2luZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gaW5mbGF0ZSQxKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIHVuZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXkpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIEp1c3Qgc2hvcnRjdXQgdG8gW1tpbmZsYXRlXV0sIGJlY2F1c2UgaXQgYXV0b2RldGVjdHMgZm9ybWF0XG4gKiBieSBoZWFkZXIuY29udGVudC4gRG9uZSBmb3IgY29udmVuaWVuY2UuXG4gKiovXG5cblxudmFyIEluZmxhdGVfMSA9IEluZmxhdGU7XG52YXIgaW5mbGF0ZV8yJDEgPSBpbmZsYXRlJDE7XG52YXIgaW5mbGF0ZVJhd18xID0gaW5mbGF0ZVJhdztcbnZhciB1bmd6aXAgPSBpbmZsYXRlJDE7XG52YXIgY29uc3RhbnRzJDIgPSBjb25zdGFudHM7XG5cbnZhciBpbmZsYXRlXzEkMSA9IHtcblx0SW5mbGF0ZTogSW5mbGF0ZV8xLFxuXHRpbmZsYXRlOiBpbmZsYXRlXzIkMSxcblx0aW5mbGF0ZVJhdzogaW5mbGF0ZVJhd18xLFxuXHR1bmd6aXA6IHVuZ3ppcCxcblx0Y29uc3RhbnRzOiBjb25zdGFudHMkMlxufTtcblxuY29uc3QgeyBEZWZsYXRlOiBEZWZsYXRlJDEsIGRlZmxhdGU6IGRlZmxhdGUkMiwgZGVmbGF0ZVJhdzogZGVmbGF0ZVJhdyQxLCBnemlwOiBnemlwJDEgfSA9IGRlZmxhdGVfMSQxO1xuXG5jb25zdCB7IEluZmxhdGU6IEluZmxhdGUkMSwgaW5mbGF0ZTogaW5mbGF0ZSQyLCBpbmZsYXRlUmF3OiBpbmZsYXRlUmF3JDEsIHVuZ3ppcDogdW5nemlwJDEgfSA9IGluZmxhdGVfMSQxO1xuXG5cblxudmFyIERlZmxhdGVfMSQxID0gRGVmbGF0ZSQxO1xudmFyIGRlZmxhdGVfMSQyID0gZGVmbGF0ZSQyO1xudmFyIGRlZmxhdGVSYXdfMSQxID0gZGVmbGF0ZVJhdyQxO1xudmFyIGd6aXBfMSQxID0gZ3ppcCQxO1xudmFyIEluZmxhdGVfMSQxID0gSW5mbGF0ZSQxO1xudmFyIGluZmxhdGVfMSQyID0gaW5mbGF0ZSQyO1xudmFyIGluZmxhdGVSYXdfMSQxID0gaW5mbGF0ZVJhdyQxO1xudmFyIHVuZ3ppcF8xID0gdW5nemlwJDE7XG52YXIgY29uc3RhbnRzXzEgPSBjb25zdGFudHM7XG5cbnZhciBwYWtvID0ge1xuXHREZWZsYXRlOiBEZWZsYXRlXzEkMSxcblx0ZGVmbGF0ZTogZGVmbGF0ZV8xJDIsXG5cdGRlZmxhdGVSYXc6IGRlZmxhdGVSYXdfMSQxLFxuXHRnemlwOiBnemlwXzEkMSxcblx0SW5mbGF0ZTogSW5mbGF0ZV8xJDEsXG5cdGluZmxhdGU6IGluZmxhdGVfMSQyLFxuXHRpbmZsYXRlUmF3OiBpbmZsYXRlUmF3XzEkMSxcblx0dW5nemlwOiB1bmd6aXBfMSxcblx0Y29uc3RhbnRzOiBjb25zdGFudHNfMVxufTtcblxudmFyIF9hJDI7XG5jb25zdCBHWmlwID0gKF9hJDIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGxldmVsID0gMSkge1xuICAgIGlmIChsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGd6aXAgY29tcHJlc3Npb24gbGV2ZWwsIGl0IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kIDlcIik7XG4gICAgfVxuICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgfVxuICBzdGF0aWMgZnJvbUNvbmZpZyh7IGxldmVsIH0pIHtcbiAgICByZXR1cm4gbmV3IF9hJDIobGV2ZWwpO1xuICB9XG4gIGVuY29kZShkYXRhKSB7XG4gICAgY29uc3QgZ3ppcHBlZCA9IHBha28uZ3ppcChkYXRhLCB7IGxldmVsOiB0aGlzLmxldmVsIH0pO1xuICAgIHJldHVybiBnemlwcGVkO1xuICB9XG4gIGRlY29kZShkYXRhLCBvdXQpIHtcbiAgICBjb25zdCB1bmNvbXByZXNzZWQgPSBwYWtvLnVuZ3ppcChkYXRhKTtcbiAgICBpZiAob3V0ICE9PSB2b2lkIDApIHtcbiAgICAgIG91dC5zZXQodW5jb21wcmVzc2VkKTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHJldHVybiB1bmNvbXByZXNzZWQ7XG4gIH1cbn0sIF9hJDIuY29kZWNJZCA9IFwiZ3ppcFwiLCBfYSQyKTtcblxudmFyIEdaaXAkMSA9IEdaaXA7XG5cbnZhciBfYSQxO1xuY29uc3QgWmxpYiA9IChfYSQxID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihsZXZlbCA9IDEpIHtcbiAgICBpZiAobGV2ZWwgPCAtMSB8fCBsZXZlbCA+IDkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgemxpYiBjb21wcmVzc2lvbiBsZXZlbCwgaXQgc2hvdWxkIGJlIGJldHdlZW4gLTEgYW5kIDlcIik7XG4gICAgfVxuICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgfVxuICBzdGF0aWMgZnJvbUNvbmZpZyh7IGxldmVsIH0pIHtcbiAgICByZXR1cm4gbmV3IF9hJDEobGV2ZWwpO1xuICB9XG4gIGVuY29kZShkYXRhKSB7XG4gICAgY29uc3QgZ3ppcHBlZCA9IHBha28uZGVmbGF0ZShkYXRhLCB7IGxldmVsOiB0aGlzLmxldmVsIH0pO1xuICAgIHJldHVybiBnemlwcGVkO1xuICB9XG4gIGRlY29kZShkYXRhLCBvdXQpIHtcbiAgICBjb25zdCB1bmNvbXByZXNzZWQgPSBwYWtvLmluZmxhdGUoZGF0YSk7XG4gICAgaWYgKG91dCAhPT0gdm9pZCAwKSB7XG4gICAgICBvdXQuc2V0KHVuY29tcHJlc3NlZCk7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICByZXR1cm4gdW5jb21wcmVzc2VkO1xuICB9XG59LCBfYSQxLmNvZGVjSWQgPSBcInpsaWJcIiwgX2EkMSk7XG5cbnZhciBabGliJDEgPSBabGliO1xuXG52YXIgYmxvc2NfY29kZWMgPSBmdW5jdGlvbigpIHtcbiAgdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgPyBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyA6IHZvaWQgMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKGJsb3NjX2NvZGVjMikge1xuICAgIGJsb3NjX2NvZGVjMiA9IGJsb3NjX2NvZGVjMiB8fCB7fTtcbiAgICB2YXIgZjtcbiAgICBmIHx8IChmID0gdHlwZW9mIGJsb3NjX2NvZGVjMiAhPT0gXCJ1bmRlZmluZWRcIiA/IGJsb3NjX2NvZGVjMiA6IHt9KTtcbiAgICB2YXIgYWEsIGJhO1xuICAgIGYucmVhZHkgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihhLCBiKSB7XG4gICAgICBhYSA9IGE7XG4gICAgICBiYSA9IGI7XG4gICAgfSk7XG4gICAgdmFyIHIgPSB7fSwgdDtcbiAgICBmb3IgKHQgaW4gZilcbiAgICAgIGYuaGFzT3duUHJvcGVydHkodCkgJiYgKHJbdF0gPSBmW3RdKTtcbiAgICB2YXIgY2EgPSBcIi4vdGhpcy5wcm9ncmFtXCIsIGRhID0gZi5wcmludCB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLCB1ID0gZi5wcmludEVyciB8fCBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtcbiAgICBmb3IgKHQgaW4gcilcbiAgICAgIHIuaGFzT3duUHJvcGVydHkodCkgJiYgKGZbdF0gPSByW3RdKTtcbiAgICByID0gbnVsbDtcbiAgICBmLnRoaXNQcm9ncmFtICYmIChjYSA9IGYudGhpc1Byb2dyYW0pO1xuICAgIHZhciB2O1xuICAgIGYud2FzbUJpbmFyeSAmJiAodiA9IGYud2FzbUJpbmFyeSk7XG4gICAgZi5ub0V4aXRSdW50aW1lICYmIChmLm5vRXhpdFJ1bnRpbWUpO1xuICAgIHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gXCJvYmplY3RcIiAmJiB3KFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTtcbiAgICB2YXIgeSwgZWEgPSBmYWxzZSwgZmEgPSB0eXBlb2YgVGV4dERlY29kZXIgIT09IFwidW5kZWZpbmVkXCIgPyBuZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpIDogdm9pZCAwO1xuICAgIGZ1bmN0aW9uIGhhKGEsIGIsIGMpIHtcbiAgICAgIHZhciBkID0gYiArIGM7XG4gICAgICBmb3IgKGMgPSBiOyBhW2NdICYmICEoYyA+PSBkKTsgKVxuICAgICAgICArK2M7XG4gICAgICBpZiAoMTYgPCBjIC0gYiAmJiBhLnN1YmFycmF5ICYmIGZhKVxuICAgICAgICByZXR1cm4gZmEuZGVjb2RlKGEuc3ViYXJyYXkoYiwgYykpO1xuICAgICAgZm9yIChkID0gXCJcIjsgYiA8IGM7ICkge1xuICAgICAgICB2YXIgZSA9IGFbYisrXTtcbiAgICAgICAgaWYgKGUgJiAxMjgpIHtcbiAgICAgICAgICB2YXIgZyA9IGFbYisrXSAmIDYzO1xuICAgICAgICAgIGlmICgoZSAmIDIyNCkgPT0gMTkyKVxuICAgICAgICAgICAgZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChlICYgMzEpIDw8IDYgfCBnKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrID0gYVtiKytdICYgNjM7XG4gICAgICAgICAgICBlID0gKGUgJiAyNDApID09IDIyNCA/IChlICYgMTUpIDw8IDEyIHwgZyA8PCA2IHwgayA6IChlICYgNykgPDwgMTggfCBnIDw8IDEyIHwgayA8PCA2IHwgYVtiKytdICYgNjM7XG4gICAgICAgICAgICA2NTUzNiA+IGUgPyBkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZSkgOiAoZSAtPSA2NTUzNiwgZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2IHwgZSA+PiAxMCwgNTYzMjAgfCBlICYgMTAyMykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlhKGEsIGIsIGMpIHtcbiAgICAgIHZhciBkID0gejtcbiAgICAgIGlmICgwIDwgYykge1xuICAgICAgICBjID0gYiArIGMgLSAxO1xuICAgICAgICBmb3IgKHZhciBlID0gMDsgZSA8IGEubGVuZ3RoOyArK2UpIHtcbiAgICAgICAgICB2YXIgZyA9IGEuY2hhckNvZGVBdChlKTtcbiAgICAgICAgICBpZiAoNTUyOTYgPD0gZyAmJiA1NzM0MyA+PSBnKSB7XG4gICAgICAgICAgICB2YXIgayA9IGEuY2hhckNvZGVBdCgrK2UpO1xuICAgICAgICAgICAgZyA9IDY1NTM2ICsgKChnICYgMTAyMykgPDwgMTApIHwgayAmIDEwMjM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgxMjcgPj0gZykge1xuICAgICAgICAgICAgaWYgKGIgPj0gYylcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkW2IrK10gPSBnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoMjA0NyA+PSBnKSB7XG4gICAgICAgICAgICAgIGlmIChiICsgMSA+PSBjKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkW2IrK10gPSAxOTIgfCBnID4+IDY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoNjU1MzUgPj0gZykge1xuICAgICAgICAgICAgICAgIGlmIChiICsgMiA+PSBjKVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZFtiKytdID0gMjI0IHwgZyA+PiAxMjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYiArIDMgPj0gYylcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRbYisrXSA9IDI0MCB8IGcgPj4gMTg7XG4gICAgICAgICAgICAgICAgZFtiKytdID0gMTI4IHwgZyA+PiAxMiAmIDYzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRbYisrXSA9IDEyOCB8IGcgPj4gNiAmIDYzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZFtiKytdID0gMTI4IHwgZyAmIDYzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkW2JdID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGphID0gdHlwZW9mIFRleHREZWNvZGVyICE9PSBcInVuZGVmaW5lZFwiID8gbmV3IFRleHREZWNvZGVyKFwidXRmLTE2bGVcIikgOiB2b2lkIDA7XG4gICAgZnVuY3Rpb24ga2EoYSwgYikge1xuICAgICAgdmFyIGMgPSBhID4+IDE7XG4gICAgICBmb3IgKHZhciBkID0gYyArIGIgLyAyOyAhKGMgPj0gZCkgJiYgQVtjXTsgKVxuICAgICAgICArK2M7XG4gICAgICBjIDw8PSAxO1xuICAgICAgaWYgKDMyIDwgYyAtIGEgJiYgamEpXG4gICAgICAgIHJldHVybiBqYS5kZWNvZGUoei5zdWJhcnJheShhLCBjKSk7XG4gICAgICBjID0gMDtcbiAgICAgIGZvciAoZCA9IFwiXCI7IDsgKSB7XG4gICAgICAgIHZhciBlID0gQ1thICsgMiAqIGMgPj4gMV07XG4gICAgICAgIGlmIChlID09IDAgfHwgYyA9PSBiIC8gMilcbiAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgKytjO1xuICAgICAgICBkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxhKGEsIGIsIGMpIHtcbiAgICAgIGMgPT09IHZvaWQgMCAmJiAoYyA9IDIxNDc0ODM2NDcpO1xuICAgICAgaWYgKDIgPiBjKVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIGMgLT0gMjtcbiAgICAgIHZhciBkID0gYjtcbiAgICAgIGMgPSBjIDwgMiAqIGEubGVuZ3RoID8gYyAvIDIgOiBhLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgYzsgKytlKVxuICAgICAgICBDW2IgPj4gMV0gPSBhLmNoYXJDb2RlQXQoZSksIGIgKz0gMjtcbiAgICAgIENbYiA+PiAxXSA9IDA7XG4gICAgICByZXR1cm4gYiAtIGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hKGEpIHtcbiAgICAgIHJldHVybiAyICogYS5sZW5ndGg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5hKGEsIGIpIHtcbiAgICAgIGZvciAodmFyIGMgPSAwLCBkID0gXCJcIjsgIShjID49IGIgLyA0KTsgKSB7XG4gICAgICAgIHZhciBlID0gRFthICsgNCAqIGMgPj4gMl07XG4gICAgICAgIGlmIChlID09IDApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgICsrYztcbiAgICAgICAgNjU1MzYgPD0gZSA/IChlIC09IDY1NTM2LCBkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYgfCBlID4+IDEwLCA1NjMyMCB8IGUgJiAxMDIzKSkgOiBkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gb2EoYSwgYiwgYykge1xuICAgICAgYyA9PT0gdm9pZCAwICYmIChjID0gMjE0NzQ4MzY0Nyk7XG4gICAgICBpZiAoNCA+IGMpXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgdmFyIGQgPSBiO1xuICAgICAgYyA9IGQgKyBjIC0gNDtcbiAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgYS5sZW5ndGg7ICsrZSkge1xuICAgICAgICB2YXIgZyA9IGEuY2hhckNvZGVBdChlKTtcbiAgICAgICAgaWYgKDU1Mjk2IDw9IGcgJiYgNTczNDMgPj0gZykge1xuICAgICAgICAgIHZhciBrID0gYS5jaGFyQ29kZUF0KCsrZSk7XG4gICAgICAgICAgZyA9IDY1NTM2ICsgKChnICYgMTAyMykgPDwgMTApIHwgayAmIDEwMjM7XG4gICAgICAgIH1cbiAgICAgICAgRFtiID4+IDJdID0gZztcbiAgICAgICAgYiArPSA0O1xuICAgICAgICBpZiAoYiArIDQgPiBjKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgRFtiID4+IDJdID0gMDtcbiAgICAgIHJldHVybiBiIC0gZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGEoYSkge1xuICAgICAgZm9yICh2YXIgYiA9IDAsIGMgPSAwOyBjIDwgYS5sZW5ndGg7ICsrYykge1xuICAgICAgICB2YXIgZCA9IGEuY2hhckNvZGVBdChjKTtcbiAgICAgICAgNTUyOTYgPD0gZCAmJiA1NzM0MyA+PSBkICYmICsrYztcbiAgICAgICAgYiArPSA0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIHZhciBFLCBGLCB6LCBDLCBBLCBELCBHLCBxYSwgcmE7XG4gICAgZnVuY3Rpb24gc2EoYSkge1xuICAgICAgRSA9IGE7XG4gICAgICBmLkhFQVA4ID0gRiA9IG5ldyBJbnQ4QXJyYXkoYSk7XG4gICAgICBmLkhFQVAxNiA9IEMgPSBuZXcgSW50MTZBcnJheShhKTtcbiAgICAgIGYuSEVBUDMyID0gRCA9IG5ldyBJbnQzMkFycmF5KGEpO1xuICAgICAgZi5IRUFQVTggPSB6ID0gbmV3IFVpbnQ4QXJyYXkoYSk7XG4gICAgICBmLkhFQVBVMTYgPSBBID0gbmV3IFVpbnQxNkFycmF5KGEpO1xuICAgICAgZi5IRUFQVTMyID0gRyA9IG5ldyBVaW50MzJBcnJheShhKTtcbiAgICAgIGYuSEVBUEYzMiA9IHFhID0gbmV3IEZsb2F0MzJBcnJheShhKTtcbiAgICAgIGYuSEVBUEY2NCA9IHJhID0gbmV3IEZsb2F0NjRBcnJheShhKTtcbiAgICB9XG4gICAgdmFyIHRhID0gZi5JTklUSUFMX01FTU9SWSB8fCAxNjc3NzIxNjtcbiAgICBmLndhc21NZW1vcnkgPyB5ID0gZi53YXNtTWVtb3J5IDogeSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoeyBpbml0aWFsOiB0YSAvIDY1NTM2LCBtYXhpbXVtOiAzMjc2OCB9KTtcbiAgICB5ICYmIChFID0geS5idWZmZXIpO1xuICAgIHRhID0gRS5ieXRlTGVuZ3RoO1xuICAgIHNhKEUpO1xuICAgIHZhciBJLCB1YSA9IFtdLCB2YSA9IFtdLCB3YSA9IFtdLCB4YSA9IFtdO1xuICAgIGZ1bmN0aW9uIHlhKCkge1xuICAgICAgdmFyIGEgPSBmLnByZVJ1bi5zaGlmdCgpO1xuICAgICAgdWEudW5zaGlmdChhKTtcbiAgICB9XG4gICAgdmFyIEogPSAwLCBLID0gbnVsbDtcbiAgICBmLnByZWxvYWRlZEltYWdlcyA9IHt9O1xuICAgIGYucHJlbG9hZGVkQXVkaW9zID0ge307XG4gICAgZnVuY3Rpb24gdyhhKSB7XG4gICAgICBpZiAoZi5vbkFib3J0KVxuICAgICAgICBmLm9uQWJvcnQoYSk7XG4gICAgICB1KGEpO1xuICAgICAgZWEgPSB0cnVlO1xuICAgICAgYSA9IG5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IoXCJhYm9ydChcIiArIGEgKyBcIikuIEJ1aWxkIHdpdGggLXMgQVNTRVJUSU9OUz0xIGZvciBtb3JlIGluZm8uXCIpO1xuICAgICAgYmEoYSk7XG4gICAgICB0aHJvdyBhO1xuICAgIH1cbiAgICBmdW5jdGlvbiBBYShhKSB7XG4gICAgICB2YXIgYiA9IEw7XG4gICAgICByZXR1cm4gU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoID8gYi5zdGFydHNXaXRoKGEpIDogYi5pbmRleE9mKGEpID09PSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBCYSgpIHtcbiAgICAgIHJldHVybiBBYShcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIik7XG4gICAgfVxuICAgIHZhciBMID0gXCJibG9zY19jb2RlYy53YXNtXCI7XG4gICAgaWYgKCFCYSgpKSB7XG4gICAgICB2YXIgQ2EgPSBMO1xuICAgICAgTCA9IGYubG9jYXRlRmlsZSA/IGYubG9jYXRlRmlsZShDYSwgXCJcIikgOiBcIlwiICsgQ2E7XG4gICAgfVxuICAgIGZ1bmN0aW9uIERhKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHYpXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHYpO1xuICAgICAgICB0aHJvdyBcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCI7XG4gICAgICB9IGNhdGNoIChhKSB7XG4gICAgICAgIHcoYSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIE4oYSkge1xuICAgICAgZm9yICg7IDAgPCBhLmxlbmd0aDsgKSB7XG4gICAgICAgIHZhciBiID0gYS5zaGlmdCgpO1xuICAgICAgICBpZiAodHlwZW9mIGIgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIGIoZik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBjID0gYi5UO1xuICAgICAgICAgIHR5cGVvZiBjID09PSBcIm51bWJlclwiID8gYi5PID09PSB2b2lkIDAgPyBJLmdldChjKSgpIDogSS5nZXQoYykoYi5PKSA6IGMoYi5PID09PSB2b2lkIDAgPyBudWxsIDogYi5PKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBFYShhKSB7XG4gICAgICB0aGlzLk4gPSBhIC0gMTY7XG4gICAgICB0aGlzLiQgPSBmdW5jdGlvbihiKSB7XG4gICAgICAgIERbdGhpcy5OICsgOCA+PiAyXSA9IGI7XG4gICAgICB9O1xuICAgICAgdGhpcy5YID0gZnVuY3Rpb24oYikge1xuICAgICAgICBEW3RoaXMuTiArIDAgPj4gMl0gPSBiO1xuICAgICAgfTtcbiAgICAgIHRoaXMuWSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBEW3RoaXMuTiArIDQgPj4gMl0gPSAwO1xuICAgICAgfTtcbiAgICAgIHRoaXMuVyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBGW3RoaXMuTiArIDEyID4+IDBdID0gMDtcbiAgICAgIH07XG4gICAgICB0aGlzLlogPSBmdW5jdGlvbigpIHtcbiAgICAgICAgRlt0aGlzLk4gKyAxMyA+PiAwXSA9IDA7XG4gICAgICB9O1xuICAgICAgdGhpcy5WID0gZnVuY3Rpb24oYiwgYykge1xuICAgICAgICB0aGlzLiQoYik7XG4gICAgICAgIHRoaXMuWChjKTtcbiAgICAgICAgdGhpcy5ZKCk7XG4gICAgICAgIHRoaXMuVygpO1xuICAgICAgICB0aGlzLlooKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIEZhKGEpIHtcbiAgICAgIHN3aXRjaCAoYSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gdHlwZSBzaXplOiBcIiArIGEpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgR2EgPSB2b2lkIDA7XG4gICAgZnVuY3Rpb24gUChhKSB7XG4gICAgICBmb3IgKHZhciBiID0gXCJcIjsgelthXTsgKVxuICAgICAgICBiICs9IEdhW3pbYSsrXV07XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgdmFyIFEgPSB7fSwgUiA9IHt9LCBTID0ge307XG4gICAgZnVuY3Rpb24gSGEoYSkge1xuICAgICAgaWYgKGEgPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuIFwiX3Vua25vd25cIjtcbiAgICAgIGEgPSBhLnJlcGxhY2UoL1teYS16QS1aMC05X10vZywgXCIkXCIpO1xuICAgICAgdmFyIGIgPSBhLmNoYXJDb2RlQXQoMCk7XG4gICAgICByZXR1cm4gNDggPD0gYiAmJiA1NyA+PSBiID8gXCJfXCIgKyBhIDogYTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSWEoYSwgYikge1xuICAgICAgYSA9IEhhKGEpO1xuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcImJvZHlcIiwgXCJyZXR1cm4gZnVuY3Rpb24gXCIgKyBhICsgJygpIHtcXG4gICAgXCJ1c2Ugc3RyaWN0XCI7ICAgIHJldHVybiBib2R5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxufTtcXG4nKShiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSmEoYSkge1xuICAgICAgdmFyIGIgPSBFcnJvciwgYyA9IElhKGEsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gYTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZDtcbiAgICAgICAgZCA9IEVycm9yKGQpLnN0YWNrO1xuICAgICAgICBkICE9PSB2b2lkIDAgJiYgKHRoaXMuc3RhY2sgPSB0aGlzLnRvU3RyaW5nKCkgKyBcIlxcblwiICsgZC5yZXBsYWNlKC9eRXJyb3IoOlteXFxuXSopP1xcbi8sIFwiXCIpKTtcbiAgICAgIH0pO1xuICAgICAgYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGIucHJvdG90eXBlKTtcbiAgICAgIGMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gYztcbiAgICAgIGMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2UgPT09IHZvaWQgMCA/IHRoaXMubmFtZSA6IHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMubWVzc2FnZTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgdmFyIEthID0gdm9pZCAwO1xuICAgIGZ1bmN0aW9uIFQoYSkge1xuICAgICAgdGhyb3cgbmV3IEthKGEpO1xuICAgIH1cbiAgICB2YXIgTGEgPSB2b2lkIDA7XG4gICAgZnVuY3Rpb24gTWEoYSwgYikge1xuICAgICAgZnVuY3Rpb24gYyhoKSB7XG4gICAgICAgIGggPSBiKGgpO1xuICAgICAgICBpZiAoaC5sZW5ndGggIT09IGQubGVuZ3RoKVxuICAgICAgICAgIHRocm93IG5ldyBMYShcIk1pc21hdGNoZWQgdHlwZSBjb252ZXJ0ZXIgY291bnRcIik7XG4gICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgZC5sZW5ndGg7ICsrbClcbiAgICAgICAgICBVKGRbbF0sIGhbbF0pO1xuICAgICAgfVxuICAgICAgdmFyIGQgPSBbXTtcbiAgICAgIGQuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICAgIFNbaF0gPSBhO1xuICAgICAgfSk7XG4gICAgICB2YXIgZSA9IEFycmF5KGEubGVuZ3RoKSwgZyA9IFtdLCBrID0gMDtcbiAgICAgIGEuZm9yRWFjaChmdW5jdGlvbihoLCBsKSB7XG4gICAgICAgIFIuaGFzT3duUHJvcGVydHkoaCkgPyBlW2xdID0gUltoXSA6IChnLnB1c2goaCksIFEuaGFzT3duUHJvcGVydHkoaCkgfHwgKFFbaF0gPSBbXSksIFFbaF0ucHVzaChmdW5jdGlvbigpIHtcbiAgICAgICAgICBlW2xdID0gUltoXTtcbiAgICAgICAgICArK2s7XG4gICAgICAgICAgayA9PT0gZy5sZW5ndGggJiYgYyhlKTtcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgICBnLmxlbmd0aCA9PT0gMCAmJiBjKGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVKGEsIGIsIGMpIHtcbiAgICAgIGMgPSBjIHx8IHt9O1xuICAgICAgaWYgKCEoXCJhcmdQYWNrQWR2YW5jZVwiIGluIGIpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmVnaXN0ZXJUeXBlIHJlZ2lzdGVyZWRJbnN0YW5jZSByZXF1aXJlcyBhcmdQYWNrQWR2YW5jZVwiKTtcbiAgICAgIHZhciBkID0gYi5uYW1lO1xuICAgICAgYSB8fCBUKCd0eXBlIFwiJyArIGQgKyAnXCIgbXVzdCBoYXZlIGEgcG9zaXRpdmUgaW50ZWdlciB0eXBlaWQgcG9pbnRlcicpO1xuICAgICAgaWYgKFIuaGFzT3duUHJvcGVydHkoYSkpIHtcbiAgICAgICAgaWYgKGMuVSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIFQoXCJDYW5ub3QgcmVnaXN0ZXIgdHlwZSAnXCIgKyBkICsgXCInIHR3aWNlXCIpO1xuICAgICAgfVxuICAgICAgUlthXSA9IGI7XG4gICAgICBkZWxldGUgU1thXTtcbiAgICAgIFEuaGFzT3duUHJvcGVydHkoYSkgJiYgKGIgPSBRW2FdLCBkZWxldGUgUVthXSwgYi5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZSgpO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICB2YXIgTmEgPSBbXSwgViA9IFt7fSwgeyB2YWx1ZTogdm9pZCAwIH0sIHsgdmFsdWU6IG51bGwgfSwgeyB2YWx1ZTogdHJ1ZSB9LCB7IHZhbHVlOiBmYWxzZSB9XTtcbiAgICBmdW5jdGlvbiBRYShhKSB7XG4gICAgICA0IDwgYSAmJiAtLVZbYV0uUCA9PT0gMCAmJiAoVlthXSA9IHZvaWQgMCwgTmEucHVzaChhKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJhKGEpIHtcbiAgICAgIHN3aXRjaCAoYSkge1xuICAgICAgICBjYXNlIHZvaWQgMDpcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICBjYXNlIHRydWU6XG4gICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgIGNhc2UgZmFsc2U6XG4gICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdmFyIGIgPSBOYS5sZW5ndGggPyBOYS5wb3AoKSA6IFYubGVuZ3RoO1xuICAgICAgICAgIFZbYl0gPSB7IFA6IDEsIHZhbHVlOiBhIH07XG4gICAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNhKGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmZyb21XaXJlVHlwZShHW2EgPj4gMl0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUYShhKSB7XG4gICAgICBpZiAoYSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgdmFyIGIgPSB0eXBlb2YgYTtcbiAgICAgIHJldHVybiBiID09PSBcIm9iamVjdFwiIHx8IGIgPT09IFwiYXJyYXlcIiB8fCBiID09PSBcImZ1bmN0aW9uXCIgPyBhLnRvU3RyaW5nKCkgOiBcIlwiICsgYTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVWEoYSwgYikge1xuICAgICAgc3dpdGNoIChiKSB7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKHFhW2MgPj4gMl0pO1xuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKHJhW2MgPj4gM10pO1xuICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZmxvYXQgdHlwZTogXCIgKyBhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gVmEoYSkge1xuICAgICAgdmFyIGIgPSBGdW5jdGlvbjtcbiAgICAgIGlmICghKGIgaW5zdGFuY2VvZiBGdW5jdGlvbikpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJuZXdfIGNhbGxlZCB3aXRoIGNvbnN0cnVjdG9yIHR5cGUgXCIgKyB0eXBlb2YgYiArIFwiIHdoaWNoIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgdmFyIGMgPSBJYShiLm5hbWUgfHwgXCJ1bmtub3duRnVuY3Rpb25OYW1lXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgfSk7XG4gICAgICBjLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICAgICAgYyA9IG5ldyBjKCk7XG4gICAgICBhID0gYi5hcHBseShjLCBhKTtcbiAgICAgIHJldHVybiBhIGluc3RhbmNlb2YgT2JqZWN0ID8gYSA6IGM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdhKGEpIHtcbiAgICAgIGZvciAoOyBhLmxlbmd0aDsgKSB7XG4gICAgICAgIHZhciBiID0gYS5wb3AoKTtcbiAgICAgICAgYS5wb3AoKShiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gWGEoYSwgYikge1xuICAgICAgdmFyIGMgPSBmO1xuICAgICAgaWYgKGNbYV0uTCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHZhciBkID0gY1thXTtcbiAgICAgICAgY1thXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNbYV0uTC5oYXNPd25Qcm9wZXJ0eShhcmd1bWVudHMubGVuZ3RoKSB8fCBUKFwiRnVuY3Rpb24gJ1wiICsgYiArIFwiJyBjYWxsZWQgd2l0aCBhbiBpbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMgKFwiICsgYXJndW1lbnRzLmxlbmd0aCArIFwiKSAtIGV4cGVjdHMgb25lIG9mIChcIiArIGNbYV0uTCArIFwiKSFcIik7XG4gICAgICAgICAgcmV0dXJuIGNbYV0uTFthcmd1bWVudHMubGVuZ3RoXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgICBjW2FdLkwgPSBbXTtcbiAgICAgICAgY1thXS5MW2QuU10gPSBkO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBZYShhLCBiLCBjKSB7XG4gICAgICBmLmhhc093blByb3BlcnR5KGEpID8gKChjID09PSB2b2lkIDAgfHwgZlthXS5MICE9PSB2b2lkIDAgJiYgZlthXS5MW2NdICE9PSB2b2lkIDApICYmIFQoXCJDYW5ub3QgcmVnaXN0ZXIgcHVibGljIG5hbWUgJ1wiICsgYSArIFwiJyB0d2ljZVwiKSwgWGEoYSwgYSksIGYuaGFzT3duUHJvcGVydHkoYykgJiYgVChcIkNhbm5vdCByZWdpc3RlciBtdWx0aXBsZSBvdmVybG9hZHMgb2YgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIG51bWJlciBvZiBhcmd1bWVudHMgKFwiICsgYyArIFwiKSFcIiksIGZbYV0uTFtjXSA9IGIpIDogKGZbYV0gPSBiLCBjICE9PSB2b2lkIDAgJiYgKGZbYV0uYmEgPSBjKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFphKGEsIGIpIHtcbiAgICAgIGZvciAodmFyIGMgPSBbXSwgZCA9IDA7IGQgPCBhOyBkKyspXG4gICAgICAgIGMucHVzaChEWyhiID4+IDIpICsgZF0pO1xuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIGZ1bmN0aW9uICRhKGEsIGIpIHtcbiAgICAgIDAgPD0gYS5pbmRleE9mKFwialwiKSB8fCB3KFwiQXNzZXJ0aW9uIGZhaWxlZDogZ2V0RHluQ2FsbGVyIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aXRoIGk2NCBzaWdzXCIpO1xuICAgICAgdmFyIGMgPSBbXTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgYy5sZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGFyZ3VtZW50cy5sZW5ndGg7IGQrKylcbiAgICAgICAgICBjW2RdID0gYXJndW1lbnRzW2RdO1xuICAgICAgICB2YXIgZTtcbiAgICAgICAgYS5pbmRleE9mKFwialwiKSAhPSAtMSA/IGUgPSBjICYmIGMubGVuZ3RoID8gZltcImR5bkNhbGxfXCIgKyBhXS5hcHBseShudWxsLCBbYl0uY29uY2F0KGMpKSA6IGZbXCJkeW5DYWxsX1wiICsgYV0uY2FsbChudWxsLCBiKSA6IGUgPSBJLmdldChiKS5hcHBseShudWxsLCBjKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhYihhLCBiKSB7XG4gICAgICBhID0gUChhKTtcbiAgICAgIHZhciBjID0gYS5pbmRleE9mKFwialwiKSAhPSAtMSA/ICRhKGEsIGIpIDogSS5nZXQoYik7XG4gICAgICB0eXBlb2YgYyAhPT0gXCJmdW5jdGlvblwiICYmIFQoXCJ1bmtub3duIGZ1bmN0aW9uIHBvaW50ZXIgd2l0aCBzaWduYXR1cmUgXCIgKyBhICsgXCI6IFwiICsgYik7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgdmFyIGJiID0gdm9pZCAwO1xuICAgIGZ1bmN0aW9uIGNiKGEpIHtcbiAgICAgIGEgPSBkYihhKTtcbiAgICAgIHZhciBiID0gUChhKTtcbiAgICAgIFcoYSk7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWIoYSwgYikge1xuICAgICAgZnVuY3Rpb24gYyhnKSB7XG4gICAgICAgIGVbZ10gfHwgUltnXSB8fCAoU1tnXSA/IFNbZ10uZm9yRWFjaChjKSA6IChkLnB1c2goZyksIGVbZ10gPSB0cnVlKSk7XG4gICAgICB9XG4gICAgICB2YXIgZCA9IFtdLCBlID0ge307XG4gICAgICBiLmZvckVhY2goYyk7XG4gICAgICB0aHJvdyBuZXcgYmIoYSArIFwiOiBcIiArIGQubWFwKGNiKS5qb2luKFtcIiwgXCJdKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZiKGEsIGIsIGMpIHtcbiAgICAgIHN3aXRjaCAoYikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIGMgPyBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gRltkXTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIHpbZF07XG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBjID8gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIENbZCA+PiAxXTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIEFbZCA+PiAxXTtcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIGMgPyBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gRFtkID4+IDJdO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gR1tkID4+IDJdO1xuICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gaW50ZWdlciB0eXBlOiBcIiArIGEpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZ2IgPSB7fTtcbiAgICBmdW5jdGlvbiBoYigpIHtcbiAgICAgIGlmICghaWIpIHtcbiAgICAgICAgdmFyIGEgPSB7IFVTRVI6IFwid2ViX3VzZXJcIiwgTE9HTkFNRTogXCJ3ZWJfdXNlclwiLCBQQVRIOiBcIi9cIiwgUFdEOiBcIi9cIiwgSE9NRTogXCIvaG9tZS93ZWJfdXNlclwiLCBMQU5HOiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJvYmplY3RcIiAmJiBuYXZpZ2F0b3IubGFuZ3VhZ2VzICYmIG5hdmlnYXRvci5sYW5ndWFnZXNbMF0gfHwgXCJDXCIpLnJlcGxhY2UoXCItXCIsIFwiX1wiKSArIFwiLlVURi04XCIsIF86IGNhIHx8IFwiLi90aGlzLnByb2dyYW1cIiB9LCBiO1xuICAgICAgICBmb3IgKGIgaW4gZ2IpXG4gICAgICAgICAgYVtiXSA9IGdiW2JdO1xuICAgICAgICB2YXIgYyA9IFtdO1xuICAgICAgICBmb3IgKGIgaW4gYSlcbiAgICAgICAgICBjLnB1c2goYiArIFwiPVwiICsgYVtiXSk7XG4gICAgICAgIGliID0gYztcbiAgICAgIH1cbiAgICAgIHJldHVybiBpYjtcbiAgICB9XG4gICAgZm9yICh2YXIgaWIsIGpiID0gW251bGwsIFtdLCBbXV0sIGtiID0gQXJyYXkoMjU2KSwgWCA9IDA7IDI1NiA+IFg7ICsrWClcbiAgICAgIGtiW1hdID0gU3RyaW5nLmZyb21DaGFyQ29kZShYKTtcbiAgICBHYSA9IGtiO1xuICAgIEthID0gZi5CaW5kaW5nRXJyb3IgPSBKYShcIkJpbmRpbmdFcnJvclwiKTtcbiAgICBMYSA9IGYuSW50ZXJuYWxFcnJvciA9IEphKFwiSW50ZXJuYWxFcnJvclwiKTtcbiAgICBmLmNvdW50X2VtdmFsX2hhbmRsZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIGEgPSAwLCBiID0gNTsgYiA8IFYubGVuZ3RoOyArK2IpXG4gICAgICAgIFZbYl0gIT09IHZvaWQgMCAmJiArK2E7XG4gICAgICByZXR1cm4gYTtcbiAgICB9O1xuICAgIGYuZ2V0X2ZpcnN0X2VtdmFsID0gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBhID0gNTsgYSA8IFYubGVuZ3RoOyArK2EpXG4gICAgICAgIGlmIChWW2FdICE9PSB2b2lkIDApXG4gICAgICAgICAgcmV0dXJuIFZbYV07XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIGJiID0gZi5VbmJvdW5kVHlwZUVycm9yID0gSmEoXCJVbmJvdW5kVHlwZUVycm9yXCIpO1xuICAgIHZhLnB1c2goeyBUOiBmdW5jdGlvbigpIHtcbiAgICAgIGxiKCk7XG4gICAgfSB9KTtcbiAgICB2YXIgbWIgPSB7IHA6IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBZKGEgKyAxNikgKyAxNjtcbiAgICB9LCBvOiBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICBuZXcgRWEoYSkuVihiLCBjKTtcbiAgICAgIHRocm93IGE7XG4gICAgfSwgejogZnVuY3Rpb24oYSwgYiwgYywgZCwgZSkge1xuICAgICAgdmFyIGcgPSBGYShjKTtcbiAgICAgIGIgPSBQKGIpO1xuICAgICAgVShhLCB7IG5hbWU6IGIsIGZyb21XaXJlVHlwZTogZnVuY3Rpb24oaykge1xuICAgICAgICByZXR1cm4gISFrO1xuICAgICAgfSwgdG9XaXJlVHlwZTogZnVuY3Rpb24oaywgaCkge1xuICAgICAgICByZXR1cm4gaCA/IGQgOiBlO1xuICAgICAgfSwgYXJnUGFja0FkdmFuY2U6IDgsIHJlYWRWYWx1ZUZyb21Qb2ludGVyOiBmdW5jdGlvbihrKSB7XG4gICAgICAgIGlmIChjID09PSAxKVxuICAgICAgICAgIHZhciBoID0gRjtcbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gMilcbiAgICAgICAgICBoID0gQztcbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gNClcbiAgICAgICAgICBoID0gRDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGJvb2xlYW4gdHlwZSBzaXplOiBcIiArIGIpO1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoaFtrID4+IGddKTtcbiAgICAgIH0sIE06IG51bGwgfSk7XG4gICAgfSwgeTogZnVuY3Rpb24oYSwgYikge1xuICAgICAgYiA9IFAoYik7XG4gICAgICBVKGEsIHsgbmFtZTogYiwgZnJvbVdpcmVUeXBlOiBmdW5jdGlvbihjKSB7XG4gICAgICAgIHZhciBkID0gVltjXS52YWx1ZTtcbiAgICAgICAgUWEoYyk7XG4gICAgICAgIHJldHVybiBkO1xuICAgICAgfSwgdG9XaXJlVHlwZTogZnVuY3Rpb24oYywgZCkge1xuICAgICAgICByZXR1cm4gUmEoZCk7XG4gICAgICB9LCBhcmdQYWNrQWR2YW5jZTogOCwgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IFNhLCBNOiBudWxsIH0pO1xuICAgIH0sIGg6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgIGMgPSBGYShjKTtcbiAgICAgIGIgPSBQKGIpO1xuICAgICAgVShhLCB7IG5hbWU6IGIsIGZyb21XaXJlVHlwZTogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZDtcbiAgICAgIH0sIHRvV2lyZVR5cGU6IGZ1bmN0aW9uKGQsIGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlICE9PSBcIm51bWJlclwiICYmIHR5cGVvZiBlICE9PSBcImJvb2xlYW5cIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBcIicgKyBUYShlKSArICdcIiB0byAnICsgdGhpcy5uYW1lKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9LCBhcmdQYWNrQWR2YW5jZTogOCwgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IFVhKGIsIGMpLCBNOiBudWxsIH0pO1xuICAgIH0sIGU6IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGcpIHtcbiAgICAgIHZhciBrID0gWmEoYiwgYyk7XG4gICAgICBhID0gUChhKTtcbiAgICAgIGUgPSBhYihkLCBlKTtcbiAgICAgIFlhKGEsIGZ1bmN0aW9uKCkge1xuICAgICAgICBlYihcIkNhbm5vdCBjYWxsIFwiICsgYSArIFwiIGR1ZSB0byB1bmJvdW5kIHR5cGVzXCIsIGspO1xuICAgICAgfSwgYiAtIDEpO1xuICAgICAgTWEoaywgZnVuY3Rpb24oaCkge1xuICAgICAgICB2YXIgbCA9IGEsIG4gPSBhO1xuICAgICAgICBoID0gW2hbMF0sIG51bGxdLmNvbmNhdChoLnNsaWNlKDEpKTtcbiAgICAgICAgdmFyIHAgPSBlLCBxID0gaC5sZW5ndGg7XG4gICAgICAgIDIgPiBxICYmIFQoXCJhcmdUeXBlcyBhcnJheSBzaXplIG1pc21hdGNoISBNdXN0IGF0IGxlYXN0IGdldCByZXR1cm4gdmFsdWUgYW5kICd0aGlzJyB0eXBlcyFcIik7XG4gICAgICAgIGZvciAodmFyIHggPSBoWzFdICE9PSBudWxsICYmIGZhbHNlLCBCID0gZmFsc2UsIG0gPSAxOyBtIDwgaC5sZW5ndGg7ICsrbSlcbiAgICAgICAgICBpZiAoaFttXSAhPT0gbnVsbCAmJiBoW21dLk0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgQiA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIHZhciBPYSA9IGhbMF0ubmFtZSAhPT0gXCJ2b2lkXCIsIEggPSBcIlwiLCBNID0gXCJcIjtcbiAgICAgICAgZm9yIChtID0gMDsgbSA8IHEgLSAyOyArK20pXG4gICAgICAgICAgSCArPSAobSAhPT0gMCA/IFwiLCBcIiA6IFwiXCIpICsgXCJhcmdcIiArIG0sIE0gKz0gKG0gIT09IDAgPyBcIiwgXCIgOiBcIlwiKSArIFwiYXJnXCIgKyBtICsgXCJXaXJlZFwiO1xuICAgICAgICBuID0gXCJyZXR1cm4gZnVuY3Rpb24gXCIgKyBIYShuKSArIFwiKFwiICsgSCArIFwiKSB7XFxuaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IFwiICsgKHEgLSAyKSArIFwiKSB7XFxudGhyb3dCaW5kaW5nRXJyb3IoJ2Z1bmN0aW9uIFwiICsgbiArIFwiIGNhbGxlZCB3aXRoICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBhcmd1bWVudHMsIGV4cGVjdGVkIFwiICsgKHEgLSAyKSArIFwiIGFyZ3MhJyk7XFxufVxcblwiO1xuICAgICAgICBCICYmIChuICs9IFwidmFyIGRlc3RydWN0b3JzID0gW107XFxuXCIpO1xuICAgICAgICB2YXIgUGEgPSBCID8gXCJkZXN0cnVjdG9yc1wiIDogXCJudWxsXCI7XG4gICAgICAgIEggPSBcInRocm93QmluZGluZ0Vycm9yIGludm9rZXIgZm4gcnVuRGVzdHJ1Y3RvcnMgcmV0VHlwZSBjbGFzc1BhcmFtXCIuc3BsaXQoXCIgXCIpO1xuICAgICAgICBwID0gW1QsIHAsIGcsIFdhLCBoWzBdLCBoWzFdXTtcbiAgICAgICAgeCAmJiAobiArPSBcInZhciB0aGlzV2lyZWQgPSBjbGFzc1BhcmFtLnRvV2lyZVR5cGUoXCIgKyBQYSArIFwiLCB0aGlzKTtcXG5cIik7XG4gICAgICAgIGZvciAobSA9IDA7IG0gPCBxIC0gMjsgKyttKVxuICAgICAgICAgIG4gKz0gXCJ2YXIgYXJnXCIgKyBtICsgXCJXaXJlZCA9IGFyZ1R5cGVcIiArIG0gKyBcIi50b1dpcmVUeXBlKFwiICsgUGEgKyBcIiwgYXJnXCIgKyBtICsgXCIpOyAvLyBcIiArIGhbbSArIDJdLm5hbWUgKyBcIlxcblwiLCBILnB1c2goXCJhcmdUeXBlXCIgKyBtKSwgcC5wdXNoKGhbbSArIDJdKTtcbiAgICAgICAgeCAmJiAoTSA9IFwidGhpc1dpcmVkXCIgKyAoMCA8IE0ubGVuZ3RoID8gXCIsIFwiIDogXCJcIikgKyBNKTtcbiAgICAgICAgbiArPSAoT2EgPyBcInZhciBydiA9IFwiIDogXCJcIikgKyBcImludm9rZXIoZm5cIiArICgwIDwgTS5sZW5ndGggPyBcIiwgXCIgOiBcIlwiKSArIE0gKyBcIik7XFxuXCI7XG4gICAgICAgIGlmIChCKVxuICAgICAgICAgIG4gKz0gXCJydW5EZXN0cnVjdG9ycyhkZXN0cnVjdG9ycyk7XFxuXCI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKG0gPSB4ID8gMSA6IDI7IG0gPCBoLmxlbmd0aDsgKyttKVxuICAgICAgICAgICAgcSA9IG0gPT09IDEgPyBcInRoaXNXaXJlZFwiIDogXCJhcmdcIiArIChtIC0gMikgKyBcIldpcmVkXCIsIGhbbV0uTSAhPT0gbnVsbCAmJiAobiArPSBxICsgXCJfZHRvcihcIiArIHEgKyBcIik7IC8vIFwiICsgaFttXS5uYW1lICsgXCJcXG5cIiwgSC5wdXNoKHEgKyBcIl9kdG9yXCIpLCBwLnB1c2goaFttXS5NKSk7XG4gICAgICAgIE9hICYmIChuICs9IFwidmFyIHJldCA9IHJldFR5cGUuZnJvbVdpcmVUeXBlKHJ2KTtcXG5yZXR1cm4gcmV0O1xcblwiKTtcbiAgICAgICAgSC5wdXNoKG4gKyBcIn1cXG5cIik7XG4gICAgICAgIGggPSBWYShIKS5hcHBseShudWxsLCBwKTtcbiAgICAgICAgbSA9IGIgLSAxO1xuICAgICAgICBpZiAoIWYuaGFzT3duUHJvcGVydHkobCkpXG4gICAgICAgICAgdGhyb3cgbmV3IExhKFwiUmVwbGFjaW5nIG5vbmV4aXN0YW50IHB1YmxpYyBzeW1ib2xcIik7XG4gICAgICAgIGZbbF0uTCAhPT0gdm9pZCAwICYmIG0gIT09IHZvaWQgMCA/IGZbbF0uTFttXSA9IGggOiAoZltsXSA9IGgsIGZbbF0uUyA9IG0pO1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9KTtcbiAgICB9LCBjOiBmdW5jdGlvbihhLCBiLCBjLCBkLCBlKSB7XG4gICAgICBmdW5jdGlvbiBnKG4pIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9XG4gICAgICBiID0gUChiKTtcbiAgICAgIGUgPT09IC0xICYmIChlID0gNDI5NDk2NzI5NSk7XG4gICAgICB2YXIgayA9IEZhKGMpO1xuICAgICAgaWYgKGQgPT09IDApIHtcbiAgICAgICAgdmFyIGggPSAzMiAtIDggKiBjO1xuICAgICAgICBnID0gZnVuY3Rpb24obikge1xuICAgICAgICAgIHJldHVybiBuIDw8IGggPj4+IGg7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgbCA9IGIuaW5kZXhPZihcInVuc2lnbmVkXCIpICE9IC0xO1xuICAgICAgVShhLCB7IG5hbWU6IGIsIGZyb21XaXJlVHlwZTogZywgdG9XaXJlVHlwZTogZnVuY3Rpb24obiwgcCkge1xuICAgICAgICBpZiAodHlwZW9mIHAgIT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHAgIT09IFwiYm9vbGVhblwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IFwiJyArIFRhKHApICsgJ1wiIHRvICcgKyB0aGlzLm5hbWUpO1xuICAgICAgICBpZiAocCA8IGQgfHwgcCA+IGUpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGFzc2luZyBhIG51bWJlciBcIicgKyBUYShwKSArICdcIiBmcm9tIEpTIHNpZGUgdG8gQy9DKysgc2lkZSB0byBhbiBhcmd1bWVudCBvZiB0eXBlIFwiJyArIGIgKyAnXCIsIHdoaWNoIGlzIG91dHNpZGUgdGhlIHZhbGlkIHJhbmdlIFsnICsgZCArIFwiLCBcIiArIGUgKyBcIl0hXCIpO1xuICAgICAgICByZXR1cm4gbCA/IHAgPj4+IDAgOiBwIHwgMDtcbiAgICAgIH0sIGFyZ1BhY2tBZHZhbmNlOiA4LCByZWFkVmFsdWVGcm9tUG9pbnRlcjogZmIoYiwgaywgZCAhPT0gMCksIE06IG51bGwgfSk7XG4gICAgfSwgYjogZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgZnVuY3Rpb24gZChnKSB7XG4gICAgICAgIGcgPj49IDI7XG4gICAgICAgIHZhciBrID0gRztcbiAgICAgICAgcmV0dXJuIG5ldyBlKEUsIGtbZyArIDFdLCBrW2ddKTtcbiAgICAgIH1cbiAgICAgIHZhciBlID0gW0ludDhBcnJheSwgVWludDhBcnJheSwgSW50MTZBcnJheSwgVWludDE2QXJyYXksIEludDMyQXJyYXksIFVpbnQzMkFycmF5LCBGbG9hdDMyQXJyYXksIEZsb2F0NjRBcnJheV1bYl07XG4gICAgICBjID0gUChjKTtcbiAgICAgIFUoYSwgeyBuYW1lOiBjLCBmcm9tV2lyZVR5cGU6IGQsIGFyZ1BhY2tBZHZhbmNlOiA4LCByZWFkVmFsdWVGcm9tUG9pbnRlcjogZCB9LCB7IFU6IHRydWUgfSk7XG4gICAgfSwgaTogZnVuY3Rpb24oYSwgYikge1xuICAgICAgYiA9IFAoYik7XG4gICAgICB2YXIgYyA9IGIgPT09IFwic3RkOjpzdHJpbmdcIjtcbiAgICAgIFUoYSwgeyBuYW1lOiBiLCBmcm9tV2lyZVR5cGU6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdmFyIGUgPSBHW2QgPj4gMl07XG4gICAgICAgIGlmIChjKVxuICAgICAgICAgIGZvciAodmFyIGcgPSBkICsgNCwgayA9IDA7IGsgPD0gZTsgKytrKSB7XG4gICAgICAgICAgICB2YXIgaCA9IGQgKyA0ICsgaztcbiAgICAgICAgICAgIGlmIChrID09IGUgfHwgeltoXSA9PSAwKSB7XG4gICAgICAgICAgICAgIGcgPSBnID8gaGEoeiwgZywgaCAtIGcpIDogXCJcIjtcbiAgICAgICAgICAgICAgaWYgKGwgPT09IHZvaWQgMClcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGc7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBsICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMCksIGwgKz0gZztcbiAgICAgICAgICAgICAgZyA9IGggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbCA9IEFycmF5KGUpO1xuICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBlOyArK2spXG4gICAgICAgICAgICBsW2tdID0gU3RyaW5nLmZyb21DaGFyQ29kZSh6W2QgKyA0ICsga10pO1xuICAgICAgICAgIGwgPSBsLmpvaW4oXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgVyhkKTtcbiAgICAgICAgcmV0dXJuIGw7XG4gICAgICB9LCB0b1dpcmVUeXBlOiBmdW5jdGlvbihkLCBlKSB7XG4gICAgICAgIGUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciAmJiAoZSA9IG5ldyBVaW50OEFycmF5KGUpKTtcbiAgICAgICAgdmFyIGcgPSB0eXBlb2YgZSA9PT0gXCJzdHJpbmdcIjtcbiAgICAgICAgZyB8fCBlIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBlIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkgfHwgZSBpbnN0YW5jZW9mIEludDhBcnJheSB8fCBUKFwiQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBzdGQ6OnN0cmluZ1wiKTtcbiAgICAgICAgdmFyIGsgPSAoYyAmJiBnID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICh2YXIgbiA9IDAsIHAgPSAwOyBwIDwgZS5sZW5ndGg7ICsrcCkge1xuICAgICAgICAgICAgdmFyIHEgPSBlLmNoYXJDb2RlQXQocCk7XG4gICAgICAgICAgICA1NTI5NiA8PSBxICYmIDU3MzQzID49IHEgJiYgKHEgPSA2NTUzNiArICgocSAmIDEwMjMpIDw8IDEwKSB8IGUuY2hhckNvZGVBdCgrK3ApICYgMTAyMyk7XG4gICAgICAgICAgICAxMjcgPj0gcSA/ICsrbiA6IG4gPSAyMDQ3ID49IHEgPyBuICsgMiA6IDY1NTM1ID49IHEgPyBuICsgMyA6IG4gKyA0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBlLmxlbmd0aDtcbiAgICAgICAgfSkoKSwgaCA9IFkoNCArIGsgKyAxKTtcbiAgICAgICAgR1toID4+IDJdID0gaztcbiAgICAgICAgaWYgKGMgJiYgZylcbiAgICAgICAgICBpYShlLCBoICsgNCwgayArIDEpO1xuICAgICAgICBlbHNlIGlmIChnKVxuICAgICAgICAgIGZvciAoZyA9IDA7IGcgPCBrOyArK2cpIHtcbiAgICAgICAgICAgIHZhciBsID0gZS5jaGFyQ29kZUF0KGcpO1xuICAgICAgICAgICAgMjU1IDwgbCAmJiAoVyhoKSwgVChcIlN0cmluZyBoYXMgVVRGLTE2IGNvZGUgdW5pdHMgdGhhdCBkbyBub3QgZml0IGluIDggYml0c1wiKSk7XG4gICAgICAgICAgICB6W2ggKyA0ICsgZ10gPSBsO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIGZvciAoZyA9IDA7IGcgPCBrOyArK2cpXG4gICAgICAgICAgICB6W2ggKyA0ICsgZ10gPSBlW2ddO1xuICAgICAgICBkICE9PSBudWxsICYmIGQucHVzaChXLCBoKTtcbiAgICAgICAgcmV0dXJuIGg7XG4gICAgICB9LCBhcmdQYWNrQWR2YW5jZTogOCwgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IFNhLCBNOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIFcoZCk7XG4gICAgICB9IH0pO1xuICAgIH0sIGQ6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgIGMgPSBQKGMpO1xuICAgICAgaWYgKGIgPT09IDIpIHtcbiAgICAgICAgdmFyIGQgPSBrYTtcbiAgICAgICAgdmFyIGUgPSBsYTtcbiAgICAgICAgdmFyIGcgPSBtYTtcbiAgICAgICAgdmFyIGsgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gQTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGggPSAxO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGIgPT09IDQgJiYgKGQgPSBuYSwgZSA9IG9hLCBnID0gcGEsIGsgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gRztcbiAgICAgICAgfSwgaCA9IDIpO1xuICAgICAgVShhLCB7IG5hbWU6IGMsIGZyb21XaXJlVHlwZTogZnVuY3Rpb24obCkge1xuICAgICAgICBmb3IgKHZhciBuID0gR1tsID4+IDJdLCBwID0gaygpLCBxLCB4ID0gbCArIDQsIEIgPSAwOyBCIDw9IG47ICsrQikge1xuICAgICAgICAgIHZhciBtID0gbCArIDQgKyBCICogYjtcbiAgICAgICAgICBpZiAoQiA9PSBuIHx8IHBbbSA+PiBoXSA9PSAwKVxuICAgICAgICAgICAgeCA9IGQoeCwgbSAtIHgpLCBxID09PSB2b2lkIDAgPyBxID0geCA6IChxICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMCksIHEgKz0geCksIHggPSBtICsgYjtcbiAgICAgICAgfVxuICAgICAgICBXKGwpO1xuICAgICAgICByZXR1cm4gcTtcbiAgICAgIH0sIHRvV2lyZVR5cGU6IGZ1bmN0aW9uKGwsIG4pIHtcbiAgICAgICAgdHlwZW9mIG4gIT09IFwic3RyaW5nXCIgJiYgVChcIkNhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gQysrIHN0cmluZyB0eXBlIFwiICsgYyk7XG4gICAgICAgIHZhciBwID0gZyhuKSwgcSA9IFkoNCArIHAgKyBiKTtcbiAgICAgICAgR1txID4+IDJdID0gcCA+PiBoO1xuICAgICAgICBlKG4sIHEgKyA0LCBwICsgYik7XG4gICAgICAgIGwgIT09IG51bGwgJiYgbC5wdXNoKFcsIHEpO1xuICAgICAgICByZXR1cm4gcTtcbiAgICAgIH0sIGFyZ1BhY2tBZHZhbmNlOiA4LCByZWFkVmFsdWVGcm9tUG9pbnRlcjogU2EsIE06IGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgVyhsKTtcbiAgICAgIH0gfSk7XG4gICAgfSwgQTogZnVuY3Rpb24oYSwgYikge1xuICAgICAgYiA9IFAoYik7XG4gICAgICBVKGEsIHtcbiAgICAgICAgYWE6IHRydWUsXG4gICAgICAgIG5hbWU6IGIsXG4gICAgICAgIGFyZ1BhY2tBZHZhbmNlOiAwLFxuICAgICAgICBmcm9tV2lyZVR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB9LFxuICAgICAgICB0b1dpcmVUeXBlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgbjogUWEsIHg6IGZ1bmN0aW9uKGEpIHtcbiAgICAgIDQgPCBhICYmIChWW2FdLlAgKz0gMSk7XG4gICAgfSwgQzogZnVuY3Rpb24oYSwgYikge1xuICAgICAgdmFyIGMgPSBSW2FdO1xuICAgICAgYyA9PT0gdm9pZCAwICYmIFQoXCJfZW12YWxfdGFrZV92YWx1ZSBoYXMgdW5rbm93biB0eXBlIFwiICsgY2IoYSkpO1xuICAgICAgYSA9IGMucmVhZFZhbHVlRnJvbVBvaW50ZXIoYik7XG4gICAgICByZXR1cm4gUmEoYSk7XG4gICAgfSwgdDogZnVuY3Rpb24oKSB7XG4gICAgICB3KCk7XG4gICAgfSwgcjogZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgei5jb3B5V2l0aGluKGEsIGIsIGIgKyBjKTtcbiAgICB9LCBzOiBmdW5jdGlvbihhKSB7XG4gICAgICBhID4+Pj0gMDtcbiAgICAgIHZhciBiID0gei5sZW5ndGg7XG4gICAgICBpZiAoMjE0NzQ4MzY0OCA8IGEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAodmFyIGMgPSAxOyA0ID49IGM7IGMgKj0gMikge1xuICAgICAgICB2YXIgZCA9IGIgKiAoMSArIDAuMiAvIGMpO1xuICAgICAgICBkID0gTWF0aC5taW4oZCwgYSArIDEwMDY2MzI5Nik7XG4gICAgICAgIGQgPSBNYXRoLm1heCgxNjc3NzIxNiwgYSwgZCk7XG4gICAgICAgIDAgPCBkICUgNjU1MzYgJiYgKGQgKz0gNjU1MzYgLSBkICUgNjU1MzYpO1xuICAgICAgICBhOiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHkuZ3JvdyhNYXRoLm1pbigyMTQ3NDgzNjQ4LCBkKSAtIEUuYnl0ZUxlbmd0aCArIDY1NTM1ID4+PiAxNik7XG4gICAgICAgICAgICBzYSh5LmJ1ZmZlcik7XG4gICAgICAgICAgICB2YXIgZSA9IDE7XG4gICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgIH0gY2F0Y2ggKGcpIHtcbiAgICAgICAgICB9XG4gICAgICAgICAgZSA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCB1OiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICB2YXIgYyA9IDA7XG4gICAgICBoYigpLmZvckVhY2goZnVuY3Rpb24oZCwgZSkge1xuICAgICAgICB2YXIgZyA9IGIgKyBjO1xuICAgICAgICBlID0gRFthICsgNCAqIGUgPj4gMl0gPSBnO1xuICAgICAgICBmb3IgKGcgPSAwOyBnIDwgZC5sZW5ndGg7ICsrZylcbiAgICAgICAgICBGW2UrKyA+PiAwXSA9IGQuY2hhckNvZGVBdChnKTtcbiAgICAgICAgRltlID4+IDBdID0gMDtcbiAgICAgICAgYyArPSBkLmxlbmd0aCArIDE7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sIHY6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHZhciBjID0gaGIoKTtcbiAgICAgIERbYSA+PiAyXSA9IGMubGVuZ3RoO1xuICAgICAgdmFyIGQgPSAwO1xuICAgICAgYy5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZCArPSBlLmxlbmd0aCArIDE7XG4gICAgICB9KTtcbiAgICAgIERbYiA+PiAyXSA9IGQ7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LCB3OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sIHE6IGZ1bmN0aW9uKCkge1xuICAgIH0sIGc6IGZ1bmN0aW9uKGEsIGIsIGMsIGQpIHtcbiAgICAgIGZvciAodmFyIGUgPSAwLCBnID0gMDsgZyA8IGM7IGcrKykge1xuICAgICAgICBmb3IgKHZhciBrID0gRFtiICsgOCAqIGcgPj4gMl0sIGggPSBEW2IgKyAoOCAqIGcgKyA0KSA+PiAyXSwgbCA9IDA7IGwgPCBoOyBsKyspIHtcbiAgICAgICAgICB2YXIgbiA9IHpbayArIGxdLCBwID0gamJbYV07XG4gICAgICAgICAgbiA9PT0gMCB8fCBuID09PSAxMCA/ICgoYSA9PT0gMSA/IGRhIDogdSkoaGEocCwgMCkpLCBwLmxlbmd0aCA9IDApIDogcC5wdXNoKG4pO1xuICAgICAgICB9XG4gICAgICAgIGUgKz0gaDtcbiAgICAgIH1cbiAgICAgIERbZCA+PiAyXSA9IGU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LCBhOiB5LCBsOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sIGs6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSwgajogZnVuY3Rpb24oKSB7XG4gICAgfSwgQjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gNjtcbiAgICB9LCBtOiBmdW5jdGlvbigpIHtcbiAgICB9LCBmOiBmdW5jdGlvbigpIHtcbiAgICB9IH07XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gYShlKSB7XG4gICAgICAgIGYuYXNtID0gZS5leHBvcnRzO1xuICAgICAgICBJID0gZi5hc20uRDtcbiAgICAgICAgSi0tO1xuICAgICAgICBmLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMgJiYgZi5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKEopO1xuICAgICAgICBKID09IDAgJiYgKEsgJiYgKGUgPSBLLCBLID0gbnVsbCwgZSgpKSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBiKGUpIHtcbiAgICAgICAgYShlLmluc3RhbmNlKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGMoZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihEYSkudGhlbihmdW5jdGlvbihnKSB7XG4gICAgICAgICAgcmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGcsIGQpO1xuICAgICAgICB9KS50aGVuKGUsIGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgICB1KFwiZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogXCIgKyBnKTtcbiAgICAgICAgICB3KGcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBkID0geyBhOiBtYiB9O1xuICAgICAgSisrO1xuICAgICAgZi5tb25pdG9yUnVuRGVwZW5kZW5jaWVzICYmIGYubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhKKTtcbiAgICAgIGlmIChmLmluc3RhbnRpYXRlV2FzbSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZi5pbnN0YW50aWF0ZVdhc20oZCwgYSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gdShcIk1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6IFwiICsgZSksIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2IHx8IHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyAhPT0gXCJmdW5jdGlvblwiIHx8IEJhKCkgfHwgQWEoXCJmaWxlOi8vXCIpIHx8IHR5cGVvZiBmZXRjaCAhPT0gXCJmdW5jdGlvblwiID8gYyhiKSA6IGZldGNoKEwsIHsgY3JlZGVudGlhbHM6IFwic2FtZS1vcmlnaW5cIiB9KS50aGVuKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICByZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoZSwgZCkudGhlbihiLCBmdW5jdGlvbihnKSB7XG4gICAgICAgICAgICB1KFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiICsgZyk7XG4gICAgICAgICAgICB1KFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIik7XG4gICAgICAgICAgICByZXR1cm4gYyhiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KSgpLmNhdGNoKGJhKTtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9KSgpO1xuICAgIHZhciBsYiA9IGYuX19fd2FzbV9jYWxsX2N0b3JzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKGxiID0gZi5fX193YXNtX2NhbGxfY3RvcnMgPSBmLmFzbS5FKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0sIFkgPSBmLl9tYWxsb2MgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoWSA9IGYuX21hbGxvYyA9IGYuYXNtLkYpLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSwgVyA9IGYuX2ZyZWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoVyA9IGYuX2ZyZWUgPSBmLmFzbS5HKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0sIGRiID0gZi5fX19nZXRUeXBlTmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChkYiA9IGYuX19fZ2V0VHlwZU5hbWUgPSBmLmFzbS5IKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgZi5fX19lbWJpbmRfcmVnaXN0ZXJfbmF0aXZlX2FuZF9idWlsdGluX3R5cGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKGYuX19fZW1iaW5kX3JlZ2lzdGVyX25hdGl2ZV9hbmRfYnVpbHRpbl90eXBlcyA9IGYuYXNtLkkpLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBmLmR5bkNhbGxfamlpaWlpID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKGYuZHluQ2FsbF9qaWlpaWkgPSBmLmFzbS5KKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgZi5keW5DYWxsX2ppamkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoZi5keW5DYWxsX2ppamkgPSBmLmFzbS5LKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgdmFyIFo7XG4gICAgSyA9IGZ1bmN0aW9uIG5iKCkge1xuICAgICAgWiB8fCBvYigpO1xuICAgICAgWiB8fCAoSyA9IG5iKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG9iKCkge1xuICAgICAgZnVuY3Rpb24gYSgpIHtcbiAgICAgICAgaWYgKCFaICYmIChaID0gdHJ1ZSwgZi5jYWxsZWRSdW4gPSB0cnVlLCAhZWEpKSB7XG4gICAgICAgICAgTih2YSk7XG4gICAgICAgICAgTih3YSk7XG4gICAgICAgICAgYWEoZik7XG4gICAgICAgICAgaWYgKGYub25SdW50aW1lSW5pdGlhbGl6ZWQpXG4gICAgICAgICAgICBmLm9uUnVudGltZUluaXRpYWxpemVkKCk7XG4gICAgICAgICAgaWYgKGYucG9zdFJ1bilcbiAgICAgICAgICAgIGZvciAodHlwZW9mIGYucG9zdFJ1biA9PSBcImZ1bmN0aW9uXCIgJiYgKGYucG9zdFJ1biA9IFtmLnBvc3RSdW5dKTsgZi5wb3N0UnVuLmxlbmd0aDsgKSB7XG4gICAgICAgICAgICAgIHZhciBiID0gZi5wb3N0UnVuLnNoaWZ0KCk7XG4gICAgICAgICAgICAgIHhhLnVuc2hpZnQoYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgTih4YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghKDAgPCBKKSkge1xuICAgICAgICBpZiAoZi5wcmVSdW4pXG4gICAgICAgICAgZm9yICh0eXBlb2YgZi5wcmVSdW4gPT0gXCJmdW5jdGlvblwiICYmIChmLnByZVJ1biA9IFtmLnByZVJ1bl0pOyBmLnByZVJ1bi5sZW5ndGg7IClcbiAgICAgICAgICAgIHlhKCk7XG4gICAgICAgIE4odWEpO1xuICAgICAgICAwIDwgSiB8fCAoZi5zZXRTdGF0dXMgPyAoZi5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLCBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmLnNldFN0YXR1cyhcIlwiKTtcbiAgICAgICAgICB9LCAxKTtcbiAgICAgICAgICBhKCk7XG4gICAgICAgIH0sIDEpKSA6IGEoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGYucnVuID0gb2I7XG4gICAgaWYgKGYucHJlSW5pdClcbiAgICAgIGZvciAodHlwZW9mIGYucHJlSW5pdCA9PSBcImZ1bmN0aW9uXCIgJiYgKGYucHJlSW5pdCA9IFtmLnByZUluaXRdKTsgMCA8IGYucHJlSW5pdC5sZW5ndGg7IClcbiAgICAgICAgZi5wcmVJbml0LnBvcCgpKCk7XG4gICAgb2IoKTtcbiAgICByZXR1cm4gYmxvc2NfY29kZWMyLnJlYWR5O1xuICB9O1xufSgpO1xuXG52YXIgX19pc05vZGUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAhPSBudWxsICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZSAhPSBudWxsO1xudmFyIF9fdG9CaW5hcnkgPSBfX2lzTm9kZVxuICA/IGJhc2U2NCA9PiBuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbShiYXNlNjQsICdiYXNlNjQnKSlcbiAgOiAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgICB2YXIgdGFibGUgPSBuZXcgVWludDhBcnJheSgxMjgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7IGkrKykgdGFibGVbaSA8IDI2ID8gaSArIDY1IDogaSA8IDUyID8gaSArIDcxIDogaSA8IDYyID8gaSAtIDQgOiBpICogNCAtIDIwNV0gPSBpO1xuICAgIHJldHVybiBiYXNlNjQgPT4ge1xuICAgICAgdmFyIG4gPSBiYXNlNjQubGVuZ3RoLCBieXRlcyA9IG5ldyBVaW50OEFycmF5KChuIC0gKGJhc2U2NFtuIC0gMV0gPT0gJz0nKSAtIChiYXNlNjRbbiAtIDJdID09ICc9JykpICogMyAvIDQgfCAwKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IG47KSB7XG4gICAgICAgIHZhciBjMCA9IHRhYmxlW2Jhc2U2NC5jaGFyQ29kZUF0KGkrKyldLCBjMSA9IHRhYmxlW2Jhc2U2NC5jaGFyQ29kZUF0KGkrKyldO1xuICAgICAgICB2YXIgYzIgPSB0YWJsZVtiYXNlNjQuY2hhckNvZGVBdChpKyspXSwgYzMgPSB0YWJsZVtiYXNlNjQuY2hhckNvZGVBdChpKyspXTtcbiAgICAgICAgYnl0ZXNbaisrXSA9IChjMCA8PCAyKSB8IChjMSA+PiA0KTtcbiAgICAgICAgYnl0ZXNbaisrXSA9IChjMSA8PCA0KSB8IChjMiA+PiAyKTtcbiAgICAgICAgYnl0ZXNbaisrXSA9IChjMiA8PCA2KSB8IGMzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ5dGVzXG4gICAgfVxuICB9KSgpO1xudmFyIHdhc21CaW5hcnkgPSBfX3RvQmluYXJ5KFwiQUdGemJRRUFBQUFCd0FJbVlBRi9BWDlnQTM5L2Z3Ri9ZQVYvZjM5L2Z3Ri9ZQUovZndGL1lBSi9md0JnQVg4QVlBTi9mMzhBWUFSL2YzOS9BWDlnQkg5L2YzOEFZQUFBWUFaL2YzOS9mMzhCZjJBRmYzOS9mMzhBWUFaL2YzOS9mMzhBWUFkL2YzOS9mMzkvQVg5Z0JIOS9mMzhCZm1BRmYzOS9mMzhCZm1BSWYzOS9mMzkvZjM4QmYyQUpmMzkvZjM5L2YzOS9BWDlnQW41L0FYOWdDMzkvZjM5L2YzOS9mMzkvQVg5Z0EzOStmd0YrWUFOL2YzNEFZQU4vZjM0QmYyQURmbjkvQVg5Z0FuNStBWDVnQ0g5L2YzOS9mMzkvQUdBSmYzOS9mMzkvZjM5L0FHQUZmMzUvZjM4QVlBQUJmMkFOZjM5L2YzOS9mMzkvZjM5L2Z3Ri9ZQTkvZjM5L2YzOS9mMzkvZjM5L2YzOEJmMkFGZjM5L2ZuOEJmMkFHZjN4L2YzOS9BWDlnQVg4QmZtQUNmMzhCZm1BSGYzNS9mMzkvZndGK1lBRitBWDVnQkg1L2YzNEJmZ0swQVIwQllRRmlBQVlCWVFGakFBc0JZUUZrQUFZQllRRmxBQXdCWVFGbUFBVUJZUUZuQUFjQllRRm9BQVlCWVFGcEFBUUJZUUZxQUFNQllRRnJBQUFCWVFGc0FBQUJZUUZ0QUFNQllRRnVBQVVCWVFGdkFBWUJZUUZ3QUFBQllRRnhBQUlCWVFGeUFBRUJZUUZ6QUFBQllRRjBBQWtCWVFGMUFBTUJZUUYyQUFNQllRRjNBQUFCWVFGNEFBVUJZUUY1QUFRQllRRjZBQXNCWVFGQkFBUUJZUUZDQUFjQllRRkRBQU1CWVFGaEFnR0FBb0NBQWdPdEJLc0VCQUVCQXdJQUNBQUFBQVFIQVFFQkFBSUJBQVFEQVFNQkJBRUZBd1VGQUFZQUF3QUlBZ0lEQVFnQkF3WUJDd0VCQUFRWUJBRUVCd29HQXdNTEJ3Z0JCZ2dEQ3dVREF3TUdDQUVHQkFZQUJ3SUdBQUFCQUFJRUJBWUVCUU1EQUFzQUJnd0RBQUFOQmdJWUF3a0FBUXdHQmdnQUFnQUFBQVVRSFFBRUFRTWJCd2NIQndNREJoNFRCQWdCQWdFQ0NnY0dDZ1lFQUFRQUFSQVJBd0FJQUFZREJnQUZCUVVGQlFVSkN3VUdBUUFGQlFJQ0FnY0hBd1FFQUFjU0FSSVhKUVFHQXdNREFBVUVBUUFCQlFVREFBTUdDZ0FGQlFNQkh3VURBd1VGQVJFREJ3b0VBQVVCQXdjS0NpRUdCUUVBQmdZR0JRVUlBeE1OQUFBREFBa0JCd2NIQndjSEJ3Y0FBUWdHQndNUkFnSUNBZ1lDQ0FvQ0FnY0NDQUFGQkFVRkFBTUFBQUlLQkJRQUNRd01Dd01MQ0FnSUN3d0FBUUVGQUFVQUJRa0RBQU1TRWhjR0FRQVVBQUFKQ1FrSkJnQUpDUWtKQ1FrSkNRa0pDUWtKRFEwQUJnY0JBUWNIQWdFQkFnRUVBd29BQkFjRkJSd0tDZ29GQWdvQ0FnTWFHUVVFQWdJQ0Fna0ZDd0lDQVFvUUFnZ01JaU1DQmdZQkRBSUNBZ0lDQWdJQ0FnTUNBZzBNQWdvQ0FnSUVDZ0lDQWdRVEFRRUhBUWNCQ0FVR0NnVUZCQVlrQndVQUFBZ1dGZ1lSQUEwQ0Fnc0RFQVVCQWdZSEN3SUJBZ0lBQlJVVkF3VUFCZ0lCQ1FFR0FnSUhCd2NGQUFvRUFnSUhBUUFBQUFBQUJBTUdDQWdJQUFBRkJnUUFBQUVEQXdFREJRVUFCQUVEQVFRQUJBTU5EUVFFQ2dvRkFnNFBEZzhPRGc0SUNBZ0JDQUVCQVFFSEJBVUJjQUZXVmdZSkFYOEJRYUQ5d1FJTEJ5WUlBVVFCQUFGRkFKWUNBVVlBVEFGSEFEZ0JTQURoQWdGSkFNTUJBVW9BdmdJQlN3QzlBZ21sQVFFQVFRRUxWWDlmNXdLNkFyWUNmMStyQXFFQ3VBUFZBNk1EcmdPUEE1MERqUUcwQXA4Q25nS2RBcHdDbXdLM0JMa0V2Z1RCQktjRXBnU2lCS0FFbndUQkE4WUR0d081QTdvRHZRT2xBNkVEb0FPL0E4UURzZ094QTdBRHJ3T2FBNWtEd0FQRkE3TUR0QU8xQTdZRG5BT2JBOWNDM1FMZkFuOWYwd0xTQXRFQzBBSi9YL1VCOVFIT0Fzd0N5d0xLQWwvUEFsL0RBc1VDeVFKZnhBTEhBc2dDd1FMQUFncXlyUkdyQkJZQUlBQWdBU2tBQURjQUFDQUFJQUVwQUFnM0FBZ0xyZ0VCQTM4Q1FDQUNRWDFxSWdRZ0FFMEVRQ0FBSVFNTUFRc2dBU2dBQUNBQUtBQUFjeUlEUlFSQUlBQWhBd05BSUFGQkJHb2hBU0FEUVFScUlnTWdCRThOQWlBQktBQUFJQU1vQUFCeklnVkZEUUFMSUFVUUpTQURhaUFBYXc4TElBTVFKUThMQWtBZ0F5QUNRWDlxVHcwQUlBRXZBQUFnQXk4QUFFY05BQ0FCUVFKcUlRRWdBMEVDYWlFREN5QURJQUpKQkg4Z0EwRUJhaUFESUFFdEFBQWdBeTBBQUVZYkJTQURDeUFBYXd0b0FBSkFBa0FDUUFKQUFrQWdBa0Y3YWc0RUFRSURCQUFMSUFBZ0FSRGVBUThMSUFBZ0FSRGRBUThMSUFBZ0FSRGNBUThMSUFBcEFBQkNnTWFWL2N1Yjc0MVBma0hBQUNBQmE2MklwdzhMSUFBcEFBQkM0OGlWdmN1Yjc0MVBma0hBQUNBQmE2Mklwd3NVQUNBQUtBQUFJZ0JCQ0hRZ0FDQUJRUU5HR3dzNEFRRi9JQU1nQVNBQUlBRWdBQ0FESUFGcmFpSUZJQUlnQlNBQ1NSc1FIU0lGYWtZRWZ5QUFJQVZxSUFRZ0FoQWRJQVZxQlNBRkN3c0lBQ0FBUVloL1N3dVRBUUVDZnlBQklBTk5CRUFnQUNBQkVCd2dBRUVRYWlBQlFSQnFFQndnQUNBRElBRnJJZ1JxSVFVZ0JFRWhUZ1JBSUFCQklHb2hBQU5BSUFBZ0FVRWdhaUlFRUJ3Z0FFRVFhaUFCUVRCcUVCd2dCQ0VCSUFCQklHb2lBQ0FGU1EwQUN3c2dBeUVCSUFVaEFBc2dBU0FDU1FSQUEwQWdBQ0FCTFFBQU9nQUFJQUJCQVdvaEFDQUJRUUZxSWdFZ0FrY05BQXNMQzVnQkFRUi9RUU1oQVFKQUlBQW9BZ1FpQWtFZ1RRUkFJQUFDZnlBQUtBSUlJZ0VnQUNnQ0VFOEVRQ0FBSUFFZ0FrRURkbXNpQXpZQ0NFRUFJUUVnQWtFSGNRd0JDeUFCSUFBb0Fnd2lBMFlOQWlBQUlBRWdBU0FEYXlBQ1FRTjJJZ1FnQVNBRWF5QURTU0lCR3lJRWF5SUROZ0lJSUFJZ0JFRURkR3NMTmdJRUlBQWdBeWdBQURZQ0FBc2dBUThMUVFGQkFpQUNRU0JKR3dzSUFDQUFaMEVmY3dzSUFDQUFhRUVEZGdzUEFDQUFJQUFvQWdRZ0FXbzJBZ1FMSEFBZ0FDQUNRUUVnQTNRaUEyc2dBQ0FDSUFCcklBTkxHeUFCR3d2ekFnSUNmd0YrQWtBZ0FrVU5BQ0FBSUFKcUlnTkJmMm9nQVRvQUFDQUFJQUU2QUFBZ0FrRURTUTBBSUFOQmZtb2dBVG9BQUNBQUlBRTZBQUVnQTBGOWFpQUJPZ0FBSUFBZ0FUb0FBaUFDUVFkSkRRQWdBMEY4YWlBQk9nQUFJQUFnQVRvQUF5QUNRUWxKRFFBZ0FFRUFJQUJyUVFOeElnUnFJZ01nQVVIL0FYRkJnWUtFQ0d3aUFUWUNBQ0FESUFJZ0JHdEJmSEVpQkdvaUFrRjhhaUFCTmdJQUlBUkJDVWtOQUNBRElBRTJBZ2dnQXlBQk5nSUVJQUpCZUdvZ0FUWUNBQ0FDUVhScUlBRTJBZ0FnQkVFWlNRMEFJQU1nQVRZQ0dDQURJQUUyQWhRZ0F5QUJOZ0lRSUFNZ0FUWUNEQ0FDUVhCcUlBRTJBZ0FnQWtGc2FpQUJOZ0lBSUFKQmFHb2dBVFlDQUNBQ1FXUnFJQUUyQWdBZ0JDQURRUVJ4UVJoeUlnUnJJZ0pCSUVrTkFDQUJyU0lGUWlDR0lBV0VJUVVnQXlBRWFpRUJBMEFnQVNBRk53TVlJQUVnQlRjREVDQUJJQVUzQXdnZ0FTQUZOd01BSUFGQklHb2hBU0FDUVdCcUlnSkJIMHNOQUFzTElBQUxEUUFnQUNBQmRFRUFJQUpyZGd1Q0JBRURmeUFDUVlBRVR3UkFJQUFnQVNBQ0VCQWFJQUFQQ3lBQUlBSnFJUU1DUUNBQUlBRnpRUU54UlFSQUFrQWdBa0VCU0FSQUlBQWhBZ3dCQ3lBQVFRTnhSUVJBSUFBaEFnd0JDeUFBSVFJRFFDQUNJQUV0QUFBNkFBQWdBVUVCYWlFQklBSkJBV29pQWlBRFR3MEJJQUpCQTNFTkFBc0xBa0FnQTBGOGNTSUVRY0FBU1EwQUlBSWdCRUZBYWlJRlN3MEFBMEFnQWlBQktBSUFOZ0lBSUFJZ0FTZ0NCRFlDQkNBQ0lBRW9BZ2cyQWdnZ0FpQUJLQUlNTmdJTUlBSWdBU2dDRURZQ0VDQUNJQUVvQWhRMkFoUWdBaUFCS0FJWU5nSVlJQUlnQVNnQ0hEWUNIQ0FDSUFFb0FpQTJBaUFnQWlBQktBSWtOZ0lrSUFJZ0FTZ0NLRFlDS0NBQ0lBRW9BaXcyQWl3Z0FpQUJLQUl3TmdJd0lBSWdBU2dDTkRZQ05DQUNJQUVvQWpnMkFqZ2dBaUFCS0FJOE5nSThJQUZCUUdzaEFTQUNRVUJySWdJZ0JVME5BQXNMSUFJZ0JFOE5BUU5BSUFJZ0FTZ0NBRFlDQUNBQlFRUnFJUUVnQWtFRWFpSUNJQVJKRFFBTERBRUxJQU5CQkVrRVFDQUFJUUlNQVFzZ0EwRjhhaUlFSUFCSkJFQWdBQ0VDREFFTElBQWhBZ05BSUFJZ0FTMEFBRG9BQUNBQ0lBRXRBQUU2QUFFZ0FpQUJMUUFDT2dBQ0lBSWdBUzBBQXpvQUF5QUJRUVJxSVFFZ0FrRUVhaUlDSUFSTkRRQUxDeUFDSUFOSkJFQURRQ0FDSUFFdEFBQTZBQUFnQVVFQmFpRUJJQUpCQVdvaUFpQURSdzBBQ3dzZ0FBc2JBUUYvSUFCQkFXb2lBQkFrSWdGQkNIUWdBRUVJZENBQmRtb0xoUUVCQm44Z0FDZ0NJQ0VHSUFBb0FoZ2lCU0FESUFBb0FnUWlDR3NpQjBrRVFFRi9JQUYwUVg5eklRRWdBQ2dDS0NFSkEwQWdDU0FCSUFWeFFRSjBhaUFHSUFVZ0NHb2dBaUFFRUZwQkFuUnFJZ29vQWdBMkFnQWdDaUFGTmdJQUlBVkJBV29pQlNBSFNRMEFDd3NnQUNBSE5nSVlJQVlnQXlBQ0lBUVFXa0VDZEdvb0FnQUxYQUVCZnlBQktBSTRRUUZHQkVBZ0FnUkFJQUFRS3c4TElBQVFMZzhMSUFBUWdBRkJBblFpQTBHd3B3RnFLQUlBUVFoMElBRW9BaXhxSVFBZ0FTZ0NCQ0FEYWlnQ0FDRUJJQUlFUUNBQUlBRVFLMnNQQ3lBQUlBRVFMbXNMREFBZ0FFRUJhaEFrUVFoMEN3a0FJQUFnQVRzQUFBc1dBQ0FBUWJIejNmRjViRUVUUVJRZ0FVRURSaHQyQzVzQkFRVi9Jd0JCRUdzaUJTUUFJQVVnQWpZQ0RDQUNRUmgySVFZZ0FVRUVhaUVISUFBaEJBTkFJQVFpQXlBSFR3UkFJQUlnQTBGOGFpSUVLQUFBUmcwQkN3c0NRQ0FESUFGTkRRQWdBMEYvYWlJRUxRQUFJQVpIRFFBZ0JVRU1ha0VEY2lFQ0EwQWdCQ0lESUFGTkJFQWdBU0VEREFJTElBTkJmMm9pQkMwQUFDQUNRWDlxSWdJdEFBQkdEUUFMQ3lBRlFSQnFKQUFnQUNBRGF3c05BQ0FCUVg5eklBQnFRUUpMQzNnQkEzOENRQUpBSUFGQmZXb2lCQ0FBSWdOTkRRQURRQ0FDSUFNb0FBQnpJZ1ZGQkVBZ0EwRUVhaUlESUFSSkRRRU1BZ3NMSUFVUUpTQURhaUVEREFFTElBTWdBVThOQUFOQUlBTXRBQUFnQWtIL0FYRkhEUUVnQWtFSWRpRUNJQU5CQVdvaUF5QUJSdzBBQ3lBQklBQnJEd3NnQXlBQWF3c0pBQ0FBSUFFMkFBQUxGQUFnQVVVRVFFRUFEd3NnQUNBQklBSVFxUVFMaWdFQkEzOGdBQ2dDSENJQkVKa0VBa0FnQUNnQ0VDSUNJQUVvQWhRaUF5QURJQUpMR3lJQ1JRMEFJQUFvQWd3Z0FTZ0NFQ0FDRUNvYUlBQWdBQ2dDRENBQ2FqWUNEQ0FCSUFFb0FoQWdBbW8yQWhBZ0FDQUFLQUlVSUFKcU5nSVVJQUFnQUNnQ0VDQUNhellDRUNBQklBRW9BaFFnQW1zaUFEWUNGQ0FBRFFBZ0FTQUJLQUlJTmdJUUN3c1JBQ0FBSUFFcEFBQTNBQUFnQUVFSWFndlhBZ0VGZnlBQUJFQWdBRUY4YWlJQktBSUFJZ1FoQXlBQklRSWdBRUY0YWlnQ0FDSUZRWDlNQkVBZ0FTQUZhaUlBS0FJRklnSWdBQ2dDQ1RZQ0NDQUFLQUlKSUFJMkFnUWdCQ0FGUVg5emFpRURJQUJCQVdvaEFnc2dBU0FFYWlJQUtBSUFJZ0VnQUNBQmFrRjhhaWdDQUVjRVFDQUFLQUlFSWdRZ0FDZ0NDRFlDQ0NBQUtBSUlJQVEyQWdRZ0FTQURhaUVEQ3lBQ0lBTTJBZ0FnQTBGOGNTQUNha0Y4YWlBRFFYOXpOZ0lBSUFJQ2Z5QUNLQUlBUVhocUlnQkIvd0JOQkVBZ0FFRURka0YvYWd3QkN5QUFaeUVCSUFCQkhTQUJhM1pCQkhNZ0FVRUNkR3RCN2dCcUlBQkIveDlORFFBYUlBQkJIaUFCYTNaQkFuTWdBVUVCZEd0Qnh3QnFJZ0JCUHlBQVFUOUpHd3NpQTBFRWRDSUFRWUR0QVdvMkFnUWdBaUFBUVlqdEFXb2lBQ2dDQURZQ0NDQUFJQUkyQWdBZ0FpZ0NDQ0FDTmdJRVFZajFBVUdJOVFFcEF3QkNBU0FEcllhRU53TUFDd3RVQVFKL0lBQW9BZ1FoQVNBQUtBSU1JQUFvQWdBUS9BRWdBQ0FBS0FJRVFRZHhOZ0lFSUFBZ0FDZ0NBQ0FCUVhoeGRqWUNBQ0FBSUFBb0FoQWlBaUFBS0FJTUlBRkJBM1pxSWdBZ0FDQUNTeHMyQWd3TEVRQWdBQ2dBQUVHeDg5M3hlV3hCRVhZTElnQURRQ0FBSUFFcEFBQTNBQUFnQVVFSWFpRUJJQUJCQ0dvaUFDQUNTUTBBQ3dzZEFDQUFRWUFCVHdSQUlBQVFKRUVrYWc4TElBQkJzS1lCYWkwQUFBc0tBQ0FCSUFCQkEzUjNDdzBBSUFBb0FnZ2dBQ2dDREdvTHBRRUJBWDhnQWtFRFR3UkFJQUFnQVNnQ0JEWUNDQ0FCS0FJQUlRRWdBQ0FDUVg1cU5nSUFJQUFnQVRZQ0JBOExBa0FDZndKQUFrQWdBaUFEYWlJQ0RnUURBUUVBQVFzZ0FTZ0NBQ0lEUVg5cURBRUxJQUVvQWdBaEF5QUJJQUpCQW5ScUtBSUFDeUVFSUFGQkJFRUlJQUpCQVVzYmFpZ0NBQ0VCSUFBZ0F6WUNCQ0FBSUFFMkFnZ2dBQ0FFTmdJQUR3c2dBQ0FCS1FJQU53SUFJQUFnQVNnQ0NEWUNDQXRWQVFKL0lBUWdBUkRRQVNFR0lBTW9BZ0FpQlNBRUlBQnJJZ1JKQkVBRFFDQUNJQUFnQldvZ0FSRFFBVUVDZEdvZ0JUWUNBQ0FGUVFGcUlnVWdCRWtOQUFzTElBTWdCRFlDQUNBQ0lBWkJBblJxS0FJQUM3UUVBUlYvSXdCQkVHc2lEaVFBSUFBb0FpQWdBU0FBS0FKOElBTVFIa0VDZEdvaUJTZ0NBQ0VESUFBb0FuZ2hCaUFBS0FJSUlROGdBQ2dDRENFTUlBQW9BaWdoRWlBQUtBS0FBU0VJSUFBb0FoQWhFeUFGSUFFZ0FDZ0NCQ0lOYXlJSk5nSUFJQklnQ1VGL0lBWkJmMnAwUVg5ekloUnhRUU4wYWlFSElBbEJDV29oQ2dKL0lBTWdFMGtFUUNBSFFnQTNBZ0JCQUF3QkMwRUFJQWtnRkdzaUFDQUFJQWxMR3lFVklBZEJCR29oQmlBTUlBMXFJUllnRENBUGFpRVhRWDhnQ0hSQmYzTWhFVUVJSVF0QkFDRUlBMEFDZnlBRVFRQWdFQ0FJSUJBZ0NFa2JJZ0FnQTJvZ0RFa2JSUVJBSUFBZ0FXb2dBeUFOYWlBQWFpQUNFQjBnQUdvaUFDQURhaUVGSUEwTUFRc2dEeUFOSUFBZ0FXb2dBeUFQYWlBQWFpQUNJQmNnRmhBZ0lBQnFJZ0FnQTJvaUJTQU1TUnNMSVJnZ0JTQUtJQUFnQ2lBRGEwc2JJQW9nQUNBTFN5SUZHeUVLSUFBZ0N5QUZHeUVMQWtBZ0FDQUJhaUlaSUFKR0RRQWdFaUFESUJSeFFRTjBhaUVGQWtBQ1FDQURJQmhxSUFCcUxRQUFJQmt0QUFCSkJFQWdCeUFETmdJQUlBTWdGVXNOQVNBT1FReHFJUWNNQXdzZ0JpQUROZ0lBSUFNZ0ZVc0VRQ0FBSVFnZ0JTRUdEQUlMSUE1QkRHb2hCZ3dDQ3lBQUlSQWdCVUVFYWlJSElRVUxJQkZGRFFBZ0VVRi9haUVSSUFVb0FnQWlBeUFUVHcwQkN3c2dCa0VBTmdJQUlBZEJBRFlDQUNBTFFZQjlhaUlBUWNBQklBQkJ3QUZKRzBFQUlBdEJnQU5MR3dzaEF5QU9RUkJxSkFBZ0F5QUtJQWxyUVhocUlnQWdBeUFBU3hzTEhBRUJmeUFBS0FJQUlBQW9BZ1FnQVJBcElRSWdBQ0FCRUNZZ0Fnc3NBQ0FDUlFSQUlBQW9BZ1FnQVNnQ0JFWVBDeUFBSUFGR0JFQkJBUThMSUFBUWtBRWdBUkNRQVJCZFJRdWtCQUVEZjBFQklRWUNRQ0FCUlNBQ1FRUnFBbjhnQUNnQ2hBRkJBVTRFUUNBQUtBSUFJZ1FvQWl4QkFrWUVRQ0FFSUFBUW1BUTJBaXdMSUFBZ0FFR1lGbW9RcmdFZ0FDQUFRYVFXYWhDdUFTQUFFSmNFUVFGcUlRWWdBQ2dDcUMxQkNtcEJBM1lpQlNBQUtBS3NMVUVLYWtFRGRpSUVJQVFnQlVzYkRBRUxJQUpCQldvaUJBc2lCVXR5UlFSQUlBQWdBU0FDSUFNUWpnSU1BUXNnQUNnQ3ZDMGhBUUpBSUFRZ0JVY0VRQ0FBS0FLSUFVRUVSdzBCQ3lBQUlBQXZBYmd0SUFOQkFtcEIvLzhEY1NJQ0lBRjBjaUlFT3dHNExTQUFBbjhnQVVFT1RnUkFJQUFnQUNnQ0ZDSUJRUUZxTmdJVUlBRWdBQ2dDQ0dvZ0JEb0FBQ0FBSUFBb0FoUWlBVUVCYWpZQ0ZDQUJJQUFvQWdocUlBQkJ1UzFxTFFBQU9nQUFJQUFnQWtFUUlBQW9Bcnd0SWdGcmRqc0J1QzBnQVVGemFnd0JDeUFCUVFOcUN6WUN2QzBnQUVHQTJ3QkJnTmtBRUlzQ0RBRUxJQUFnQUM4QnVDMGdBMEVFYWtILy93TnhJZ0lnQVhSeUlnUTdBYmd0SUFBQ2Z5QUJRUTVPQkVBZ0FDQUFLQUlVSWdGQkFXbzJBaFFnQVNBQUtBSUlhaUFFT2dBQUlBQWdBQ2dDRkNJQlFRRnFOZ0lVSUFFZ0FDZ0NDR29nQUVHNUxXb3RBQUE2QUFBZ0FDQUNRUkFnQUNnQ3ZDMGlBV3QyT3dHNExTQUJRWE5xREFFTElBRkJBMm9MTmdLOExTQUFJQUJCbkJacUtBSUFRUUZxSUFCQnFCWnFLQUlBUVFGcUlBWVFsZ1FnQUNBQVFaUUJhaUFBUVlnVGFoQ0xBZ3NnQUJDTkFpQURCRUFnQUJDTUFnc0w5UUVCQVg4Z0FrVUVRQ0FBUWdBM0FnQWdBRUVBTmdJUUlBQkNBRGNDQ0VHNGZ3OExJQUFnQVRZQ0RDQUFJQUZCQkdvMkFoQWdBa0VFVHdSQUlBQWdBU0FDYWlJQlFYeHFJZ00yQWdnZ0FDQURLQUFBTmdJQUlBRkJmMm90QUFBaUFVVUVRQ0FBUVFBMkFnUkJmdzhMSUFCQkNDQUJFQ1JyTmdJRUlBSVBDeUFBSUFFMkFnZ2dBQ0FCTFFBQUlnTTJBZ0FDUUFKQUFrQWdBa0YrYWc0Q0FRQUNDeUFBSUFFdEFBSkJFSFFnQTNJaUF6WUNBQXNnQUNBQkxRQUJRUWgwSUFOcU5nSUFDeUFCSUFKcVFYOXFMUUFBSWdGRkJFQWdBRUVBTmdJRVFXd1BDeUFBUVNnZ0FSQWtJQUpCQTNScWF6WUNCQ0FDQ3kwQkFYOGdBVUVDZEVHd3d3RnFLQUlBSUFBb0FnQkJJQ0FCSUFBb0FnUnFhM1p4SVFJZ0FDQUJFQ1lnQWdzeEFRRi9JQUFnQUNnQ0JDSURJQUpxTmdJRUlBQWdBQ2dDQUNBQ1FRSjBRYkREQVdvb0FnQWdBWEVnQTNSeU5nSUFDeUVBSUFKQkFrWUVRQ0FCSUFCQkFuUnFLQUlBRHdzZ0FTQUFRUUYwYWk4QkFBdElBQUpBQWtBQ1FBSkFJQU5CZjJvT0F3QUJBZ01MSUFJZ0FVRUNkR29nQURZQ0FBOExJQUlnQVVFQ2RHb2dBQ0FFYXpZQ0FBOExJQUlnQVVFQmRHb2dBQ0FFYXpzQkFBc0w2UUlCQVg4Q1FDQUFJQUZHRFFBZ0FTQUFheUFDYTBFQUlBSkJBWFJyVFFSQUlBQWdBU0FDRUNvUEN5QUFJQUZ6UVFOeElRTUNRQUpBSUFBZ0FVa0VRQ0FEQkVBZ0FDRUREQU1MSUFCQkEzRkZCRUFnQUNFRERBSUxJQUFoQXdOQUlBSkZEUVFnQXlBQkxRQUFPZ0FBSUFGQkFXb2hBU0FDUVg5cUlRSWdBMEVCYWlJRFFRTnhEUUFMREFFTEFrQWdBdzBBSUFBZ0FtcEJBM0VFUUFOQUlBSkZEUVVnQUNBQ1FYOXFJZ0pxSWdNZ0FTQUNhaTBBQURvQUFDQURRUU54RFFBTEN5QUNRUU5ORFFBRFFDQUFJQUpCZkdvaUFtb2dBU0FDYWlnQ0FEWUNBQ0FDUVFOTERRQUxDeUFDUlEwQ0EwQWdBQ0FDUVg5cUlnSnFJQUVnQW1vdEFBQTZBQUFnQWcwQUN3d0NDeUFDUVFOTkRRQURRQ0FESUFFb0FnQTJBZ0FnQVVFRWFpRUJJQU5CQkdvaEF5QUNRWHhxSWdKQkEwc05BQXNMSUFKRkRRQURRQ0FESUFFdEFBQTZBQUFnQTBFQmFpRURJQUZCQVdvaEFTQUNRWDlxSWdJTkFBc0xJQUFMRFFBZ0FTQUNSaUFBUVNCR2NRc0pBRUVJSUFBUXRRRUxDQUFnQUNBQkVEUUxJUUFnQVVMUDF0Tyswc2VyMlVKK0lBQjhRaCtKUW9lVnI2K1l0dDZibm45K0N5WUJBWDhqQUVFUWF5SUNKQUFnQWlBQk5nSU1RZGpwQVNBQUlBRVF1UUVnQWtFUWFpUUFDMkFBQWtBQ1FBSkFBa0FnQWtGNGFnNFpBZ01EQXdNREF3TUJBd01EQXdNREF3TURBd01EQXdNREFBTUxJQUFnQVJDVUFnOExJQUFnQVJCV0R3c2dBQ0FCRURjUEN5QUNRUWROQkVBZ0FDQUJJQUlRd3dRUEN5QUFJQUVnQWhEQ0JBdC9BUUYvSUFCQlFHc29BZ0FRY0FSQUlBQW9BaGdoQWlBQUFuOGdBUVJBSUFJUUt3d0JDeUFDRUM0TE5nSW9DeUFBS0FJY0lRSWdBQUovSUFFRVFDQUNFQ3NoQVNBQUtBSWdFQ3NoQWlBQUtBSWtFQ3NNQVFzZ0FoQXVJUUVnQUNnQ0lCQXVJUUlnQUNnQ0pCQXVDellDTkNBQUlBSTJBakFnQUNBQk5nSXNDNE1CQVFOL0lBRkZCRUJCQUE4TElBSkJRR3NvQWdBUWNFVUVRQ0FCUVF0MER3c2dBaWdDT0VFQlJnUkFJQUZCZ0F4c0R3c2dBaWdDS0NBQmJDRUVJQUlvQWdBaEJrRUFJUUlEUUNBR0lBQWdBbW90QUFCQkFuUnFLQUlBSVFVZ0JBSi9JQU1FUUNBRkVDc01BUXNnQlJBdUMyc2hCQ0FDUVFGcUlnSWdBVWNOQUFzZ0JBdXdCZ0VYZnlNQVFSQnJJaFFrQUVFQklBQW9Bb0FCZENFS0lBQW9BaWdoRGdKQUlBQW9BaUFnQVNBQUtBSjhJQVFRV2tFQ2RHb2lEQ2dDQUNJSlFRQWdBU0FBS0FJRUlnOXJJZ2hCZnlBQUtBSjRRWDlxZEVGL2N5SVFheUlHSUFZZ0NFc2JJaFVnQUNnQ0VDQUFLQUlVSUFnZ0FDZ0NkQkFuSWhZZ0ZTQVdTeHNpRFUwTkFDQUtJUWNDUUFOQUlBNGdDU0lHSUJCeFFRTjBhaUlKS0FJRUloZEJBVWNnQjBFQ1NYSkZCRUFnQ1NBTE5nSUVJQWRCZjJvaEJ5QUdJUXNnQ1NnQ0FDSUpJQTFMRFFFTUFnc0xJQmRCQVVZRVFDQUpRZ0EzQWdBTElBc2lCa1VOQVFzZ0RrRUVhaUVKQTBBZ0NTQUdJQkJ4UVFOMGFpZ0NBQ0VMSUFBZ0JpQUNJQWNnRFNBRkVMd0RJQWRCQVdvaEJ5QUxJZ1lOQUFzTElBQW9BZ2doR0NBQUtBSU1JUkVnRENnQ0FDRUhJQXdnQ0RZQ0FDQUtRWDlxSVFvZ0NFRUphaUVTSUE0Z0NDQVFjVUVEZEdvaUUwRUVhaUVNQWtBZ0J5QVdUUVJBSUFvaEJrRUFJUWdNQVFzZ0R5QVJhaUVaSUJFZ0dHb2hHaUFJUVFKcUlSc2dDRUVCYWlFY1FRQWhDRUVBSVF0QkFDRU5BMEFDZnlBRlFRRkdRUUFnRFNBTElBMGdDMGtiSWdZZ0Iyb2dFVWtiUlFSQUlBRWdCbW9nQnlBUGFpQUdhaUFDRUIwZ0Jtb2hCaUFQREFFTElCZ2dEeUFCSUFacUlBY2dHR29nQm1vZ0FpQWFJQmtRSUNBR2FpSUdJQWRxSUJGSkd3c2hGd0pBSUFZZ0NFME5BQ0FHSUFoclFRSjBJQndnQjJzUUpDQURLQUlBUVFGcUVDUnJTZ1JBSUFNZ0d5QUhhellDQUNBR0lRZ0xJQVlnQjJvZ0VpQUdJQklnQjJ0TEd5RVNJQUVnQm1vZ0FrY05BRUVBSUFvZ0JVRUNSaHNoQmd3Q0N5QU9JQWNnRUhGQkEzUnFJUWtDUUFKQUlBY2dGMm9nQm1vdEFBQWdBU0FHYWkwQUFFa0VRQ0FUSUFjMkFnQWdCeUFWU3cwQklCUkJER29oRXlBS0lRWU1CQXNnRENBSE5nSUFJQWNnRlVzRVFDQUdJUXNnQ1NFTURBSUxJQlJCREdvaERDQUtJUVlNQXdzZ0JpRU5JQWxCQkdvaUV5RUpDeUFLUVg5cUlnWWdDazhOQVNBR0lRb2dDU2dDQUNJSElCWkxEUUFMQ3lBTVFRQTJBZ0FnRTBFQU5nSUFJQVpGSUFWQkFrZHlSUVJBSUFBZ0FTQUNJQU1nQ0NBR0lBUVF1d01oQ0FzZ0FDQVNRWGhxTmdJWUlCUkJFR29rQUNBSUM0NEJBUWgvSUFBb0FoZ2lBeUFCSUFBb0FnUWlCV3NpQVVrRVFFRi9JQUFvQW5oQmYycDBRWDl6SVFZZ0FDZ0NmQ0VISUFBb0FpZ2hDQ0FBS0FJZ0lRa0RRQ0FKSUFNZ0JXb2dCeUFDRUZwQkFuUnFJZ1FvQWdBaENpQUVJQU0yQWdBZ0NDQURJQVp4UVFOMGFpSUVRUUUyQWdRZ0JDQUtOZ0lBSUFOQkFXb2lBeUFCU1EwQUN3c2dBQ0FCTmdJWUN3NEFJQUFnQVJEakFVRUNFT0lCQzZjQkFDQUFJQUV0QUFBNkFBQWdBQ0FCTFFBQk9nQUJJQUFnQVMwQUFqb0FBaUFBSUFFdEFBTTZBQU1nQUNBQkxRQUVPZ0FFSUFBZ0FTMEFCVG9BQlNBQUlBRXRBQVk2QUFZZ0FDQUJMUUFIT2dBSElBQWdBUzBBQ0RvQUNDQUFJQUV0QUFrNkFBa2dBQ0FCTFFBS09nQUtJQUFnQVMwQUN6b0FDeUFBSUFFdEFBdzZBQXdnQUNBQkxRQU5PZ0FOSUFBZ0FTMEFEam9BRGlBQUlBRXRBQTg2QUE4Z0FFRVFhZ3ZUQVFFRGZ5QUFRVUJyS0FJQUVIQUVRQ0FCQkVBZ0FDZ0NBQ0VHQTBBZ0JpQUNJQVZxTFFBQVFRSjBhaUlISUFjb0FnQkJBbW8yQWdBZ0JVRUJhaUlGSUFGSERRQUxDeUFBSUFBb0FoZ2dBVUVCZEdvMkFoZ0xJQUFvQWdRZ0FSQ0FBVUVDZEdvaUFTQUJLQUlBUVFGcU5nSUFJQUFnQUNnQ0hFRUJhallDSENBQUtBSU1JQU5CQVdvUUpFRUNkR29pQVNBQktBSUFRUUZxTmdJQUlBQWdBQ2dDSkVFQmFqWUNKQ0FBS0FJSUlBUkJmV29RUEVFQ2RHb2lBU0FCS0FJQVFRRnFOZ0lBSUFBZ0FDZ0NJRUVCYWpZQ0lBc1dBQ0FBSUFFZ0FpQURFRklnQVNBQ0lBTVFvZ05xQzdjSUFRUi9Jd0JCRUdzaUJpUUFJQUJCUUdzb0FnQVFjQ0VGSUFCQkFEWUNPQUpBSUFBb0FoeEZCRUFnQWtHQUNFMEVRQ0FBUVFFMkFqZ0xJQUFvQWp3aUJDZ0NnQWhCQWtZRVFFRUFJUUlnQUVFQU5nSTRJQVVFUUNBQVFRQTJBaGdnQUNnQ0FDSUZRUUZCQ3lBRVFRQVErUUVpQVd0MFFRRWdBUnNpQVRZQ0FDQUFJQUFvQWhnZ0FXbzJBaGhCQVNFQkEwQWdCU0FCUVFKMGFrRUJRUXNnQkNBQkVQa0JJZ2RyZEVFQklBY2JJZ2MyQWdBZ0FDQUFLQUlZSUFkcU5nSVlJQUZCQVdvaUFVR0FBa2NOQUFzTElBWWdCRUcwR1dvUWN5QUFRUUEyQWh3Z0FDZ0NCQ0VCSUFZb0FnZ2hCUU5BSUFFZ0FrRUNkR3BCQVVFS0lBVWdBaENZQVNJRWEzUkJBU0FFR3lJRU5nSUFJQUFnQUNnQ0hDQUVhallDSENBQ1FRRnFJZ0pCSkVjTkFBc2dCaUFBS0FJOFFZZ09haEJ6UVFBaEFpQUFRUUEyQWlBZ0FDZ0NDQ0VCSUFZb0FnZ2hCUU5BSUFFZ0FrRUNkR3BCQVVFS0lBVWdBaENZQVNJRWEzUkJBU0FFR3lJRU5nSUFJQUFnQUNnQ0lDQUVhallDSUNBQ1FRRnFJZ0pCTlVjTkFBc2dCaUFBS0FJOFFZUUlhaEJ6UVFBaEFpQUFRUUEyQWlRZ0FDZ0NEQ0VCSUFZb0FnZ2hCUU5BSUFFZ0FrRUNkR3BCQVVFS0lBVWdBaENZQVNJRWEzUkJBU0FFR3lJRU5nSUFJQUFnQUNnQ0pDQUVhallDSkNBQ1FRRnFJZ0pCSUVjTkFBc01BZ3NnQlFSQUlBWkIvd0UyQWdBZ0FDZ0NBQ0FHSUFFZ0FoQ3FBUm9nQUNBQUtBSUFRZjhCUVFFUWJ6WUNHQXNnQUNnQ0JDSUJRb0dBZ0lBUU53S0lBU0FCUW9HQWdJQVFOd0tBQVNBQlFvR0FnSUFRTndKNElBRkNnWUNBZ0JBM0FuQWdBVUtCZ0lDQUVEY0NhQ0FCUW9HQWdJQVFOd0pnSUFGQ2dZQ0FnQkEzQWxnZ0FVS0JnSUNBRURjQ1VDQUJRb0dBZ0lBUU53SklJQUZDZ1lDQWdCQTNBa0FnQVVLQmdJQ0FFRGNDT0NBQlFvR0FnSUFRTndJd0lBRkNnWUNBZ0JBM0FpZ2dBVUtCZ0lDQUVEY0NJQ0FCUW9HQWdJQVFOd0lZSUFGQ2dZQ0FnQkEzQWhBZ0FVS0JnSUNBRURjQ0NDQUJRb0dBZ0lBUU53SUFJQUJCSkRZQ0hDQUFLQUlJSVFGQkFDRUNBMEFnQVNBQ1FRSjBha0VCTmdJQUlBSkJBV29pQWtFMVJ3MEFDeUFBUVRVMkFpQWdBQ2dDRENJQlFvR0FnSUFRTndKNElBRkNnWUNBZ0JBM0FuQWdBVUtCZ0lDQUVEY0NhQ0FCUW9HQWdJQVFOd0pnSUFGQ2dZQ0FnQkEzQWxnZ0FVS0JnSUNBRURjQ1VDQUJRb0dBZ0lBUU53SklJQUZDZ1lDQWdCQTNBa0FnQVVLQmdJQ0FFRGNDT0NBQlFvR0FnSUFRTndJd0lBRkNnWUNBZ0JBM0FpZ2dBVUtCZ0lDQUVEY0NJQ0FCUW9HQWdJQVFOd0lZSUFGQ2dZQ0FnQkEzQWhBZ0FVS0JnSUNBRURjQ0NDQUJRb0dBZ0lBUU53SUFJQUJCSURZQ0pBd0JDeUFGQkVBZ0FDQUFLQUlBUWY4QlFRRVFiellDR0FzZ0FDQUFLQUlFUVNOQkFCQnZOZ0ljSUFBZ0FDZ0NDRUUwUVFBUWJ6WUNJQ0FBSUFBb0FneEJIMEVBRUc4MkFpUUxJQUFnQXhCUklBWkJFR29rQUFzc0FBSkFBa0FDUUNBQ1FYdHFEZ0lCQWdBTElBQWdBUkRlQVE4TElBQWdBUkRkQVE4TElBQWdBUkRjQVFzaEFDQUFJQUlnQUNnQ0JDSUNhallDQkNBQUlBQW9BZ0FnQVNBQ2RISTJBZ0FMTUFBQ1FBSkFBa0FnQTBGK2FnNENBQUVDQ3lBQ0lBRkJBblJxSUFBMkFnQVBDeUFDSUFGQkFYUnFJQUE3QVFBTEMwb0JBbjhDUUNBQUxRQUFJZ0pGSUFJZ0FTMEFBQ0lEUjNJTkFBTkFJQUV0QUFFaEF5QUFMUUFCSWdKRkRRRWdBVUVCYWlFQklBQkJBV29oQUNBQ0lBTkdEUUFMQ3lBQ0lBTnJDMjBCQVg4akFFR0FBbXNpQlNRQUlBUkJnTUFFY1NBQ0lBTk1ja1VFUUNBRklBRkIvd0Z4SUFJZ0Eyc2lBa0dBQWlBQ1FZQUNTU0lCR3hBb0dpQUJSUVJBQTBBZ0FDQUZRWUFDRUdZZ0FrR0FmbW9pQWtIL0FVc05BQXNMSUFBZ0JTQUNFR1lMSUFWQmdBSnFKQUFMQmdBZ0FCQTRDd3NBSUFBZ0FVRUJFT0lCQ3k4QkFuOGdBQ2dDQkNBQUtBSUFRUUowYWlJQ0xRQUNJUU1nQUNBQ0x3RUFJQUVnQWkwQUF4QkdhallDQUNBREN5OEJBbjhnQUNnQ0JDQUFLQUlBUVFKMGFpSUNMUUFDSVFNZ0FDQUNMd0VBSUFFZ0FpMEFBeEJDYWpZQ0FDQURDMFlBSUFBZ0FSQnpJQUFnQUNnQ0JDQUFLQUlJSUFKQkEzUnFJZ0FvQWdRaUFVR0FnQUpxSWdKQmdJQjhjU0FCYXlBQ1FSQjJkU0FBS0FJQWFrRUJkR292QVFBMkFnQUxHZ0FnQUFSQUlBSUVRQ0FESUFBZ0FoRUVBQThMSUFBUU9Bc0wwQVVCQTM4Z0FFSC8vd054SVFNZ0FFRVFkaUVFUVFFaEFDQUNRUUZHQkVBZ0F5QUJMUUFBYWlJQVFZK0FmR29nQUNBQVFmRC9BMHNiSWdBZ0JHb2lBVUVRZENJQ1FZQ0FQR29nQWlBQlFmRC9BMHNiSUFCeUR3c2dBUVIvSUFKQkVFOEVRQUpBQWtBQ1FDQUNRYThyU3dSQUEwQkIyd0loQlNBQklRQURRQ0FESUFBdEFBQnFJZ01nQkdvZ0F5QUFMUUFCYWlJRGFpQURJQUF0QUFKcUlnTnFJQU1nQUMwQUEyb2lBMm9nQXlBQUxRQUVhaUlEYWlBRElBQXRBQVZxSWdOcUlBTWdBQzBBQm1vaUEyb2dBeUFBTFFBSGFpSURhaUFESUFBdEFBaHFJZ05xSUFNZ0FDMEFDV29pQTJvZ0F5QUFMUUFLYWlJRGFpQURJQUF0QUF0cUlnTnFJQU1nQUMwQURHb2lBMm9nQXlBQUxRQU5haUlEYWlBRElBQXRBQTVxSWdOcUlBTWdBQzBBRDJvaUEyb2hCQ0FBUVJCcUlRQWdCVUYvYWlJRkRRQUxJQVJCOGY4RGNDRUVJQU5COGY4RGNDRURJQUZCc0N0cUlRRWdBa0hRVkdvaUFrR3ZLMHNOQUFzZ0FrVU5BeUFDUVJCSkRRRUxBMEFnQXlBQkxRQUFhaUlBSUFScUlBQWdBUzBBQVdvaUFHb2dBQ0FCTFFBQ2FpSUFhaUFBSUFFdEFBTnFJZ0JxSUFBZ0FTMEFCR29pQUdvZ0FDQUJMUUFGYWlJQWFpQUFJQUV0QUFacUlnQnFJQUFnQVMwQUIyb2lBR29nQUNBQkxRQUlhaUlBYWlBQUlBRXRBQWxxSWdCcUlBQWdBUzBBQ21vaUFHb2dBQ0FCTFFBTGFpSUFhaUFBSUFFdEFBeHFJZ0JxSUFBZ0FTMEFEV29pQUdvZ0FDQUJMUUFPYWlJQWFpQUFJQUV0QUE5cUlnTnFJUVFnQVVFUWFpRUJJQUpCY0dvaUFrRVBTdzBBQ3lBQ1JRMEJDd05BSUFNZ0FTMEFBR29pQXlBRWFpRUVJQUZCQVdvaEFTQUNRWDlxSWdJTkFBc0xJQVJCOGY4RGNDRUVJQU5COGY4RGNDRURDeUFFUVJCMElBTnlEd3NnQWdSQUEwQWdBeUFCTFFBQWFpSURJQVJxSVFRZ0FVRUJhaUVCSUFKQmYyb2lBZzBBQ3dzZ0JFSHgvd053UVJCMElBTkJqNEI4YWlBRElBTkI4UDhEU3h0eUJTQUFDd3NZQUNBQUxRQUFRU0J4UlFSQUlBRWdBaUFBRUtVQkdnc0xEQUFnQUNBQktRQUFOd0FBQ3g4QUlBQWdBU0FDS0FJRUVFWTJBZ0FnQVJBakdpQUFJQUpCQ0dvMkFnUUxDUUJCQVVFRklBQWJDODhNQVExL0FrQUNRQUpBQWtBQ1FDQUFLQUtFQVVGN2FnNERBUUlDQUFzZ0FDZ0NCQ0VMSUFBb0FuUWhCeUFBS0FJUUlRVWdBQ2dDRkNFS0lBQW9BaWdoQ0NBQUtBSU1JUTlCQVNBQUtBS0FBWFFoREVFRElRWUNRQ0FBSUFBb0FuZ2lEU0FBS0FKOElBRkJCQkFzSWdRZ0JTQUJJQXRySWdsQkFTQUhkQ0lIYXlBRklBa2dCV3NnQjBzYklBb2JJZ2RORFFCQkFDQUpRUUVnRFhRaUJtc2lCU0FGSUFsTEd5RUtJQVpCZjJvaERTQUpRUUpxSVE1QkF5RUdBMEFDUUNBRUlBdHFJZ1VnQm1vdEFBQWdBU0FHYWkwQUFFY05BQ0FCSUFVZ0FoQWRJZ1VnQmswTkFDQURJQTRnQkdzMkFnQWdCU0lHSUFGcUlBSkhEUUFNQWdzZ0JDQUtUUTBCSUF4QmYyb2lERVVOQVNBSUlBUWdEWEZCQW5ScUtBSUFJZ1FnQjBzTkFBc0xJQUFvQW5BaUFDZ0NCQ0VGSUFBb0FnQWhCeUFBS0FKNElRZ2dBQ2dDRENFS0lBQW9BaWdoRFNBQUtBSWdJUVFnQVNBQUtBSjhRUVFRV2lFQUlBeEZEUU1nQkNBQVFRSjBhaWdDQUNJRUlBcE5EUU1nQ3lBUGFpRUxRUUFnQnlBRmF5SUFRUUVnQ0hRaUNHc2lEaUFPSUFCTEd5RU9JQWhCZjJvaENDQUJRUVJxSVJBZ0NTQVBheUFBYWtFQ2FpRUpBMEFDUUNBRUlBVnFJZ0FvQUFBZ0FTZ0FBRWNOQUNBUUlBQkJCR29nQWlBSElBc1FJRUVFYWlJQUlBWk5EUUFnQXlBSklBUnJOZ0lBSUFBaEJpQUFJQUZxSUFKR0RRUUxJQVFnRGswTkJDQU1RWDlxSWd4RkRRUWdCaUVBSUEwZ0JDQUljVUVDZEdvb0FnQWlCQ0FLU3cwQUN3d0NDeUFBS0FJRUlRc2dBQ2dDZENFSElBQW9BaEFoQlNBQUtBSVVJUW9nQUNnQ0tDRUlJQUFvQWd3aEQwRUJJQUFvQW9BQmRDRU1RUU1oQmdKQUlBQWdBQ2dDZUNJTklBQW9BbndnQVVFRkVDd2lCQ0FGSUFFZ0Myc2lDVUVCSUFkMElnZHJJQVVnQ1NBRmF5QUhTeHNnQ2hzaUIwME5BRUVBSUFsQkFTQU5kQ0lHYXlJRklBVWdDVXNiSVFvZ0JrRi9haUVOSUFsQkFtb2hEa0VESVFZRFFBSkFJQVFnQzJvaUJTQUdhaTBBQUNBQklBWnFMUUFBUncwQUlBRWdCU0FDRUIwaUJTQUdUUTBBSUFNZ0RpQUVhellDQUNBRklnWWdBV29nQWtjTkFBd0NDeUFFSUFwTkRRRWdERUYvYWlJTVJRMEJJQWdnQkNBTmNVRUNkR29vQWdBaUJDQUhTdzBBQ3dzZ0FDZ0NjQ0lBS0FJRUlRVWdBQ2dDQUNFSElBQW9BbmdoQ0NBQUtBSU1JUW9nQUNnQ0tDRU5JQUFvQWlBaEJDQUJJQUFvQW54QkJSQmFJUUFnREVVTkFpQUVJQUJCQW5ScUtBSUFJZ1FnQ2swTkFpQUxJQTlxSVF0QkFDQUhJQVZySWdCQkFTQUlkQ0lJYXlJT0lBNGdBRXNiSVE0Z0NFRi9haUVJSUFGQkJHb2hFQ0FKSUE5cklBQnFRUUpxSVFrRFFBSkFJQVFnQldvaUFDZ0FBQ0FCS0FBQVJ3MEFJQkFnQUVFRWFpQUNJQWNnQ3hBZ1FRUnFJZ0FnQmswTkFDQURJQWtnQkdzMkFnQWdBQ0VHSUFBZ0FXb2dBa1lOQXdzZ0JDQU9UUTBESUF4QmYyb2lERVVOQXlBR0lRQWdEU0FFSUFoeFFRSjBhaWdDQUNJRUlBcExEUUFMREFFTElBQW9BZ1FoQ3lBQUtBSjBJUWNnQUNnQ0VDRUZJQUFvQWhRaENpQUFLQUlvSVFnZ0FDZ0NEQ0VQUVFFZ0FDZ0NnQUYwSVF4QkF5RUdBa0FnQUNBQUtBSjRJZzBnQUNnQ2ZDQUJRUVlRTENJRUlBVWdBU0FMYXlJSlFRRWdCM1FpQjJzZ0JTQUpJQVZySUFkTEd5QUtHeUlIVFEwQVFRQWdDVUVCSUExMElnWnJJZ1VnQlNBSlN4c2hDaUFHUVg5cUlRMGdDVUVDYWlFT1FRTWhCZ05BQWtBZ0JDQUxhaUlGSUFacUxRQUFJQUVnQm1vdEFBQkhEUUFnQVNBRklBSVFIU0lGSUFaTkRRQWdBeUFPSUFSck5nSUFJQVVpQmlBQmFpQUNSdzBBREFJTElBUWdDazBOQVNBTVFYOXFJZ3hGRFFFZ0NDQUVJQTF4UVFKMGFpZ0NBQ0lFSUFkTERRQUxDeUFBS0FKd0lnQW9BZ1FoQlNBQUtBSUFJUWNnQUNnQ2VDRUlJQUFvQWd3aENpQUFLQUlvSVEwZ0FDZ0NJQ0VFSUFFZ0FDZ0NmRUVHRUZvaEFDQU1SUTBCSUFRZ0FFRUNkR29vQWdBaUJDQUtUUTBCSUFzZ0Qyb2hDMEVBSUFjZ0JXc2lBRUVCSUFoMElnaHJJZzRnRGlBQVN4c2hEaUFJUVg5cUlRZ2dBVUVFYWlFUUlBa2dEMnNnQUdwQkFtb2hDUU5BQWtBZ0JDQUZhaUlBS0FBQUlBRW9BQUJIRFFBZ0VDQUFRUVJxSUFJZ0J5QUxFQ0JCQkdvaUFDQUdUUTBBSUFNZ0NTQUVhellDQUNBQUlRWWdBQ0FCYWlBQ1JnMENDeUFFSUE1TkRRSWdERUYvYWlJTVJRMENJQVloQUNBTklBUWdDSEZCQW5ScUtBSUFJZ1FnQ2tzTkFBc0xJQUFQQ3lBR0M5d0ZBUXgvSXdCQkVHc2lDaVFBQW44Z0JFRURUUVJBSUFwQkFEWUNEQ0FLUVF4cUlBTWdCQkFxR2lBQUlBRWdBaUFLUVF4cVFRUVFheUlBUVd3Z0FCQWhHeUFBSUFBZ0JFc2JEQUVMSUFCQkFDQUJLQUlBUVFGMFFRSnFFQ2doRGtGVUlBTW9BQUFpQlVFUGNTSUFRUXBMRFFBYUlBSWdBRUVGYWpZQ0FDQURJQVJxSWdKQmZHb2hDeUFDUVhscUlROGdBa0Y3YWlFUVFRUWhBaUFGUVFSMklRUWdBRUVHYWlFTVFTQWdBSFFpQ0VFQmNpRUpJQUVvQWdBaERTQURJUVpCQUNFQVFRQWhCUU5BQWtBQ1FDQUFSUVJBSUFVaEJ3d0JDeUFGSVFBZ0JFSC8vd054UWYvL0EwWUVRQU5BSUFCQkdHb2hBQUovSUFZZ0VFa0VRQ0FHUVFKcUlnWW9BQUFnQW5ZTUFRc2dBa0VRYWlFQ0lBUkJFSFlMSWdSQi8vOERjVUgvL3dOR0RRQUxDeUFFUVFOeElnZEJBMFlFUUFOQUlBSkJBbW9oQWlBQVFRTnFJUUFnQkVFQ2RpSUVRUU54SWdkQkEwWU5BQXNMUVZBZ0FDQUhhaUlISUExTERRTWFJQUpCQW1vaEFnSkFJQWNnQlUwRVFDQUZJUWNNQVFzZ0RpQUZRUUYwYWtFQUlBY2dCV3RCQVhRUUtCb0xJQVlnRDB0QkFDQUdJQUpCQTNWcUlnQWdDMHNiUlFSQUlBQW9BQUFnQWtFSGNTSUNkaUVFREFJTElBUkJBblloQkFzZ0JpRUFDd0ovSUF4QmYyb2dCQ0FJUVg5cWNTSUdJQWhCQVhSQmYyb2lCU0FKYXlJTlNRMEFHaUFFSUFWeElnUkJBQ0FOSUFRZ0NFZ2JheUVHSUF3TElRVWdEaUFIUVFGMGFpQUdRWDlxSWdRN0FRQWdCRUVCSUFacklBWkJBVWdiSUFscUlna2dDRWdFUUFOQUlBeEJmMm9oRENBSklBaEJBWFVpQ0VnTkFBc0xJQUlnQldvaUFpQUFJQXRyUVFOMGFpQUNRUWR4SUFBZ0Qwc2dBQ0FDUVFOMWFpSUFJQXRMY1NJRkd5RUNJQXNnQUNBRkd5SUdLQUFBSVFVZ0NVRUNUZ1JBSUFSRklRQWdCU0FDZGlFRUlBZEJBV29pQlNBQktBSUFJZzFORFFFTEMwRnNJQWxCQVVjZ0FrRWdTbklOQUJvZ0FTQUhOZ0lBSUFZZ0FrRUhha0VEZFdvZ0Eyc0xJUUFnQ2tFUWFpUUFJQUFMVGdFQ2Z5QUJLQUlJSUFKQkEzUnFJZ0lvQWdBaEF5QUJLQUlFSVFRZ0FDQUJLQUlBSWdBZ0FDQUNLQUlFYWtFUWRpSUFFRWNnQVNBRUlBTWdBU2dDQUNBQWRXcEJBWFJxTHdFQU5nSUFDeHNBSUFCQkFTQUFHeUVBQWtBZ0FCQk1JZ0FOQUJBU0FBc2dBQXNLQUNBQVFWQnFRUXBKQzBjQkEzOGdBa0VFYWlFRlFRQWhBZ05BSUFBZ0FrRUNkR29pQXlBREtBSUFJQVYyUVFGcUlnTTJBZ0FnQXlBRWFpRUVJQUVnQWtjaEF5QUNRUUZxSVFJZ0F3MEFDeUFFQ3djQUlBQkJBa2NMOUFJQkFuOGpBRUVnYXlJRkpBQUNmMEVBSUFGQkNFa05BQm9nQlVFSWFpQUFJQUVRK1FOQkFFRUFFQ0VOQUJvZ0EwRjhjU0VHQWtBQ1FBSkFBa0FnQTBFRGNVRUJhdzREQWdFQUF3c2dCVUVJYWlBRUlBSWdCa0VDY21vdEFBQkJBblJxSWdBdkFRQWdBQzBBQWhCYklBVkJDR29RT1FzZ0JVRUlhaUFFSUFJZ0JrRUJjbW90QUFCQkFuUnFJZ0F2QVFBZ0FDMEFBaEJiQ3lBRlFRaHFJQVFnQWlBR2FpMEFBRUVDZEdvaUFDOEJBQ0FBTFFBQ0VGc2dCVUVJYWhBNUN5QUdCRUFEUUNBRlFRaHFJQVFnQWlBR2FpSUFRWDlxTFFBQVFRSjBhaUlCTHdFQUlBRXRBQUlRV3lBRlFRaHFJQVFnQUVGK2FpMEFBRUVDZEdvaUFTOEJBQ0FCTFFBQ0VGc2dCVUVJYWhBNUlBVkJDR29nQkNBQVFYMXFMUUFBUVFKMGFpSUFMd0VBSUFBdEFBSVFXeUFGUVFocUlBUWdBaUFHUVh4cUlnWnFMUUFBUVFKMGFpSUFMd0VBSUFBdEFBSVFXeUFGUVFocUVEa2dCZzBBQ3dzZ0JVRUlhaEQ0QXdzaEJpQUZRU0JxSkFBZ0Jncy9BUUYvSUFFaEFpQUNBbjlCcE9vQktBSUFRWDlNQkVBZ0FDQUNRZGpwQVJDbEFRd0JDeUFBSUFKQjJPa0JFS1VCQ3lJQVJnUkFEd3NnQUNBQmJob0xQZ0VCZnlBQUlBRXZBQUFpQWpZQ0RDQUFJQUZCQkdvaUFUWUNCQ0FBUVFFZ0FuUTJBZ0FnQUNBQlFRRWdBa0YvYW5SQkFTQUNHMEVDZEdvMkFnZ0xEZ0FnQUNBQklBSVFSeUFBRURrTFB3RUJmeUFBSUFBb0FoUWlBa0VCYWpZQ0ZDQUNJQUFvQWdocUlBRkJDSFk2QUFBZ0FDQUFLQUlVSWdKQkFXbzJBaFFnQWlBQUtBSUlhaUFCT2dBQUM0NEZBUXAvSUFBb0Fpd2lBa0g2ZldvaENDQUFLQUowSVFVZ0FpRUJBMEFnQUNnQ1BDQUZheUFBS0FKc0lnVnJJUVFnQlNBQklBaHFUd1JBSUFBb0FqZ2lBU0FCSUFKcUlBSVFLaG9nQUNBQUtBSndJQUpyTmdKd0lBQWdBQ2dDYkNBQ2F5SUZOZ0pzSUFBZ0FDZ0NYQ0FDYXpZQ1hDQUFLQUpFSUFBb0Frd2lBMEVCZEdvaEFRTkFJQUZCZm1vaUFVRUFJQUV2QVFBaUJ5QUNheUlHSUFZZ0Iwc2JPd0VBSUFOQmYyb2lBdzBBQ3lBQUtBSkFJQUpCQVhScUlRRWdBaUVEQTBBZ0FVRithaUlCUVFBZ0FTOEJBQ0lISUFKcklnWWdCaUFIU3hzN0FRQWdBMEYvYWlJRERRQUxJQUlnQkdvaEJBc0NRQ0FBS0FJQUlnRW9BZ1JGRFFBZ0FDQUJJQUFvQW5RZ0FDZ0NPQ0FGYW1vZ0JCQ2VCQ0FBS0FKMGFpSUZOZ0owQWtBZ0FDZ0N0QzBpQXlBRmFrRURTUTBBSUFBZ0FDZ0NPQ0lISUFBb0Ftd2dBMnNpQVdvaUJDMEFBQ0lHTmdKSUlBQWdBQ2dDVkNJSklBUXRBQUVnQmlBQUtBSllJZ1owYzNFaUJEWUNTQU5BSUFORkRRRWdBQ0FCSUFkcUxRQUNJQVFnQm5SeklBbHhJZ1EyQWtnZ0FDZ0NRQ0FBS0FJMElBRnhRUUYwYWlBQUtBSkVJQVJCQVhScUlnb3ZBUUE3QVFBZ0NpQUJPd0VBSUFBZ0EwRi9haUlETmdLMExTQUJRUUZxSVFFZ0F5QUZha0VDU3cwQUN3c2dCVUdGQWtzTkFDQUFLQUlBS0FJRVJRMEFJQUFvQWl3aEFRd0JDd3NDUUNBQUtBSThJZ01nQUNnQ3dDMGlBazBOQUNBQ0lBQW9BblFnQUNnQ2JHb2lBVWtFUUNBQUtBSTRJQUZxUVFBZ0F5QUJheUlDUVlJQ0lBSkJnZ0pKR3lJQ0VDZ2FJQUFnQVNBQ2FqWUN3QzBQQ3lBQlFZSUNhaUlCSUFKTkRRQWdBQ2dDT0NBQ2FrRUFJQU1nQW1zaUF5QUJJQUpySWdJZ0FpQURTeHNpQWhBb0dpQUFJQUFvQXNBdElBSnFOZ0xBTFFzTEVRQWdBQ0FCS0FBQU5nQUFJQUJCQkdvTEVRQWdBQ0FCTHdBQU93QUFJQUJCQW1vTFRBRUJmeU1BUVJCcklnRWtBQ0FCUVFBMkFnd0NRQUovSUFGQklDQUFFTFVCSWdBMkFneEJBRUVNSUFBYlJRc0VRQ0FCS0FJTUlnQU5BUXNRL0FOQkFDRUFDeUFCUVJCcUpBQWdBQXRKQVFKL0lBQW9BZ1FpQlVFSWRTRUdJQUFvQWdBaUFDQUJJQVZCQVhFRWZ5QUNLQUlBSUFacUtBSUFCU0FHQ3lBQ2FpQURRUUlnQlVFQ2NSc2dCQ0FBS0FJQUtBSVlFUXNBQ3hZQUFuOGdBQkNSQVFSQUlBQW9BZ0FNQVFzZ0FBc0xzQUVCQVg4Z0FRSi9JQUpCQjAwRVFDQUFLQUlBSUFFb0FnQXRBQUE2QUFBZ0FDZ0NBQ0FCS0FJQUxRQUJPZ0FCSUFBb0FnQWdBU2dDQUMwQUFqb0FBaUFBS0FJQUlBRW9BZ0F0QUFNNkFBTWdBU0FCS0FJQUlBSkJBblFpQWtHUXd3RnFLQUlBYWlJRE5nSUFJQUFvQWdBZ0F5Z0FBRFlBQkNBQktBSUFJQUpCOE1JQmFpZ0NBR3NNQVFzZ0FDZ0NBQ0FCS0FJQUVHY2dBU2dDQUF0QkNHbzJBZ0FnQUNBQUtBSUFRUWhxTmdJQUM5RURBUXAvSXdCQjhBQnJJZ3NrQUNBQVFRaHFJUXhCQVNBRmRDRUtBa0FnQWtGL1JnUkFJQUFnQlRZQ0JDQUFRUUUyQWdBTUFRdEJnSUFFSUFWQmYycDBRUkIxSVEwZ0NrRi9haUlPSVFoQkFTRUdBMEFDUUNBQklBZEJBWFFpRDJvdkFRQWlDVUgvL3dOR0JFQWdEQ0FJUVFOMGFpQUhOZ0lFSUFoQmYyb2hDRUVCSVFrTUFRc2dCa0VBSUEwZ0NVRVFkRUVRZFVvYklRWUxJQXNnRDJvZ0NUc0JBQ0FDSUFkSElRa2dCMEVCYWlFSElBa05BQXNnQUNBRk5nSUVJQUFnQmpZQ0FDQUtRUU4ySUFwQkFYWnFRUU5xSVFsQkFDRUhRUUFoQmdOQUlBRWdCa0VCZEdvdUFRQWlBRUVCVGdSQUlBQkIvLzhEY1NJQVFRRWdBRUVCU3hzaERVRUFJUUFEUUNBTUlBZEJBM1JxSUFZMkFnUURRQ0FISUFscUlBNXhJZ2NnQ0VzTkFBc2dBRUVCYWlJQUlBMUhEUUFMQ3lBQ0lBWkdJUUFnQmtFQmFpRUdJQUJGRFFBTEN5QUtRUUVnQ2tFQlN4c2hBa0VBSVFnRFFDQUxJQXdnQ0VFRGRHb2lBQ2dDQkNJR1FRRjBhaUlCSUFFdkFRQWlBVUVCYWpzQkFDQUFJQVVnQVJBa2F5SUhPZ0FESUFBZ0FTQUhkQ0FLYXpzQkFDQUFJQVFnQmtFQ2RDSUJhaWdDQURvQUFpQUFJQUVnQTJvb0FnQTJBZ1FnQ0VFQmFpSUlJQUpIRFFBTElBdEI4QUJxSkFBTFBBRURmd05BSUFBZ0EwRUNkR29pQWlBQ0tBSUFRUVIwUVg5cUlnSTJBZ0FnQWlBRWFpRUVJQUVnQTBjaEFpQURRUUZxSVFNZ0FnMEFDeUFFQ3dRQUlBQUxIUUFnQUVIQUFFOEVRQ0FBRUNSQkUyb1BDeUFBUWZDbEFXb3RBQUFMVVFBZ0FpQUJheUVDQW44Z0JVVUVRQ0FCSUFJZ0F5QUVJQVlRY1F3QkN5QUJJQUlnQXlBRUlBWVErZ01MSWdVUUlTQUZSWEpGQkVBZ0FTQUZhaUFBYXlJQVFRQWdBQ0FFUVg5cVNSc1BDeUFGQ3g4QUlBQWdBU0FDTHdFQUVFWTJBZ0FnQVJBakdpQUFJQUpCQkdvMkFnUUxOd0VCZnlBRFFkc0xUUVJBSUFBZ0FTQUNJQU1RcWdFUEMwRi9JUVVnQkVFRGNRUi9JQVVGSUFBZ0FTQUNJQU5CQUNBRUVJTUNDd3NqQUVJQUlBRVFUaUFBaFVLSGxhK3ZtTGJlbTU1L2ZrTGozTXFWL003eTlZVi9mQXNOQUNBQklBQkJBblJxS0FJQUMwQUJBWDhqQUVFZ2F5SUFKQUFnQUVFSWFoQzBCRUdnN0FFZ0FDZ0NHRFlDQUVHWTdBRWdBQ2tERURjQ0FFR1E3QUVnQUNrRENEY0NBQ0FBUVNCcUpBQUxQQUFDUUNBQUtBSkVRUUZIQkVBZ0FDZ0NGQ0FBS0FJa2JVRUJTZzBCQ3lBQUVMa0NEd3NnQUJDNEFpQUFRb0dBZ0lCd053TEFFU0FBS0FJc0M2c0RBUU4vSUFFZ0FFRUVhaUlFYWtGL2FrRUFJQUZyY1NJRklBSnFJQUFnQUNnQ0FDSUJha0Y4YWswRWZ5QUFLQUlFSWdNZ0FDZ0NDRFlDQ0NBQUtBSUlJQU0yQWdRZ0JDQUZSd1JBSUFBZ0FFRjhhaWdDQUNJRFFSOTFJQU56YXlJRElBVWdCR3NpQkNBREtBSUFhaUlGTmdJQUlBVkJmSEVnQTJwQmZHb2dCVFlDQUNBQUlBUnFJZ0FnQVNBRWF5SUJOZ0lBQ3dKQUlBSkJHR29nQVUwRVFDQUFJQUpxUVFocUlnTWdBU0FDYXlJQlFYaHFJZ1EyQWdBZ0JFRjhjU0FEYWtGOGFrRUhJQUZyTmdJQUlBTUNmeUFES0FJQVFYaHFJZ0ZCL3dCTkJFQWdBVUVEZGtGL2Fnd0JDeUFCWnlFRUlBRkJIU0FFYTNaQkJITWdCRUVDZEd0QjdnQnFJQUZCL3g5TkRRQWFJQUZCSGlBRWEzWkJBbk1nQkVFQmRHdEJ4d0JxSWdGQlB5QUJRVDlKR3dzaUFVRUVkQ0lFUVlEdEFXbzJBZ1FnQXlBRVFZanRBV29pQkNnQ0FEWUNDQ0FFSUFNMkFnQWdBeWdDQ0NBRE5nSUVRWWoxQVVHSTlRRXBBd0JDQVNBQnJZYUVOd01BSUFBZ0FrRUlhaUlCTmdJQUlBRkJmSEVnQUdwQmZHb2dBVFlDQUF3QkN5QUFJQUZxUVh4cUlBRTJBZ0FMSUFCQkJHb0ZJQU1MQzBzQkFuOGdBQ2dDQkNJR1FRaDFJUWNnQUNnQ0FDSUFJQUVnQWlBR1FRRnhCSDhnQXlnQ0FDQUhhaWdDQUFVZ0J3c2dBMm9nQkVFQ0lBWkJBbkViSUFVZ0FDZ0NBQ2dDRkJFTUFBdGRBUUYvSUFBb0FoQWlBMFVFUUNBQVFRRTJBaVFnQUNBQ05nSVlJQUFnQVRZQ0VBOExBa0FnQVNBRFJnUkFJQUFvQWhoQkFrY05BU0FBSUFJMkFoZ1BDeUFBUVFFNkFEWWdBRUVDTmdJWUlBQWdBQ2dDSkVFQmFqWUNKQXNMSUFBQ1FDQUFLQUlFSUFGSERRQWdBQ2dDSEVFQlJnMEFJQUFnQWpZQ0hBc0xvZ0VBSUFCQkFUb0FOUUpBSUFBb0FnUWdBa2NOQUNBQVFRRTZBRFFnQUNnQ0VDSUNSUVJBSUFCQkFUWUNKQ0FBSUFNMkFoZ2dBQ0FCTmdJUUlBTkJBVWNOQVNBQUtBSXdRUUZIRFFFZ0FFRUJPZ0EyRHdzZ0FTQUNSZ1JBSUFBb0FoZ2lBa0VDUmdSQUlBQWdBellDR0NBRElRSUxJQUFvQWpCQkFVY2dBa0VCUjNJTkFTQUFRUUU2QURZUEN5QUFRUUU2QURZZ0FDQUFLQUlrUVFGcU5nSWtDd3MzQVFKL0lBQkIvT01CTmdJQUFuOGdBQ2dDQkVGMGFpSUNJZ0VnQVNnQ0NFRi9haUlCTmdJSUlBRkJmMHdMQkVBZ0FoQTRDeUFBQzRvUkFnOS9BWDRqQUVIUUFHc2lCU1FBSUFVZ0FUWUNUQ0FGUVRkcUlSTWdCVUU0YWlFUlFRQWhBUUpBQTBBQ1FDQU5RUUJJRFFBZ0FVSC8vLy8vQnlBTmEwb0VRRUd3N0FGQlBUWUNBRUYvSVEwTUFRc2dBU0FOYWlFTkN5QUZLQUpNSWdraEFRSkFBa0FDUUNBSkxRQUFJZ1lFUUFOQUFrQUNRQ0FHUWY4QmNTSUdSUVJBSUFFaEJnd0JDeUFHUVNWSERRRWdBU0VHQTBBZ0FTMEFBVUVsUncwQklBVWdBVUVDYWlJSE5nSk1JQVpCQVdvaEJpQUJMUUFDSVFvZ0J5RUJJQXBCSlVZTkFBc0xJQVlnQ1dzaEFTQUFCRUFnQUNBSklBRVFaZ3NnQVEwR0lBVW9Ba3dpQjBFQmFpRUJRWDhoRHdKQUlBY3NBQUVpQmhCdVJRMEFJQWN0QUFKQkpFY05BQ0FIUVFOcUlRRWdCa0ZRYWlFUFFRRWhFZ3NnQlNBQk5nSk1RUUFoRGdKQUlBRXNBQUFpQ2tGZ2FpSUhRUjlMQkVBZ0FTRUdEQUVMSUFFaEJrRUJJQWQwSWdkQmlkRUVjVVVOQUFOQUlBVWdBVUVCYWlJR05nSk1JQWNnRG5JaERpQUJMQUFCSWdwQllHb2lCMEVnVHcwQklBWWhBVUVCSUFkMElnZEJpZEVFY1EwQUN3c0NRQ0FLUVNwR0JFQUNmd0pBSUFZc0FBRWlBUkJ1UlEwQUlBWXRBQUpCSkVjTkFDQUJRUUowSUFScVFjQitha0VLTmdJQUlBWkJBMm9oQVNBR0xBQUJRUU4wSUFOcVFZQjlhaWdDQUNFTFFRRU1BUXNnRWcwR0lBWkJBV29oQVNBQVJRUkFJQVVnQVRZQ1RFRUFJUkpCQUNFTERBTUxJQUlnQWlnQ0FDSUdRUVJxTmdJQUlBWW9BZ0FoQzBFQUN5RVNJQVVnQVRZQ1RDQUxRWDlLRFFGQkFDQUxheUVMSUE1QmdNQUFjaUVPREFFTElBVkJ6QUJxRUx3QklndEJBRWdOQkNBRktBSk1JUUVMUVg4aENBSkFJQUV0QUFCQkxrY05BQ0FCTFFBQlFTcEdCRUFDUUFKQUlBRXNBQUlpQmhCdVJRMEFJQUV0QUFOQkpFY05BQ0FHUVFKMElBUnFRY0IrYWtFS05nSUFJQUVzQUFKQkEzUWdBMnBCZ0gxcUtBSUFJUWdnQVVFRWFpRUJEQUVMSUJJTkJpQUJRUUpxSVFFZ0FFVUVRRUVBSVFnTUFRc2dBaUFDS0FJQUlnWkJCR28yQWdBZ0JpZ0NBQ0VJQ3lBRklBRTJBa3dNQVFzZ0JTQUJRUUZxTmdKTUlBVkJ6QUJxRUx3QklRZ2dCU2dDVENFQkMwRUFJUWNEUUNBSElSQkJmeUVNSUFFaUNpd0FBRUcvZjJwQk9Vc05DQ0FGSUFwQkFXb2lBVFlDVENBS0xBQUFJQkJCT214cVFmL1BBV290QUFBaUIwRi9ha0VJU1EwQUN3SkFBa0FnQjBFVFJ3UkFJQWRGRFFvZ0QwRUFUZ1JBSUFRZ0QwRUNkR29nQnpZQ0FDQUZJQU1nRDBFRGRHb3BBd0EzQTBBTUFnc2dBRVVOQ0NBRlFVQnJJQWNnQWhDN0FRd0NDeUFQUVg5S0RRa0xRUUFoQVNBQVJRMEhDeUFPUWYvL2UzRWlCaUFPSUE1QmdNQUFjUnNoQjBFQUlReEJrTlFCSVE4Z0VTRU9Ba0FDUUFKQUFuOENRQUpBQWtBQ1FBSi9Ba0FDUUFKQUFrQUNRQUpBQWtBZ0Npd0FBQ0lCUVY5eElBRWdBVUVQY1VFRFJoc2dBU0FRR3lJQlFhaC9hZzRoQkJRVUZCUVVGQlFVRGhRUEJnNE9EaFFHRkJRVUZBSUZBeFFVQ1JRQkZCUUVBQXNDUUNBQlFiOS9hZzRIRGhRTEZBNE9EZ0FMSUFGQjB3QkdEUWtNRXdzZ0JTa0RRQ0VVUVpEVUFRd0ZDMEVBSVFFQ1FBSkFBa0FDUUFKQUFrQUNRQ0FRUWY4QmNRNElBQUVDQXdRYUJRWWFDeUFGS0FKQUlBMDJBZ0FNR1FzZ0JTZ0NRQ0FOTmdJQURCZ0xJQVVvQWtBZ0RhdzNBd0FNRndzZ0JTZ0NRQ0FOT3dFQURCWUxJQVVvQWtBZ0RUb0FBQXdWQ3lBRktBSkFJQTAyQWdBTUZBc2dCU2dDUUNBTnJEY0RBQXdUQ3lBSVFRZ2dDRUVJU3hzaENDQUhRUWh5SVFkQitBQWhBUXNnQlNrRFFDQVJJQUZCSUhFUTJ3SWhDU0FIUVFoeFJRMERJQVVwQTBCUURRTWdBVUVFZGtHUTFBRnFJUTlCQWlFTURBTUxJQVVwQTBBZ0VSRGFBaUVKSUFkQkNIRkZEUUlnQ0NBUklBbHJJZ0ZCQVdvZ0NDQUJTaHNoQ0F3Q0N5QUZLUU5BSWhSQ2YxY0VRQ0FGUWdBZ0ZIMGlGRGNEUUVFQklReEJrTlFCREFFTElBZEJnQkJ4QkVCQkFTRU1RWkhVQVF3QkMwR1MxQUZCa05RQklBZEJBWEVpREJzTElROGdGQ0FSRU5rQ0lRa0xJQWRCLy85N2NTQUhJQWhCZjBvYklRY2dDQ0FGS1FOQUloUlFSWEpGQkVCQkFDRUlJQkVoQ1F3TUN5QUlJQlJRSUJFZ0NXdHFJZ0VnQ0NBQlNoc2hDQXdMQ3lBRktBSkFJZ0ZCbXRRQklBRWJJZ2tnQ0JEWUFpSUJJQWdnQ1dvZ0FSc2hEaUFHSVFjZ0FTQUpheUFJSUFFYklRZ01DZ3NnQ0FSQUlBVW9Ba0FNQWd0QkFDRUJJQUJCSUNBTFFRQWdCeEJlREFJTElBVkJBRFlDRENBRklBVXBBMEErQWdnZ0JTQUZRUWhxTmdKQVFYOGhDQ0FGUVFocUN5RUdRUUFoQVFKQUEwQWdCaWdDQUNJSlJRMEJJQVZCQkdvZ0NSQzZBU0lLUVFCSUlna2dDaUFJSUFGclMzSkZCRUFnQmtFRWFpRUdJQWdnQVNBS2FpSUJTdzBCREFJTEMwRi9JUXdnQ1EwTEN5QUFRU0FnQ3lBQklBY1FYaUFCUlFSQVFRQWhBUXdCQzBFQUlRb2dCU2dDUUNFR0EwQWdCaWdDQUNJSlJRMEJJQVZCQkdvZ0NSQzZBU0lKSUFwcUlnb2dBVW9OQVNBQUlBVkJCR29nQ1JCbUlBWkJCR29oQmlBS0lBRkpEUUFMQ3lBQVFTQWdDeUFCSUFkQmdNQUFjeEJlSUFzZ0FTQUxJQUZLR3lFQkRBZ0xJQUFnQlNzRFFDQUxJQWdnQnlBQlFRQVJJQUFoQVF3SEN5QUZJQVVwQTBBOEFEZEJBU0VJSUJNaENTQUdJUWNNQkFzZ0JTQUJRUUZxSWdjMkFrd2dBUzBBQVNFR0lBY2hBUXdBQ3dBTElBMGhEQ0FBRFFRZ0VrVU5Ba0VCSVFFRFFDQUVJQUZCQW5ScUtBSUFJZ0FFUUNBRElBRkJBM1JxSUFBZ0FoQzdBVUVCSVF3Z0FVRUJhaUlCUVFwSERRRU1CZ3NMUVFFaERDQUJRUXBQRFFSQkFDRUdBMEFnQmcwQklBRkJBV29pQVVFS1JnMEZJQVFnQVVFQ2RHb29BZ0FoQmd3QUN3QUxRWDhoREF3REN5QUFRU0FnRENBT0lBbHJJZ29nQ0NBSUlBcElHeUlHYWlJUUlBc2dDeUFRU0JzaUFTQVFJQWNRWGlBQUlBOGdEQkJtSUFCQk1DQUJJQkFnQjBHQWdBUnpFRjRnQUVFd0lBWWdDa0VBRUY0Z0FDQUpJQW9RWmlBQVFTQWdBU0FRSUFkQmdNQUFjeEJlREFFTEMwRUFJUXdMSUFWQjBBQnFKQUFnREFzV0FDQUFSUVJBUVFBUEMwR3c3QUVnQURZQ0FFRi9DeUlCQVg4akFFRVFheUlCSUFBMkFnZ2dBU0FCS0FJSUtBSUVOZ0lNSUFFb0Fnd0xDZ0FnQUMwQUMwRUhkZ3NSQUNBQUVKRUJCRUFnQUNnQ0FCQTRDd3ZZQVFFSWYwRzZmeUVKQWtBZ0FDQUNLQUlFSWdnZ0FpZ0NBQ0lLYWlJTmFpQUJTdzBBUVd3aENTQURLQUlBSWc0Z0Ntb2lEeUFFU3cwQUlBQWdDbW9pQkNBQ0tBSUlJZ3RySVF3Z0FDQUJRV0JxSWdFZ0RpQUtRUUFReEFFZ0F5QVBOZ0lBQWtBQ1FDQUxJQVFnQld0TkJFQWdEQ0VGREFFTElBc2dCQ0FHYTBzTkFpQUhJQXdnQldzaUEyb2lBQ0FJYWlBSFRRUkFJQVFnQUNBSUVFb2FEQUlMSUFRZ0FFRUFJQU5yRUVvaEFDQUNJQU1nQ0dvaUNEWUNCQ0FBSUFOcklRUUxJQVFnQVNBRklBaEJBUkRFQVFzZ0RTRUpDeUFKQzR3Q0FRSi9Jd0JCZ0FGcklnNGtBQ0FPSUFNMkFueEJmeUVOQWtBQ1FBSkFBa0FDUUNBQ0RnUUJBQU1DQkFzZ0JrVUVRRUc0ZnlFTkRBUUxRV3doRFNBRkxRQUFJZ0lnQTBzTkF5QUFJQWNnQWtFQ2RDSUNhaWdDQUNBQ0lBaHFLQUlBRVBnQ0lBRWdBRFlDQUVFQklRME1Bd3NnQVNBSk5nSUFRUUFoRFF3Q0N5QUtSUVJBUVd3aERRd0NDMEVBSVEwZ0MwVWdERUVaU0hJTkFVRUlJQVIwUVFocUlRQkJBQ0VEQTBBZ0EwRkFheUlESUFCSkRRQUxEQUVMUVd3aERTQU9JQTVCL0FCcUlBNUIrQUJxSUFVZ0JoQnJJZ0lRSVEwQUlBNG9BbmdpQXlBRVN3MEFJQUFnRGlBT0tBSjhJQWNnQ0NBREVIMGdBU0FBTmdJQUlBSWhEUXNnRGtHQUFXb2tBQ0FOQ3hBQUlBQXZBQUFnQUMwQUFrRVFkSElMRVFBZ0FDQUJRUVJxSUFFb0FnQVE1Z0lMWGdFQmYwRzRmeUVESUFJUWFTSUNJQUZOQkg4Z0FDQUNha0YvYWkwQUFDSUFRUU54UVFKMFFjQ3JBV29vQWdBZ0Ftb2dBRUVHZGlJQlFRSjBRZENyQVdvb0FnQnFJQUJCSUhGQkJYWWlBRUVCYzJvZ0FDQUJSWEZxQlNBREN3c1ZBQ0FBSUFGQkEzUnFLQUlFUWYvL0EycEJFSFlMZGdFQ2Z5TUFRU0JySWdVa0FDQUJJQUlnQkNnQ0VDSUdFTmdCUVg4Z0JuUkJmM05HQkVBZ0FDZ0NHQ0VHSUFBb0FoUWhBQ0FGSUFRcEFoQTNBeGdnQlNBRUtRSUlOd01RSUFVZ0JDa0NBRGNEQ0NBQUlBWWdBU0FDRU5jQklBTWdBU0FDRU5VQklBVkJDR29RcHdNTElBVkJJR29rQUF1YUFRQUNmd0pBQWtBQ1FDQUFLQUtFQVVGN2FnNERBUUlDQUF0QkFDQUFLQUlFSUFBb0FoaHFJQUZMRFFJYUlBQWdBVUVFRUZRZ0FDQUJJQUlnQTBFRVFRRVFVdzhMUVFBZ0FDZ0NCQ0FBS0FJWWFpQUJTdzBCR2lBQUlBRkJCUkJVSUFBZ0FTQUNJQU5CQlVFQkVGTVBDMEVBSUFBb0FnUWdBQ2dDR0dvZ0FVc05BQm9nQUNBQlFRWVFWQ0FBSUFFZ0FpQURRUVpCQVJCVEN3dWFBUUFDZndKQUFrQUNRQ0FBS0FLRUFVRjdhZzREQVFJQ0FBdEJBQ0FBS0FJRUlBQW9BaGhxSUFGTERRSWFJQUFnQVVFRUVGUWdBQ0FCSUFJZ0EwRUVRUUlRVXc4TFFRQWdBQ2dDQkNBQUtBSVlhaUFCU3cwQkdpQUFJQUZCQlJCVUlBQWdBU0FDSUFOQkJVRUNFRk1QQzBFQUlBQW9BZ1FnQUNnQ0dHb2dBVXNOQUJvZ0FDQUJRUVlRVkNBQUlBRWdBaUFEUVFaQkFoQlRDd3VhQVFBQ2Z3SkFBa0FDUUNBQUtBS0VBVUY3YWc0REFRSUNBQXRCQUNBQUtBSUVJQUFvQWhocUlBRkxEUUlhSUFBZ0FVRUVFRlFnQUNBQklBSWdBMEVFUVFBUVV3OExRUUFnQUNnQ0JDQUFLQUlZYWlBQlN3MEJHaUFBSUFGQkJSQlVJQUFnQVNBQ0lBTkJCVUVBRUZNUEMwRUFJQUFvQWdRZ0FDZ0NHR29nQVVzTkFCb2dBQ0FCUVFZUVZDQUFJQUVnQWlBRFFRWkJBQkJUQ3d0NkFRTi9RYnAvSVFVZ0EwSC9IMHRCQWtFQklBTkJIMHNiYWlJRUlBTnFJZ1lnQVUwRWZ3SkFBa0FDUUFKQUlBUkJmMm9PQXdBQkFnTUxJQUFnQTBFRGREb0FBQXdDQ3lBQUlBTkJCSFJCQkhKQjlQOERjUkF2REFFTElBQWdBMEVFZEVFTWNoQk5DeUFBSUFScUlBSWdBeEFxR2lBR0JTQUZDd3M1QVFKL0lBQW9BaFFoQXlBQUtBSU1JUUlnQUVFQ0VPRUJJQUVnQW1vaUFTQURTd1JBSUFCQkFUWUNHRUVBRHdzZ0FDQUJOZ0lNSUFJTFRBRUJmeUFCRU9NQklRRUNRQ0FBS0FJZ1JRUkFJQUFvQWdnaUFpQUJhaUlCSUFBb0FnUk5EUUVMSUFCQkFUWUNHRUVBRHdzZ0FDQUJOZ0lRSUFBZ0FUWUNEQ0FBSUFFMkFnZ2dBZ3ZqQXdFR2Z5QUJRUkJ0SVFnZ0FVRVFUZ1JBQTBBZ0FDQUdRUUowSWdWcUlnRkJBQ0FCS0FJQUlnRWdBbXNpQXlBRElBRkxHellDQUNBQUlBVkJCSEpxSWdGQkFDQUJLQUlBSWdNZ0Ftc2lCQ0FFSUFOTEd6WUNBQ0FCUVFBZ0FTZ0NCQ0lCSUFKcklnTWdBeUFCU3hzMkFnUWdBQ0FGUVF4eWFpSUJRUUFnQVNnQ0FDSURJQUpySWdRZ0JDQURTeHMyQWdBZ0FVRUFJQUVvQWdRaUF5QUNheUlFSUFRZ0Ewc2JOZ0lFSUFGQkFDQUJLQUlJSWdNZ0Ftc2lCQ0FFSUFOTEd6WUNDQ0FCUVFBZ0FTZ0NEQ0lCSUFKcklnTWdBeUFCU3hzMkFnd2dBQ0FGUVJ4eWFpSUJRUUFnQVNnQ0FDSURJQUpySWdRZ0JDQURTeHMyQWdBZ0FVRUFJQUVvQWdRaUF5QUNheUlFSUFRZ0Ewc2JOZ0lFSUFGQkFDQUJLQUlJSWdNZ0Ftc2lCQ0FFSUFOTEd6WUNDQ0FCUVFBZ0FTZ0NEQ0lESUFKcklnUWdCQ0FEU3hzMkFnd2dBVUVBSUFFb0FoQWlBeUFDYXlJRUlBUWdBMHNiTmdJUUlBRkJBQ0FCS0FJVUlnTWdBbXNpQkNBRUlBTkxHellDRkNBQlFRQWdBU2dDR0NJRElBSnJJZ1FnQkNBRFN4czJBaGdnQVVFQUlBRW9BaHdpQVNBQ2F5SURJQU1nQVVzYk5nSWNJQUFnQlVFOGNtb2lBVUVBSUFFb0FnQWlBU0FDYXlJRklBVWdBVXNiTmdJQUlBWkJFR29oQmlBSFFRRnFJZ2NnQ0VjTkFBc0xDNUlDQVFKL0l3QkI4QUJySWhBa0FFRi9JUThDUUFKQUFrQUNRQUpBSUFRT0JBSUFBd0VFQ3lBQ0lBWkIvd0Z4RUljRVFRQWhEMEVBRUNFTkF5QUJSUVJBUWJwL0lROE1CQXNnQUNBSExRQUFPZ0FBUVFFaER3d0RDeUFDSUF3Z0RSQXFHa0VBSVE4TUFnc2dBaUFKSUFzZ0NpQU9RWUF3RUtrQklnQVFJU0VCSUJCQjhBQnFKQUFnQUVFQUlBRWJEd3NnRUNBRElBZ2dCaENuQVNJRUlBVWdCU0FISUFoQmYyb2lBMm90QUFCQkFuUnFJZ2NvQWdBaUNVRUNUd1IvSUFjZ0NVRi9hallDQUNBREJTQUlDeUFHRUtZQklnOFFJUTBBSUFBZ0FTQVFJQVlnQkJDb0FTSVBFQ0VOQUNBQ0lCQWdCaUFFSUE1QmdEQVFxUUVpQUNBUElBQVFJUnNoRHdzZ0VFSHdBR29rQUNBUEMrQUJBQUpBSUFNZ0JFY0VRQUpBQWtBZ0NrRURUUVJBSUFsRkRRRWdCRUhuQjAwRVFFRURJUWtnQUNnQ0FFRUNSZzBEQzBFS0lBcHJJQWgwUVFOMklBUkxEUVFnQkNBSVFYOXFkaUFEVFEwQkRBUUxRWDhoQ2tGL0lRTWdDUVJBSUFjZ0NDQUJJQUlRelFNaEF3dEJBeUVKQW44Z0FDZ0NBQVJBSUFZZ0FTQUNFTXdESVFvTElBTWdDazBMUVFBZ0F5QUJJQUlnQkNBRkVNc0RRUU4wSUFFZ0FpQUVFTW9EYWlJQlRSc05BeUFLSUFGTkRRRUxJQUJCQVRZQ0FFRUNJUWtMSUFrUEN5QUFRUUEyQWdBZ0NVVWdBMEVDUzNJUEN5QUFRUUEyQWdCQkFBc1hBQ0FBSUFGQi8vOERjUkF2SUFBZ0FVRVFkam9BQWdzNEFRRi9JQUJDQURjQ0NDQUFRZ0EzQWhBZ0FFSUFOd0lZSUFCQkFEWUNJQ0FBS0FJQUlRUWdBRUlBTndJQUlBUWdBU0FDSUFNUVpBdkJBUUVEZndKQUlBSW9BaEFpQXdSL0lBTUZJQUlRaFFRTkFTQUNLQUlRQ3lBQ0tBSVVJZ1ZySUFGSkJFQWdBaUFBSUFFZ0FpZ0NKQkVCQUE4TEFrQWdBaXdBUzBFQVNBUkFRUUFoQXd3QkN5QUJJUVFEUUNBRUlnTkZCRUJCQUNFRERBSUxJQUFnQTBGL2FpSUVhaTBBQUVFS1J3MEFDeUFDSUFBZ0F5QUNLQUlrRVFFQUlnUWdBMGtOQVNBQUlBTnFJUUFnQVNBRGF5RUJJQUlvQWhRaEJRc2dCU0FBSUFFUUtob2dBaUFDS0FJVUlBRnFOZ0lVSUFFZ0Eyb2hCQXNnQkF2OUFnSUlmd1YrQWtBQ2YwRi9JQUZCQ3lBQkd5SUdRUVZKRFFBYVFWUWdCa0VNU3cwQUdrRi9JQVlnQXlBRUVJQUNTUTBBR2lBRElBWjJJUXhCQVNBR2RDRUhRb0NBZ0lDQWdJQ0F3QUFnQTYyQUlRNUJQaUFHYTYwaURVSnNmQ0VQUVFBaEFRSkFBMEFnQWlBQlFRSjBhaWdDQUNJRklBTkdEUUVDUUNBRlJRUkFJQUFnQVVFQmRHcEJBRHNCQUF3QkN5QUZJQXhOQkVBZ0FDQUJRUUYwYWtILy93TTdBUUFnQjBGL2FpRUhEQUVMSUE0Z0JhMStJaEFnRFlnaUVhY2lCVUgvL3dOeElncEJCMDBFUUNBUUlCRkMvLzhEZ3lBTmhuMGdDa0VDZEVIZ2hBRnFOUUlBSUErR1ZpQUZhaUVGQ3lBQUlBRkJBWFJxSUFVN0FRQWdCU0FJSUFWQkVIUkJFSFVpQlNBSVFSQjBRUkIxU2lJS0d5RUlJQUVnQ1NBS0d5RUpJQWNnQldzaEJ3c2dBVUVCYWlJQklBUk5EUUFMSUFBZ0NVRUJkR29pQVM0QkFDSUZRUUYxUVFBZ0IydEtEUUlnQmlJRklBQWdCU0FDSUFNZ0JCQ0lCQ0lMRUNGRkRRRWFDeUFMQ3c4TElBRWdCU0FIYWpzQkFDQUdDdzBBSUFBZ0FTQUNRUUlRZ1FJTFVnQUNmMEZVSUFSQkRFc05BQnBCZnlBRVFRVkpEUUFhSUFOQkFXb2dCR3hCQTNaQkEycEJnQVFnQXhzZ0FVc0VRQ0FBSUFFZ0FpQURJQVJCQUJDQ0FnOExJQUFnQVNBQ0lBTWdCRUVCRUlJQ0N3dklCQUVLZnlNQVFaQUlheUlKSkFCQkFTRUdRVlFoQjBFQklBTjBJZ2dnQlUwRVFDQUlRUUYySWd4QkFTQURHMEVDZENFS0lBQWdBenNCQUNBQVFRUnFJZzVCZm1vZ0Fqc0JBRUVBSVFBZ0NVRUFOZ0lBSUFoQmYyb2lCU0VISUFKQkFXb2lDeUFDVHdSQUlBVWhCd05BSUFrZ0JrRUNkR29DZnlBQklBWkJmMm9pRFVFQmRHb3VBUUFpRDBGL1JnUkFJQVFnQjJvZ0RUb0FBQ0FIUVg5cUlRY2dBRUVCYWd3QkN5QUFJQTlxQ3lJQU5nSUFJQVpCQVdvaUJpQUxUUTBBQ3dzZ0NpQU9haUVLSUFrZ0MwRUNkR29nQ0VFQmFqWUNBQ0FJUVFOMklBeHFRUU5xSVF4QkFDRUFRUUFoQmdOQUlBRWdBRUVCZEdvdUFRQWlEVUVCVGdSQVFRQWhDd05BSUFRZ0Jtb2dBRG9BQUFOQUlBWWdER29nQlhFaUJpQUhTdzBBQ3lBTFFRRnFJZ3NnRFVjTkFBc0xJQUJCQVdvaUFDQUNUUTBBQ3lBSVFRRWdDRUVCU3hzaEFFRUFJUVlEUUNBSklBUWdCbW90QUFCQkFuUnFJZ1VnQlNnQ0FDSUZRUUZxTmdJQUlBNGdCVUVCZEdvZ0JpQUlhanNCQUNBR1FRRnFJZ1lnQUVjTkFBc2dBMEVRZENBSWF5SUVRWUNBQkdvaEJVRUFJUVpCQUNFSEEwQUNRQUpBQWtBQ1FDQUJJQVpCQVhScUxnRUFJZ0JCQVdvT0F3RUFBUUlMSUFvZ0JrRURkR29nQlRZQ0JBd0NDeUFLSUFaQkEzUnFJZ0FnQjBGL2FqWUNBQ0FBSUFRMkFnUWdCMEVCYWlFSERBRUxJQW9nQmtFRGRHb2lDQ0FISUFCck5nSUFJQWdnQXlBQVFYOXFFQ1JySWdoQkVIUWdBQ0FJZEdzMkFnUWdBQ0FIYWlFSEN5QUdRUUZxSWdZZ0FrME5BQXRCQUNFSEN5QUpRWkFJYWlRQUlBY0xyd0VCQW44Z0FFRUFJQUVvQWdBaUFFRUNkRUVFYWhBb0lRUWdBd1JBSUFOQkFFb0VRQ0FDSUFOcUlRTURRQ0FFSUFJdEFBQkJBblJxSWdVZ0JTZ0NBRUVCYWpZQ0FDQUNRUUZxSWdJZ0Ewa05BQXNMQTBBZ0FDSUNRWDlxSVFBZ0JDQUNRUUowYWlnQ0FFVU5BQXNnQVNBQ05nSUFRUUFoQTBFQUlRQURRQ0FFSUFOQkFuUnFLQUlBSWdFZ0FDQUJJQUJMR3lFQUlBTkJBV29pQXlBQ1RRMEFDeUFBRHdzZ0FVRUFOZ0lBUVFBTEN3QWdBQ0FCSUFJUUtob0xtZzBCRjM4akFFRkFhaUlIUWdBM0F6QWdCMElBTndNNElBZENBRGNESUNBSFFnQTNBeWdDUUFKQUFuOENRQUpBSUFJRVFBTkFJQWRCSUdvZ0FTQUlRUUYwYWk4QkFFRUJkR29pQmlBR0x3RUFRUUZxT3dFQUlBaEJBV29pQ0NBQ1J3MEFDeUFFS0FJQUlRaEJEeUVLSUFjdkFUNGlEQTBDSUFjdkFUeEZEUUZCRGlFS1FRQWhEQXdDQ3lBRUtBSUFJUWdMUVEwaENrRUFJUXdnQnk4Qk9nMEFRUXdoQ2lBSEx3RTREUUJCQ3lFS0lBY3ZBVFlOQUVFS0lRb2dCeThCTkEwQVFRa2hDaUFITHdFeURRQkJDQ0VLSUFjdkFUQU5BRUVISVFvZ0J5OEJMZzBBUVFZaENpQUhMd0VzRFFCQkJTRUtJQWN2QVNvTkFFRUVJUW9nQnk4QktBMEFRUU1oQ2lBSEx3RW1EUUJCQWlFS0lBY3ZBU1FOQUNBSEx3RWlJZ3RGQkVBZ0F5QURLQUlBSWdCQkJHbzJBZ0FnQUVIQUFqWUJBQ0FESUFNb0FnQWlBRUVFYWpZQ0FDQUFRY0FDTmdFQUlBUkJBVFlDQUF3REN5QUlRUUJISVE1QkFTRUtRUUVoQ0VFQURBRUxJQW9nQ0NBSUlBcExHeUVPUVFFaENBSkFBMEFnQjBFZ2FpQUlRUUYwYWk4QkFBMEJJQWhCQVdvaUNDQUtSdzBBQ3lBS0lRZ0xJQWN2QVNJaEMwRUJDeUVRUVg4aENTQUxRZi8vQTNFaUJrRUNTdzBCUVFRZ0J5OEJKQ0lSSUFaQkFYUnFheUlHUVFCSURRRWdCa0VCZENBSEx3RW1JaEpySWdaQkFFZ05BU0FHUVFGMElBY3ZBU2dpRTJzaUJrRUFTQTBCSUFaQkFYUWdCeThCS2lJVWF5SUdRUUJJRFFFZ0JrRUJkQ0FITHdFc0loVnJJZ1pCQUVnTkFTQUdRUUYwSUFjdkFTNGlHR3NpQmtFQVNBMEJJQVpCQVhRZ0J5OEJNQ0liYXlJR1FRQklEUUVnQmtFQmRDQUhMd0V5SWh4cklnWkJBRWdOQVNBR1FRRjBJQWN2QVRRaURXc2lCa0VBU0EwQklBWkJBWFFnQnk4Qk5pSVdheUlHUVFCSURRRWdCa0VCZENBSEx3RTRJaGRySWdaQkFFZ05BU0FHUVFGMElBY3ZBVG9pR1dzaUJrRUFTQTBCSUFaQkFYUWdCeThCUENJYWF5SUdRUUJJRFFFZ0JrRUJkQ0FNYXlJR1FRQklJQVpCQUNBQVJTQVFjaHR5RFFGQkFDRUpJQWRCQURzQkFpQUhJQXM3QVFRZ0J5QUxJQkZxSWdZN0FRWWdCeUFHSUJKcUlnWTdBUWdnQnlBR0lCTnFJZ1k3QVFvZ0J5QUdJQlJxSWdZN0FRd2dCeUFHSUJWcUlnWTdBUTRnQnlBR0lCaHFJZ1k3QVJBZ0J5QUdJQnRxSWdZN0FSSWdCeUFHSUJ4cUlnWTdBUlFnQnlBR0lBMXFJZ1k3QVJZZ0J5QUdJQlpxSWdZN0FSZ2dCeUFHSUJkcUlnWTdBUm9nQnlBR0lCbHFJZ1k3QVJ3Z0J5QUdJQnBxT3dFZUlBSUVRQU5BSUFFZ0NVRUJkR292QVFBaUJnUkFJQWNnQmtFQmRHb2lCaUFHTHdFQUlnWkJBV283QVFBZ0JTQUdRUUYwYWlBSk93RUFDeUFKUVFGcUlna2dBa2NOQUFzTElBZ2dEaUFPSUFoSkd5RU5RUk1oRGtFQUlSUWdCU0VXSUFVaEYwRUFJUkFDUUFKQUFrQWdBQTRDQWdBQkMwRUJJUWtnRFVFSlN3MERRWUFDSVE1QjN1b0FJUmRCM3VrQUlSWkJBU0VRREFFTElBQkJBa1loRkVGL0lRNUJvTzRBSVJkQm9PMEFJUllnQUVFQ1J3UkFEQUVMUVFFaENTQU5RUWxMRFFJTFFRRWdEWFFpRVVGL2FpRWJJQU1vQWdBaEVrRUFJUk1nRFNFR1FRQWhDMEYvSVJvRFFFRUJJQVowSVJrQ1FBTkFJQWdnRDJzaEZRSi9RUUFnRGlBRklCTkJBWFJxTHdFQUlnWktEUUFhSUE0Z0JrNEVRRUVBSVFaQjRBQU1BUXNnRmlBR1FRRjBJZ0JxTHdFQUlRWWdBQ0FYYWkwQUFBc2hBQ0FMSUE5MklSeEJmeUFWZENFSklCa2hBZ05BSUJJZ0FpQUphaUlDSUJ4cVFRSjBhaUlZSUFZN0FRSWdHQ0FWT2dBQklCZ2dBRG9BQUNBQ0RRQUxRUUVnQ0VGL2FuUWhDUU5BSUFraUFFRUJkaUVKSUFBZ0MzRU5BQXNnQjBFZ2FpQUlRUUYwYWlJQ0lBSXZBUUJCZjJvaUFqc0JBQ0FBUVg5cUlBdHhJQUJxUVFBZ0FCc2hDeUFUUVFGcUlSTWdBa0gvL3dOeFJRUkFJQWdnQ2tZTkFpQUJJQVVnRTBFQmRHb3ZBUUJCQVhScUx3RUFJUWdMSUFnZ0RVME5BQ0FMSUJ0eElnQWdHa1lOQUF0QkFTQUlJQThnRFNBUEd5SVBheUlHZENFTUlBZ2dDa2tFUUNBS0lBOXJJUUlnQ0NFSkFrQURRQ0FNSUFkQklHb2dDVUVCZEdvdkFRQnJJZ2xCQVVnTkFTQUpRUUYwSVF3Z0JrRUJhaUlHSUE5cUlna2dDa2tOQUFzZ0FpRUdDMEVCSUFaMElRd0xRUUVoQ1NBUUlBd2dFV29pRVVIVUJrdHhJQlFnRVVIUUJFdHhjZzBESUFNb0FnQWlBaUFBUVFKMGFpSUpJQTA2QUFFZ0NTQUdPZ0FBSUFrZ0VpQVpRUUowYWlJU0lBSnJRUUoyT3dFQ0lBQWhHZ3dCQ3dzZ0N3UkFJQklnQzBFQ2RHb2lBRUVBT3dFQ0lBQWdGVG9BQVNBQVFjQUFPZ0FBQ3lBRElBTW9BZ0FnRVVFQ2RHbzJBZ0FnQkNBTk5nSUFDMEVBSVFrTElBa0x5Z0lCQzM4Z0FDQUNRUUowYWtIY0Ztb29BZ0FoQmdKQUlBSkJBWFFpQXlBQUtBTFFLQ0lGU2dSQUlBSWhCQXdCQ3lBQUlBWnFRZGdvYWlFS0lBRWdCa0VDZEdvaEN5QUFRZHdXYWlFSUlBQkIyQ2hxSVFrRFFBSi9JQU1nQXlBRlRnMEFHaUFCSUFnZ0EwRUJjaUlGUVFKMGFpZ0NBQ0lIUVFKMGFpOEJBQ0lFSUFFZ0NDQURRUUowYWlnQ0FDSU1RUUowYWk4QkFDSU5Ud1JBSUFNZ0JDQU5SdzBCR2lBRElBY2dDV290QUFBZ0NTQU1haTBBQUVzTkFSb0xJQVVMSVFRZ0N5OEJBQ0lGSUFFZ0FDQUVRUUowYWtIY0Ztb29BZ0FpQTBFQ2RHb3ZBUUFpQjBrRVFDQUNJUVFNQWdzQ1FDQUZJQWRIRFFBZ0NpMEFBQ0FBSUFOcVFkZ29haTBBQUVzTkFDQUNJUVFNQWdzZ0FDQUNRUUowYWtIY0Ztb2dBellDQUNBRUlnSkJBWFFpQXlBQUtBTFFLQ0lGVEEwQUN3c2dBQ0FFUVFKMGFrSGNGbW9nQmpZQ0FBdXlCUUVLZnlBQktBSUlJZ01vQWdBaEJ5QURLQUlNSVFVZ0FTZ0NBQ0VHSUFCQ2dJQ0FnTkRIQURjQzBDaEJmeUVEQWtBZ0JVRUFTZ1JBQTBBQ1FDQUdJQUpCQW5ScUlnUXZBUUFFUUNBQUlBQW9BdEFvUVFGcUlnTTJBdEFvSUFBZ0EwRUNkR3BCM0JacUlBSTJBZ0FnQUNBQ2FrSFlLR3BCQURvQUFDQUNJUU1NQVFzZ0JFRUFPd0VDQ3lBQ1FRRnFJZ0lnQlVjTkFBc2dBQ2dDMENnaUFrRUJTZzBCQ3dOQUlBQWdBa0VCYWlJQ05nTFFLQ0FBSUFKQkFuUnFRZHdXYWlBRFFRRnFJZ2xCQUNBRFFRSklJZ1FiSWdnMkFnQWdCaUFJUVFKMElnSnFRUUU3QVFBZ0FDQUlha0hZS0dwQkFEb0FBQ0FBSUFBb0FxZ3RRWDlxTmdLb0xTQUhCRUFnQUNBQUtBS3NMU0FDSUFkcUx3RUNhellDckMwTElBa2dBeUFFR3lFRElBQW9BdEFvSWdKQkFrZ05BQXNMSUFFZ0F6WUNCQ0FDUVFGMklRSURRQ0FBSUFZZ0FoQ3RBU0FDUVFGS0lRUWdBa0YvYWlFQ0lBUU5BQXNnQUNnQzBDZ2hBaUFBUWR3V2FpRUtJQUJCMkNocUlRc0RRQ0FBSUFKQmYybzJBdEFvSUFBb0F1QVdJUWNnQUNBS0lBSkJBblJxS0FJQU5nTGdGaUFBSUFaQkFSQ3RBU0FBSUFBb0F0UW9RWDlxSWdJMkF0UW9JQUFvQXVBV0lRUWdDaUFDUVFKMGFpQUhOZ0lBSUFBZ0FDZ0MxQ2hCZjJvaUFqWUMxQ2dnQ2lBQ1FRSjBhaUFFTmdJQUlBWWdCVUVDZEdvZ0JpQUVRUUowYWlJSUx3RUFJQVlnQjBFQ2RHb2lDUzhCQUdvN0FRQWdCU0FMYWlBRUlBdHFMUUFBSWdRZ0J5QUxhaTBBQUNJQ0lBSWdCRWtiUVFGcU9nQUFJQWdnQlRzQkFpQUpJQVU3QVFJZ0FDQUZOZ0xnRmlBQUlBWkJBUkN0QVNBRlFRRnFJUVVnQUNnQzBDZ2lBa0VCU2cwQUN5QUFJQUFvQXRRb1FYOXFJZ0kyQXRRb0lBQWdBa0VDZEdwQjNCWnFJQUFvQXVBV05nSUFJQUFnQVNnQ0FDQUJLQUlFSUFFb0FnZ1FsQVFnQmlBRElBQkJ2QlpxRUpNRUM1Z0NBUU4vUVg0aEFnSkFJQUJGRFFBZ0FDZ0NIQ0lCUlEwQUFrQUNRQ0FCS0FJRUlnTkJ1MzlxRGkwQkFnSUNBUUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBUUlDQWdJQ0FnSUNBZ0lDQVFJQ0FnSUNBZ0lDQWdFQUN5QURRWm9GUmcwQUlBTkJLa2NOQVFzQ2Z3Si9BbjhnQVNnQ0NDSUNCRUFnQUNnQ0tDQUNJQUFvQWlRUkJBQWdBQ2dDSENFQkN5QUJLQUpFSWdJTEJFQWdBQ2dDS0NBQ0lBQW9BaVFSQkFBZ0FDZ0NIQ0VCQ3lBQktBSkFJZ0lMQkVBZ0FDZ0NLQ0FDSUFBb0FpUVJCQUFnQUNnQ0hDRUJDeUFCS0FJNElnSUxCRUFnQUNnQ0tDQUNJQUFvQWlRUkJBQWdBQ2dDSENFQkN5QUFLQUlvSUFFZ0FDZ0NKQkVFQUNBQVFRQTJBaHhCZlVFQUlBTkI4UUJHR3lFQ0N5QUNDeDBBSUFCQkNTQUJJQUZCQVVnYklnQkJEQ0FBUVF4SUd6c0JtSUFRQzZJREFRWi9Jd0JCRUdzaUF5UUFBbjhnQUNnQ0JDSUJJQUFvQWdnaUFrWUVRQ0FBS0FJQUlnSWdBQ2dDRENBQ0tBSUFLQUlRRVFRQUlBQW9BZ0FpQWlBRFFReHFJQUlvQWdBb0Fnd1JBd0FoQVNBQUlBTW9BZ3dpQWpZQ0RDQUNSUVJBSUFCQkFUb0FFRUVBREFJTElBQWdBU0FDYWlJQ05nSUlDd0pBSUFJZ0FXc2lBaUFCTFFBQVFRRjBRY0FKYWk4QkFFRUxka0VCYWlJRVNRUkFJQUJCRVdvZ0FTQUNFRW9oQmlBQUtBSUFJZ0VnQUNnQ0RDQUJLQUlBS0FJUUVRUUFJQUJCQURZQ0RBTkFJQUFvQWdBaUFTQURRUWhxSUFFb0FnQW9BZ3dSQXdBaEJVRUFJQU1vQWdnaUFVVU5BeG9nQUNBQ2FrRVJhaUFGSUFFZ0JDQUNheUlGSUFFZ0JVa2JJZ0VRS2hvZ0FDZ0NBQ0lGSUFFZ0JTZ0NBQ2dDRUJFRUFDQUJJQUpxSWdJZ0JFa05BQXNnQUNBR05nSUVJQUFnQUNBRWFrRVJhallDQ0F3QkN5QUNRUVJOQkVBZ0FFRVJhaUFCSUFJUVNpRUJJQUFvQWdBaUJDQUFLQUlNSUFRb0FnQW9BaEFSQkFBZ0FDQUJJQUpxTmdJSUlBQWdBVFlDQkNBQVFRQTJBZ3dNQVFzZ0FDQUJOZ0lFQzBFQkN5RUNJQU5CRUdva0FDQUNDeDRCQVg4Z0FFRUZSaUFCUVJCS2NnUi9JQU1GSUFJZ0FXMUIvd0JLQ3d2Q0FnRUtmeUFBS0FJTUxRQUFJZ2hCQW5ZZ0FDZ0NLQ0lKSUFGTWNTRU5JQWdnQ1VFQlNuRWhEaUFBS0FJWUlRc2dBU0VLUVFFaERBSkFBa0FDUUNBSVFSQnhJQWxCRUVweURRQWdBaUFCSUFsdElnaEJnQUZJY2cwQUlBZ2hDaUFKSVF3Z0NVRUJUZzBBREFFTElBWWdCaUFGSUEwYklBNGJJUUlnQ2lBTWJDRVBJQXRCZkdvaEVBTkFRWDhoQ0NBRVFRQklJQVFnRUV0eURRSWdBeUFFYWlnQUFDSUxRUUJJRFFJZ0N5QUFLQUlZSUFSQkJHb2lCR3RLRFFJZ0F5QUVhaUVJQWtBZ0NpQUxSZ1JBSUFJZ0NDQUtFRkFhREFFTElBZ2dDeUFDSUFvZ0FDZ0NRQkVIQUNBS1JnMEFRWDRQQ3lBQ0lBcHFJUUlnQkNBTGFpRUVJQkZCQVdvaUVTQU1SdzBBQ3dzQ1FDQU9CRUFnQ1NBQklBWWdCUkN0QWd3QkN5QU5SUTBBSUFrZ0FTQUdJQVVnQnhDc0FpSUlRUUJJRFFFTElBOGhDQXNnQ0F1ZkJRRUtmeU1BUVJCcklnb2tBQUpBQWtBZ0FDZ0NEQzBBQUNJSlFRRnhSU0FBS0FJb0lndEJBa2h5UlFSQUlBc2dBU0FGSUFjUXN3SU1BUXNnQ3lBQlNnUkFJQVVoQnd3QkN5QUpRUVJ4UlFSQUlBVWhCd3dCQ3lBTElBRWdCU0FISUFnUXNnSWlDRUVBU0EwQkN5QUJRUUVnQ3lBSlFSQnhJQUp5R3lJTmJTRUZJQUFpQVNnQ09FRUJSZ1IvUVFvZ0FTZ0NQR3NGUVFFTElRNGdEVUVCU0FSQVFRQWhDQXdCQzBFQUlRSkJBQ0VJQTBBZ0EwRUVhaUVNSUFVaEF5QUFLQUk0UVFOR0JFQWdCUkNWQWlFREN3SkFJQU1nREdvZ0JFd05BQ0FFSUF4cklnTkJBVTROQUVFQUlRZ01BZ3NnQmtFRWFpRUpBbjhDUUFKQUFrQUNRQUpBQWtBQ1FDQUFLQUk0SWdFT0JnWUFBUUlEQkFVTElBY2dBaUFGYkdvZ0NTQUZJQU1nRGhDcUFnd0dDeUFISUFJZ0JXeHFJUThnQ1NFQklBTWhFQ0FBS0FJOElSRWdCU0lTUVlDQWdJQjRUUVIvSUE4Z0FTQVNJQkFnRVJDcEFnVkJmd3NNQlFzZ0J5QUNJQVZzYWlBRklBa2dBeEN4QWd3RUN5QUhJQUlnQld4cUlBVWdDU0FESUFBb0Fqd1FzQUlNQXdzZ0J5QUNJQVZzYWlBRklBa2dBeUFBS0FJOEVLOENEQUlMSUFvZ0FVRUZUUVIvSUFGQkFuUkJnQkJxS0FJQUJVRUFDellDRENBS0lBb29BZ3dpQUVHYTFBRWdBQnMyQWdCQjZCRWdDaEJQUVk4U1FTOFFja0Y3SVFnTUF3c2dBQ2dDUENBSElBSWdCV3hxSUFVZ0NTQURJQUFvQWd3dEFBQWdDMEVCU25FUXJnSUxJZ0VnQTBvRVFFRi9JUWdNQWdzZ0FVRUFTQVJBUVg0aENBd0NDd0pBSUFGRklBRWdCVVp5UlFSQUlBRWdER29oQXd3QkN5QUZJQXhxSWdNZ0JFb0VRRUVBSVFnTUF3c2dDU0FISUFJZ0JXeHFJQVVRVUJvZ0JTRUJDeUFHSUFFUU5DQUlRUVJxSUFGcUlRZ2dBU0FKYWlFR0lBSkJBV29pQWlBTlJ3MEFDd3NnQ2tFUWFpUUFJQWdMOUFNQ0JYOENmZ0pBQWtBRFFDQUFJQUJCZjJweERRRWdBRUVJSUFCQkNFc2JJUUJCaVBVQktRTUFJZ2dDZnlBQlFRTnFRWHh4UVFnZ0FVRUlTeHNpQVVIL0FFMEVRQ0FCUVFOMlFYOXFEQUVMSUFGbklRSWdBVUVkSUFKcmRrRUVjeUFDUVFKMGEwSHVBR29nQVVIL0gwME5BQm9nQVVFZUlBSnJka0VDY3lBQ1FRRjBhMEhIQUdvaUFrRS9JQUpCUDBrYkN5SUVyWWdpQjFCRkJFQURRQ0FISUFkNklnaUlJUWNDZmlBRUlBaW5haUlFUVFSMElnTkJpTzBCYWlnQ0FDSUNJQU5CZ08wQmFpSUdSd1JBSUFJZ0FDQUJFSWdCSWdVTkJpQUNLQUlFSWdVZ0FpZ0NDRFlDQ0NBQ0tBSUlJQVUyQWdRZ0FpQUdOZ0lJSUFJZ0EwR0U3UUZxSWdNb0FnQTJBZ1FnQXlBQ05nSUFJQUlvQWdRZ0FqWUNDQ0FFUVFGcUlRUWdCMElCaUF3QkMwR0k5UUZCaVBVQktRTUFRbjRnQksySmd6Y0RBQ0FIUWdHRkN5SUhRZ0JTRFFBTFFZajFBU2tEQUNFSUMwRS9JQWg1cDJ0QkJIUWlBa0dBN1FGcUlRTWdBa0dJN1FGcUtBSUFJUUlDUUNBSVFvQ0FnSUFFVkEwQVFlTUFJUVFnQWlBRFJnMEFBMEFnQkVVTkFTQUNJQUFnQVJDSUFTSUZEUVFnQkVGL2FpRUVJQUlvQWdnaUFpQURSdzBBQ3lBRElRSUxJQUZCTUdvUXRnRU5BQXNnQWlBRFJnMEFBMEFnQWlBQUlBRVFpQUVpQlEwQ0lBSW9BZ2dpQWlBRFJ3MEFDd3RCQUNFRkN5QUZDLzBEQVFaL1FlanFBU2dDQUNJQ0lBQkJBMnBCZkhFaUEyb2hBUUpBSUFOQkFVNUJBQ0FCSUFKTkcwVUVRQ0FCUHdCQkVIUk5EUUVnQVJBUkRRRUxRYkRzQVVFd05nSUFRUUFQQzBFQUlRTkI2T29CSUFFMkFnQWdBa0VCVGdSL1FSQWhBeUFBSUFKcUlnUkJjR29pQUVFUU5nSU1JQUJCRURZQ0FBSkFBa0FDUUVHQTlRRW9BZ0FpQVVVTkFDQUNJQUVvQWdoSERRQWdBaUFDUVh4cUtBSUFJZ05CSDNVZ0EzTnJJZ1pCZkdvb0FnQWhCU0FCSUFRMkFnaEJjQ0VESUFZZ0JTQUZRUjkxYzJzaUFTQUJLQUlBYWtGOGFpZ0NBRUYvU2cwQklBRW9BZ1FpQWlBQktBSUlOZ0lJSUFFb0FnZ2dBallDQkNBQklBQWdBV3NpQURZQ0FBd0NDeUFDUVJBMkFnd2dBa0VRTmdJQUlBSWdCRFlDQ0NBQ0lBRTJBZ1JCZ1BVQklBSTJBZ0FMSUFJZ0Eyb2lBU0FBSUFGcklnQTJBZ0FMSUFCQmZIRWdBV3BCZkdvZ0FFRi9jellDQUNBQkFuOGdBU2dDQUVGNGFpSUFRZjhBVFFSQUlBQkJBM1pCZjJvTUFRc2dBR2NoQWlBQVFSMGdBbXQyUVFSeklBSkJBblJyUWU0QWFpQUFRZjhmVFEwQUdpQUFRUjRnQW10MlFRSnpJQUpCQVhSclFjY0FhaUlBUVQ4Z0FFRS9TUnNMSWdKQkJIUWlBRUdBN1FGcU5nSUVJQUVnQUVHSTdRRnFJZ0FvQWdBMkFnZ2dBQ0FCTmdJQUlBRW9BZ2dnQVRZQ0JFR0k5UUZCaVBVQktRTUFRZ0VnQXEyR2hEY0RBRUVCQlNBREN3dFNBUUYvSUFBb0FnUWhCQ0FBS0FJQUlnQWdBUUovUVFBZ0FrVU5BQm9nQkVFSWRTSUJJQVJCQVhGRkRRQWFJQUlvQWdBZ0FXb29BZ0FMSUFKcUlBTkJBaUFFUVFKeEd5QUFLQUlBS0FJY0VRZ0FDM1VCQTM4Q1FBSkFBMEFnQUNBQlFjRFVBV290QUFCSEJFQkIxd0FoQWlBQlFRRnFJZ0ZCMXdCSERRRU1BZ3NMSUFFaEFpQUJEUUJCb05VQklRQU1BUXRCb05VQklRRURRQ0FCTFFBQUlRTWdBVUVCYWlJQUlRRWdBdzBBSUFBaEFTQUNRWDlxSWdJTkFBc0xRZkRzQVNnQ0FCb2dBQXNMQUNBQUlBRWdBaERjQWdzU0FDQUFSUVJBUVFBUEN5QUFJQUVRMWdJTHV3SUFBa0FnQVVFVVN3MEFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQVVGM2FnNEtBQUVDQXdRRkJnY0lDUW9MSUFJZ0FpZ0NBQ0lCUVFScU5nSUFJQUFnQVNnQ0FEWUNBQThMSUFJZ0FpZ0NBQ0lCUVFScU5nSUFJQUFnQVRRQ0FEY0RBQThMSUFJZ0FpZ0NBQ0lCUVFScU5nSUFJQUFnQVRVQ0FEY0RBQThMSUFJZ0FpZ0NBRUVIYWtGNGNTSUJRUWhxTmdJQUlBQWdBU2tEQURjREFBOExJQUlnQWlnQ0FDSUJRUVJxTmdJQUlBQWdBVElCQURjREFBOExJQUlnQWlnQ0FDSUJRUVJxTmdJQUlBQWdBVE1CQURjREFBOExJQUlnQWlnQ0FDSUJRUVJxTmdJQUlBQWdBVEFBQURjREFBOExJQUlnQWlnQ0FDSUJRUVJxTmdJQUlBQWdBVEVBQURjREFBOExJQUlnQWlnQ0FFRUhha0Y0Y1NJQlFRaHFOZ0lBSUFBZ0FTc0RBRGtEQUE4TElBQWdBa0VBRVFRQUN3dEVBUVIvSUFBb0FnQWlBaXdBQUNJREVHNEVRQU5BSUFBZ0FrRUJhaUlFTmdJQUlBRkJDbXdnQTJwQlVHb2hBU0FDTEFBQklRTWdCQ0VDSUFNUWJnMEFDd3NnQVFzb0FRRi9Jd0JCRUdzaUFTUUFJQUVnQURZQ0RFSG95d0ZCQlNBQktBSU1FQUFnQVVFUWFpUUFDeWdCQVg4akFFRVFheUlCSkFBZ0FTQUFOZ0lNUVpETUFVRUVJQUVvQWd3UUFDQUJRUkJxSkFBTEtBRUJmeU1BUVJCcklnRWtBQ0FCSUFBMkFneEJ1TXdCUVFNZ0FTZ0NEQkFBSUFGQkVHb2tBQXNvQVFGL0l3QkJFR3NpQVNRQUlBRWdBRFlDREVIZ3pBRkJBaUFCS0FJTUVBQWdBVUVRYWlRQUN5Y0JBWDhqQUVFUWF5SUJKQUFnQVNBQU5nSU1RY3dQUVFFZ0FTZ0NEQkFBSUFGQkVHb2tBQXNvQVFGL0l3QkJFR3NpQVNRQUlBRWdBRFlDREVHSXpRRkJBQ0FCS0FJTUVBQWdBVUVRYWlRQUMrQUJBRUg0NWdGQnNNUUJFQmxCaE9jQlFiWEVBVUVCUVFGQkFCQVlFUE1DRVBJQ0VQRUNFUEFDRU84Q0VPNENFTzBDRU93Q0VPc0NFT29DRU9rQ1FiQU9RWi9GQVJBSFFlalBBVUdyeFFFUUIwR1F6d0ZCQkVITXhRRVFBa0cwemdGQkFrSFp4UUVRQWtIWXpRRkJCRUhveFFFUUFrR29Ea0gzeFFFUUZ4RG9Ba0dseGdFUXdnRkJ5c1lCRU1FQlFmSEdBUkRBQVVHUXh3RVF2d0ZCdU1jQkVMNEJRZFhIQVJDOUFSRGxBaERrQWtIQXlBRVF3Z0ZCNE1nQkVNRUJRWUhKQVJEQUFVR2l5UUVRdndGQnhNa0JFTDRCUWVYSkFSQzlBUkRqQWhEaUFndU5CQUVEZnlNQVFSQnJJZ1VrQUNBRklBSTJBZ2dnQlNBQU5nSU1JQUFnQTJvaEJ3SkFJQU5CQjB3RVFDQURRUUZJRFFFRFFDQUFJQUl0QUFBNkFBQWdBa0VCYWlFQ0lBQkJBV29pQUNBSFJ3MEFDeUFGSUFjMkFnd2dCU0FDTmdJSURBRUxJQVJCQVVZRVFDQUZRUXhxSUFWQkNHb2dBQ0FDYXhCOElBVW9BZ3doQUFzZ0J5QUJUUVJBSUFBZ0Eyb2hCaUFFUVFGSElBQWdCU2dDQ0NJQ2EwRVBTbkpGQkVBRFFDQUFJQUlRWnlBQ1FRaHFJUUlnQUVFSWFpSUFJQVpKRFFBTUF3c0FDeUFBSUFJUUhDQUFRUkJxSUFKQkVHb1FIQ0FEUVNGSURRRWdBRUVnYWlFQUEwQWdBQ0FDUVNCcUlnRVFIQ0FBUVJCcUlBSkJNR29RSENBQklRSWdBRUVnYWlJQUlBWkpEUUFMREFFTEFrQWdBQ0FCU3dSQUlBQWhBUXdCQ3dKQUlBUkJBVWNnQUNBRktBSUlJZ1pyUVE5S2NrVUVRQ0FBSVFJZ0JpRURBMEFnQWlBREVHY2dBMEVJYWlFRElBSkJDR29pQWlBQlNRMEFDeUFCSUFCcklRUU1BUXNnQUNBR0VCd2dBRUVRYWlBR1FSQnFFQndnQVNBQWF5SUVRU0ZJRFFBZ0FFRWdhaUVBSUFZaEFnTkFJQUFnQWtFZ2FpSURFQndnQUVFUWFpQUNRVEJxRUJ3Z0F5RUNJQUJCSUdvaUFDQUJTUTBBQ3dzZ0JTQUVJQVpxTmdJSUN5QUJJQWRQRFFBZ0JTZ0NDQ0VBQTBBZ0FTQUFMUUFBT2dBQUlBQkJBV29oQUNBQlFRRnFJZ0VnQjBjTkFBc2dCU0FITmdJTUlBVWdBRFlDQ0FzZ0JVRVFhaVFBQ3drQUlBQW9BZ0FRREF0QkFRSi9JQUFnQUNnQ3VPQUJJZ00yQXNUZ0FTQUFLQUs4NEFFaEJDQUFJQUUyQXJ6Z0FTQUFJQUVnQW1vMkFyamdBU0FBSUFFZ0JDQURhMm8yQXNEZ0FRdGJBUUYvUWJoL0lRTUNRQ0FCUVFOSkRRQWdBaUFBRUpVQklnRkJBM1lpQURZQ0NFRUJJUU1nQWlBQlFRRnhOZ0lFSUFJZ0FVRUJka0VEY1NJQk5nSUFBa0FDUUNBQlFYOXFEZ01DQVFBQkMwRnNEd3NnQUNFREN5QURDdzRBSUFBb0FnQVFGaUFBS0FJQUM2d0JBUUYvSUFBb0F1emhBU0VCSUFCQkFEWUNoT0VCSUFBZ0FSQnBOZ0xJNEFFZ0FFSUFOd1A0NEFFZ0FFSUFOd080NEFFZ0FFSEE0QUZxUWdBM0F3QWdBRUdvMEFCcUlnRkJqSUNBNEFBMkFnQWdBRUVBTmdLWTRnRWdBRUlBTndPSTRRRWdBRUdzMEFGcVFkQ3dBU2tDQURjQ0FDQUFRYlRRQVdwQjJMQUJLQUlBTmdJQUlBQWdBVFlDRENBQUlBQkJtQ0JxTmdJSUlBQWdBRUdnTUdvMkFnUWdBQ0FBUVJCcU5nSUFDeDRBSUFBb0FwRGlBUkNYQXlBQVFRQTJBcURpQVNBQVFnQTNBNURpQVF1M0VBRU1meU1BUWZBQWF5SUZKQUJCYkNFR0FrQWdBMEVLU1EwQUlBSXZBQUFoQ3lBQ0x3QUNJUWNnQWk4QUJDRU1JQVZCQ0dvZ0JDZ0NBQkEwSUFNZ0RDQUhJQXRxYWtFR2FpSUlTUTBBSUFVdEFBb2hDU0FGUWRnQWFpQUNRUVpxSWdJZ0N4QkZJZ1lRSVEwQUlBVkJRR3NnQWlBTGFpSUNJQWNRUlNJR0VDRU5BQ0FGUVNocUlBSWdCMm9pQWlBTUVFVWlCaEFoRFFBZ0JVRVFhaUFDSUF4cUlBTWdDR3NRUlNJR0VDRU5BQ0FFUVFScUlRZ2dBQ0FCUVFOcVFRSjJJZ0pxSWdjZ0Ftb2lEQ0FDYWlJTElBQWdBV29pRGtGOWFpSVBTU0VLSUFWQjJBQnFFQ01oQWlBRlFVQnJFQ01oQXlBRlFTaHFFQ01oQkFKQUlBVkJFR29RSXlBQ0lBTnlJQVJ5Y2lBTElBOVBja1VFUUNBSElRUWdEQ0VESUFzaEFnTkFJQWdnQlNnQ1dDQUZLQUpjSUFrUUtVRUJkR29pQmkwQUFDRUtJQVZCMkFCcUlBWXRBQUVRSmlBQUlBbzZBQUFnQ0NBRktBSkFJQVVvQWtRZ0NSQXBRUUYwYWlJR0xRQUFJUW9nQlVGQWF5QUdMUUFCRUNZZ0JDQUtPZ0FBSUFnZ0JTZ0NLQ0FGS0FJc0lBa1FLVUVCZEdvaUJpMEFBQ0VLSUFWQktHb2dCaTBBQVJBbUlBTWdDam9BQUNBSUlBVW9BaEFnQlNnQ0ZDQUpFQ2xCQVhScUlnWXRBQUFoQ2lBRlFSQnFJQVl0QUFFUUppQUNJQW82QUFBZ0NDQUZLQUpZSUFVb0Fsd2dDUkFwUVFGMGFpSUdMUUFBSVFvZ0JVSFlBR29nQmkwQUFSQW1JQUFnQ2pvQUFTQUlJQVVvQWtBZ0JTZ0NSQ0FKRUNsQkFYUnFJZ1l0QUFBaENpQUZRVUJySUFZdEFBRVFKaUFFSUFvNkFBRWdDQ0FGS0FJb0lBVW9BaXdnQ1JBcFFRRjBhaUlHTFFBQUlRb2dCVUVvYWlBR0xRQUJFQ1lnQXlBS09nQUJJQWdnQlNnQ0VDQUZLQUlVSUFrUUtVRUJkR29pQmkwQUFDRUtJQVZCRUdvZ0JpMEFBUkFtSUFJZ0Nqb0FBU0FEUVFKcUlRTWdCRUVDYWlFRUlBQkJBbW9oQUNBRlFkZ0FhaEFqR2lBRlFVQnJFQ01hSUFWQktHb1FJeG9nQlVFUWFoQWpHaUFDUVFKcUlnSWdEMGtOQUF0QkFDRUtEQUVMSUFzaEFpQU1JUU1nQnlFRUN5QURJQXRMQkVCQmJDRUdEQUVMSUFRZ0RFc0VRRUZzSVFZTUFRdEJiQ0VHSUFBZ0Iwc05BQUpBSUFWQjJBQnFFQ01nQjBGOWFpSUdJQUJOY2cwQUEwQWdDQ0FGS0FKWUlBVW9BbHdnQ1JBcFFRRjBhaUlOTFFBQUlSQWdCVUhZQUdvZ0RTMEFBUkFtSUFBZ0VEb0FBQ0FJSUFVb0FsZ2dCU2dDWENBSkVDbEJBWFJxSWcwdEFBQWhFQ0FGUWRnQWFpQU5MUUFCRUNZZ0FDQVFPZ0FCSUFWQjJBQnFFQ01oRFNBQVFRSnFJZ0FnQms4TkFTQU5SUTBBQ3dzQ1FDQUZRZGdBYWhBaklBQWdCMDl5RFFBRFFDQUlJQVVvQWxnZ0JTZ0NYQ0FKRUNsQkFYUnFJZ1l0QUFBaERTQUZRZGdBYWlBR0xRQUJFQ1lnQUNBTk9nQUFJQVZCMkFCcUVDTWhCaUFBUVFGcUlnQWdCMDhOQVNBR1JRMEFDd3NnQUNBSFNRUkFBMEFnQ0NBRktBSllJQVVvQWx3Z0NSQXBRUUYwYWlJR0xRQUFJUTBnQlVIWUFHb2dCaTBBQVJBbUlBQWdEVG9BQUNBQVFRRnFJZ0FnQjBjTkFBc0xBa0FnQlVGQWF4QWpJQXhCZldvaUFDQUVUWElOQUFOQUlBZ2dCU2dDUUNBRktBSkVJQWtRS1VFQmRHb2lCeTBBQUNFR0lBVkJRR3NnQnkwQUFSQW1JQVFnQmpvQUFDQUlJQVVvQWtBZ0JTZ0NSQ0FKRUNsQkFYUnFJZ2N0QUFBaEJpQUZRVUJySUFjdEFBRVFKaUFFSUFZNkFBRWdCVUZBYXhBaklRY2dCRUVDYWlJRUlBQlBEUUVnQjBVTkFBc0xBa0FnQlVGQWF4QWpJQVFnREU5eURRQURRQ0FJSUFVb0FrQWdCU2dDUkNBSkVDbEJBWFJxSWdBdEFBQWhCeUFGUVVCcklBQXRBQUVRSmlBRUlBYzZBQUFnQlVGQWF4QWpJUUFnQkVFQmFpSUVJQXhQRFFFZ0FFVU5BQXNMSUFRZ0RFa0VRQU5BSUFnZ0JTZ0NRQ0FGS0FKRUlBa1FLVUVCZEdvaUFDMEFBQ0VISUFWQlFHc2dBQzBBQVJBbUlBUWdCem9BQUNBRVFRRnFJZ1FnREVjTkFBc0xBa0FnQlVFb2FoQWpJQXRCZldvaUFDQURUWElOQUFOQUlBZ2dCU2dDS0NBRktBSXNJQWtRS1VFQmRHb2lCQzBBQUNFSElBVkJLR29nQkMwQUFSQW1JQU1nQnpvQUFDQUlJQVVvQWlnZ0JTZ0NMQ0FKRUNsQkFYUnFJZ1F0QUFBaEJ5QUZRU2hxSUFRdEFBRVFKaUFESUFjNkFBRWdCVUVvYWhBaklRUWdBMEVDYWlJRElBQlBEUUVnQkVVTkFBc0xBa0FnQlVFb2FoQWpJQU1nQzA5eURRQURRQ0FJSUFVb0FpZ2dCU2dDTENBSkVDbEJBWFJxSWdBdEFBQWhCQ0FGUVNocUlBQXRBQUVRSmlBRElBUTZBQUFnQlVFb2FoQWpJUUFnQTBFQmFpSURJQXRQRFFFZ0FFVU5BQXNMSUFNZ0Mwa0VRQU5BSUFnZ0JTZ0NLQ0FGS0FJc0lBa1FLVUVCZEdvaUFDMEFBQ0VFSUFWQktHb2dBQzBBQVJBbUlBTWdCRG9BQUNBRFFRRnFJZ01nQzBjTkFBc0xBa0FnQlVFUWFoQWpJQXBCQVhOeURRQURRQ0FJSUFVb0FoQWdCU2dDRkNBSkVDbEJBWFJxSWdBdEFBQWhBeUFGUVJCcUlBQXRBQUVRSmlBQ0lBTTZBQUFnQ0NBRktBSVFJQVVvQWhRZ0NSQXBRUUYwYWlJQUxRQUFJUU1nQlVFUWFpQUFMUUFCRUNZZ0FpQURPZ0FCSUFWQkVHb1FJeUVBSUFKQkFtb2lBaUFQVHcwQklBQkZEUUFMQ3dKQUlBVkJFR29RSXlBQ0lBNVBjZzBBQTBBZ0NDQUZLQUlRSUFVb0FoUWdDUkFwUVFGMGFpSUFMUUFBSVFNZ0JVRVFhaUFBTFFBQkVDWWdBaUFET2dBQUlBVkJFR29RSXlFQUlBSkJBV29pQWlBT1R3MEJJQUJGRFFBTEN5QUNJQTVKQkVBRFFDQUlJQVVvQWhBZ0JTZ0NGQ0FKRUNsQkFYUnFJZ0F0QUFBaEF5QUZRUkJxSUFBdEFBRVFKaUFDSUFNNkFBQWdBa0VCYWlJQ0lBNUhEUUFMQ3lBQlFXd2dCU2dDWENBRktBSmdJQVVvQW1RUVN5QUZLQUpFSUFVb0FrZ2dCU2dDVEJCTGNTQUZLQUlzSUFVb0FqQWdCU2dDTkJCTGNTQUZLQUlVSUFVb0FoZ2dCU2dDSEJCTGNSc2hCZ3NnQlVId0FHb2tBQ0FHQzdZVUFRMS9Jd0JCOEFCcklnVWtBRUZzSVFZQ1FDQURRUXBKRFFBZ0FpOEFBQ0VMSUFJdkFBSWhDU0FDTHdBRUlRd2dCVUVJYWlBRUtBSUFFRFFnQXlBTUlBa2dDMnBxUVFacUlnZEpEUUFnQlMwQUNpRUlJQVZCMkFCcUlBSkJCbW9pQWlBTEVFVWlCaEFoRFFBZ0JVRkFheUFDSUF0cUlnSWdDUkJGSWdZUUlRMEFJQVZCS0dvZ0FpQUphaUlDSUF3UVJTSUdFQ0VOQUNBRlFSQnFJQUlnREdvZ0F5QUhheEJGSWdZUUlRMEFJQVJCQkdvaEJ5QUFJQUZCQTJwQkFuWWlBbW9pQ1NBQ2FpSU1JQUpxSWdzZ0FDQUJhaUlSUVgxcUlnOUpJUTBnQlVIWUFHb1FJeUVDSUFWQlFHc1FJeUVESUFWQktHb1FJeUVFQWtBZ0JVRVFhaEFqSUFJZ0EzSWdCSEp5SUFzZ0QwOXlSUVJBSUFraEFpQU1JUVFnQ3lFREEwQWdBQ0FISUFVb0FsZ2dCU2dDWENBSUVDbEJBblJxSWdZdkFRQTdBQUFnQlVIWUFHb2dCaTBBQWhBbUlBWXRBQU1oRFNBQ0lBY2dCU2dDUUNBRktBSkVJQWdRS1VFQ2RHb2lCaThCQURzQUFDQUZRVUJySUFZdEFBSVFKaUFHTFFBRElRb2dCQ0FISUFVb0FpZ2dCU2dDTENBSUVDbEJBblJxSWdZdkFRQTdBQUFnQlVFb2FpQUdMUUFDRUNZZ0JpMEFBeUVPSUFNZ0J5QUZLQUlRSUFVb0FoUWdDQkFwUVFKMGFpSUdMd0VBT3dBQUlBVkJFR29nQmkwQUFoQW1JQVl0QUFNaEJpQUFJQTFxSWcwZ0J5QUZLQUpZSUFVb0Fsd2dDQkFwUVFKMGFpSUFMd0VBT3dBQUlBVkIyQUJxSUFBdEFBSVFKaUFBTFFBRElSQWdBaUFLYWlJQ0lBY2dCU2dDUUNBRktBSkVJQWdRS1VFQ2RHb2lBQzhCQURzQUFDQUZRVUJySUFBdEFBSVFKaUFBTFFBRElRb2dCQ0FPYWlJRUlBY2dCU2dDS0NBRktBSXNJQWdRS1VFQ2RHb2lBQzhCQURzQUFDQUZRU2hxSUFBdEFBSVFKaUFBTFFBRElRNGdBeUFHYWlJR0lBY2dCU2dDRUNBRktBSVVJQWdRS1VFQ2RHb2lBeThCQURzQUFDQUZRUkJxSUFNdEFBSVFKaUFOSUJCcUlRQWdBaUFLYWlFQ0lBUWdEbW9oQkNBR0lBTXRBQU5xSWdNZ0Qwa2hEU0FGUWRnQWFoQWpJUVlnQlVGQWF4QWpJUW9nQlVFb2FoQWpJUTRnQlVFUWFoQWpJUkFnQXlBUFR3MENJQVlnQ25JZ0RuSWdFSEpGRFFBTERBRUxJQXNoQXlBTUlRUWdDU0VDQ3lBRUlBdExCRUJCYkNFR0RBRUxJQUlnREVzRVFFRnNJUVlNQVF0QmJDRUdJQUFnQ1VzTkFBSkFJQVZCMkFCcUVDTWdDVUY5YWlJS0lBQk5jZzBBQTBBZ0FDQUhJQVVvQWxnZ0JTZ0NYQ0FJRUNsQkFuUnFJZ1l2QVFBN0FBQWdCVUhZQUdvZ0JpMEFBaEFtSUFBZ0JpMEFBMm9pQmlBSElBVW9BbGdnQlNnQ1hDQUlFQ2xCQW5ScUlnQXZBUUE3QUFBZ0JVSFlBR29nQUMwQUFoQW1JQVlnQUMwQUEyb2hBQ0FGUWRnQWFoQWpEUUVnQUNBS1NRMEFDd3NDUUNBRlFkZ0FhaEFqSUFBZ0NVRithaUlHUzNJTkFBTkFJQUFnQnlBRktBSllJQVVvQWx3Z0NCQXBRUUowYWlJS0x3RUFPd0FBSUFWQjJBQnFJQW90QUFJUUppQUFJQW90QUFOcUlRQWdCVUhZQUdvUUl3MEJJQUFnQmswTkFBc0xJQUFnQmswRVFBTkFJQUFnQnlBRktBSllJQVVvQWx3Z0NCQXBRUUowYWlJS0x3RUFPd0FBSUFWQjJBQnFJQW90QUFJUUppQUFJQW90QUFOcUlnQWdCazBOQUFzTEFrQWdBQ0FKVHcwQUlBQWdCeUFGS0FKWUlBVW9BbHdnQ0JBcElnbEJBblJxSWdBdEFBQTZBQUFnQUMwQUEwRUJSZ1JBSUFWQjJBQnFJQUF0QUFJUUpnd0JDeUFGS0FKY1FSOUxEUUFnQlVIWUFHb2dCeUFKUVFKMGFpMEFBaEFtSUFVb0FseEJJVWtOQUNBRlFTQTJBbHdMQWtBZ0JVRkFheEFqSUF4QmZXb2lDU0FDVFhJTkFBTkFJQUlnQnlBRktBSkFJQVVvQWtRZ0NCQXBRUUowYWlJQUx3RUFPd0FBSUFWQlFHc2dBQzBBQWhBbUlBSWdBQzBBQTJvaUFpQUhJQVVvQWtBZ0JTZ0NSQ0FJRUNsQkFuUnFJZ0F2QVFBN0FBQWdCVUZBYXlBQUxRQUNFQ1lnQWlBQUxRQURhaUVDSUFWQlFHc1FJdzBCSUFJZ0NVa05BQXNMQWtBZ0JVRkFheEFqSUFJZ0RFRithaUlBUzNJTkFBTkFJQUlnQnlBRktBSkFJQVVvQWtRZ0NCQXBRUUowYWlJSkx3RUFPd0FBSUFWQlFHc2dDUzBBQWhBbUlBSWdDUzBBQTJvaEFpQUZRVUJyRUNNTkFTQUNJQUJORFFBTEN5QUNJQUJOQkVBRFFDQUNJQWNnQlNnQ1FDQUZLQUpFSUFnUUtVRUNkR29pQ1M4QkFEc0FBQ0FGUVVCcklBa3RBQUlRSmlBQ0lBa3RBQU5xSWdJZ0FFME5BQXNMQWtBZ0FpQU1UdzBBSUFJZ0J5QUZLQUpBSUFVb0FrUWdDQkFwSWdKQkFuUnFJZ0F0QUFBNkFBQWdBQzBBQTBFQlJnUkFJQVZCUUdzZ0FDMEFBaEFtREFFTElBVW9Ba1JCSDBzTkFDQUZRVUJySUFjZ0FrRUNkR290QUFJUUppQUZLQUpFUVNGSkRRQWdCVUVnTmdKRUN3SkFJQVZCS0dvUUl5QUxRWDFxSWdJZ0JFMXlEUUFEUUNBRUlBY2dCU2dDS0NBRktBSXNJQWdRS1VFQ2RHb2lBQzhCQURzQUFDQUZRU2hxSUFBdEFBSVFKaUFFSUFBdEFBTnFJZ1FnQnlBRktBSW9JQVVvQWl3Z0NCQXBRUUowYWlJQUx3RUFPd0FBSUFWQktHb2dBQzBBQWhBbUlBUWdBQzBBQTJvaEJDQUZRU2hxRUNNTkFTQUVJQUpKRFFBTEN3SkFJQVZCS0dvUUl5QUVJQXRCZm1vaUFFdHlEUUFEUUNBRUlBY2dCU2dDS0NBRktBSXNJQWdRS1VFQ2RHb2lBaThCQURzQUFDQUZRU2hxSUFJdEFBSVFKaUFFSUFJdEFBTnFJUVFnQlVFb2FoQWpEUUVnQkNBQVRRMEFDd3NnQkNBQVRRUkFBMEFnQkNBSElBVW9BaWdnQlNnQ0xDQUlFQ2xCQW5ScUlnSXZBUUE3QUFBZ0JVRW9haUFDTFFBQ0VDWWdCQ0FDTFFBRGFpSUVJQUJORFFBTEN3SkFJQVFnQzA4TkFDQUVJQWNnQlNnQ0tDQUZLQUlzSUFnUUtTSUNRUUowYWlJQUxRQUFPZ0FBSUFBdEFBTkJBVVlFUUNBRlFTaHFJQUF0QUFJUUpnd0JDeUFGS0FJc1FSOUxEUUFnQlVFb2FpQUhJQUpCQW5ScUxRQUNFQ1lnQlNnQ0xFRWhTUTBBSUFWQklEWUNMQXNDUUNBRlFSQnFFQ01nRFVFQmMzSU5BQU5BSUFNZ0J5QUZLQUlRSUFVb0FoUWdDQkFwUVFKMGFpSUFMd0VBT3dBQUlBVkJFR29nQUMwQUFoQW1JQU1nQUMwQUEyb2lBaUFISUFVb0FoQWdCU2dDRkNBSUVDbEJBblJxSWdBdkFRQTdBQUFnQlVFUWFpQUFMUUFDRUNZZ0FpQUFMUUFEYWlFRElBVkJFR29RSXcwQklBTWdEMGtOQUFzTEFrQWdCVUVRYWhBaklBTWdFVUYrYWlJQVMzSU5BQU5BSUFNZ0J5QUZLQUlRSUFVb0FoUWdDQkFwUVFKMGFpSUNMd0VBT3dBQUlBVkJFR29nQWkwQUFoQW1JQU1nQWkwQUEyb2hBeUFGUVJCcUVDTU5BU0FESUFCTkRRQUxDeUFESUFCTkJFQURRQ0FESUFjZ0JTZ0NFQ0FGS0FJVUlBZ1FLVUVDZEdvaUFpOEJBRHNBQUNBRlFSQnFJQUl0QUFJUUppQURJQUl0QUFOcUlnTWdBRTBOQUFzTEFrQWdBeUFSVHcwQUlBTWdCeUFGS0FJUUlBVW9BaFFnQ0JBcElnSkJBblJxSWdBdEFBQTZBQUFnQUMwQUEwRUJSZ1JBSUFWQkVHb2dBQzBBQWhBbURBRUxJQVVvQWhSQkgwc05BQ0FGUVJCcUlBY2dBa0VDZEdvdEFBSVFKaUFGS0FJVVFTRkpEUUFnQlVFZ05nSVVDeUFCUVd3Z0JTZ0NYQ0FGS0FKZ0lBVW9BbVFRU3lBRktBSkVJQVVvQWtnZ0JTZ0NUQkJMY1NBRktBSXNJQVVvQWpBZ0JTZ0NOQkJMY1NBRktBSVVJQVVvQWhnZ0JTZ0NIQkJMY1JzaEJnc2dCVUh3QUdva0FDQUdDNDhEQVFSL0l3QkJJR3NpQlNRQUlBVWdCQ2dDQUJBMElBVXRBQUloQnlBRlFRaHFJQUlnQXhCRklnSVFJVVVFUUNBRVFRUnFJUUlDUUNBRlFRaHFFQ01nQUNBQmFpSURRWDFxSWdRZ0FFMXlEUUFEUUNBQ0lBVW9BZ2dnQlNnQ0RDQUhFQ2xCQVhScUlnWXRBQUFoQ0NBRlFRaHFJQVl0QUFFUUppQUFJQWc2QUFBZ0FpQUZLQUlJSUFVb0Fnd2dCeEFwUVFGMGFpSUdMUUFBSVFnZ0JVRUlhaUFHTFFBQkVDWWdBQ0FJT2dBQklBVkJDR29RSXlFR0lBQkJBbW9pQUNBRVR3MEJJQVpGRFFBTEN3SkFJQVZCQ0dvUUl5QUFJQU5QY2cwQUEwQWdBaUFGS0FJSUlBVW9BZ3dnQnhBcFFRRjBhaUlFTFFBQUlRWWdCVUVJYWlBRUxRQUJFQ1lnQUNBR09nQUFJQVZCQ0dvUUl5RUVJQUJCQVdvaUFDQURUdzBCSUFSRkRRQUxDeUFBSUFOSkJFQURRQ0FDSUFVb0FnZ2dCU2dDRENBSEVDbEJBWFJxSWdRdEFBQWhCaUFGUVFocUlBUXRBQUVRSmlBQUlBWTZBQUFnQUVFQmFpSUFJQU5IRFFBTEN5QUJRV3dnQlNnQ0RDQUZLQUlRSUFVb0FoUVFTeHNoQWdzZ0JVRWdhaVFBSUFJTHdnUUJEWDhqQUVFUWF5SUZKQUFnQlVFRWFpQUFLQUlBRURRZ0JTMEFCQ0VISUFOQjhBUnFRUUJCN0FBUUtDRUlRVlFoQkFKQUlBZEJERXNOQUNBRFFkd0phaUlNSUFnZ0JVRUlhaUFGUVF4cUlBRWdBaEQ3QVNJUUVDRkZCRUFnQlNnQ0RDSU5JQWRMRFFFZ0EwR29CV29oQmlBTklRUURRQ0FFSWdKQmYyb2hCQ0FJSUFKQkFuUnFLQUlBUlEwQUMwRUJJUUZCQUNFRUlBSkJBV29pQ2tFQ1R3UkFBMEFnQ0NBQlFRSjBJZ3RxS0FJQUlRNGdCaUFMYWlBSk5nSUFJQWtnRG1vaENTQUJJQUpISVFzZ0FVRUJhaUVCSUFzTkFBc0xJQU5CM0FWcUlRc2dCaUFKTmdJQUlBVW9BZ2dpQVFSQUEwQWdCaUFFSUF4cUxRQUFJZzVCQW5ScUlnOGdEeWdDQUNJUFFRRnFOZ0lBSUFzZ0QwRUJkR29pRHlBT09nQUJJQThnQkRvQUFDQUVRUUZxSWdRZ0FVY05BQXNMUVFBaEFTQURRUUEyQXFnRklBcEJBazhFUUNBTlFYOXpJQWRxSVFaQkFTRUVBMEFnQ0NBRVFRSjBJZ3hxS0FJQUlRNGdBeUFNYWlBQk5nSUFJQTRnQkNBR2FuUWdBV29oQVNBQ0lBUkhJUXdnQkVFQmFpRUVJQXdOQUFzTElBMUJBV29pRFNBQ2F5SUJJQWNnQVd0QkFXb2lDRWtFUUNBS1FRSkpJUVlEUUVFQklRUWdCa1VFUUFOQUlBUkJBblFpQ2lBRElBRkJOR3hxYWlBRElBcHFLQUlBSUFGMk5nSUFJQUlnQkVjaENpQUVRUUZxSVFRZ0NnMEFDd3NnQVVFQmFpSUJJQWhKRFFBTEN5QUFRUVJxSUFjZ0N5QUpJQU5CcEFWcUlBTWdBaUFORUpZRElBVkJBVG9BQlNBRklBYzZBQVlnQUNBRktBSUVOZ0lBQ3lBUUlRUUxJQVZCRUdva0FDQUVDK0FDQVFsL0l3QkJFR3NpQkNRQUlBUkJBRFlDRENBRVFRQTJBZ2dDUUNBRFFVQnJJZ2tnQXlBRVFRaHFJQVJCREdvZ0FTQUNFUHNCSWdnUUlRMEFJQVJCQkdvZ0FDZ0NBQkEwUVFFaEFTQUVLQUlNSWdVZ0JDMEFCRUVCYWswRVFFRUFJUUlnQkVFQU9nQUZJQVFnQlRvQUJpQUFJQVFvQWdRMkFnQWdCVUVCYWtFQlN3UkFBMEFnQXlBQlFRSjBhaUlHS0FJQUlRY2dCaUFDTmdJQUlBY2dBVUYvYW5RZ0Ftb2hBaUFCSUFWR0lRWWdBVUVCYWlFQklBWkZEUUFMQ3lBRUtBSUlJZ2RGRFFFZ0FFRUVhaUVLSUFWQkFXb2hDMEVBSVFBRFFDQURJQUFnQ1dvdEFBQWlCVUVDZEdvaUJpZ0NBQ0lCSUFGQkFTQUZkRUVCZFNJTWFpSUNTUVJBSUFzZ0JXc2hCUU5BSUFvZ0FVRUJkR29pQWlBRk9nQUJJQUlnQURvQUFDQUJRUUZxSWdFZ0JpZ0NBQ0FNYWlJQ1NRMEFDd3NnQmlBQ05nSUFJQUJCQVdvaUFDQUhSdzBBQ3d3QkMwRlVJUWdMSUFSQkVHb2tBQ0FJQ3hRQUlBQW9BQUJCZ1BxZXJRTnNRU0FnQVd0MkN5Z0FBa0FDUUFKQUlBQW9Bb3dCUVg5cURnSUFBUUlMSUFBZ0FSRENBdzhMSUFBZ0FSREhBd3NMT2dFQmZ5QUJJQUFvQWdScklnRWdBQ2dDR0NJQ1FZQUlha3NFUUNBQUlBRWdBU0FDYTBHQWVHb2lBRUdBQkNBQVFZQUVTUnRyTmdJWUN3c1ZBQ0FBRUpFQkJFQWdBQ2dDQkE4TElBQXRBQXNMUlFFQmZ3SkFJQUlnQTAwZ0FDQUJUWElOQUFOQUlBQkJmMm9pQUMwQUFDQUNRWDlxSWdJdEFBQkhEUUVnQkVFQmFpRUVJQUlnQTAwTkFTQUFJQUZMRFFBTEN5QUVDd3dBSUFCQklDQUJhNjJJcHdzUUFDQUFJQUVnQWlnQ0NIUkJBM1JxQ3hJQUlBQkJ3QUFnQVd1dGlLZEJBQ0FCR3dzdkFFRWdJQUZySWdFZ0Fra0VRQ0FBcDBGL0lBSjBRWDl6Y1E4TElBQWdBU0FDYTYySXAwRi9JQUowUVg5emNRc2dBQ0FDclNBQUlBR3RRZ3A4SUFOK2ZVTGp5Slc5eTV2dmpVOStmRUlLZkFzb0FRRi9Jd0JCRUdzaUFpUUFJQUJCekE4Z0FrRUlhaUFCRU1ZQ0VCczJBZ0FnQWtFUWFpUUFDeEFBSUFBZ0FqWUNCQ0FBSUFFMkFnQUxHd0FnQUNrQUFFS0FnT3o4eTV2dmpVOStRY0FBSUFGcnJZaW5DeHNBSUFBcEFBQkNnSUNBMk11Yjc0MVBma0hBQUNBQmE2Mklwd3NVQUNBQUtBQUFRYkh6M2ZGNWJFRWdJQUZyZGdzTkFDQUFLQUlJUVFoMlFRRnhDeEFBSUFCQ0FEY0NBQ0FBUWdBM0FnZ0xVZ0VCZnlBQUtBSWdJZ0lnQVVrRVFDQUNSUVJBSUFBZ0FDZ0NDRFlDRUFzQ1FDQUJRUUpKRFFBZ0FDQUFLQUlVUVh4eElnSTJBaFFnQWlBQUtBSVFUdzBBSUFBZ0FqWUNFQXNnQUNBQk5nSWdDd3RIQVFGL0lBQW9BZ3doQXlBQUlBSVE0UUVnQUNnQ0ZDQUJheUlCSUFOSkJFQWdBRUVCTmdJWVFRQVBDeUFCSUFBb0FoQkpCRUFnQUNBQk5nSVFDeUFBSUFFMkFoUWdBUXNLQUNBQVFRTnFRWHh4Q3c4QUlBQWdBUkRuQVNBQ1FRTnNUd3NkQVFGL0lBQWdBQ2dDQUNBQUtBSUVheUlCTmdJUUlBQWdBVFlDREFzdkFDQUFRUUEyQWhnZ0FDQUFLQUlJTmdJTUlBQWdBQ2dDQkRZQ0ZDQUFLQUlnUVFKUEJFQWdBRUVCTmdJZ0N3c0hBQ0FCSUFCckN3MEFJQUFvQWhBZ0FDZ0NERWtMRlFBZ0FDQUJRWDlxUVFZZ0FVRUhTeHQyUVFKcUM4b0JBUWQvQWtBZ0FVVU5BQ0FBS0FJRUlnTWdBQ2dDQ0NJR0lBTWdCa3NiSVFnRFFDQURJQWhHRFFFZ0FDZ0NBQ0lKSUFOQkRHeHFJZ1VoQkNBQklBVW9BZ1FpQjAwRVFDQUVJQWNnQVdzMkFnUVBDeUFFUVFBMkFnUWdBU0FIYXlJQklBVW9BZ2dpQkVrRVFDQUZJQVFnQVdzaUFUWUNDQ0FCSUFKUERRSWdBMEVCYWlJQ0lBWkpCRUFnQ1VFTWFpQURRUXhzYWlJRElBTW9BZ1FnQVdvMkFnUUxJQUFnQWpZQ0JBOExJQVZCQURZQ0NDQUFJQU5CQVdvaUF6WUNCQ0FCSUFScklnRU5BQXNMQzVnRUFneC9BWDRqQUVFUWF5SUlKQUFnQkNBRmFpRUpJQUVvQW9RQklROGdBU2dDakFFZ0FSRHNBUkR6QVNFTEFrQUNRQ0FGUVFGSURRQWdBQ2dDQkNBQUtBSUlUdzBBSUFsQllHb2hEQU5BSUFnZ0FDQUpJQVJySWdVZ0R4Q21BeUFJS0FJQUlnMUZEUUlnQVNBRUVOSUJJQUVnQkJEUkFTQUJJQUlnQXlBRUlBZ29BZ1FpQlNBTEVRSUFJUVlnQXlrQ0FDRVNJQU1nRFRZQ0FDQURJQkkzQWdRZ0JDQUZhaUlLSUFacklRY2dDQ2dDQ0NJUVFYMXFJUTRnQWlnQ0RDRUVBa0FDUUNBS0lBeE5CRUFnQkNBSEVCd2dBaWdDRENFRUlBWkJFRTBFUUNBQ0lBUWdCbW8yQWd3TUF3c2dCRUVRYWlBSFFSQnFJZ1VRSENBRVFTQnFJQWRCSUdvUUhDQUdRVEZJRFFFZ0JDQUdhaUVSSUFSQk1Hb2hCQU5BSUFRZ0JVRWdhaUlIRUJ3Z0JFRVFhaUFGUVRCcUVCd2dCeUVGSUFSQklHb2lCQ0FSU1EwQUN3d0JDeUFFSUFjZ0NpQU1FQ0lMSUFJZ0FpZ0NEQ0FHYWpZQ0RDQUdRWUNBQkVrTkFDQUNRUUUyQWlRZ0FpQUNLQUlFSUFJb0FnQnJRUU4xTmdJb0N5QUNLQUlFSWdRZ0RVRURhallDQUNBRUlBWTdBUVFnRGtHQWdBUlBCRUFnQWtFQ05nSWtJQUlnQkNBQ0tBSUFhMEVEZFRZQ0tBc2dCQ0FPT3dFR0lBSWdCRUVJYWpZQ0JDQUtJQkJxSWdRZ0NVOE5BU0FBS0FJRUlBQW9BZ2hKRFFBTEN5QUpJQVJySVFVTElBRWdCQkRTQVNBQklBUVEwUUVnQVNBQ0lBTWdCQ0FGSUFzUkFnQWhBQ0FJUVJCcUpBQWdBQXRSQVFKL0l3QkJJR3NpQVNRQUlBRWdBQ2dDRURZQ0dDQUJJQUFwQWdnM0F4QWdBU0FBS1FJQU53TUlRUUVoQWlBQlFRaHFFT2dCUlFSQUlBQW9BbkJCQUVkQkFYUWhBZ3NnQVVFZ2FpUUFJQUlMR3dFQmZ5QUFLQUlRSUFBb0Fnd2lBVWtFUUNBQUlBRTJBaEFMQ3d3QUlBQWdBQ2dDQ0RZQ0VBc1JBQ0FCSUFBb0FnUnJRWUNBZ0lCNlN3dXBBUUVFZndKQUlBRWdBQ2dDQUNJRFJnUkFJQUFvQWd3aEF5QUFLQUlRSVFVZ0FDZ0NDQ0VFUVFFaEJnd0JDeUFBSUFBb0Fnd2lCVFlDRUNBQUlBQW9BZ1FpQkRZQ0NDQUFJQU1nQkdzaUF6WUNEQ0FBSUFFZ0EyczJBZ1FnQXlBRmEwRUhTdzBBSUFBZ0F6WUNFQ0FESVFVTElBQWdBU0FDYWlJQ05nSUFJQUlnQkNBRmFrMGdBeUFFYWlBQlRYSkZCRUFnQUNBRElBSWdCR3NpQUNBQUlBTktHellDRUFzZ0JndVJBd0VHZnlBQ0tBSW9JUVlnQWlnQ0JDRUpJQUlvQWlRaEJ5QUNLQUlnSWdvRVFDQURRdjhCVmlBRFF2K0JCRlpxSUFOQy92Ly8vdzlXYWlFSUMwRzZmeUVGQWtBZ0FVRVNTUTBBUVFBZ0JFRUFSeUFFUWY4QlMyb2dCRUgvL3dOTGFpQUdHeUlHSUFkQkFFcEJBblJxUVNCQkFDQUtRUUJIUVFFZ0NYU3RJQU5hY1NJQkczSWdDRUVHZEhJaEIwRUFJUVVnQWlnQ0FFVUVRQ0FBUWFqcXZta1FUVUVFSVFVTElBQWdCV29nQnpvQUFDQUZRUUZ5SVFVZ0FVVUVRQ0FBSUFWcUlBbEJBM1JCc0g5cU9nQUFJQVZCQVdvaEJRc0NRQUpBQWtBQ1FDQUdRWDlxRGdNQUFRSURDeUFBSUFWcUlBUTZBQUFnQlVFQmFpRUZEQUlMSUFBZ0JXb2dCRUgvL3dOeEVDOGdCVUVDYWlFRkRBRUxJQUFnQldvZ0JCQk5JQVZCQkdvaEJRc0NRQUpBQWtBQ1FDQUlRWDlxRGdNQkFnTUFDeUFCUlEwRElBQWdCV29nQXp3QUFDQUZRUUZxRHdzZ0FDQUZhaUFEcDBHQWZtcEIvLzhEY1JBdklBVkJBbW9QQ3lBQUlBVnFJQU9uRUUwZ0JVRUVhZzhMSUFBZ0JXb2dBemNBQUNBRlFRaHFJUVVMSUFVTEhRQWdBRUVBTmdJa0lBQWdBQ2dDQ0RZQ0RDQUFJQUFvQWdBMkFnUUxGUUFnQVVFb2JDQUFRUUowYWtHUW1RRnFLQUlBQ3dvQUlBQWdBVUVGUzJzTEF3QUJDMDBBSUFBb0F2QUZJQUFvQXBnRElBQW9BcHdESUFBb0FxQURFR1FnQUNnQ2dBWVE5d01nQUVFQU5nS1FCaUFBUWdBM0E0Z0dJQUJDQURjRGdBWWdBRUlBTndQNEJTQUFRZ0EzQS9BRkMwUUJBMzhnQWtFQVRnUi9BMEFnQkNBQklBTkJBblFpQkdvb0FnQWdBQ0FFYWkwQUFteHFJUVFnQWlBRFJ5RUZJQU5CQVdvaEF5QUZEUUFMSUFSQkEzWUZJQU1MQzZBRUFRVi9Jd0JCRUdzaUN5UUFJQXRCL3dFMkFneEJmeUVKQWtBZ0JVRURjUTBBSUFGRkJFQkJBQ0VKREFFTFFiaC9JUWtnQTBHQWdBaExEUUFnQUNBQmFpRU1Ba0FnQjBFQVJ5QUlRUUJIY1NJSVJRMEFJQWNvQWdCQkFrY05BQ0FBSUFBZ0RDQUNJQU1nQkNBR0VJRUJJUWtNQVFzZ0JTQUxRUXhxSUFJZ0F5QUZFSWtFSWdrUUlRMEFJQU1nQ1VZRVFDQUFJQUl0QUFBNkFBQkJBU0VKREFFTElBa2dBMEVIZGtFRWFrMGhDa0VBSVFrZ0NnMEFBa0FnQjBVTkFBSkFBa0FnQnlnQ0FDSUpRUUZHQkVBZ0JpQUZJQXNvQWd3USt3TU5BU0FIUVFBMkFnQU1Bd3NnQ1VVTkFpQUlRUUZ6UlEwQkRBSUxJQWhGRFFFTElBQWdBQ0FNSUFJZ0F5QUVJQVlRZ1FFaENRd0JDeUFGUVlBSWFpSUlJQVVnQ3lnQ0RDSUtRUXNnQXlBS1FRRVFnUUlnQlVHQUVHb1Evd01pQ1JBaERRQWdDa0VDZENJTklBaHFRUVJxUVFCQi9BY2dEV3NRS0JvZ0FDQUJJQWdnQ2lBSkVJQUVJZ0VRSVFSQUlBRWhDUXdCQ3dKQUFrQWdCd1JBSUFjb0FnQkZCRUFnQVVFTWFpRUZEQUlMSUFZZ0JTQUtFUGNCSVFrZ0NDQUZJQW9ROXdFaENpQUJRUXhxSWdVZ0EwbEJBQ0FKSUFFZ0NtcExHdzBCSUFBZ0FDQU1JQUlnQXlBRUlBWVFnUUVoQ1F3REMwRUFJUWtnQVVFTWFpQURUdzBDREFFTFFRQWhDU0FGSUFOUERRRWdCMEVBTmdJQUN5QUdCRUFnQmlBSVFZQUlFQ29hQ3lBQUlBQWdBV29nRENBQ0lBTWdCQ0FJRUlFQklRa0xJQXRCRUdva0FDQUpDdzBBSUFBZ0FVRUNkR290QUFJTGdBSUJCbjhqQUVHUUEyc2lCQ1FBSUFSQkREWUNqQU1DUUNBRFFRSkpEUUFnQkVFZ2FpQUVRWXdEYWlBQ0lBTVFxZ0VpQlNBRFJpRUdJQVZCQVVZZ0F5QUZSbklOQUNBRVFRWWdBeUFFS0FLTUF5SUhFS2NCSWdnZ0JFRWdhaUFESUFjUXBnRWlCaEFoRFFBZ0FDQUJJQVFnQnlBSUVLZ0JJZ1VRSVNJSkJFQWdCU0VHREFFTElBUkJvQUZxSUFRZ0J5QUlJQVJCNEFCcVFjQUFFS2tCSWdZUUlRMEFJQUFnQUNBRmFpQUpHeUlGSUFBZ0FXb2dCV3NpQVNBQ0lBTWdCRUdnQVdvZ0F5QURRUWQyYWtFSWFpQUJUUkNHQkNJQkVDRUVRQ0FCSVFZTUFRdEJBQ0VHSUFGRkRRQWdBU0FGYWlBQWF5RUdDeUFFUVpBRGFpUUFJQVlMZ2dRQkJuOGpBRUdRQW1zaUN5UUFRYmgvSVFnQ1FDQUZSUTBBSUFRc0FBQWlDVUgvQVhFaEJnSkFBa0FnQ1VGL1RBUkFJQVpCZ245cVFRRjJJZ2tnQlU4TkEwRnNJUWdnQmtHQmYyb2lCMEgvQVVzTkF5QUhSUTBDSUFSQkFXb2hCRUVBSVFVRFFDQUFJQVZxSUFRZ0JVRUJkbW9pQmkwQUFFRUVkam9BQUNBQUlBVkJBWEpxSUFZdEFBQkJEM0U2QUFBZ0JVRUNhaUlGSUFkSkRRQUxJQWtoQmd3QkN5QUdJQVZQRFFJZ0FDQUVRUUZxSUFZZ0N4Q0JCQ0lISVFnZ0J4QWhEUUlMSUFGQ0FEY0NBRUVBSVFRZ0FVRUFOZ0l3SUFGQ0FEY0NLQ0FCUWdBM0FpQWdBVUlBTndJWUlBRkNBRGNDRUNBQlFnQTNBZ2hCYkNFSUlBZEZEUUZCQUNFRkEwQWdBQ0FGYWlJSkxRQUFJZ3BCQzBzTkFpQUJJQXBCQW5ScUlnb2dDaWdDQUVFQmFqWUNBRUVCSUFrdEFBQjBRUUYxSUFScUlRUWdCVUVCYWlJRklBZEhEUUFMSUFSRkRRRWdCQkFrUVFGcUlnVkJERXNOQVNBRElBVTJBZ0JCQVVFQklBVjBJQVJySWdNUUpDSUVkQ0FEUncwQklBQWdCMm9nQkVFQmFpSUFPZ0FBSUFFZ0FFRUNkR29pQUNBQUtBSUFRUUZxTmdJQUlBRW9BZ1FpQUVFQ1NTQUFRUUZ4Y2cwQklBSWdCMEVCYWpZQ0FDQUdRUUZxSVFnTUFRc2dBVUlBTndJQUlBRkJBRFlDTUNBQlFnQTNBaWdnQVVJQU53SWdJQUZDQURjQ0dDQUJRZ0EzQWhBZ0FVSUFOd0lJQ3lBTFFaQUNhaVFBSUFnTENBQWdBQ0FCRUUwTE1RRUNmeUFBRUlRRUlBQVFPU0FBS0FJTUlnSWdBQ2dDRUVrRWZ5QUNJQUFvQWdocklBQW9BZ1JCQUVkcUJTQUJDd3RGQVFGL0lBQW9BZ1FoQVNBQUtBSU1JQUFvQWdBUS9BRWdBQ0FBS0FJTUlBRkJBM1pxTmdJTUlBQWdBQ2dDQkVFSGNUWUNCQ0FBSUFBb0FnQWdBVUY0Y1hZMkFnQUxMd0FnQUNBQk5nSU1JQUFnQVRZQ0NDQUFRZ0EzQWdBZ0FDQUJJQUpxUVh4cU5nSVFRYnAvUVFBZ0FrRUZTUnNMR2dBZ0FCQWtRUUZxSWdBZ0FSQWtRUUpxSWdFZ0FDQUJTUnNMUVFFQmZ5QUJRWDlxRUNRaEJDQUJJQUlRZ0FJaUFTQUVJQU5ySWdJZ0FDQUNJQUJKR3lJQUlBRWdBRXNiSWdCQkJTQUFRUVZMR3lJQVFRd2dBRUVNU1JzTDVBUUJDMzhDZjBGL0lBTkJBV29pRGlBRFNRMEFHaUFFUVFGcUlROGdCRUY3YWlFSFFRRWdCSFFpREVFQmFpRUtJQUFnQVdwQmZtb2hEVUVFSVFFZ0FDRUlBMEFDUUFKQUlBdEZCRUFnQmlFRURBRUxBa0FnQmlJRUlBNVBEUUFEUUNBQ0lBUkJBWFJxTHdFQURRRWdBeUFFUmlFSklBUkJBV29oQkNBSlJRMEFDeUFLSVFrTUFnc2dCQ0FPUmdSQUlBb2hDUXdDQ3lBRUlBWkJHR29pQ1U4RVFFSC8vd01nQVhRaEN3TkFJQVVnQ0NBTlRYSkZCRUJCdW44UEN5QUlJQWNnQzJvaUJqc0FBQ0FHUVJCMklRY2dDRUVDYWlFSUlBa2lCa0VZYWlJUUlRa2dCQ0FRVHcwQUN3c2dCQ0FHUVFOcUlnbFBCRUFEUUVFRElBRjBJQWRxSVFjZ0FVRUNhaUVCSUFRZ0NTSUdRUU5xSWdsUERRQUxDeUFFSUFacklBRjBJQWRxSVFjZ0FVRVBTQVJBSUFGQkFtb2hBUXdCQ3lBRklBZ2dEVTF5UlFSQVFicC9Ed3NnQ0NBSE93QUFJQUZCY21vaEFTQUhRUkIySVFjZ0NFRUNhaUVJQzBGL0lBSWdCRUVCZEdvdUFRQWlCa0VBSUFacklBWkJBRWdiSUFwcUlnbEJBVWdOQWhvZ0FTQVBha0VBSUFwQmYzTWdERUVCZEdvaUN5QUdRUUZxSWdZZ0RFZ2JJQVpxSWdvZ0MwaHJJUVlnQ1NBTVNBUkFBMEFnRDBGL2FpRVBJQWtnREVFQmRTSU1TQTBBQ3dzZ0NpQUJkQ0FIYWlFSElBWkJFVWdFZnlBR0JTQUZJQWdnRFUxeVJRUkFRYnAvRHdzZ0NDQUhPd0FBSUFkQkVIWWhCeUFJUVFKcUlRZ2dCa0Z3YWdzaEFTQUpRUUpJRFFBZ0NrRUJSaUVMSUFraENpQUVRUUZxSWdZZ0Rra05BUXNMUVg4Z0NVRUJSdzBBR2lBRlJRUkFRYnAvSUFnZ0RVc05BUm9MSUFnZ0J6c0FBQ0FJSUFGQkIycEJDRzFxSUFCckN3dmdCZ0VKZnlBQktBSUFJUXdnQlVFQVFZQWdFQ2doQnlBRFJRUkFJQUJCQUNBTVFRRnFFQ2dhSUFGQkFEWUNBRUVBRHdzZ0IwR0FHR29oQ0NBSFFZQVFhaUVKSUFkQmdBaHFJUW9nQWlBRGFpRU5Ba0FnQTBFVVNBUkFJQUloQXd3QkN5QU5RWEZxSVE0Z0FrRUVhaUVGSUFJb0FBQWhCZ05BSUFVb0FBQWhBeUFISUFaQi93RnhRUUowYWlJRklBVW9BZ0JCQVdvMkFnQWdDaUFHUVFaMlFmd0hjV29pQlNBRktBSUFRUUZxTmdJQUlBa2dCa0VPZGtIOEIzRnFJZ1VnQlNnQ0FFRUJhallDQUNBSUlBWkJGblpCL0FkeGFpSUZJQVVvQWdCQkFXbzJBZ0FnQWlnQUNDRUZJQWNnQTBIL0FYRkJBblJxSWdZZ0JpZ0NBRUVCYWpZQ0FDQUtJQU5CQm5aQi9BZHhhaUlHSUFZb0FnQkJBV28yQWdBZ0NTQURRUTUyUWZ3SGNXb2lCaUFHS0FJQVFRRnFOZ0lBSUFnZ0EwRVdka0g4QjNGcUlnTWdBeWdDQUVFQmFqWUNBQ0FDS0FBTUlRc2dCeUFGUWY4QmNVRUNkR29pQXlBREtBSUFRUUZxTmdJQUlBb2dCVUVHZGtIOEIzRnFJZ01nQXlnQ0FFRUJhallDQUNBSklBVkJEblpCL0FkeGFpSURJQU1vQWdCQkFXbzJBZ0FnQ0NBRlFSWjJRZndIY1dvaUF5QURLQUlBUVFGcU5nSUFJQUpCRUdvaUF5Z0FBQ0VHSUFjZ0MwSC9BWEZCQW5ScUlnVWdCU2dDQUVFQmFqWUNBQ0FLSUF0QkJuWkIvQWR4YWlJRklBVW9BZ0JCQVdvMkFnQWdDU0FMUVE1MlFmd0hjV29pQlNBRktBSUFRUUZxTmdJQUlBZ2dDMEVXZGtIOEIzRnFJZ1VnQlNnQ0FFRUJhallDQUNBQ1FSUnFJUVVnQXlFQ0lBVWdEa2tOQUFzTElBTWdEVWtFUUFOQUlBY2dBeTBBQUVFQ2RHb2lBaUFDS0FJQVFRRnFOZ0lBSUFOQkFXb2lBeUFOUncwQUN3c0NRQ0FFUlNBTVFmOEJJQXdiSWdKQi93RlBjZzBBUWY4QklRTURRQUpBSUFjZ0EwRUNkQ0lFYWlJRklBVW9BZ0FnQkNBSWFpZ0NBQ0FFSUFscUtBSUFJQVFnQ21vb0FnQnFhbW9pQkRZQ0FDQUVEUUFnQTBGL2FpSURJQUpMRFFFTUFnc0xRVkFQQ3lBQ1FmOEJJQUpCL3dGSkd5RUZRUUFoQTBFQUlRWURRQ0FBSUFOQkFuUWlBbW9nQWlBSWFpZ0NBQ0FDSUFscUtBSUFJQUlnQ21vb0FnQWdBaUFIYWlnQ0FHcHFhaUlDTmdJQUlBSWdCaUFDSUFaTEd5RUdJQU1nQlVjaEFpQURRUUZxSVFNZ0FnMEFDd05BSUFVaUFrRi9haUVGSUFBZ0FrRUNkR29vQWdCRkRRQUxJQUVnQWpZQ0FDQUdDNGdEQWdWL0JYNGdBRUVvYWlJQklBQW9Ba2dpQldvaEFnSitJQUFwQXdBaUJrSWdXZ1JBSUFBcEF4QWlCMElIaVNBQUtRTUlJZ2hDQVlsOElBQXBBeGdpQ1VJTWlYd2dBQ2tESUNJS1FoS0pmQ0FJRUlRQklBY1FoQUVnQ1JDRUFTQUtFSVFCREFFTElBQXBBeGhDeGMvWnN2SGx1dW9uZkFzZ0Jud2hCZ0pBSUFJZ0FFRXdhaUlFU1FSQUlBRWhBd3dCQ3dOQVFnQWdBU2tBQUJCT0lBYUZRaHVKUW9lVnI2K1l0dDZibm45K1F1UGN5cFg4enZMMWhYOThJUVlnQkNJRElnRkJDR29pQkNBQ1RRMEFDd3NDUUNBRFFRUnFJZ0VnQWtzRVFDQURJUUVNQVFzZ0F5Z0FBSzFDaDVXdnI1aTIzcHVlZjM0Z0JvVkNGNGxDejliVHZ0TEhxOWxDZmtMNTg5M3htZmFacXhaOElRWUxJQUVnQWtrRVFDQUFJQVZxUVNocUlRQURRQ0FCTVFBQVFzWFAyYkx4NWJycUozNGdCb1ZDQzRsQ2g1V3ZyNWkyM3B1ZWYzNGhCaUFCUVFGcUlnRWdBRWNOQUFzTElBWkNJWWdnQm9WQ3o5YlR2dExIcTlsQ2ZpSUdRaDJJSUFhRlF2bnozZkdaOXBtckZuNGlCa0lnaUNBR2hRdjRBZ0lDZndSK0lBQWdBQ2tEQUNBQ3JYdzNBd0FDUUFKQUlBQW9Ba2dpQXlBQ2FrRWZUUVJBSUFBZ0EycEJLR29nQVNBQ0VLc0JJQUFvQWtnZ0Ftb2hBUXdCQ3lBQklBSnFJUVFDUUFKL0lBTUVRQ0FBUVNocUlnSWdBMm9nQVVFZ0lBTnJFS3NCSUFBZ0FDa0RDQ0FDS1FBQUVFNDNBd2dnQUNBQUtRTVFJQUFwQURBUVRqY0RFQ0FBSUFBcEF4Z2dBQ2tBT0JCT053TVlJQUFnQUNrRElDQUFRVUJyS1FBQUVFNDNBeUFnQUNnQ1NDRUNJQUJCQURZQ1NDQUJJQUpyUVNCcUlRRUxJQUZCSUdvZ0JFc0xCRUFnQVNFQ0RBRUxJQVJCWUdvaEF5QUFLUU1nSVFVZ0FDa0RHQ0VHSUFBcEF4QWhCeUFBS1FNSUlRZ0RRQ0FJSUFFcEFBQVFUaUVJSUFjZ0FTa0FDQkJPSVFjZ0JpQUJLUUFRRUU0aEJpQUZJQUVwQUJnUVRpRUZJQUZCSUdvaUFpRUJJQUlnQTAwTkFBc2dBQ0FGTndNZ0lBQWdCamNER0NBQUlBYzNBeEFnQUNBSU53TUlDeUFDSUFSUERRRWdBRUVvYWlBQ0lBUWdBbXNpQVJDckFRc2dBQ0FCTmdKSUN3dGxBQ0FBUWdBM0F5Z2dBRUw1NnREUTU4bWg1T0VBTndNZ0lBQkNBRGNER0NBQVFzL1cwNzdTeDZ2WlFqY0RFQ0FBUXRicmd1N3EvWW4xNEFBM0F3Z2dBRUlBTndNQUlBQkNBRGNETUNBQVFnQTNBemdnQUVGQWEwSUFOd01BSUFCQ0FEY0RTQXNWQUNBQkJFQWdBaUFBSUFFUkF3QVBDeUFBRUV3TFlRRURmMEYrSVFFQ1FDQUFSUTBBSUFBb0Fod2lBa1VOQUNBQUtBSWtJZ05GRFFBZ0FpZ0NOQ0lCQkVBZ0FDZ0NLQ0FCSUFNUkJBQWdBQ2dDSkNFRElBQW9BaHdoQWdzZ0FDZ0NLQ0FDSUFNUkJBQkJBQ0VCSUFCQkFEWUNIQXNnQVF1ZEN3RU1meUFDUVFCT0JFQkJCRUVESUFFdkFRSWlDeHNoQjBFSFFZb0JJQXNiSVFRZ0FFRzVMV29oQ0VGL0lRWURRQ0FMSVFrQ1FDQUpJQUVnRENJTlFRRnFJZ3hCQW5ScUx3RUNJZ3RISUFWQkFXb2lBeUFFVG5KRkJFQWdBeUVGREFFTEFrQWdBeUFIU0FSQUlBQWdDVUVDZEdvaUJVSDhGR29oQnlBRlFmNFVhaUVLSUFBdkFiZ3RJUVFnQUNnQ3ZDMGhCUU5BSUFvdkFRQWhCaUFBSUFRZ0J5OEJBQ0lPSUFWMGNpSUVPd0c0TFNBQUFuOGdCVUVRSUFaclNnUkFJQUFnQUNnQ0ZDSUZRUUZxTmdJVUlBVWdBQ2dDQ0dvZ0JEb0FBQ0FBSUFBb0FoUWlCVUVCYWpZQ0ZDQUZJQUFvQWdocUlBZ3RBQUE2QUFBZ0FDQU9RUkFnQUNnQ3ZDMGlCV3QySWdRN0FiZ3RJQVVnQm1wQmNHb01BUXNnQlNBR2Fnc2lCVFlDdkMwZ0EwRi9haUlERFFBTERBRUxJQUFDZnlBSkJFQUNRQ0FHSUFsR0JFQWdBQzhCdUMwaEJ5QUFLQUs4TFNFRUlBTWhCUXdCQ3lBQUlBbEJBblJxSWdaQi9oUnFMd0VBSVFNZ0FDQUFMd0c0TFNBR1Fmd1VhaThCQUNJS0lBQW9Bcnd0SWdaMGNpSUhPd0c0TFFKQUlBWkJFQ0FEYTBvRVFDQUFJQUFvQWhRaUJrRUJhallDRkNBR0lBQW9BZ2hxSUFjNkFBQWdBQ0FBS0FJVUlnWkJBV28yQWhRZ0JpQUFLQUlJYWlBSUxRQUFPZ0FBSUFNZ0FDZ0N2QzBpQm1wQmNHb2hCQ0FLUVJBZ0JtdDJJUWNNQVFzZ0F5QUdhaUVFQ3lBQUlBUTJBcnd0Q3lBSElBQXZBYndWSWdZZ0JIUnlJUWNDUUNBRVFSQWdBQzhCdmhVaUEydEtCRUFnQUNBSE93RzRMU0FBSUFBb0FoUWlCRUVCYWpZQ0ZDQUVJQUFvQWdocUlBYzZBQUFnQUNBQUtBSVVJZ1JCQVdvMkFoUWdCQ0FBS0FJSWFpQUlMUUFBT2dBQUlBTWdBQ2dDdkMwaUIycEJjR29oQkNBR1FSQWdCMnQySVFjTUFRc2dBeUFFYWlFRUN5QUFJQVEyQXJ3dElBQWdCeUFGUWYzL0EycEIvLzhEY1NJRklBUjBjaUlET3dHNExTQUVRUTlPQkVBZ0FDQUFLQUlVSWdaQkFXbzJBaFFnQmlBQUtBSUlhaUFET2dBQUlBQWdBQ2dDRkNJRFFRRnFOZ0lVSUFNZ0FDZ0NDR29nQ0MwQUFEb0FBQ0FBSUFWQkVDQUFLQUs4TFNJRmEzWTdBYmd0SUFWQmNtb01BZ3NnQkVFQ2Fnd0JDeUFGUVFsTUJFQWdBQzhCdUMwZ0FDOEJ3QlVpQ2lBQUtBSzhMU0lEZEhJaEJ3SkFJQU5CRUNBQUx3SENGU0lHYTBvRVFDQUFJQWM3QWJndElBQWdBQ2dDRkNJRFFRRnFOZ0lVSUFNZ0FDZ0NDR29nQnpvQUFDQUFJQUFvQWhRaUEwRUJhallDRkNBRElBQW9BZ2hxSUFndEFBQTZBQUFnQmlBQUtBSzhMU0lEYWtGd2FpRUVJQXBCRUNBRGEzWWhCd3dCQ3lBRElBWnFJUVFMSUFBZ0JEWUN2QzBnQUNBSElBVkIvdjhEYWtILy93TnhJZ1VnQkhSeUlnTTdBYmd0SUFSQkRrNEVRQ0FBSUFBb0FoUWlCa0VCYWpZQ0ZDQUdJQUFvQWdocUlBTTZBQUFnQUNBQUtBSVVJZ05CQVdvMkFoUWdBeUFBS0FJSWFpQUlMUUFBT2dBQUlBQWdCVUVRSUFBb0Fyd3RJZ1ZyZGpzQnVDMGdCVUZ6YWd3Q0N5QUVRUU5xREFFTElBQXZBYmd0SUFBdkFjUVZJZ29nQUNnQ3ZDMGlBM1J5SVFjQ1FDQURRUkFnQUM4QnhoVWlCbXRLQkVBZ0FDQUhPd0c0TFNBQUlBQW9BaFFpQTBFQmFqWUNGQ0FESUFBb0FnaHFJQWM2QUFBZ0FDQUFLQUlVSWdOQkFXbzJBaFFnQXlBQUtBSUlhaUFJTFFBQU9nQUFJQVlnQUNnQ3ZDMGlBMnBCY0dvaEJDQUtRUkFnQTJ0MklRY01BUXNnQXlBR2FpRUVDeUFBSUFRMkFyd3RJQUFnQnlBRlFmYi9BMnBCLy84RGNTSUZJQVIwY2lJRE93RzRMU0FFUVFwT0JFQWdBQ0FBS0FJVUlnWkJBV28yQWhRZ0JpQUFLQUlJYWlBRE9nQUFJQUFnQUNnQ0ZDSURRUUZxTmdJVUlBTWdBQ2dDQ0dvZ0NDMEFBRG9BQUNBQUlBVkJFQ0FBS0FLOExTSUZhM1k3QWJndElBVkJkMm9NQVFzZ0JFRUhhZ3MyQXJ3dEMwRUFJUVVDZnlBTFJRUkFRWW9CSVFSQkF3d0JDMEVHUVFjZ0NTQUxSaUlER3lFRVFRTkJCQ0FER3dzaEJ5QUpJUVlMSUFJZ0RVY05BQXNMQzdrQ0FReC9JQUV2QVFJaEJpQUNRUUowSUFGcVFmLy9BenNCQmlBQ1FRQk9CRUJCQjBHS0FTQUdHeUVJUVFSQkF5QUdHeUVISUFCQndCVnFJUXNnQUVIRUZXb2hEQ0FBUWJ3VmFpRU5RWDhoQ1FOQUlBWWhCQUpBSUFRZ0FTQUtJZzVCQVdvaUNrRUNkR292QVFJaUJrY2dBMEVCYWlJRklBaE9ja1VFUUNBRklRTU1BUXNDZnlBRklBZElCRUFnQUNBRVFRSjBha0g4RkdvaUF5OEJBQ0FGYWd3QkN5QUVCRUFnQkNBSlJ3UkFJQUFnQkVFQ2RHcEIvQlJxSWdNZ0F5OEJBRUVCYWpzQkFBc2dEU0lETHdFQVFRRnFEQUVMSUFOQkNVd0VRQ0FMSWdNdkFRQkJBV29NQVFzZ0RDSURMd0VBUVFGcUN5RUZJQU1nQlRzQkFFRUFJUU1DZnlBR1JRUkFRUU1oQjBHS0FRd0JDMEVEUVFRZ0JDQUdSaUlGR3lFSFFRWkJCeUFGR3dzaENDQUVJUWtMSUFJZ0RrY05BQXNMQytFSUFRcC9Ba0FnQUNnQ29DMUZCRUFnQUM4QnVDMGhCU0FBS0FLOExTRUVEQUVMSUFCQnVTMXFJUWdEUUNBRFFRRnFJUW9nQUNnQ21DMGdBMm90QUFBaEJRSkFJQUFDZnlBQUtBS2tMU0FEUVFGMGFpOEJBQ0lKUlFSQUlBRWdCVUVDZEdvaUJDOEJBaUVESUFBZ0FDOEJ1QzBnQkM4QkFDSUhJQUFvQXJ3dElnUjBjaUlGT3dHNExTQUVRUkFnQTJ0S0JFQWdBQ0FBS0FJVUlnUkJBV28yQWhRZ0JDQUFLQUlJYWlBRk9nQUFJQUFnQUNnQ0ZDSUVRUUZxTmdJVUlBUWdBQ2dDQ0dvZ0NDMEFBRG9BQUNBQUlBZEJFQ0FBS0FLOExTSUVhM1lpQlRzQnVDMGdBeUFFYWtGd2Fnd0NDeUFESUFScURBRUxJQVZCb09VQWFpMEFBQ0lMUVFKMElnZEJnQWh5SUFGcUlnUXZBUVloQXlBQUlBQXZBYmd0SUFRdkFRUWlEQ0FBS0FLOExTSUdkSElpQkRzQnVDMGdBQUovSUFaQkVDQURhMG9FUUNBQUlBQW9BaFFpQmtFQmFqWUNGQ0FHSUFBb0FnaHFJQVE2QUFBZ0FDQUFLQUlVSWdSQkFXbzJBaFFnQkNBQUtBSUlhaUFJTFFBQU9nQUFJQUFnREVFUUlBQW9Bcnd0SWdacmRpSUVPd0c0TFNBRElBWnFRWEJxREFFTElBTWdCbW9MSWdNMkFyd3RJQXRCZUdwQkUwMEVRQ0FBSUFRZ0JTQUhRYURuQUdvb0FnQnJRZi8vQTNFaUJpQURkSElpQkRzQnVDMGdBQUovSUFOQkVDQUhRWURrQUdvb0FnQWlCV3RLQkVBZ0FDQUFLQUlVSWdOQkFXbzJBaFFnQXlBQUtBSUlhaUFFT2dBQUlBQWdBQ2dDRkNJRFFRRnFOZ0lVSUFNZ0FDZ0NDR29nQ0MwQUFEb0FBQ0FBSUFaQkVDQUFLQUs4TFNJRGEzWWlCRHNCdUMwZ0F5QUZha0Z3YWd3QkN5QURJQVZxQ3lJRE5nSzhMUXNnQWlBSlFYOXFJZ2NnQjBFSGRrR0FBbW9nQjBHQUFra2JRYURvQUdvdEFBQWlDMEVDZENJSmFpSUZMd0VDSVFZZ0FDQUVJQVV2QVFBaURDQURkSElpQlRzQnVDMGdBQUovSUFOQkVDQUdhMG9FUUNBQUlBQW9BaFFpQTBFQmFqWUNGQ0FESUFBb0FnaHFJQVU2QUFBZ0FDQUFLQUlVSWdOQkFXbzJBaFFnQXlBQUtBSUlhaUFJTFFBQU9nQUFJQUFnREVFUUlBQW9Bcnd0SWdOcmRpSUZPd0c0TFNBRElBWnFRWEJxREFFTElBTWdCbW9MSWdRMkFyd3RJQXRCQkVrTkFTQUFJQVVnQnlBSlFhRHNBR29vQWdCclFmLy9BM0VpQnlBRWRISWlCVHNCdUMwZ0JFRVFJQWxCZ05vQWFpZ0NBQ0lEYTBvRVFDQUFJQUFvQWhRaUJFRUJhallDRkNBRUlBQW9BZ2hxSUFVNkFBQWdBQ0FBS0FJVUlnUkJBV28yQWhRZ0JDQUFLQUlJYWlBSUxRQUFPZ0FBSUFBZ0IwRVFJQUFvQXJ3dElnUnJkaUlGT3dHNExTQURJQVJxUVhCcURBRUxJQU1nQkdvTElnUTJBcnd0Q3lBS0lnTWdBQ2dDb0MxSkRRQUxDeUFCUVlJSWFpOEJBQ0VDSUFBZ0JTQUJMd0dBQ0NJQklBUjBjaUlET3dHNExTQUVRUkFnQW10S0JFQWdBQ0FBS0FJVUlncEJBV28yQWhRZ0NpQUFLQUlJYWlBRE9nQUFJQUFnQUNnQ0ZDSURRUUZxTmdJVUlBTWdBQ2dDQ0dvZ0FFRzVMV290QUFBNkFBQWdBQ0FCUVJBZ0FDZ0N2QzBpQVd0Mk93RzRMU0FBSUFFZ0FtcEJjR28yQXJ3dER3c2dBQ0FDSUFScU5nSzhMUXVYQVFFQ2Z3SkFBbjhnQUNnQ3ZDMGlBVUVKVGdSQUlBQWdBQ2dDRkNJQlFRRnFOZ0lVSUFFZ0FDZ0NDR29nQUMwQXVDMDZBQUFnQUNBQUtBSVVJZ0ZCQVdvMkFoUWdBRUc1TFdvdEFBQWhBaUFCSUFBb0FnaHFEQUVMSUFGQkFVZ05BU0FBSUFBb0FoUWlBVUVCYWpZQ0ZDQUFMUUM0TFNFQ0lBRWdBQ2dDQ0dvTElBSTZBQUFMSUFCQkFEWUN2QzBnQUVFQU93RzRMUXZhQkFFQmZ3TkFJQUFnQVVFQ2RHcEJBRHNCbEFFZ0FVRUJhaUlCUVo0Q1J3MEFDeUFBUVFBN0Fmd1VJQUJCQURzQmlCTWdBRUhFRldwQkFEc0JBQ0FBUWNBVmFrRUFPd0VBSUFCQnZCVnFRUUE3QVFBZ0FFRzRGV3BCQURzQkFDQUFRYlFWYWtFQU93RUFJQUJCc0JWcVFRQTdBUUFnQUVHc0ZXcEJBRHNCQUNBQVFhZ1Zha0VBT3dFQUlBQkJwQlZxUVFBN0FRQWdBRUdnRldwQkFEc0JBQ0FBUVp3VmFrRUFPd0VBSUFCQm1CVnFRUUE3QVFBZ0FFR1VGV3BCQURzQkFDQUFRWkFWYWtFQU93RUFJQUJCakJWcVFRQTdBUUFnQUVHSUZXcEJBRHNCQUNBQVFZUVZha0VBT3dFQUlBQkJnQlZxUVFBN0FRQWdBRUg4RTJwQkFEc0JBQ0FBUWZnVGFrRUFPd0VBSUFCQjlCTnFRUUE3QVFBZ0FFSHdFMnBCQURzQkFDQUFRZXdUYWtFQU93RUFJQUJCNkJOcVFRQTdBUUFnQUVIa0UycEJBRHNCQUNBQVFlQVRha0VBT3dFQUlBQkIzQk5xUVFBN0FRQWdBRUhZRTJwQkFEc0JBQ0FBUWRRVGFrRUFPd0VBSUFCQjBCTnFRUUE3QVFBZ0FFSE1FMnBCQURzQkFDQUFRY2dUYWtFQU93RUFJQUJCeEJOcVFRQTdBUUFnQUVIQUUycEJBRHNCQUNBQVFid1Rha0VBT3dFQUlBQkJ1Qk5xUVFBN0FRQWdBRUcwRTJwQkFEc0JBQ0FBUWJBVGFrRUFPd0VBSUFCQnJCTnFRUUE3QVFBZ0FFR29FMnBCQURzQkFDQUFRYVFUYWtFQU93RUFJQUJCb0JOcVFRQTdBUUFnQUVHY0UycEJBRHNCQUNBQVFaZ1Rha0VBT3dFQUlBQkJsQk5xUVFBN0FRQWdBRUdRRTJwQkFEc0JBQ0FBUVl3VGFrRUFPd0VBSUFCQ0FEY0NyQzBnQUVHVUNXcEJBVHNCQUNBQVFRQTJBcWd0SUFCQkFEWUNvQzBMbmdFQkFuOGdBQ0FBTHdHNExTQURRZi8vQTNFaUJDQUFLQUs4TFNJRGRISWlCVHNCdUMwZ0FBSi9JQU5CRGs0RVFDQUFJQUFvQWhRaUEwRUJhallDRkNBRElBQW9BZ2hxSUFVNkFBQWdBQ0FBS0FJVUlnTkJBV28yQWhRZ0F5QUFLQUlJYWlBQVFia3RhaTBBQURvQUFDQUFJQVJCRUNBQUtBSzhMU0lEYTNZN0FiZ3RJQU5CYzJvTUFRc2dBMEVEYWdzMkFyd3RJQUFnQVNBQ0VKb0VDNWNFQVJCL0lBQW9BbndpQkNBRVFRSjJJQUFvQW5naUJDQUFLQUtNQVVrYklRbEJBQ0FBS0FKc0lnSWdBQ2dDTEd0QmhnSnFJZ01nQXlBQ1N4c2hEQ0FBS0FKMElnY2dBQ2dDa0FFaUF5QURJQWRMR3lFTklBQW9BamdpRGlBQ2FpSUZRWUlDYWlFUElBUWdCV29pQWkwQUFDRUtJQUpCZjJvdEFBQWhDeUFBS0FJMElSQWdBQ2dDUUNFUkEwQUNRQUpBSUFFZ0Rtb2lBeUFFYWlJQ0xRQUFJQXBIRFFBZ0FrRi9haTBBQUNBTFJ3MEFJQU10QUFBZ0JTMEFBRWNOQUVFQ0lRWWdBeTBBQVNBRkxRQUJSdzBBQTBBQ1FDQUZJQVpxSWdJdEFBRWdBeTBBQTBjRVFDQUNRUUZxSVFJTUFRc2dBaTBBQWlBRExRQUVSd1JBSUFKQkFtb2hBZ3dCQ3lBQ0xRQURJQU10QUFWSEJFQWdBa0VEYWlFQ0RBRUxJQUl0QUFRZ0F5MEFCa2NFUUNBQ1FRUnFJUUlNQVFzZ0FpMEFCU0FETFFBSFJ3UkFJQUpCQldvaEFnd0JDeUFDTFFBR0lBTXRBQWhIQkVBZ0FrRUdhaUVDREFFTElBSXRBQWNnQXkwQUNVY0VRQ0FDUVFkcUlRSU1BUXNnQmtINUFVc2hDQ0FGSUFaQkNHb2lCbW9oQWlBSURRQWdBeTBBQ2lFSUlBTkJDR29oQXlBQ0xRQUFJQWhHRFFFTEN5QUNJQTlySWdOQmdnSnFJZ0lnQkV3TkFDQUFJQUUyQW5BZ0FpQU5UZ1JBSUFJaEJBd0NDeUFDSUFWcUxRQUFJUW9nQXlBRmFpMEFnUUloQ3lBQ0lRUUxJQXdnRVNBQklCQnhRUUYwYWk4QkFDSUJUdzBBSUFsQmYyb2lDUTBCQ3dzZ0J5QUVJQVFnQjBzYkMrQkdBVEYvSXdCQnNJQUVheUlaSkFBZ0F5Z0NBQ0VMSUFOQkFEWUNBQ0FDSUFScUlqZEJlMm9nTnlBSFFRSkdJanNiSVRJZ0FpRWRBbjhDUUNBTElBRWlKMm9pT0VGMGFpSTVJQ2RKRFFBZ0JrSC9IeUFHUWY4ZlNSc2hPaUE0UVh0cUlocEJmMm9oTHlBYVFYMXFJU1lnQVNFZUEwQWdBQ2dDa0lBUUlnMUJnSUFFYWlBZUlBQW9Bb1NBRUNJZmF5SU9TeUVNSUI4Z0FDZ0NqSUFRSWh0cUlSd2dBQ2dDaUlBUUlTb2dBQ2dDbklBUUlTc2dIaWdBQUNFaUlBQW9BcFNBRUNJR0lBNUpCRUFEUUNBQUlBWkIvLzhEY1VFQmRHcEJnSUFJYWlBR0lBQWdCaUFmYWhBNlFRSjBhaUlMS0FJQWF5SUVRZi8vQXlBRVFmLy9BMGtiT3dFQUlBc2dCallDQUNBR1FRRnFJZ1lnRGtrTkFBc0xJQTBnRGtHQmdIeHFJQXdiSVN3Z0hpQW5heUVYSUFBZ0RqWUNsSUFRSUNKQi8vOERjU0FpUVJCMlJpQWlRZjhCY1NBaVFSaDJSbkVoSlNBYklDcHFJVEFnSEVFRWFpRVNJQjVCQ0dvaExpQWVRUVJxSVJNZ0hrRi9haUVXSUFBZ0hoQTZRUUowSWlCcUtBSUFJUlJCQXlFTVFRQWhEMEVBSVMxQkFDRU5RUUFoRVNBRklTUURRQUpBSUNSRklCUWdMRWx5RFFCQkFDRVFBa0FnQ2tFQUlBNGdGR3RCQ0VrYkRRQUNRQUovQWtBQ1FDQWJJQlJOQkVBZ0RDQVdhaThBQUNBVUlCOXFJaGdnREdwQmYyb3ZBQUJIRFFVZ0lpQVlLQUFBUncwRklCaEJCR29oQmlBbUlCTk5CSDhnRXdVZ0JpZ0FBQ0FUS0FBQWN5SUVEUUlnQmtFRWFpRUdJQzRMSWdRZ0pra0VRQU5BSUFZb0FBQWdCQ2dBQUhNaUN3UkFJQXNRSlNBRWFpQVRheUVHREFjTElBWkJCR29oQmlBRVFRUnFJZ1FnSmtrTkFBc0xBa0FnQkNBdlR3MEFJQVl2QUFBZ0JDOEFBRWNOQUNBR1FRSnFJUVlnQkVFQ2FpRUVDeUFFSUJwSkJIOGdCRUVCYWlBRUlBWXRBQUFnQkMwQUFFWWJCU0FFQ3lBVGF5RUdEQVFMSUNJZ0ZDQXFhaUlFS0FBQVJ3MEVJQVJCQkdvaEJnSi9JQk1nR2lBZUlCc2dGR3RxSWhVZ0ZTQWFTeHNpQzBGOWFpSVlJQk5ORFFBYUlBWW9BQUFnRXlnQUFITWlCQTBDSUFaQkJHb2hCaUF1Q3lJRUlCaEpCRUFEUUNBR0tBQUFJQVFvQUFCekloQUVRQ0FRRUNVZ0JHb2dFMnNNQlFzZ0JrRUVhaUVHSUFSQkJHb2lCQ0FZU1EwQUN3c0NRQ0FFSUF0QmYycFBEUUFnQmk4QUFDQUVMd0FBUncwQUlBWkJBbW9oQmlBRVFRSnFJUVFMSUFRZ0Mwa0VmeUFFUVFGcUlBUWdCaTBBQUNBRUxRQUFSaHNGSUFRTElCTnJEQUlMSUFRUUpTRUdEQUlMSUFRUUpRc2hCQ0FVSUI5cUlBOENmeUFFUVFScUloQWdIbW9nQzBjZ0ZTQWFUM0pGQkVBZ0hDRUVBbjhDUUNBbUlBc2lCa3NFUUNBY0tBQUFJQXNvQUFCeklnUU5BU0FMUVFScUlRWWdFaUVFQ3lBR0lDWkpCRUFEUUNBRUtBQUFJQVlvQUFCeklnOEVRQ0FQRUNVZ0Jtb2dDMnNNQkFzZ0JFRUVhaUVFSUFaQkJHb2lCaUFtU1EwQUN3c0NRQ0FHSUM5UERRQWdCQzhBQUNBR0x3QUFSdzBBSUFSQkFtb2hCQ0FHUVFKcUlRWUxJQVlnR2trRWZ5QUdRUUZxSUFZZ0JDMEFBQ0FHTFFBQVJoc0ZJQVlMSUF0ckRBRUxJQVFRSlFzZ0VHb2hFQXNnRUNBTVNpSUVDeHNoRHlBUUlBd2dCQnNoREF3QkN5QUdRUVJxSWhBZ0RDQVFJQXhLSWdRYklRd2dHQ0FQSUFRYklROExJQ1JCZjJvaEpBSkFBa0FnRENBUVJ5QU1JQlJxSUE1TGNpQVFRUVJJY2cwQUlCQkJmV29oRlVFQUlRWkJFQ0VMUVFFaEJBTkFJQUFnQmlBVWFrSC8vd054UVFGMGFrR0FnQWhxTHdFQUloZ2dCQ0FFSUJoSklqRWJJUVFnQmlBUklERWJJUkVnQzBFRWRTRVlRUkFnQzBFQmFpQXhHeUVMSUFZZ0dHb2lCaUFWU0EwQUN5QVVRUUFnQkNBVUlBUkpJZ1liUVFBZ0JFRUJTeUlFRzJzaEZDQUVSUTBBUVFOQkFpQUdHeUVHSUJBaERBd0JDd0pBSUJFTkFDQUFJQlJCLy84RGNVRUJkR3BCZ0lBSWFpOEJBRUVCUncwQUlBMUZCRUJCQVNFTklDVkZEUUVnRXlBYUlDSVFNMEVFYWlFdFFRSWhEUXNnRFVFQ1J5QVVRWDlxSWhnZ0xFbHlEUUJCQWlFTklCc2dHQkF5UlEwQUlDSWdLaUFmSUJnZ0cwa2lCQnNnR0dvaUVDZ0FBRWNOQUNBUVFRUnFJREFnR2lBRUd5SUdJQ0lRTTBFRWFpRUxJQ29nQUNnQ2tJQVFJZ1JxSVJRQ1FDQVlJQnRKQkVBZ0JpQUxJQkJxUmdSQUlCd2dHaUFMSUNJUVBSQXpJQXRxSVFzTElCQWdGQ0FpRURFaERRd0JDeUFRSUJBZ0hDQWlFREVpRFdzZ0hFY2dCQ0FiVDNJTkFDQXdJQlJCQUNBTmF5QWlFRDBRTVNBTmFpRU5DeUFZSUJnZ0RXc2lCQ0FzSUFRZ0xFc2JJaFJySUF0cUlnUWdMVWtnQ3lBdFMzSkZCRUFnQ3lBWUlDMXJhaUlFSUJzZ0d5QUVFREliSVJSQkFDRVJRUUloQmtFQ0lRME1BZ3RCQUNFUlFRSWhCaUFiSUJRUU1rVUVRRUVDSVEwZ0d5RVVEQUlMQWtBZ0RDQUVJQzBnQkNBdFNSc2lDMDhFUUNBUElRMGdEQ0VMREFFTElCNGdGQ0FmYWlJTmEwSC8vd05LRFFNTElCUWdBQ0FVUWYvL0EzRkJBWFJxUVlDQUNHb3ZBUUFpQkVrRVFDQU5JUThnQ3lFTURBTUxJQlFnQkdzaEZDQU5JUTlCQWlFTklBc2hEQXdCQ3lBVUlBQWdFU0FVYWtILy93TnhRUUYwYWtHQWdBaHFMd0VBYXlFVVFRQWhCZ3NnQmtFRFJ3MEJDd3NDUUNBa1JTQUpRUUZISUE0Z0xHdEIvdjhEUzNKeURRQWdEaUFnSUN0cUtBSUFJaEVnTEdvZ0t5Z0NnSUFRSUNzb0FvU0FFQ0lTYXlJTmF5SVVhMEgvL3dOTERRQURRQ0FrUlEwQklDSWdFU0FTYWlJRUtBQUFSZ1JBSUFSQkJHb2hCZ0ovQWtBQ2Z5QVRJQm9nSGlBTklCRnJhaUlFSUFRZ0drc2JJaHhCZldvaUVDQVRUUTBBR2lBR0tBQUFJQk1vQUFCeklnUU5BU0FHUVFScUlRWWdMZ3NpQkNBUVNRUkFBMEFnQmlnQUFDQUVLQUFBY3lJTEJFQWdDeEFsSUFScUlCTnJEQVFMSUFaQkJHb2hCaUFFUVFScUlnUWdFRWtOQUFzTEFrQWdCQ0FjUVg5cVR3MEFJQVl2QUFBZ0JDOEFBRWNOQUNBR1FRSnFJUVlnQkVFQ2FpRUVDeUFFSUJ4SkJIOGdCRUVCYWlBRUlBWXRBQUFnQkMwQUFFWWJCU0FFQ3lBVGF3d0JDeUFFRUNVTFFRUnFJZ1FnRENBRUlBeEtJZ1FiSVF3Z0ZDQWZhaUFQSUFRYklROExJQ1JCZjJvaEpDQVJJQ3NnRVVILy93TnhRUUYwYWtHQWdBaHFMd0VBSWdScklSRWdEaUFVSUFSckloUnJRWUNBQkVrTkFBc0xBa0FDUUFKL0FrQUNRQ0FNUVFST0JFQWdIaUFQYXlFUFFSSWdEQ0FNUVcxcVFSSkpHeUFNSUFvYklod2dPa3NOQVNBWFFRNUtJZ3NOQWlBWFFRRnFJUVlnRnd3REN5QWVRUUZxSVI0TUF3c2dCd1JBSUIwZ0YwSC9BVzVxSUJkcVFRbHFJREpMRFFRTElCMUJBV29oQmdKQUlCZEJEMDhFUUNBZFFmQUJPZ0FBSUJkQmNXb2lCRUgvQVU4RVFDQUdRZjhCSUI0Z0oydEI4bjFxSWdSQi93RnVJZ1pCQVdvUUtCb2dCa0dCZm13Z0JHb2hCQ0FHSUIxcVFRSnFJUVlMSUFZZ0JEb0FBQ0FHUVFGcUlRWU1BUXNnSFNBWFFRUjBPZ0FBQ3lBR0lDY2dCaUFYYWlJRUVEc2dCQ0FQUWYvL0EzRVFMeUFjUVh4cUlRd2dCRUVDYWlFRUlBY0VRQ0FFSUF4Qi93RnVha0VHYWlBeVN3MEVDeUFkTFFBQUlRc2dERUVQVHdSQUlCMGdDMEVQYWpvQUFDQWNRVzFxSWd0Qi9nTlBCRUFnQkVIL0FTQWNRZTk3YWlJTVFmNERiaUlMUVFGMElnUkJBbW9RS0JvZ0MwR0NmR3dnREdvaEN5QUdJQVFnSG1vZ0oydHFRUVJxSVFRTElBdEIvd0ZQQkVBZ0JFSC9BVG9BQUNBTFFZRithaUVMSUFSQkFXb2hCQXNnQkNBTE9nQUFJQVJCQVdvaEhTQWNJQjVxSWg0aEp3d0RDeUFkSUFzZ0RHbzZBQUFnSENBZWFpSWVJU2NnQkNFZERBSUxJQmRCQVdvaUJpQVhRWEZxUWY4QmJXb0xJUVFnR1NBWE5nSU1JQmxDZ0lDQWdCQTNBZ1FnR1NBRU5nSUFJQVlpQkVFT1NnUkFJQVlnQmtGeGFrSC9BVzFxUVFGcUlRUUxJQmtnQmpZQ0hDQVpRb0NBZ0lBUU53SVVJQmtnQkRZQ0VDQVhRUUpxSVFRQ2Z3SkFJQmRCRFU0RVFDQVpJQVEyQWl3Z0dVS0FnSUNBRURjQ0pDQVpJQmRCQTJvaURTQVhRWE5xUWY4QmJXbzJBaUFNQVFzZ0dTQUVOZ0lzSUJsQ2dJQ0FnQkEzQWlRZ0dTQUVOZ0lnSUJkQkEyb2lEU0FYUVF4SERRRWFDeUFYSUJkQmRHcEIvd0Z0YWtFRWFnc2hCQ0FaSUEwMkFqd2dHVUtBZ0lDQUVEY0NOQ0FaSUFRMkFqQWdCaUFYUVhGcVFmOEJiV29nRnlBTEcwRURhaUVFUVFRaEJnTkFJQVFoQ3lBR1FSTlBCRUFnQmtGdGFrSC9BVzBnQkdwQkFXb2hDd3NnR1NBR1FRUjBhaUlNSUJjMkFnd2dEQ0FQTmdJRUlBd2dCallDQ0NBTUlBczJBZ0FnQmlBY1J5RUxJQVpCQVdvaEJpQUxEUUFMUVFFaEZDQVpJQnhCQkhScUlnWkJBVFlDSENBR1FvQ0FnSUFRTndJVUlBWkNnSUNBZ0JBM0FpUWdCa0VDTmdJc0lBWkJBellDUENBR1FvQ0FnSUFRTndJMElBWWdCaWdDQUNJRVFRRnFOZ0lRSUFZZ0JFRUNhallDSUNBR0lBUkJBMm8yQWpBQ1FBTkFJQjRnRkNJWWFpSWhJRGxOQkVBZ0dTQVlRUVIwSWdScUlqUW9BZ0FoTXlBWklCaEJBV29pRkVFRWRHb2lOU2dDQUNFMkFrQUNRQUpBSUFnRVFDQTJJRE5NQkVBZ0JDQVpha0ZBYXlnQ0FDQXpRUU5xU0EwRUN5QUFLQUtRZ0JBaURFR0FnQVJxSUNFZ0gyc2lJRXNoQ3lBZklBQW9Bb3lBRUNJVGFpRWJJQ0VvQUFBaEl5QU9JQ0JKQkVBRFFDQUFJQTVCLy84RGNVRUJkR3BCZ0lBSWFpQU9JQUFnRGlBZmFoQTZRUUowYWlJR0tBSUFheUlFUWYvL0F5QUVRZi8vQTBrYk93RUFJQVlnRGpZQ0FDQU9RUUZxSWc0Z0lFa05BQXNMSUF3Z0lFR0JnSHhxSUFzYklSY2dBQ0FnTmdLVWdCQWdJMEgvL3dOeElDTkJFSFpHSUNOQi93RnhJQ05CR0haR2NTRXVJQk1nS21vaExDQWJRUVJxSVE4Z0lVRUlhaUVpSUNGQkJHb2hGU0FoUVg5cUlUQWdBQ0FoRURwQkFuUWlNV29vQWdBaERrRURJUXhCQUNFU1FRQWhLVUVBSVExQkFDRVJJQVVoSkFOQUFrQWdKRVVnRGlBWFNYSU5BRUVBSVJBQ1FDQUtRUUFnSUNBT2EwRUlTUnNOQUFKQUFuOENRQUpBSUJNZ0RrMEVRQ0FNSURCcUx3QUFJQTRnSDJvaUZpQU1ha0YvYWk4QUFFY05CU0FqSUJZb0FBQkhEUVVnRmtFRWFpRUdJQ1lnRlUwRWZ5QVZCU0FHS0FBQUlCVW9BQUJ6SWdRTkFpQUdRUVJxSVFZZ0lnc2lCQ0FtU1FSQUEwQWdCaWdBQUNBRUtBQUFjeUlMQkVBZ0N4QWxJQVJxSUJWcklRWU1Cd3NnQmtFRWFpRUdJQVJCQkdvaUJDQW1TUTBBQ3dzQ1FDQUVJQzlQRFFBZ0JpOEFBQ0FFTHdBQVJ3MEFJQVpCQW1vaEJpQUVRUUpxSVFRTElBUWdHa2tFZnlBRVFRRnFJQVFnQmkwQUFDQUVMUUFBUmhzRklBUUxJQlZySVFZTUJBc2dJeUFPSUNwcUlnUW9BQUJIRFFRZ0JFRUVhaUVHQW44Z0ZTQWFJQ0VnRXlBT2Eyb2lKU0FsSUJwTEd5SUxRWDFxSWhZZ0ZVME5BQm9nQmlnQUFDQVZLQUFBY3lJRURRSWdCa0VFYWlFR0lDSUxJZ1FnRmtrRVFBTkFJQVlvQUFBZ0JDZ0FBSE1pRUFSQUlCQVFKU0FFYWlBVmF3d0ZDeUFHUVFScUlRWWdCRUVFYWlJRUlCWkpEUUFMQ3dKQUlBUWdDMEYvYWs4TkFDQUdMd0FBSUFRdkFBQkhEUUFnQmtFQ2FpRUdJQVJCQW1vaEJBc2dCQ0FMU1FSL0lBUkJBV29nQkNBR0xRQUFJQVF0QUFCR0d3VWdCQXNnRldzTUFnc2dCQkFsSVFZTUFnc2dCQkFsQ3lFRUlBNGdIMm9nRWdKL0lDRWdCRUVFYWlJUWFpQUxSeUFsSUJwUGNrVUVRQ0FiSVFRQ2Z3SkFJQ1lnQ3lJR1N3UkFJQnNvQUFBZ0N5Z0FBSE1pQkEwQklBdEJCR29oQmlBUElRUUxJQVlnSmtrRVFBTkFJQVFvQUFBZ0JpZ0FBSE1pRWdSQUlCSVFKU0FHYWlBTGF3d0VDeUFFUVFScUlRUWdCa0VFYWlJR0lDWkpEUUFMQ3dKQUlBWWdMMDhOQUNBRUx3QUFJQVl2QUFCSERRQWdCRUVDYWlFRUlBWkJBbW9oQmdzZ0JpQWFTUVIvSUFaQkFXb2dCaUFFTFFBQUlBWXRBQUJHR3dVZ0Jnc2dDMnNNQVFzZ0JCQWxDeUFRYWlFUUN5QVFJQXhLSWdRTEd5RVNJQkFnRENBRUd5RU1EQUVMSUFaQkJHb2lFQ0FNSUJBZ0RFb2lCQnNoRENBV0lCSWdCQnNoRWdzZ0pFRi9haUVrQWtBQ1FDQU1JQkJISUF3Z0Rtb2dJRXR5SUJCQkJFaHlEUUFnRUVGOWFpRWxRUUFoQmtFUUlRdEJBU0VFQTBBZ0FDQUdJQTVxUWYvL0EzRkJBWFJxUVlDQUNHb3ZBUUFpRmlBRUlBUWdGa2tpTFJzaEJDQUdJQkVnTFJzaEVTQUxRUVIxSVJaQkVDQUxRUUZxSUMwYklRc2dCaUFXYWlJR0lDVklEUUFMSUE1QkFDQUVJQTRnQkVraUJodEJBQ0FFUVFGTElnUWJheUVPSUFSRkRRQkJBMEVDSUFZYklRWWdFQ0VNREFFTEFrQWdFUTBBSUFBZ0RrSC8vd054UVFGMGFrR0FnQWhxTHdFQVFRRkhEUUFnRFVVRVFFRUJJUTBnTGtVTkFTQVZJQm9nSXhBelFRUnFJU2xCQWlFTkN5QU5RUUpISUE1QmYyb2lGaUFYU1hJTkFFRUNJUTBnRXlBV0VESkZEUUFnSXlBcUlCOGdGaUFUU1NJRUd5QVdhaUlRS0FBQVJ3MEFJQkJCQkdvZ0xDQWFJQVFiSWdZZ0l4QXpRUVJxSVFzZ0tpQUFLQUtRZ0JBaUJHb2hEZ0pBSUJZZ0Uwa0VRQ0FHSUFzZ0VHcEdCRUFnR3lBYUlBc2dJeEE5RURNZ0Myb2hDd3NnRUNBT0lDTVFNU0VOREFFTElCQWdFQ0FiSUNNUU1TSU5heUFiUnlBRUlCTlBjZzBBSUN3Z0RrRUFJQTFySUNNUVBSQXhJQTFxSVEwTElCWWdGaUFOYXlJRUlCY2dCQ0FYU3hzaURtc2dDMm9pQkNBcFNTQUxJQ2xMY2tVRVFDQUxJQllnS1d0cUlnUWdFeUFUSUFRUU1oc2hEa0VBSVJGQkFpRUdRUUloRFF3Q0MwRUFJUkZCQWlFR0lCTWdEaEF5UlFSQVFRSWhEU0FUSVE0TUFnc0NRQ0FNSUFRZ0tTQUVJQ2xKR3lJTFR3UkFJQkloRFNBTUlRc01BUXNnSVNBT0lCOXFJZzFyUWYvL0Ewb05Bd3NnRGlBQUlBNUIvLzhEY1VFQmRHcEJnSUFJYWk4QkFDSUVTUVJBSUEwaEVpQUxJUXdNQXdzZ0RpQUVheUVPSUEwaEVrRUNJUTBnQ3lFTURBRUxJQTRnQUNBT0lCRnFRZi8vQTNGQkFYUnFRWUNBQ0dvdkFRQnJJUTVCQUNFR0N5QUdRUU5IRFFFTEN3SkFJQ1JGSUFsQkFVY2dJQ0FYYTBIKy93TkxjbklOQUNBZ0lDc2dNV29vQWdBaUVTQVhhaUFyS0FLQWdCQWdLeWdDaElBUUlnOXJJZzFySWc1clFmLy9BMHNOQUFOQUlDUkZEUUVnSXlBUElCRnFJZ1FvQUFCR0JFQWdCRUVFYWlFR0FuOENRQUovSUJVZ0dpQWhJQTBnRVd0cUlnUWdCQ0FhU3hzaUcwRjlhaUlRSUJWTkRRQWFJQVlvQUFBZ0ZTZ0FBSE1pQkEwQklBWkJCR29oQmlBaUN5SUVJQkJKQkVBRFFDQUdLQUFBSUFRb0FBQnpJZ3NFUUNBTEVDVWdCR29nRldzTUJBc2dCa0VFYWlFR0lBUkJCR29pQkNBUVNRMEFDd3NDUUNBRUlCdEJmMnBQRFFBZ0JpOEFBQ0FFTHdBQVJ3MEFJQVpCQW1vaEJpQUVRUUpxSVFRTElBUWdHMGtFZnlBRVFRRnFJQVFnQmkwQUFDQUVMUUFBUmhzRklBUUxJQlZyREFFTElBUVFKUXRCQkdvaUJDQU1JQVFnREVvaUJCc2hEQ0FPSUI5cUlCSWdCQnNoRWdzZ0pFRi9haUVrSUJFZ0t5QVJRZi8vQTNGQkFYUnFRWUNBQ0dvdkFRQWlCR3NoRVNBZ0lBNGdCR3NpRG10QmdJQUVTUTBBQ3dzZ0RFRUVTQTBDUVJJZ0RDQU1RVzFxUVJKSkd5QU1JQW9iSVE4Z0lTQVNheUVPREFFTElEWWdNMHdOQWlBQUtBS1FnQkFpREVHQWdBUnFJQ0VnSDJzaUlFc2hDeUFmSUFBb0FveUFFQ0lUYWlFYklDRW9BQUFoS0NBT0lDQkpCRUFEUUNBQUlBNUIvLzhEY1VFQmRHcEJnSUFJYWlBT0lBQWdEaUFmYWhBNlFRSjBhaUlHS0FJQWF5SUVRZi8vQXlBRVFmLy9BMGtiT3dFQUlBWWdEallDQUNBT1FRRnFJZzRnSUVrTkFBc0xJQXdnSUVHQmdIeHFJQXNiSVNNZ0FDQWdOZ0tVZ0JBZ0tFSC8vd054SUNoQkVIWkdJQ2hCL3dGeElDaEJHSFpHY1NFdElCTWdLbW9oSWlBYlFRUnFJU1FnSVVFSWFpRVhJQ0ZCQkdvaEZTQWhRWDlxSVM0Z0FDQWhFRHBCQW5RaU1Hb29BZ0FoRGtFQUlSSkJBQ0VwUVFBaERVRUFJUkVnQlNFUUlCd2dHR3NpTVNFUEEwQUNRQ0FRUlNBT0lDTkpjZzBBUVFBaERBSkFJQXBCQUNBZ0lBNXJRUWhKR3cwQUFrQUNmd0pBQWtBZ0V5QU9UUVJBSUE4Z0xtb3ZBQUFnRGlBZmFpSVdJQTlxUVg5cUx3QUFSdzBGSUNnZ0ZpZ0FBRWNOQlNBV1FRUnFJUVlnSmlBVlRRUi9JQlVGSUFZb0FBQWdGU2dBQUhNaUJBMENJQVpCQkdvaEJpQVhDeUlFSUNaSkJFQURRQ0FHS0FBQUlBUW9BQUJ6SWdzRVFDQUxFQ1VnQkdvZ0ZXc2hCZ3dIQ3lBR1FRUnFJUVlnQkVFRWFpSUVJQ1pKRFFBTEN3SkFJQVFnTDA4TkFDQUdMd0FBSUFRdkFBQkhEUUFnQmtFQ2FpRUdJQVJCQW1vaEJBc2dCQ0FhU1FSL0lBUkJBV29nQkNBR0xRQUFJQVF0QUFCR0d3VWdCQXNnRldzaEJnd0VDeUFvSUE0Z0ttb2lCQ2dBQUVjTkJDQUVRUVJxSVFZQ2Z5QVZJQm9nSVNBVElBNXJhaUlsSUNVZ0drc2JJZ3RCZldvaUZpQVZUUTBBR2lBR0tBQUFJQlVvQUFCeklnUU5BaUFHUVFScUlRWWdGd3NpQkNBV1NRUkFBMEFnQmlnQUFDQUVLQUFBY3lJTUJFQWdEQkFsSUFScUlCVnJEQVVMSUFaQkJHb2hCaUFFUVFScUlnUWdGa2tOQUFzTEFrQWdCQ0FMUVg5cVR3MEFJQVl2QUFBZ0JDOEFBRWNOQUNBR1FRSnFJUVlnQkVFQ2FpRUVDeUFFSUF0SkJIOGdCRUVCYWlBRUlBWXRBQUFnQkMwQUFFWWJCU0FFQ3lBVmF3d0NDeUFFRUNVaEJnd0NDeUFFRUNVTElRUWdEaUFmYWlBU0FuOGdJU0FFUVFScUlneHFJQXRISUNVZ0drOXlSUVJBSUJzaEJBSi9Ba0FnSmlBTElnWkxCRUFnR3lnQUFDQUxLQUFBY3lJRURRRWdDMEVFYWlFR0lDUWhCQXNnQmlBbVNRUkFBMEFnQkNnQUFDQUdLQUFBY3lJU0JFQWdFaEFsSUFacUlBdHJEQVFMSUFSQkJHb2hCQ0FHUVFScUlnWWdKa2tOQUFzTEFrQWdCaUF2VHcwQUlBUXZBQUFnQmk4QUFFY05BQ0FFUVFKcUlRUWdCa0VDYWlFR0N5QUdJQnBKQkg4Z0JrRUJhaUFHSUFRdEFBQWdCaTBBQUVZYkJTQUdDeUFMYXd3QkN5QUVFQ1VMSUF4cUlRd0xJQXdnRDBvaUJBc2JJUklnRENBUElBUWJJUThNQVFzZ0JrRUVhaUlNSUE4Z0RDQVBTaUlFR3lFUElCWWdFaUFFR3lFU0N5QVFRWDlxSVJBQ1FBSkFJQXdnRDBjZ0RpQVBhaUFnUzNJZ0RFRUVTSElOQUNBTVFYMXFJU1ZCQUNFR1FSQWhDMEVCSVFRRFFDQUFJQVlnRG1wQi8vOERjVUVCZEdwQmdJQUlhaThCQUNJV0lBUWdCQ0FXU1NJc0d5RUVJQVlnRVNBc0d5RVJJQXRCQkhVaEZrRVFJQXRCQVdvZ0xCc2hDeUFHSUJacUlnWWdKVWdOQUFzZ0RrRUFJQVFnRGlBRVNTSUdHMEVBSUFSQkFVc2lCQnRySVE0Z0JFVU5BRUVEUVFJZ0Joc2hCaUFNSVE4TUFRc0NRQ0FSRFFBZ0FDQU9RZi8vQTNGQkFYUnFRWUNBQ0dvdkFRQkJBVWNOQUNBTlJRUkFRUUVoRFNBdFJRMEJJQlVnR2lBb0VETkJCR29oS1VFQ0lRMExJQTFCQWtjZ0RrRi9haUlsSUNOSmNnMEFRUUloRFNBVElDVVFNa1VOQUNBb0lDb2dIeUFsSUJOSklnUWJJQ1ZxSWhZb0FBQkhEUUFnRmtFRWFpQWlJQm9nQkJzaUJpQW9FRE5CQkdvaEN5QXFJQUFvQXBDQUVDSUVhaUVNQWtBZ0pTQVRTUVJBSUFZZ0N5QVdha1lFUUNBYklCb2dDeUFvRUQwUU15QUxhaUVMQ3lBV0lBd2dLQkF4SVEwTUFRc2dGaUFXSUJzZ0tCQXhJZzFySUJ0SElBUWdFMDl5RFFBZ0lpQU1RUUFnRFdzZ0tCQTlFREVnRFdvaERRc2dKU0FsSUExcklnUWdJeUFFSUNOTEd5SU1heUFMYWlJRUlDbEpJQXNnS1V0eVJRUkFJQXNnSlNBcGEyb2lCQ0FUSUJNZ0JCQXlHeUVPUVFBaEVVRUNJUVpCQWlFTkRBSUxRUUFoRVVFQ0lRWWdFeUFNRURKRkJFQkJBaUVOSUJNaERnd0NDd0pBSUE4Z0JDQXBJQVFnS1VrYklndFBCRUFnRWlFTklBOGhDd3dCQ3lBaElBd2dIMm9pRFd0Qi8vOERTZzBEQ3lBTUlBQWdERUgvL3dOeFFRRjBha0dBZ0FocUx3RUFJZ1JKQkVBZ0RTRVNJQXNoRHd3REN5QU1JQVJySVE0Z0RTRVNRUUloRFNBTElROE1BUXNnRGlBQUlBNGdFV3BCLy84RGNVRUJkR3BCZ0lBSWFpOEJBR3NoRGtFQUlRWUxJQVpCQTBjTkFRc0xBa0FnRUVVZ0NVRUJSeUFnSUNOclFmNy9BMHR5Y2cwQUlDQWdLeUF3YWlnQ0FDSVJJQ05xSUNzb0FvQ0FFQ0FyS0FLRWdCQWlEV3NpREdzaURtdEIvLzhEU3cwQUEwQWdFRVVOQVNBb0lBMGdFV29pQkNnQUFFWUVRQ0FFUVFScUlRWUNmd0pBQW44Z0ZTQWFJQ0VnRENBUmEyb2lCQ0FFSUJwTEd5SWJRWDFxSWlRZ0ZVME5BQm9nQmlnQUFDQVZLQUFBY3lJRURRRWdCa0VFYWlFR0lCY0xJZ1FnSkVrRVFBTkFJQVlvQUFBZ0JDZ0FBSE1pQ3dSQUlBc1FKU0FFYWlBVmF3d0VDeUFHUVFScUlRWWdCRUVFYWlJRUlDUkpEUUFMQ3dKQUlBUWdHMEYvYWs4TkFDQUdMd0FBSUFRdkFBQkhEUUFnQmtFQ2FpRUdJQVJCQW1vaEJBc2dCQ0FiU1FSL0lBUkJBV29nQkNBR0xRQUFJQVF0QUFCR0d3VWdCQXNnRldzTUFRc2dCQkFsQzBFRWFpSUVJQThnQkNBUFNpSUVHeUVQSUE0Z0gyb2dFaUFFR3lFU0N5QVFRWDlxSVJBZ0VTQXJJQkZCLy84RGNVRUJkR3BCZ0lBSWFpOEJBQ0lFYXlFUklDQWdEaUFFYXlJT2EwR0FnQVJKRFFBTEN5QVBJREZNRFFFZ0lTQVNheUVPSUFwRklBOUJiV3BCRWs5eVJRUkFRUkloRHd3QkN5QVBSUTBCQ3lBUElEcExCRUFnRkNFY0RBVUxJQThnR0dwQi94OUtCRUFnRkNFY0RBVUxJRE1nTkNnQ0RDSU5RUUZxSWdZZ0RVRnhha0gvQVcxcUlBMGdEVUVPU2h0cklRd2dCaUlFUVE1S0JIOGdEU0FOUVhKcVFmOEJiV3BCQW1vRklBUUxJQXhxSWdRZ05rZ0VRQ0ExSUFZMkFnd2dOVUtBZ0lDQUVEY0NCQ0ExSUFRMkFnQUxJQTFCQW1vaUJpRUVJQTFCREVvRWZ5QU5JQTFCYzJwQi93RnRha0VEYWdVZ0JBc2dER29pQkNBWklCaEJBbXBCQkhScUlnc29BZ0JJQkVBZ0N5QUdOZ0lNSUF0Q2dJQ0FnQkEzQWdRZ0N5QUVOZ0lBQ3lBTlFRTnFJZ1loQkNBTlFReE9CSDhnRFNBTlFYUnFRZjhCYldwQkJHb0ZJQVFMSUF4cUlnUWdHU0FZUVFOcVFRUjBhaUlMS0FJQVNBUkFJQXNnQmpZQ0RDQUxRb0NBZ0lBUU53SUVJQXNnQkRZQ0FBc2dEMEVFVGdSQUlEUkJESEloRFVFRUlRWWdHU0FZUVFSMGFrRUljaUVNQTBBZ0JpQVlhaUVTQW44Z0RDZ0NBRUVCUmdSQVFRQWhFU0FZSUEwb0FnQWlDMG9FUUNBWklCZ2dDMnRCQkhScUtBSUFJUkVMSUFzaUJFRVBUZ1IvSUFzZ0MwRnhha0gvQVcxcVFRRnFCU0FFQzBFRGFpRUVJQVpCRTA4RWZ5QUdRVzFxUWY4QmJTQUVha0VCYWdVZ0JBc2dFV29NQVFzZ05DZ0NBQ0VFUVFBaEN5QUdRUk5QQkg4Z0JrRnRha0gvQVcxQkJHb0ZRUU1MSUFScUN5RVJBa0FnRWlBY1FRTnFUQVJBSUJFZ0dTQVNRUVIwYWlnQ0FDQUthMG9OQVFzZ0dTQVNRUVIwYWlJRUlBczJBZ3dnQkNBT05nSUVJQVFnQmpZQ0NDQUVJQkUyQWdBZ0VpQWNJQndnRWtnYklCd2dCaUFQUmhzaEhBc2dCaUFQUmlFRUlBWkJBV29oQmlBRVJRMEFDd3NnR1NBY1FRUjBhaUlHUVFFMkFod2dCa0tBZ0lDQUVEY0NGQ0FHUW9DQWdJQVFOd0lrSUFaQkFqWUNMQ0FHUVFNMkFqd2dCa0tBZ0lDQUVEY0NOQ0FHSUFZb0FnQWlCRUVCYWpZQ0VDQUdJQVJCQW1vMkFpQWdCaUFFUVFOcU5nSXdDeUFnSVE0TElCd2dGRW9OQVFzTElCd2dHU0FjUVFSMGFpSUVLQUlJSWc5cklSZ2dCQ2dDQkNFT0N3TkFJQmtnR0VFRWRHb2lDeWdDQ0NFR0lBc2dEellDQ0NBTEtBSUVJUVFnQ3lBT05nSUVJQmdnQms0aEN5QVlJQVpySVJnZ0JpRVBJQVFoRGlBTERRQUxRUUFoQmlBY1FRRklEUUFEUUFKL0lCa2dCa0VFZEdvaUJDZ0NDQ0lQUVFGR0JFQWdIa0VCYWlFZUlBWkJBV29NQVFzZ0hpQW5heUVTSUFRb0FnUWhDeUFIQkVBZ0hTQVNRZjhCYm1vZ0VtcEJDV29nTWtzTkJBc2dIVUVCYWlFTkFrQWdFa0VQVHdSQUlCMUI4QUU2QUFBZ0VrRnhhaUlPUWY4QlR3UkFJQTFCL3dFZ0VrSHlmV29pQkVIL0FXNGlERUVCYWhBb0dpQU1RWUYrYkNBRWFpRU9JQXdnSFdwQkFtb2hEUXNnRFNBT09nQUFJQTFCQVdvaERRd0JDeUFkSUJKQkJIUTZBQUFMSUEwZ0p5QU5JQkpxSWdRUU95QUVJQXRCLy84RGNSQXZJQTlCZkdvaERDQUVRUUpxSVFzZ0J3UkFJQXNnREVIL0FXNXFRUVpxSURKTERRUUxJQjB0QUFBaEJBSi9JQXhCRDA4RVFDQWRJQVJCRDJvNkFBQWdEMEZ0YWlJUlFmNERUd1JBSUF0Qi93RWdEMEh2ZTJvaURFSCtBMjRpQzBFQmRDSUVRUUpxRUNnYUlBdEJnbnhzSUF4cUlSRWdEU0FFSUI1cUlDZHJha0VFYWlFTEN5QVJRZjhCVHdSQUlBdEIvd0U2QUFBZ0VVR0JmbW9oRVNBTFFRRnFJUXNMSUFzZ0VUb0FBQ0FMUVFGcURBRUxJQjBnQkNBTWFqb0FBQ0FMQ3lFZElBOGdIbW9pSGlFbklBWWdEMm9MSWdZZ0hFZ05BQXNMSUI0Z09VME5BUXdDQ3d0QkFDQUhRUUpIRFFFYUN5QTRJQ2RySWdaQjhBRnFRZjhCYmlFQUFrQWdCMFVOQUNBQUlBWnFJQjFxUVFGcUlESkJCV29nTnlBN0d5SUFUUTBBUVFBZ0IwRUJSZzBCR2lBZFFYOXpJQUJxSWdBZ0FFSHdBV3BCL3dGdWF5RUdDeUFHSUNkcUlRVUNRQ0FHUVE5UEJFQWdIVUh3QVRvQUFDQWRRUUZxSVFBZ0JrRnhhaUlFUWY4QlNRUkFJQUFpSFNBRU9nQUFEQUlMSUFCQi93RWdCa0h5ZldvaUFFSC9BVzRpQkVFQmFoQW9HaUFFSUIxcVFRSnFJaDBnQkVHQmZtd2dBR282QUFBTUFRc2dIU0FHUVFSME9nQUFDeUFkUVFGcUlDY2dCaEFxSVFBZ0F5QUZJQUZyTmdJQUlBQWdCbW9nQW1zTElRQWdHVUd3Z0FScUpBQWdBQXV1UFFFMGZ3SkFJQVJCQUV4QkFDQUdRUUpHR3cwQUlBTW9BZ0FpQ2tHQWdJRHdCMHNOQUNBQUlBQW9Bb0NBRUNBS2FqWUNnSUFRUVFrZ0JTQUZRUUZJR3lJRlFRd2dCVUVNU0JzaUIwRU1iQ0lKUVpRV2FpZ0NBQ0V1QWtBQ2Z3SkFBbjhDZndKQUlBZEJDVTBFUUNBRFFRQTJBZ0FnQWlBRWFpSTNRWHRxSURjZ0JrRUNSaUk0R3lFbUlBRWdDbW9oTVNBQklTVWdBaUVKSUFwQkRVZ05CQ0F4UVhScUlpOGdBVWtOQkVHQU5DQUhka0VCY1NFeUlERkJlMm9pR0VGL2FpRXJJQmhCZldvaEhnTkFJQUFvQXBTQUVDRUhJQUFvQW9pQUVDRWRJQUFvQW9TQUVDRVJJQ1VoREFKQUFrQURRQ0FBS0FLUWdCQWlCQ0FNSUJGcklnNUJnWUI4YWlBRVFZQ0FCR29nRGtzYklTQWdBQ2dDaklBUUlSQWdEQ2dBQUNFTklBY2dEa2tFUUFOQUlBQWdCMEgvL3dOeFFRRjBha0dBZ0FocUlBY2dBQ0FISUJGcUVEcEJBblJxSWdRb0FnQnJJZ1ZCLy84RElBVkIvLzhEU1JzN0FRQWdCQ0FITmdJQUlBZEJBV29pQnlBT1NRMEFDd3NnQUNBT05nS1VnQkFDUUFKQUlBQWdEQkE2UVFKMGFpZ0NBQ0lGSUNCSkRRQWdEVUgvL3dOeElBMUJFSFpHSUExQi93RnhJQTFCR0haR2NTRWZJQkFnSFdvaEV5QVFJQkZxSWhkQkJHb2hLU0FNUVFocUlSd2dERUVFYWlFWklBeEJmMm9oSTBFQUlSdEJBeUVLSUM0aENFRUFJUm9EUUFKQUFrQUNmd0pBQWtBZ0VDQUZUUVJBSUFvZ0kyb3ZBQUFnQlNBUmFpSUxJQXBxUVg5cUx3QUFSdzBGSUEwZ0N5Z0FBRWNOQlNBTFFRUnFJUWNnSGlBWlRRUi9JQmtGSUFjb0FBQWdHU2dBQUhNaUJBMENJQWRCQkdvaEJ5QWNDeUlFSUI1SkJFQURRQ0FIS0FBQUlBUW9BQUJ6SWhZRVFDQVdFQ1VnQkdvZ0dXc2hCd3dIQ3lBSFFRUnFJUWNnQkVFRWFpSUVJQjVKRFFBTEN3SkFJQVFnSzA4TkFDQUhMd0FBSUFRdkFBQkhEUUFnQjBFQ2FpRUhJQVJCQW1vaEJBc2dCQ0FZU1FSL0lBUkJBV29nQkNBSExRQUFJQVF0QUFCR0d3VWdCQXNnR1dzaEJ3d0VDeUFOSUFVZ0hXb2lCQ2dBQUVjTkJDQUVRUVJxSVFjQ2Z5QVpJQmdnRENBUUlBVnJhaUloSUNFZ0dFc2JJaFpCZldvaUN5QVpUUTBBR2lBSEtBQUFJQmtvQUFCeklnUU5BaUFIUVFScUlRY2dIQXNpQkNBTFNRUkFBMEFnQnlnQUFDQUVLQUFBY3lJa0JFQWdKQkFsSUFScUlCbHJEQVVMSUFkQkJHb2hCeUFFUVFScUlnUWdDMGtOQUFzTEFrQWdCQ0FXUVg5cVR3MEFJQWN2QUFBZ0JDOEFBRWNOQUNBSFFRSnFJUWNnQkVFQ2FpRUVDeUFFSUJaSkJIOGdCRUVCYWlBRUlBY3RBQUFnQkMwQUFFWWJCU0FFQ3lBWmF3d0NDeUFFRUNVaEJ3d0NDeUFFRUNVTElRUWdCU0FSYWlBVUFuOGdCRUVFYWlJTElBeHFJQlpISUNFZ0dFOXlSUVJBSUJjaEJBSi9Ba0FnSGlBV0lnZExCRUFnRnlnQUFDQVdLQUFBY3lJRURRRWdGa0VFYWlFSElDa2hCQXNnQnlBZVNRUkFBMEFnQkNnQUFDQUhLQUFBY3lJVUJFQWdGQkFsSUFkcUlCWnJEQVFMSUFSQkJHb2hCQ0FIUVFScUlnY2dIa2tOQUFzTEFrQWdCeUFyVHcwQUlBUXZBQUFnQnk4QUFFY05BQ0FFUVFKcUlRUWdCMEVDYWlFSEN5QUhJQmhKQkg4Z0IwRUJhaUFISUFRdEFBQWdCeTBBQUVZYkJTQUhDeUFXYXd3QkN5QUVFQ1VMSUF0cUlRc0xJQXNnQ2tvaUJBc2JJUlFnQ3lBS0lBUWJJUW9NQVFzZ0IwRUVhaUlFSUFvZ0JDQUtTaUlFR3lFS0lBc2dGQ0FFR3lFVUN3SkFBa0FDUUNBeVJTQUFJQVZCLy84RGNVRUJkR3BCZ0lBSWFpOEJBQ0lIUVFGSGNnMEFJQnRGQkVCQkFTRWJJQjlGRFFFZ0dTQVlJQTBRTTBFRWFpRWFRUUloR3dzZ0cwRUNSeUFGUVg5cUlnUWdJRWx5RFFCQkFpRWJJQkFnQkJBeVJRMEFJQTBnSFNBUklBUWdFRWtpRmhzZ0JHb2lDeWdBQUVjTkFDQUxRUVJxSUJNZ0dDQVdHeUlGSUEwUU0wRUVhaUVISUIwZ0FDZ0NrSUFRSWh0cUlSWUNRQ0FFSUJCSkJFQWdCU0FISUF0cVJnUkFJQmNnR0NBSElBMFFQUkF6SUFkcUlRY0xJQXNnRmlBTkVERWhCUXdCQ3lBTElBc2dGeUFORURFaUJXc2dGMGNnR3lBUVQzSU5BQ0FUSUJaQkFDQUZheUFORUQwUU1TQUZhaUVGQ3lBRUlBUWdCV3NpQlNBZ0lBVWdJRXNiSWdWcklBZHFJZ3NnR2trZ0J5QWFTM0pGQkVBZ0J5QUVJQnByYWlJRUlCQWdFQ0FFRURJYklRVkJBaUViREFJTFFRSWhHeUFRSUFVUU1rVUVRQ0FRSVFVTUFnc0NRQ0FLSUFzZ0dpQUxJQnBKR3lJSFR3UkFJQlFoQkNBS0lRY01BUXNnRENBRklCRnFJZ1JyUWYvL0Ewb05Bd3NnQlNBQUlBVkIvLzhEY1VFQmRHcEJnSUFJYWk4QkFDSUtTUVJBSUFRaEZDQUhJUW9NQXdzZ0JTQUtheUVGSUFRaEZDQUhJUW9NQVFzZ0JTQUhheUVGQ3lBSVFYOXFJZ2hGRFFBZ0JTQWdUdzBCQ3dzZ0NrRURUQTBBSUNVaEZpQUpJUTBnRENFWklCUWlDU0ViSUFvaEVBTkFJQWtoRkFKQUFrQWdEQ0FLSWhkcUlpVWdMMHNOQUNBQUtBS1FnQkFpQlNBbFFYNXFJaEVnQUNnQ2hJQVFJaDlySWdSQmdZQjhhaUFGUVlDQUJHb2dCRXNiSVNNZ0FDZ0NqSUFRSVJ3Z0FDZ0NpSUFRSVNRZ0VTZ0FBQ0VUSUFBb0FwU0FFQ0lISUFSSkJFQURRQ0FBSUFkQi8vOERjVUVCZEdwQmdJQUlhaUFISUFBZ0J5QWZhaEE2UVFKMGFpSUZLQUlBYXlJSlFmLy9BeUFKUWYvL0Ewa2JPd0VBSUFVZ0J6WUNBQ0FIUVFGcUlnY2dCRWtOQUFzTElBQWdCRFlDbElBUUlBQWdFUkE2UVFKMGFpZ0NBQ0lGSUNOSkRRQWdFMEgvL3dOeElCTkJFSFpHSUJOQi93RnhJQk5CR0haR2NTRXdJQndnSkdvaExDQWNJQjlxSWlCQkJHb2hIU0FSUVFocUlTMGdFVUVFYWlFYUlBd2dFV3NoS0VFQUlTRkJBQ0FSSUF4cklpcHJJVE1nREVGL2FpRTBJQmNoQ2lBdUlTbEJBQ0VPSUE4aENRTkFBa0FDUUFKL0FrQUNRQ0FjSUFWTkJFQWdDaUEwYWk4QUFDQUZJQjlxSWdnZ00yb2dDbXBCZjJvdkFBQkhEUVVnRXlBSUtBQUFSdzBGQWtBZ0trVUVRRUVBSVFzTUFRc2dLQ0FnSUFocklnUWdLQ0FFU2hzaUQwRWZkU0FQY1NFRVFRQWhCd05BSUFjaUN5QVBUQVJBSUFRaEN3d0NDeUFSSUF0QmYyb2lCMm90QUFBZ0J5QUlhaTBBQUVZTkFBc0xJQWhCQkdvaEJ5QWVJQnBOQkg4Z0dnVWdCeWdBQUNBYUtBQUFjeUlFRFFJZ0IwRUVhaUVISUMwTElnUWdIa2tFUUFOQUlBY29BQUFnQkNnQUFITWlEd1JBSUE4UUpTQUVhaUFhYXlFSERBY0xJQWRCQkdvaEJ5QUVRUVJxSWdRZ0hra05BQXNMQWtBZ0JDQXJUdzBBSUFjdkFBQWdCQzhBQUVjTkFDQUhRUUpxSVFjZ0JFRUNhaUVFQ3lBRUlCaEpCSDhnQkVFQmFpQUVJQWN0QUFBZ0JDMEFBRVliQlNBRUN5QWFheUVIREFRTElCTWdCU0FrYWlJUEtBQUFSdzBFSUE5QkJHb2hCeUFBS0FLUWdCQWhOUUovSUJvZ0dDQVJJQndnQld0cUlpY2dKeUFZU3hzaUNFRjlhaUlMSUJwTkRRQWFJQWNvQUFBZ0dpZ0FBSE1pQkEwQ0lBZEJCR29oQnlBdEN5SUVJQXRKQkVBRFFDQUhLQUFBSUFRb0FBQnpJallFUUNBMkVDVWdCR29nR21zTUJRc2dCMEVFYWlFSElBUkJCR29pQkNBTFNRMEFDd3NDUUNBRUlBaEJmMnBQRFFBZ0J5OEFBQ0FFTHdBQVJ3MEFJQWRCQW1vaEJ5QUVRUUpxSVFRTElBUWdDRWtFZnlBRVFRRnFJQVFnQnkwQUFDQUVMUUFBUmhzRklBUUxJQnByREFJTElBUVFKU0VIREFJTElBUVFKUXNoQkNBUklBUkJCR29pQzJvZ0NFY2dKeUFZVDNKRkJFQWdJQ0VFQW44Q1FDQWVJQWdpQjBzRVFDQWdLQUFBSUFnb0FBQnpJZ1FOQVNBSVFRUnFJUWNnSFNFRUN5QUhJQjVKQkVBRFFDQUVLQUFBSUFjb0FBQnpJaWNFUUNBbkVDVWdCMm9nQ0dzTUJBc2dCRUVFYWlFRUlBZEJCR29pQnlBZVNRMEFDd3NDUUNBSElDdFBEUUFnQkM4QUFDQUhMd0FBUncwQUlBUkJBbW9oQkNBSFFRSnFJUWNMSUFjZ0dFa0VmeUFIUVFGcUlBY2dCQzBBQUNBSExRQUFSaHNGSUFjTElBaHJEQUVMSUFRUUpRc2dDMm9oQ3dzQ1FDQXFSUVJBUVFBaEJBd0JDeUFvSUNRZ05Xb2dEMnNpQkNBb0lBUktHeUluUVI5MUlDZHhJUWhCQUNFSEEwQWdCeUlFSUNkTUJFQWdDQ0VFREFJTElCRWdCRUYvYWlJSGFpMEFBQ0FISUE5cUxRQUFSZzBBQ3dzZ0N5QUVheUlISUFwTURRRWdCQ0FSYWlFVklBVWdIMm9nQkdvaENTQUhJUW9NQVFzZ0J5QUxhMEVFYWlJRUlBcE1EUUFnQ3lBUmFpRVZJQWdnQzJvaENTQUVJUW9MQWtBQ1FBSkFJREpGSUFBZ0JVSC8vd054UVFGMGFrR0FnQWhxTHdFQUlnZEJBVWR5RFFBZ0lVVUVRRUVCSVNFZ01FVU5BVUVDSVNFZ0dpQVlJQk1RTTBFRWFpRU9DeUFoUVFKSElBVkJmMm9pQkNBalNYSU5BRUVDSVNFZ0hDQUVFREpGRFFBZ0V5QWtJQjhnQkNBY1NTSVBHeUFFYWlJSUtBQUFSdzBBSUFoQkJHb2dMQ0FZSUE4YklnVWdFeEF6UVFScUlRY2dKQ0FBS0FLUWdCQWlDMm9oRHdKQUlBUWdIRWtFUUNBRklBY2dDR3BHQkVBZ0lDQVlJQWNnRXhBOUVETWdCMm9oQndzZ0NDQVBJQk1RTVNFRkRBRUxJQWdnQ0NBZ0lCTVFNU0lGYXlBZ1J5QUxJQnhQY2cwQUlDd2dEMEVBSUFWcklCTVFQUkF4SUFWcUlRVUxJQVFnQkNBRmF5SUZJQ01nQlNBalN4c2lEMnNnQjJvaUNDQU9TU0FISUE1TGNrVUVRQ0FISUFRZ0RtdHFJZ1FnSENBY0lBUVFNaHNoQlF3Q0N5QVBJQndnSENBUEVESWlCQnNoQlNBcUlBUkZjZzBCQWtBZ0NpQUlJQTRnQ0NBT1NSc2lCMDhFUUNBVklRUWdDU0VJSUFvaEJ3d0JDeUFSSWdRZ0R5QWZhaUlJYTBILy93TktEUU1MSUE4Z0FDQVBRZi8vQTNGQkFYUnFRWUNBQ0dvdkFRQWlCVWtFUUNBRUlSVWdDQ0VKSUFjaENnd0RDeUFQSUFWcklRVWdCQ0VWSUFnaENTQUhJUW9NQVFzZ0JTQUhheUVGQ3lBcFFYOXFJaWxGRFFBZ0JTQWpUdzBCQ3dzZ0NpQVhSdzBCSUFraER3c2dEQ0FXYXlFS0lBWUVRQ0FOSUFwQi93RnVhaUFLYWtFSmFpQW1TdzBLQ3lBTlFRRnFJUVFDUUNBS1FROVBCRUFnRFVId0FUb0FBQ0FLUVhGcUlnVkIvd0ZQQkVBZ0JFSC9BU0FLUWZKOWFpSUZRZjhCYmlJRVFRRnFFQ2dhSUFSQmdYNXNJQVZxSVFVZ0JDQU5ha0VDYWlFRUN5QUVJQVU2QUFBZ0JFRUJhaUVFREFFTElBMGdDa0VFZERvQUFBc2dCQ0FXSUFRZ0Ntb2lDUkE3SUFrZ0RDQVVhMEgvL3dOeEVDOGdGMEY4YWlFRklBbEJBbW9oQ1NBR0JFQWdDU0FGUWY4QmJtcEJCbW9nSmtzTkNnc2dEUzBBQUNFSElBVkJEMDhFUUNBTklBZEJEMm82QUFBZ0YwRnRhaUlGUWY0RFR3UkFJQWxCL3dFZ0YwSHZlMm9pQlVIK0EyNGlDVUVCZENJSFFRSnFFQ2dhSUFsQmdueHNJQVZxSVFVZ0JDQUhJQXBxYWtFRWFpRUpDeUFGUWY4QlR3UkFJQWxCL3dFNkFBQWdDVUVCYWlFSklBVkJnWDVxSVFVTElBa2dCVG9BQUNBSlFRRnFJUWtNQndzZ0RTQUZJQWRxT2dBQURBWUxJQmtnRENBWklBeEpJQlVnRENBUWFrbHhJZ1FiSVE0Z0NTRVBJQlVpRENBT2EwRURTQTBBSUJBZ0Z5QUVHeUVaSUJzZ0ZDQUVHeUVVSUJZaEVRTkFJQTRnR1dvaUZrRURhaUV6SUE0Z0dVRVNJQmxCRWtnYklpeHFJUzBDUUFOQUFrQUNRQUovQWtBZ0RDQU9heUlFUVJGS0RRQWdEaUFNYXlBRUlBcHFRWHhxSUN3Z0xTQUtJQXhxUVh4cVN4dHFJZ1JCQVVnTkFDQUtJQVJySVJBZ0JDQUphaUVQSUFRZ0RHb01BUXNnQ1NFUElBb2hFQ0FNQ3lJVklCQnFJaVVnTDBzTkFDQUFLQUtRZ0JBaUJTQWxRWDFxSWhjZ0FDZ0NoSUFRSWh4cklnUkJnWUI4YWlBRlFZQ0FCR29nQkVzYklTTWdBQ2dDaklBUUlSTWdBQ2dDaUlBUUlTUWdGeWdBQUNFZElBQW9BcFNBRUNJSElBUkpCRUFEUUNBQUlBZEIvLzhEY1VFQmRHcEJnSUFJYWlBSElBQWdCeUFjYWhBNlFRSjBhaUlGS0FJQWF5SUpRZi8vQXlBSlFmLy9BMGtiT3dFQUlBVWdCellDQUNBSFFRRnFJZ2NnQkVrTkFBc0xJQUFnQkRZQ2xJQVFJQUFnRnhBNlFRSjBhaWdDQUNJRklDTkpEUUFnSFVILy93TnhJQjFCRUhaR0lCMUIvd0Z4SUIxQkdIWkdjU0UwSUJNZ0pHb2hKeUFUSUJ4cUlocEJCR29oSUNBWFFRaHFJVEFnRjBFRWFpRWJJQlVnRjJzaEtFRUFJU0ZCQUNBWElCVnJJaXBySVRVZ0ZVRi9haUUySUJBaENpQXVJU2xCQUNFZklCSWhDU0FpSVF3RFFBSkFBa0FDZndKQUFrQWdFeUFGVFFSQUlBb2dObW92QUFBZ0JTQWNhaUlJSURWcUlBcHFRWDlxTHdBQVJ3MEZJQjBnQ0NnQUFFY05CUUpBSUNwRkJFQkJBQ0VMREFFTElDZ2dHaUFJYXlJRUlDZ2dCRW9iSWhKQkgzVWdFbkVoQkVFQUlRY0RRQ0FISWdzZ0Vrd0VRQ0FFSVFzTUFnc2dGeUFMUVg5cUlnZHFMUUFBSUFjZ0NHb3RBQUJHRFFBTEN5QUlRUVJxSVFjZ0hpQWJUUVIvSUJzRklBY29BQUFnR3lnQUFITWlCQTBDSUFkQkJHb2hCeUF3Q3lJRUlCNUpCRUFEUUNBSEtBQUFJQVFvQUFCekloSUVRQ0FTRUNVZ0JHb2dHMnNoQnd3SEN5QUhRUVJxSVFjZ0JFRUVhaUlFSUI1SkRRQUxDd0pBSUFRZ0swOE5BQ0FITHdBQUlBUXZBQUJIRFFBZ0IwRUNhaUVISUFSQkFtb2hCQXNnQkNBWVNRUi9JQVJCQVdvZ0JDQUhMUUFBSUFRdEFBQkdHd1VnQkFzZ0cyc2hCd3dFQ3lBZElBVWdKR29pRWlnQUFFY05CQ0FTUVFScUlRY2dBQ2dDa0lBUUlUa0NmeUFiSUJnZ0Z5QVRJQVZyYWlJaUlDSWdHRXNiSWdoQmZXb2lDeUFiVFEwQUdpQUhLQUFBSUJzb0FBQnpJZ1FOQWlBSFFRUnFJUWNnTUFzaUJDQUxTUVJBQTBBZ0J5Z0FBQ0FFS0FBQWN5STZCRUFnT2hBbElBUnFJQnRyREFVTElBZEJCR29oQnlBRVFRUnFJZ1FnQzBrTkFBc0xBa0FnQkNBSVFYOXFUdzBBSUFjdkFBQWdCQzhBQUVjTkFDQUhRUUpxSVFjZ0JFRUNhaUVFQ3lBRUlBaEpCSDhnQkVFQmFpQUVJQWN0QUFBZ0JDMEFBRVliQlNBRUN5QWJhd3dDQ3lBRUVDVWhCd3dDQ3lBRUVDVUxJUVFnRnlBRVFRUnFJZ3RxSUFoSElDSWdHRTl5UlFSQUlCb2hCQUovQWtBZ0hpQUlJZ2RMQkVBZ0dpZ0FBQ0FJS0FBQWN5SUVEUUVnQ0VFRWFpRUhJQ0FoQkFzZ0J5QWVTUVJBQTBBZ0JDZ0FBQ0FIS0FBQWN5SWlCRUFnSWhBbElBZHFJQWhyREFRTElBUkJCR29oQkNBSFFRUnFJZ2NnSGtrTkFBc0xBa0FnQnlBclR3MEFJQVF2QUFBZ0J5OEFBRWNOQUNBRVFRSnFJUVFnQjBFQ2FpRUhDeUFISUJoSkJIOGdCMEVCYWlBSElBUXRBQUFnQnkwQUFFWWJCU0FIQ3lBSWF3d0JDeUFFRUNVTElBdHFJUXNMQWtBZ0trVUVRRUVBSVFRTUFRc2dLQ0FrSURscUlCSnJJZ1FnS0NBRVNoc2lJa0VmZFNBaWNTRUlRUUFoQndOQUlBY2lCQ0FpVEFSQUlBZ2hCQXdDQ3lBWElBUkJmMm9pQjJvdEFBQWdCeUFTYWkwQUFFWU5BQXNMSUFzZ0JHc2lCeUFLVEEwQklBUWdGMm9oRENBRklCeHFJQVJxSVFrZ0J5RUtEQUVMSUFjZ0MydEJCR29pQkNBS1RBMEFJQXNnRjJvaERDQUlJQXRxSVFrZ0JDRUtDd0pBQWtBQ1FDQXlSU0FBSUFWQi8vOERjVUVCZEdwQmdJQUlhaThCQUNJSFFRRkhjZzBBSUNGRkJFQkJBU0VoSURSRkRRRWdHeUFZSUIwUU0wRUVhaUVmUVFJaElRc2dJVUVDUnlBRlFYOXFJZ1FnSTBseURRQkJBaUVoSUJNZ0JCQXlSUTBBSUIwZ0pDQWNJQVFnRTBraUVoc2dCR29pQ0NnQUFFY05BQ0FJUVFScUlDY2dHQ0FTR3lJRklCMFFNMEVFYWlFSElDUWdBQ2dDa0lBUUlpSnFJUklDUUNBRUlCTkpCRUFnQlNBSElBaHFSZ1JBSUJvZ0dDQUhJQjBRUFJBeklBZHFJUWNMSUFnZ0VpQWRFREVoQlF3QkN5QUlJQWdnR2lBZEVERWlCV3NnR2tjZ0lpQVRUM0lOQUNBbklCSkJBQ0FGYXlBZEVEMFFNU0FGYWlFRkN5QUVJQVFnQldzaUJTQWpJQVVnSTBzYkloSnJJQWRxSWdnZ0gwa2dCeUFmUzNKRkJFQWdCeUFFSUI5cmFpSUVJQk1nRXlBRUVESWJJUVVNQWdzZ0VpQVRJQk1nRWhBeUlnUWJJUVVnS2lBRVJYSU5BUUpBSUFvZ0NDQWZJQWdnSDBrYklnZFBCRUFnRENFRUlBa2hDQ0FLSVFjTUFRc2dGeUlFSUJJZ0hHb2lDR3RCLy84RFNnMERDeUFTSUFBZ0VrSC8vd054UVFGMGFrR0FnQWhxTHdFQUlnVkpCRUFnQkNFTUlBZ2hDU0FISVFvTUF3c2dFaUFGYXlFRklBUWhEQ0FJSVFrZ0J5RUtEQUVMSUFVZ0Iyc2hCUXNnS1VGL2FpSXBSUTBBSUFVZ0kwOE5BUXNMSUFvZ0VFY05BU0FKSVJJZ0RDRWlDeUFPSUJGcklRUWdCZ1JBSUEwZ0JFSC9BVzVxSUFScVFRbHFJQ1pMRFFjTElCVWdEbXNnR1NBVklCWkpHeUVKSUExQkFXb2hCUUpBSUFSQkQwOEVRQ0FOUWZBQk9nQUFJQVJCY1dvaUIwSC9BVThFUUNBRlFmOEJJQVJCOG4xcUlncEIvd0Z1SWdWQkFXb1FLQm9nQlVHQmZtd2dDbW9oQnlBRklBMXFRUUpxSVFVTElBVWdCem9BQUNBRlFRRnFJUVVNQVFzZ0RTQUVRUVIwT2dBQUN5QUZJQkVnQkNBRmFpSUhFRHNnQnlBT0lCUnJRZi8vQTNFUUx5QUpRWHhxSVFvZ0IwRUNhaUVISUFZRVFDQUhJQXBCL3dGdWFrRUdhaUFtU3cwSEN5QU5MUUFBSVF3Q1FDQUtRUTlQQkVBZ0RTQU1RUTlxT2dBQUlBbEJiV29pQzBIK0EwOEVRQ0FIUWY4QklBbEI3M3RxSWdwQi9nTnVJZ2RCQVhRaURFRUNhaEFvR2lBSFFZSjhiQ0FLYWlFTElBVWdCQ0FNYW1wQkJHb2hCd3NnQzBIL0FVOEVRQ0FIUWY4Qk9nQUFJQXRCZ1g1cUlRc2dCMEVCYWlFSEN5QUhJQXM2QUFBZ0IwRUJhaUVIREFFTElBMGdDaUFNYWpvQUFBc2dGU0FKSUE1cUlnUnJJUWtnQmdSQUlBY2dDVUgvQVc1cUlBbHFRUWxxSUNaTERRa0xJQWRCQVdvaEJRSkFJQWxCRDA4RVFDQUhRZkFCT2dBQUlBbEJjV29pQ0VIL0FVOEVRQ0FGUWY4QklBbEI4bjFxSWdwQi93RnVJZ1ZCQVdvUUtCb2dCVUdCZm13Z0Ntb2hDQ0FGSUFkcVFRSnFJUVVMSUFVZ0NEb0FBQ0FGUVFGcUlRVU1BUXNnQnlBSlFRUjBPZ0FBQ3lBRklBUWdCU0FKYWlJSkVEc2dDU0FWSUE5clFmLy9BM0VRTHlBUVFYeHFJUW9nQ1VFQ2FpRUpJQVlFUUNBSklBcEIvd0Z1YWtFR2FpQW1TdzBKQ3lBSExRQUFJUXdnQ2tFUFR3UkFJQWNnREVFUGFqb0FBQ0FRUVcxcUlnZEIvZ05QQkVBZ0NVSC9BU0FRUWU5N2FpSUpRZjREYmlJS1FRRjBJZ3hCQW1vUUtCb2dDa0dDZkd3Z0NXb2hCeUFGSUF3Z0ZXb2dCR3RxUVFScUlRa0xJQWRCL3dGUEJFQWdDVUgvQVRvQUFDQUhRWUYrYWlFSElBbEJBV29oQ1FzZ0NTQUhPZ0FBSUFsQkFXb2hDUXdLQ3lBSElBb2dER282QUFBTUNRc2dEQ0F6VHcwQklBd2hJaUFKSVJJZ0RDQVdTUTBBQ3dKQUlCVWdGazhOQUNBUUlCWWdGV3NpQkdzaUVFRURTZ1JBSUFRZ0Qyb2hEeUFXSVJVTUFRc2dEQ0VWSUFraER5QUtJUkFMSUE0Z0VXc2hCeUFHQkVBZ0RTQUhRZjhCYm1vZ0IycEJDV29nSmtzTkJRc2dEVUVCYWlFRUFrQWdCMEVQVHdSQUlBMUI4QUU2QUFBZ0IwRnhhaUlGUWY4QlR3UkFJQVJCL3dFZ0IwSHlmV29pQlVIL0FXNGlCRUVCYWhBb0dpQUVRWUYrYkNBRmFpRUZJQVFnRFdwQkFtb2hCQXNnQkNBRk9nQUFJQVJCQVdvaEJBd0JDeUFOSUFkQkJIUTZBQUFMSUFRZ0VTQUVJQWRxSWdVUU95QUZJQTRnRkd0Qi8vOERjUkF2SUJsQmZHb2hDQ0FGUVFKcUlRVWdCZ1JBSUFVZ0NFSC9BVzVxUVFacUlDWkxEUVVMSUEwdEFBQWhGQUovSUFoQkQwOEVRQ0FOSUJSQkQybzZBQUFnR1VGdGFpSUlRZjREVHdSQUlBVkIvd0VnR1VIdmUyb2lCVUgrQTI0aUNFRUJkQ0lVUVFKcUVDZ2FJQWhCZ254c0lBVnFJUWdnQkNBSElCUnFha0VFYWlFRkN5QUlRZjhCVHdSQUlBVkIvd0U2QUFBZ0NFR0JmbW9oQ0NBRlFRRnFJUVVMSUFVZ0NEb0FBQ0FGUVFGcURBRUxJQTBnQ0NBVWFqb0FBQ0FGQ3lFTklBd2hJaUFKSVJJZ0ZTRVpJQThoR3d3Q0N3Si9JQlVnRms4RVFDQVpJUWdnRUF3QkN5QVFJQlVnRG1zaUNFRVJTZzBBR2lBUUlBZ2dFR3BCZkdvZ0xDQXRJQkFnRldwQmZHcExHeUlJSUE0Z0ZXdHFJZ1JCQVVnTkFCb2dCQ0FQYWlFUElBUWdGV29oRlNBUUlBUnJDeUVaSUE0Z0VXc2hCeUFHQkVBZ0RTQUhRZjhCYm1vZ0IycEJDV29nSmtzTkJBc2dEVUVCYWlFRUFrQWdCMEVQVHdSQUlBMUI4QUU2QUFBZ0IwRnhhaUlGUWY4QlR3UkFJQVJCL3dFZ0IwSHlmV29pQlVIL0FXNGlCRUVCYWhBb0dpQUVRWUYrYkNBRmFpRUZJQVFnRFdwQkFtb2hCQXNnQkNBRk9nQUFJQVJCQVdvaEJBd0JDeUFOSUFkQkJIUTZBQUFMSUFRZ0VTQUVJQWRxSWdVUU95QUZJQTRnRkd0Qi8vOERjUkF2SUFoQmZHb2hGQ0FGUVFKcUlRVWdCZ1JBSUFVZ0ZFSC9BVzVxUVFacUlDWkxEUVFMSUEwdEFBQWhFZ0ovSUJSQkQwOEVRQ0FOSUJKQkQybzZBQUFnQ0VGdGFpSUxRZjREVHdSQUlBVkIvd0VnQ0VIdmUyb2lCVUgrQTI0aUZFRUJkQ0lTUVFKcUVDZ2FJQlJCZ254c0lBVnFJUXNnQkNBSElCSnFha0VFYWlFRkN5QUxRZjhCVHdSQUlBVkIvd0U2QUFBZ0MwR0JmbW9oQ3lBRlFRRnFJUVVMSUFVZ0N6b0FBQ0FJSUE1cUlSRWdGU0VPSUFWQkFXb01BUXNnRFNBU0lCUnFPZ0FBSUFnZ0Rtb2hFU0FWSVE0Z0JRc2hEU0FQSVJRZ0RDRWlJQWtoRWd3QUN3QUxBQXNnRGlFSElBeEJBV29pRENBdlRRMEJEQWtMQ3lBUkRBVUxJQVFoSlNBSERBVUxJQ1VnTDAwTkFBc01CQXNnQUNBQklBSWdBeUFFSUM0Z0NVR1lGbW9vQWdBZ0JpQUZRUXRLUVFBZ0FDMEFtb0FRUVFCSEVKQUNEQVFMSUJZTElTVWdEUXNoQ1VFQUlRY2dCa0VDUncwQ0N5QXhJQ1ZySWdkQjhBRnFRZjhCYmlFRUFrQWdCa1VOQUNBRUlBZHFJQWxxUVFGcUlDWkJCV29nTnlBNEd5SUVUUTBBUVFBaEJ5QUdRUUZHRFFJZ0NVRi9jeUFFYWlJRUlBUkI4QUZxUWY4QmJtc2hCd3NnQnlBbGFpRUZBa0FnQjBFUFR3UkFJQWxCOEFFNkFBQWdDVUVCYWlFRUlBZEJjV29pQmtIL0FVa0VRQ0FFSWdrZ0Jqb0FBQXdDQ3lBRVFmOEJJQWRCOG4xcUlnWkIvd0Z1SWdSQkFXb1FLQm9nQkNBSmFrRUNhaUlKSUFSQmdYNXNJQVpxT2dBQURBRUxJQWtnQjBFRWREb0FBQXNnQ1VFQmFpQWxJQWNRS2lFRUlBTWdCU0FCYXpZQ0FDQUVJQWRxSUFKckN5SUhRUUJLRFFFTElBQkJBVG9BbTRBUUN5QUhDenNCQVg4Z0FFVWdBRUVEY1hJRWZ5QUJCU0FBUVFBMkFweUFFQ0FBUXYvLy8vOFBOd0tBZ0JBZ0FFRUFPd0dhZ0JBZ0FFRUpFTEFCSUFBTEN4OEJBWDhnQUVHQWdJRHdCMDBFZnlBQUlBQkIvd0Z1YWtFUWFnVWdBUXNMeHdJQUlBQWdBUzBBQURvQUFDQUFJQUV0QUFFNkFBRWdBQ0FCTFFBQ09nQUNJQUFnQVMwQUF6b0FBeUFBSUFFdEFBUTZBQVFnQUNBQkxRQUZPZ0FGSUFBZ0FTMEFCam9BQmlBQUlBRXRBQWM2QUFjZ0FDQUJMUUFJT2dBSUlBQWdBUzBBQ1RvQUNTQUFJQUV0QUFvNkFBb2dBQ0FCTFFBTE9nQUxJQUFnQVMwQUREb0FEQ0FBSUFFdEFBMDZBQTBnQUNBQkxRQU9PZ0FPSUFBZ0FTMEFEem9BRHlBQUlBRXRBQkE2QUJBZ0FDQUJMUUFST2dBUklBQWdBUzBBRWpvQUVpQUFJQUV0QUJNNkFCTWdBQ0FCTFFBVU9nQVVJQUFnQVMwQUZUb0FGU0FBSUFFdEFCWTZBQllnQUNBQkxRQVhPZ0FYSUFBZ0FTMEFHRG9BR0NBQUlBRXRBQms2QUJrZ0FDQUJMUUFhT2dBYUlBQWdBUzBBR3pvQUd5QUFJQUV0QUJ3NkFCd2dBQ0FCTFFBZE9nQWRJQUFnQVMwQUhqb0FIaUFBSUFFdEFCODZBQjhnQUVFZ2Fnc05BQ0FBSUFCQkJtNXFRU0JxQ3o0QUVNSUNFTlVDUWRRTlFRSkIrQTlCOHc5QkNrRUxFQU5CM3cxQkJrR1FEa0g4RFVFTVFRMFFBMEhvRFVFQlFmZ05RZlFOUVE1QkR4QURFUFFDQzBVQkJIOGdBU0FBSUFFZ0FFc2JJUU1EUUNBQUlBRlBCRUFnQXc4TElBQXRBQUFoQkNBQ0xRQUFJUVVnQUVFQmFpSUdJUUFnQWtFQmFpRUNJQVFnQlVZTkFBc2dCZ3NyQVFGL0VJc0RJZ1JGQkVCQlFBOExJQVFnQUNBQklBSWdBeUFFRUlZREVJVURJUUFnQkJDSkF5QUFDNlFCQVFGL0l3QkJRR29pQkNRQUlBUWdBRFlDRkNBRUlBTTJBZ3dnQkNBQ05nSUlJQUVvQWdBaEFDQUVRZ0EzQXlnZ0JDQUFOZ0lZQWtBZ0JFRUlhaENOQkNJQ0RRQWdCRUVJYWhDTUJDSUFRUUZIQkVBZ0JFRUlhaENJQWhwQmZTRUNBa0FDUUNBQVFRVnFEZ2dBQVFFQkFRRUJBd0VMSUFRb0FneEZEUUlMSUFBaEFnd0JDeUFCSUFRb0FodzJBZ0FnQkVFSWFoQ0lBaUVDQ3lBRVFVQnJKQUFnQWd2QUJnRVFmMEYvSVFVQ1FDQUFSUTBBSUFORkJFQWdBa0VCUncwQlFYOUJBQ0FBTFFBQUd3OExJQUpGRFFBZ0FTQURhaUlJUVdCcUlROGdBQ0FDYWlJSlFYQnFJUkFnQ0VGN2FpRVJJQWhCZVdvaENpQUpRWHRxSVF3Z0NVRjRhaUVTSUFoQmRHb2hEU0FKUVhGcUlRNGdBQ0VDSUFFaEJRSkFBMEFDUUNBQ1FRRnFJUU1DUUFKQUFrQWdBaTBBQUNJSFFRUjJJZ0pCRDBjRVFDQUZJQTlMSUFNZ0VFOXlEUUVnQlNBREtRQUFOd0FBSUFVZ0F5a0FDRGNBQ0NBQ0lBVnFJZ1lnQWlBRGFpSUNMd0FBSWd0cklRUWdBa0VDYWlFQ0lBZEJEM0VpQlVFUFJnUkFJQUloQXd3REN5QUxRUWhKQkVBZ0FpRUREQU1MSUFRZ0FVa05BeUFHSUFRcEFBQTNBQUFnQmlBRUtRQUlOd0FJSUFZZ0JDOEFFRHNBRUNBRklBWnFRUVJxSVFVTUJRdEJBQ0VDSUFNZ0RrOE5CUU5BQWtBZ0FpQURMUUFBSWdScUlRSWdBMEVCYWlJRElBNVBEUUFnQkVIL0FVWU5BUXNMSUFKQkQyb2lBaUFGUVg5elN5QUNJQU5CZjNOTGNnMEZDeUFDSUFWcUlnWWdEVTFCQUNBQ0lBTnFJZ1FnRWswYlJRUkFJQVFnQ1VjZ0JpQUlTM0lOQlNBRklBTWdBaEJLR2lBR0lBRnJJUVVNQmdzZ0JTQURJQVlRT3lBSFFROXhJUVVnQkVFQ2FpRURJQVlnQkM4QUFDSUxheUVFQ3lBRlFROUhCRUFnQXlFQ0RBRUxJQU1nRENBRElBeExHeUVIUVFBaEJRTkFJQU5CQVdvaEFpQURJQWRHRFFJZ0JTQURMUUFBSWhOcUlRVWdBaUVESUJOQi93RkdEUUFMSUFWQkQyb2lCU0FHUVg5elN3MERDeUFFSUFGSkRRQWdCaUFGUVFScUlnZHFJUVVDZnlBTFFRZE5CRUFnQmtFQUVEUWdCaUFFTFFBQU9nQUFJQVlnQkMwQUFUb0FBU0FHSUFRdEFBSTZBQUlnQmlBRUxRQURPZ0FESUFZZ0JDQUxRUUowSWdOQjBCVnFLQUlBYWlJRUtBQUFOZ0FFSUFRZ0EwSHdGV29vQWdCckRBRUxJQVlnQkNrQUFEY0FBQ0FFUVFocUN5RURJQVpCQ0dvaEJDQUZJQTFMQkVBZ0JTQVJTdzBCSUFRZ0Nra0VRQ0FFSUFNZ0NoQTdJQU1nQ2lBRWEyb2hBeUFLSVFRTElBUWdCVThOQWdOQUlBUWdBeTBBQURvQUFDQURRUUZxSVFNZ0JFRUJhaUlFSUFWSERRQUxEQUlMSUFRZ0F5a0FBRGNBQUNBSFFSRkpEUUVnQmtFUWFpQURRUWhxSUFVUU93d0JDd3NnQWlFREN5QURRWDl6SUFCcUR3c2dCUXNXQUVFQUlBSWdBeUFBSUFFUW1BSWlBQ0FBRUNFYkN6a0JBWDhqQUVFUWF5SUVKQUFnQkNBRE5nSU1JQUlnQkVFTWFpQUFJQUVRbVFJaEFDQUVLQUlNSVFFZ0JFRVFhaVFBUVFBZ0FTQUFHd3M1QVFGL0l3QkJFR3NpQkNRQUlBUWdBellDRENBQUlBRWdBaUFFUVF4cUVJb0VJUUFnQkNnQ0RDRUJJQVJCRUdva0FFRUFJQUVnQUJzTERRQWdBQ0FDSUFFZ0F4Q2FBZ3VYQXdFSWZ3SkFJQUZGRFFBZ0FpQURhaUVLSUFBZ0FXb2hCU0FBUVFGcUlRRWdBQzBBQUVFZmNTRUdJQUloQkFOQUFrQUNmeUFHUVNCUEJFQUNRQ0FHUVFWMlFYOXFJZ05CQmtZRVFDQUJJUUJCQmlFREEwQWdBRUVCYWlJQklBVlBEUWNnQXlBQUxRQUFJZ2RxSVFNZ0FTRUFJQWRCL3dGR0RRQUxEQUVMSUFFZ0JVOE5CUXNnQVVFQmFpRUFJQVFnQmtFSWRFR0FQbkVpQ0dzZ0FTMEFBQ0lMYXlFSElBaEJnRDVISUF0Qi93Rkhja1VFUUNBQlFRSnFJQVZQRFFVZ0JDQUJMUUFDSUFFdEFBRkJDSFJ5YTBHQlFHb2hCeUFCUVFOcUlRQUxJQU1nQkdwQkEyb2dDa3NOQkNBSFFYOXFJZ0VnQWtrTkJDQUFJQVZQQkg5QkFBVWdBQzBBQUNFR0lBQkJBV29oQUVFQkN5RUlJQVFnQjBZRVFDQUVJQUV0QUFBZ0EwRURhaUlCRUNnZ0FXb2hCQ0FBREFJTElBUWdBU0FEUVFOcUVNUUVJUVFnQUF3QkN5QUVJQVpCQVdvaUEyb2dDa3NOQXlBQklBTnFJZ0FnQlVzTkF5QUVJQUVnQXhCUUlRUWdBQ0FGVHcwQlFRRWhDQ0FBTFFBQUlRWWdBRUVCYWdzaEFTQUlEUUVMQ3lBRUlBSnJJUWtMSUFrTG53RUJBbjhnQUNnQ0VDRUNRWHNoQVFKQUFrQUNRQUpBQWtBQ1FBSkFJQUFvQWd3dEFBQkJCWFlPQlFBQkFnTUVCZ3RCZHlFQklBSkJBVWNOQlNBQVFSSTJBa0FNQkF0QmR5RUJJQUpCQVVjTkJDQUFRUk0yQWtBTUF3dEJkeUVCSUFKQkFVY05BeUFBUVJRMkFrQU1BZ3RCZHlFQklBSkJBVWNOQWlBQVFSVTJBa0FNQVF0QmR5RUJJQUpCQVVjTkFTQUFRUlkyQWtBTFFRQWhBUXNnQVFzSEFDQUFLQUlFQzZRQ0FRUi9JQUFnQXpZQ01DQUFJQUkyQWdnZ0FDQUJOZ0lFSUFCQkFEWUNBQ0FBUVFBMkFrd2dBRUVCTmdKRUlBQkJBRFlDTENBQkxRQUFJUVVnQVMwQUFTRUNJQUFnQVVFQ2FqWUNEQ0FBSUFJMkFoQWdBQ0FCTFFBRElnYzJBaWdnQUNBQktBQUVJZ0kyQWhRZ0FDQUJLQUFJSWdRMkFpUWdBU2dBRENFR0lBQWdBVUVRYWpZQ05DQUFJQVkyQWhnQ1FDQUNSU0FFUWRiU3F0VUNTM0lnQkVFQlNDQUVJQU5MY25JZ0IwVWdCVUVDUjNKeURRQWdBUzBBQWtFSWNRMEFJQUFnQWlBRUlBSWdCRzBpQld4cklnUTJBaUFnQUNBRklBUkJBRXBxTmdJY0lBSWdBMG9OQUFKQUlBRXRBQUpCQW5FRVFDQUNRUkJxSUFaR0RRRU1BZ3NnQUJDZ0FnMEJJQUFvQWh3Z0FDZ0NHRUZ3YWtFRWJVb05BUXNnQUJDSEFSb0xDeXNCQVg4akFFSFFFV3NpQXlRQUlBTkJBRFlDVUNBRFFRaHFJQUFnQVNBQ0VLSUNJQU5CMEJGcUpBQUx5UUlCQW45QkFTRUVBa0FnQWtFRVNBMEFBa0FDUUFKQUlBTUVRQ0FEUVlBQklBTkJnQUZLR3lJRFFkYlNxdFVDSUFOQjF0S3ExUUpKR3lFRURBRUxJQUlpQkVHQWdBSklEUUJCZ0lBQ0lRUWdBQ2dDT0NJRFFYNXFJZ1ZCQTAwRVFDQUZRUUowUWNBVWFpZ0NBQ0VFQ3dKQUFrQUNRQUpBQWtBQ1FDQUJEZ29BQVFZQ0F3TUVCQVFGQmdzZ0JFRUNkaUVFREFjTElBUkJBWFloQkF3RkN5QUVRUUYwSVFRTUJBc2dCRUVDZENFRURBTUxJQVJCQTNRaEJBd0NDeUFFUVFOMElRQWdBMEVGU3dSQUlBQWhCQXdDQzBFQklBTjBRVFJ4UlFSQUlBQWhCQXdDQ3lBRVFRUjBJUVFNQVFzZ0FVRUJTQTBCSUFBb0FqZ2hBd3NnQTBFRUlBUVFzZ0ZGRFFBZ0JFR0FnQVFnQkVHQWdBUklHMEVDZENJQVFZQ0FCQ0FBUVlDQUJFb2JJUVFMSUFJZ0JDQUVJQUpLR3lJRVFRVklEUUFnQkNBRVFRUnZheUVFQ3lBRUMvVUNBUU4vSXdCQkVHc2lCQ1FBSUFBb0FnaEJBam9BQUFKL0lBQW9BamdpQTBFR1R3UkFJQVJCbXRRQk5nSUFRZWdSSUFRUVQwR1BFa0V2RUhKQmV3d0JDeUFBS0FJSVFRRTZBQUVnQUNBQUtBSUlJZ0pCQW1vMkFnd2dBa0VBT2dBQ0lBQW9BZ2dnQUNnQ0tEb0FBeUFBS0FJSVFRUnFJQUFvQWhRUU5DQUFLQUlJUVFocUlBQW9BaVFRTkNBQUlBQW9BZ2hCRUdvMkFqUWdBQ0FBS0FJY1FRSjBRUkJxTmdJc0lBQW9BanhGQkVBZ0FDZ0NEQ0lDSUFJdEFBQkJBbkk2QUFBZ0FFRVFOZ0lzQ3lBQUtBSVVRZjhBVEFSQUlBQW9BZ3dpQWlBQ0xRQUFRUUp5T2dBQUlBQkJFRFlDTEF0Q2dNQ0FnWVNNSUNBRHJVSURob2luSVFKQkFTRURBa0FDUUFKQUlBRkJmMm9PQWdFQUFndEJCQ0VEQ3lBQUtBSU1JZ0VnQVMwQUFDQURjam9BQUFzZ0FDZ0NEQ0lCSUFBb0FqZ2dBQ2dDS0NBQUtBSWtFTElCUlVFRWRDQUJMUUFBY2pvQUFDQUFLQUlNSWdBZ0FDMEFBQ0FDY2pvQUFFRUJDeUVBSUFSQkVHb2tBQ0FBQy9zQkFRRi9Jd0JCSUdzaUNTUUFJQUFnQmpZQ01DQUFJQVUyQWdnZ0FDQUVOZ0lFSUFCQkFUWUNBQ0FBUVFBMkFrd2dBRUVCTmdKRUlBQWdCellDT0NBQVFnUTNBaWdnQUNBRE5nSVVJQUFnQVRZQ1BBSi9JQU5COFAvLy93ZFBCRUFnQ1VIdi8vLy9CellDQUVHR0V5QUpFRTlCZnd3QkN5QUdRUTlOQkVBZ0NVRVFOZ0lRUWJBVElBbEJFR29RVDBGL0RBRUxJQUZCQ2s4RVFFSGpFMEVzRUhKQmRnd0JDeUFDUVFOUEJFQkJrQlJCTGhCeVFYWU1BUXNnQUNBQUlBRWdBeUFJRUtRQ0lnRTJBaVFnQUNBRElBRWdBeUFCYlNJQ2JHc2lBVFlDSUNBQUlBSWdBVUVBU21vMkFoeEJBUXNoQUNBSlFTQnFKQUFnQUF0WkFRRi9Jd0JCb0FacklnVWtBQ0FGUVFocUVOQURJQVZCQ0dvZ0FDQUJJQUlnQXlBRUVOSURJUUVnQlVFSWFpSUFFUFlCSUFCQmdBSnFJQUFvQXBnRElBQW9BcHdESUFBb0FxQURFS1FCSUFWQm9BWnFKQUFnQVF1UUFRRUJmeU1BUVVCcUlnVWtBQ0FGSUFBMkFoUWdCU0FETmdJTUlBVWdBallDQ0NBQktBSUFJUUFnQlVFQU5nSXdJQVZDQURjREtDQUZJQUEyQWhnQ1FDQUZRUWhxSUFRUXFBUWlCQTBBSUFWQkNHb1Fxd1FpQUVFQlJ3UkFJQUJCZXlBQUd5RUVJQVZCQ0dvUXJ3RWFEQUVMSUFFZ0JTZ0NIRFlDQUNBRlFRaHFFSzhCSVFRTElBVkJRR3NrQUNBRUN6RUJBbjhDZjBFQVFiaUFFQkJNSWdVaUJoQ1NBa1VOQUJvZ0JpQUFJQUVnQWlBRElBUVFzZ1FMSVFBZ0JSQTRJQUFMS3dFQmZ5TUFRYUNBQVdzaUJTUUFJQVVnQUNBQklBSWdBeUFFRUxNRUlRQWdCVUdnZ0FGcUpBQWdBQXNxQVFGL0lBQWdBU0FBS0FJRUlnTkhCSDhnQXlBQklBSVFLaG9nQUNnQ0JBVWdBUXNnQW1vMkFnUUxhUUlCZndGK0lBRWdBRzRoQlVHTTdBRXRBQUJGQkVBUWhnRkJqT3dCUVFFNkFBQUxJQVZCQjNGRkJFQWdBaUFESUFVZ0FDQUVRYURzQVNnQ0FCRVBBQ0VHSUFNZ0FDQUZiQ0lBYWlBQUlBSnFJQUVnQUdzUUtob2dCcWNQQ3lBRElBSWdBUkFxR2lBRkN5c0FRWXpzQVMwQUFFVUVRQkNHQVVHTTdBRkJBVG9BQUFzZ0FDQUJJQUlnQTBHWTdBRW9BZ0FSQ0FBTHhRc0NFbjhCZkNNQVFZQ0FBbXNpQ3lRQUlBQkIwQlJxSVFjZ0FFSGFGR29oQ1FKL0lBQkJBM1JCOEJScUt3TUFJQUszb2lJWW1VUUFBQUFBQUFEZ1FXTUVRQ0FZcWd3QkMwR0FnSUNBZUFzaEJpQUJJQUpxSVFnZ0J5MEFBQ0VISUFrdEFBQWhEa0VBSVFBRFFDQUxJQUJCQVhScVFRQTdBUUFnQUVFQmFpSUFJQWQyUlEwQUN3Si9RUUFnQWtFRVNBMEFHa0VBSUFSQndnQklEUUFhSUFoQmZtb2hEQ0FESUFRZ0JpQUdJQVJLRzJvaERTQURRUjg2QUFBZ0F5QUJMUUFBT2dBQklBTWdBUzBBQVRvQUFpQURRUU5xSVFSQkFpRUdJQUZCQW1vaEFDQUNRUTlPQkVBZ0NFRjBhaUVQSUF4QkFtb2hFa0VnSUFkcklSQkJBQ0VIQTBBQ2Z3Si9Ba0FDUUNBQUxRQUFJZ2tnQUVGL2FpMEFBRWNFUUNBQUxRQUNJUUlnQUMwQUFTRUlEQUVMSUFsQkNIUWdDWElnQUMwQUFTSUlJQUF0QUFJaUFrRUlkSEpIRFFBZ0FFRUNhaUVJSUFCQkEyb2hCd3dCQ3lBRlFRQWdBQ0FCSUFzZ0NFRUlkQ0FKY2lBQ1FSQjBjaUFBTFFBRFFSaDBja0d4ODkzeGVXd2dFSFpCQVhScUlnZ3ZBUUJxSWdwcklnSkJIM0ViUlFSQUlBZ2dBQ0FCYXpzQkFBc2dBRUVCYWlFSUlBSkJmMm9pQ1VIOHZ3UlBCRUJCQUNBRVFRSnFJZ0lnRFVzTkJob2dCQ0FBTFFBQU9nQUFJQVJCQVdvaEJDQUlJQVpCQVdvaUJrSC9BWEZCSUVjTkF4b2dCRUVmT2dBQVFRQWlCaUFIUVFGcUlnY2dEa3NOQmhvZ0FpRUVJQWdNQXdzQ1FDQUtMUUFBSWhNZ0NpMEFBU0lVUVFoMGNpQUtMUUFDSWhWQkVIUnlJQW90QUFOQkdIUnlJQUF0QUFBaUVTQUFMUUFCSWhaQkNIUnlJQUF0QUFJaUYwRVFkSElnQUMwQUEwRVlkSEpHQkVCQkJDRUhJQXBCQkdvaENBd0JDeUFSSUJOSElCUWdGa2R5SUJVZ0YwZHlSUVJBSUFwQkEyb2hDRUVESVFjTUFRdEJBQ0FFUVFKcUlnQWdEVXNOQmhvZ0JDQVJPZ0FBSUFSQkFXb2hCQ0FJSUFaQkFXb2lCa0gvQVhGQklFY05BeG9nQkVFZk9nQUFRUUFpQmlBSFFRRnFJZ2NnRGtzTkJob2dBQ0VFSUFnTUF3c2dBQ0FIYWlFSElBbEZEUUFnQnlBU0lBZ1Fsd0lNQVF0QkFTRUNRUUFoQ1NBSElBd2dDQkRGQkFzaENBSkFJQVpCL3dGeEJFQWdCa0YvYzBHQWZuSWdCR29nQmtGL2Fqb0FBQXdCQ3lBRVFYOXFJUVFMUVFBZ0JDQUlRWDFxSWdZZ0FHc2lBRUgvQVc1cVFRWnFJQTFMRFFNYUFuOGdDVUgrUDAwRVFDQUFRUVpOQkVBZ0JDQUFRUVYwSUFsQkNIWnFPZ0FBSUFSQkFtb2hBQ0FFUVFGcURBSUxJQVFnQ1VFSWRrRmdham9BQUNBRVFRRnFJUUlnQUVGNWFpSUhRZjhCVHdSQUlBSkIvd0VnQUVINmZXb2lBa0gvQVc0aUFFRUJhaEFvR2lBQVFZRitiQ0FDYWlFSElBQWdCR29pQUVFQ2FpRUNJQUJCQVdvaEJBc2dBaUFIT2dBQUlBUkJBMm9oQUNBRVFRSnFEQUVMSUFKQmdFQnFJUWtnQUVFR1RRUkFJQVJCL3dFNkFBRWdCQ0FKUVFoMk9nQUNJQVFnQUVFRmRFRWZjam9BQUNBRVFRUnFJUUFnQkVFRGFnd0JDeUFFUWY4Qk9nQUFJQVJCQVdvaEFpQUFRWGxxSWdkQi93RlBCRUFnQWtIL0FTQUFRZnA5YWlJQ1FmOEJiaUlBUVFGcUVDZ2FJQUJCZ1g1c0lBSnFJUWNnQUNBRWFpSUFRUUpxSVFJZ0FFRUJhaUVFQ3lBQ0lBYzZBQUFnQkNBSlFRaDJPZ0FESUFSQi93RTZBQUlnQkVFRmFpRUFJQVJCQkdvTElBazZBQUFnQmlBUFNRUkFJQXNnQmkwQUFDQUlRWDVxTFFBQVFRaDBjaUFJUVg5cUxRQUFRUkIwY2lBSUxRQUFRUmgwY2tHeDg5M3hlV3dnRUhaQkFYUnFJQVlnQVdzN0FRQUxJQUJCSHpvQUFDQUFRUUZxSVFSQkFDRUdRUUFoQnlBSVFYOXFDeUlBSUE5SkRRQUxDeUFBSUF4QkFXcE5CRUFEUUVFQUlBUkJBbW9pQVNBTlN3MENHaUFFSUFBdEFBQTZBQUFnQkVFQmFpRUVJQVpCQVdvaUJrSC9BWEZCSUVZRVFDQUVRUjg2QUFCQkFDRUdJQUVoQkFzZ0FDQU1UU0VCSUFCQkFXb2hBQ0FCRFFBTEN3SkFJQVpCL3dGeEJFQWdCa0YvYzBHQWZuSWdCR29nQmtGL2Fqb0FBQXdCQ3lBRVFYOXFJUVFMSUFNZ0F5MEFBRUVnY2pvQUFDQUVJQU5yQ3lFR0lBdEJnSUFDYWlRQUlBWUxKZ0JCQUNBQ0lBTWdBQ0FCSUFSQkFYUkJmMnBCRmlBRVFRbElHeENuQWlJQUlBQVFJUnNMT3dFQmZ5TUFRUkJySWdVa0FDQUZJQU0yQWd3Z0FpQUZRUXhxSUFBZ0FTQUVFS2dDSVFBZ0JTZ0NEQ0VCSUFWQkVHb2tBRUVBSUFFZ0FCc0xPUUVCZnlNQVFSQnJJZ1FrQUNBRUlBTTJBZ3dnQUNBQklBSWdCRUVNYWhER0JDRUFJQVFvQWd3aEFTQUVRUkJxSkFCQkFDQUJJQUFiQzJrQ0FYOEJmaUFCSUFCdUlRVkJqT3dCTFFBQVJRUkFFSVlCUVl6c0FVRUJPZ0FBQ3lBRlFRZHhSUVJBSUFJZ0F5QUZJQUFnQkVHYzdBRW9BZ0FSRHdBaEJpQURJQUFnQld3aUFHb2dBQ0FDYWlBQklBQnJFQ29hSUFhbkR3c2dBeUFDSUFFUUtob2dCUXNyQUVHTTdBRXRBQUJGQkVBUWhnRkJqT3dCUVFFNkFBQUxJQUFnQVNBQ0lBTkJsT3dCS0FJQUVRZ0FDOFlGQVJkL0EwQUNRQ0FBS0FJQUlnRW9Ba3hGQkVBZ0FTZ0NKQ0lGSUFFb0FpaEJBblJxSVFzZ0FDZ0NDQ0VHSUFFb0FnZ2hDQ0FCS0FJRUlRa2dBU2dDTkNFTklBRW9BaUFoRGlBQktBSWNJUUlnQVNnQ01DRVVJQUVvQWdBaER5QUJLQUlNTFFBQUlRRUNRQ0FGSUFBb0FoUk1CRUFnQUNnQ0VDRVFJQUFvQWd3aEJ3d0JDeUFHRURnZ0FDQUxJQVZCQVhScUVIa2lCallDQ0NBQUlBVWdCbW9pQnpZQ0RDQUFJQWNnQzJvaUVEWUNFQXNDZnlBQlFRSnhJaEZGSUE5QkFFZHhJaElFUUNBQUtBSUFJZ1FnQkNnQ3hCRkJBV29pQXpZQ3hCRWdBZ3dCQ3lBQ0lBSWdBQ2dDQUNJRUtBSkVJZ0Z0SWdNZ0FpQUJJQU5zYTBFQVNtb2lBU0FBS0FJRWJDSURJQUZxSWdFZ0FTQUNTaHNMSVJOQkFDRU1JQU1nRTA0TkFTQUpRUkJxSVJVZ0NFRVFhaUVXSUFKQmYyb2hGMEVBSVFvRFFDQUVLQUxBRVVFQlNBMENJQTRnQlNBRElCZEdJQTVCQUVweElnSWJJUUZCQVNBS0lBSWJJUW9DUUNBUEJFQWdBeUFGYkNFQ0lCRUVRQ0FDSUJacUlBSWdDV29nQVJCUUdnd0NDeUFFSUFFZ0NrRUFJQXNnQWlBSmFpQUhJQVlnRUJDMEFTRUJEQUVMSUJFRVFDQUlJQU1nQld3aUFtb2dBaUFWYWlBQkVGQWFEQUVMSUFRZ0FTQUtJQWtnRFNBRFFRSjBhaWdBQUNBSUlBTWdCV3hxSUFZZ0J4Q3pBU0VCQ3lBQUtBSUFJZ0lvQXNBUlFRRklEUUlnQVVGL1RBUkFJQUlnQVRZQ3dCRU1Bd3NDUUNBU0JFQWdEU0FEUVFKMGFpQUNLQUlzSWdRUU5DQUFLQUlBSVFJZ0FVRUFJQUVnQkdvZ0ZFd2JSUVJBSUFKQkFEWUN3QkVNQmdzZ0FpQUNLQUxFRVVFQmFpSUROZ0xFRVNBQ0lBSW9BaXdnQVdvMkFpd2dCQ0FJYWlBSElBRVFVQm9NQVFzZ0FTQU1haUVNSUFOQkFXb2hBd3NnQXlBVFRnMENJQUFvQWdBaEJBd0FDd0FMSUFBb0FnZ1FPQ0FBRURoQkFBOExJQklOQUNBQUtBSUFJZ0VvQXNBUlFRRklEUUFnQVNBQktBSXNJQXhxTmdJc0RBQUxBQXZ5QVFFSWZ5TUFRU0JySWdJa0FDQUFRb0dBZ0lCd053TEFFU0FBUVpRUmFpSUZFQWthSUFWQkFCQUlHZ0pBSUFBb0FrUkJBVWdOQUFOQUFrQWdBQ0FFUVFKMGFpSUdRZEFJYWlBRU5nSUFRUmdRZVNJQklBUTJBZ1FnQVNBQU5nSUFJQUVnQUNnQ0pDSURJQUFvQWloQkFuUnFJZ2NnQTBFQmRHb1FlU0lETmdJSUlBRWdBQ2dDSkNJSU5nSVVJQUVnQXlBSWFpSUROZ0lNSUFFZ0F5QUhhallDRUNBR1FkQUFhaUFGUVJFZ0FSQWFJZ0VOQUNBRVFRRnFJZ1FnQUNnQ1JFZ05BUXdDQ3dzZ0FpQUJOZ0lRUWFVUklBSkJFR29RVHlBQ0lBRVF1QUUyQWdCQjFSRWdBaEJQQ3lBQ1FTQnFKQUFMSEFBZ0FDQUFLQUlJSUFGck5nSUlJQUFnQUNnQ0JDQUJhallDQkF1QkFRRURmeU1BUVNCcklnRWtBQ0FBS0FKSVFRRk9CRUFnQUVFQk5nSk1BMEFnQUNBQ1FRSjBhaWdDVUNBQlFSeHFFQXNpQXdSQUlBRWdBellDRUVIWUVpQUJRUkJxRUU4Z0FTQURFTGdCTmdJQVFkVVJJQUVRVHdzZ0FrRUJhaUlDSUFBb0FraElEUUFMSUFCQmxCRnFFQW9hQ3lBQVFRQTJBa2dnQVVFZ2FpUUFDM1VCQW44akFFRVFheUlDSkFBQ1FDQUFLQUpFSWdGQmdRSk9CRUFnQWtHQUFqWUNBRUc3RUNBQ0VFOE1BUXNnQVVFQVRBUkFRZmtRUVNzUWNnd0JDeUFBQW45QkFTQUJRUUZHRFFBYUlBRWdBU0FBS0FKSVJnMEFHaUFBRUxjQ0lBQVF0UUlnQUNnQ1JBczJBa2dMSUFKQkVHb2tBQXYvQWdFSWZ5QUFLQUlzSVFRZ0FDZ0NLRUVDZENBQUtBSWtRUUYwYWhCNUlRVWdBQ2dDSENJR1FRRk9CRUFnQlNBQUtBSWthaUVJQTBBQ1FDQUFLQUlBUlEwQUlBQW9BZ3d0QUFCQkFuRU5BQ0FBS0FJMElBTkJBblJxSUFRUU5DQUFLQUljSVFZTFFRQWhCeUFBS0FJa0lnSWhBU0FHUVg5cUlBTkdCRUFnQUNnQ0lDSUJJQUlnQVVFQVNpSUhHeUVCQ3lBQUtBSU1MUUFBUVFKeElRWUNRQ0FBS0FJQUJFQWdCZ1JBSUFJZ0Eyd2lBaUFBS0FJSWFrRVFhaUFBS0FJRUlBSnFJQUVRVUJvTUFnc2dBQ0FCSUFjZ0JDQUFLQUl3SUFBb0FnUWdBaUFEYkdvZ0FDZ0NDQ0FFYWlBRklBZ1F0QUVpQVEwQklBVVFPRUVBRHdzZ0JnUkFJQUlnQTJ3aUFpQUFLQUlJYWlBQUtBSUVJQUpxUVJCcUlBRVFVQm9NQVFzZ0FDQUJJQWNnQUNnQ0JDQUFLQUkwSUFOQkFuUnFLQUFBSUFBb0FnZ2dBaUFEYkdvZ0JTQUlFTE1CSVFFTElBRkJBRWdFUUNBRkVEZ2dBUThMSUFFZ0JHb2hCQ0FEUVFGcUlnTWdBQ2dDSENJR1NBMEFDd3NnQlJBNElBUUxFUUFnQVNBQUtBSUlOZ0lBSUFBb0FnUUxod0VCQW44Q1FDQUFLQUlNTFFBQVFRSnhCRUFnQUNnQ0ZFRVFhaUFBS0FJd1NnMEJDMEYvSVFJZ0FCQ0hBU0lCUVFCSURRQUNRQ0FCRFFCQkFDRUJJQUFvQWhSQkVHb2dBQ2dDTUVvTkFDQUFLQUlNSWdFZ0FTMEFBRUVDY2pvQUFDQUFRUkEyQWl3Z0FCQ0hBU0lCUVFCSURRRUxJQUFvQWdoQkRHb2dBUkEwSUFFaEFnc2dBZ3RVQUNBQVFaZ1FFRjFGQkVCQkFBOExJQUJCb0JBUVhVVUVRRUVCRHdzZ0FFR2tFQkJkUlFSQVFRSVBDeUFBUWFvUUVGMUZCRUJCQXc4TElBQkJzUkFRWFVVRVFFRUVEd3RCZjBFRklBQkJ0aEFRWFJzTElnRUJmaUFCSUFLdElBT3RRaUNHaENBRUlBQVJGQUFpQlVJZ2lLY1FCQ0FGcHdzZUFRRitJQUVnQWlBRElBUWdCU0FBRVE4QUlnWkNJSWluRUFRZ0JxY0xLUUFnQUNnQ0FDQUJLQUlBTmdJQUlBQW9BZ0FnQVNnQ0JEWUNCQ0FBSUFBb0FnQkJDR28yQWdBTEJBQkNBQXNFQUVFQUN6NEJBMzhEUUNBQVFRUjBJZ0ZCaE8wQmFpQUJRWUR0QVdvaUFqWUNBQ0FCUVlqdEFXb2dBallDQUNBQVFRRnFJZ0JCd0FCSERRQUxRVEFRdGdFYUN4c0FJQUFnQVNnQ0NDQUZFRU1FUUNBQklBSWdBeUFFRUl3QkN3dVdBZ0VHZnlBQUlBRW9BZ2dnQlJCREJFQWdBU0FDSUFNZ0JCQ01BUThMSUFFdEFEVWhCeUFBS0FJTUlRWWdBVUVBT2dBMUlBRXRBRFFoQ0NBQlFRQTZBRFFnQUVFUWFpSUpJQUVnQWlBRElBUWdCUkNKQVNBSElBRXRBRFVpQ25JaEJ5QUlJQUV0QURRaUMzSWhDQUpBSUFaQkFrZ05BQ0FKSUFaQkEzUnFJUWtnQUVFWWFpRUdBMEFnQVMwQU5nMEJBa0FnQ3dSQUlBRW9BaGhCQVVZTkF5QUFMUUFJUVFKeERRRU1Bd3NnQ2tVTkFDQUFMUUFJUVFGeFJRMENDeUFCUVFBN0FUUWdCaUFCSUFJZ0F5QUVJQVVRaVFFZ0FTMEFOU0lLSUFkeUlRY2dBUzBBTkNJTElBaHlJUWdnQmtFSWFpSUdJQWxKRFFBTEN5QUJJQWRCL3dGeFFRQkhPZ0ExSUFFZ0NFSC9BWEZCQUVjNkFEUUxrZ0VBSUFBZ0FTZ0NDQ0FFRUVNRVFDQUJJQUlnQXhDTEFROExBa0FnQUNBQktBSUFJQVFRUTBVTkFBSkFJQUlnQVNnQ0VFY0VRQ0FCS0FJVUlBSkhEUUVMSUFOQkFVY05BU0FCUVFFMkFpQVBDeUFCSUFJMkFoUWdBU0FETmdJZ0lBRWdBU2dDS0VFQmFqWUNLQUpBSUFFb0FpUkJBVWNOQUNBQktBSVlRUUpIRFFBZ0FVRUJPZ0EyQ3lBQlFRUTJBaXdMQ3pRQkFYOGpBRUVRYXlJQ0pBQWdBaUFBTmdJRUlBSWdBU2tDQURjQ0NDQUNRUVJxSUFKQkNHb1F2d0lnQWtFUWFpUUFJQUFMb1FRQkJIOGdBQ0FCS0FJSUlBUVFRd1JBSUFFZ0FpQURFSXNCRHdzQ1FDQUFJQUVvQWdBZ0JCQkRCRUFDUUNBQ0lBRW9BaEJIQkVBZ0FTZ0NGQ0FDUncwQkN5QURRUUZIRFFJZ0FVRUJOZ0lnRHdzZ0FTQUROZ0lnSUFFb0FpeEJCRWNFUUNBQVFSQnFJZ1VnQUNnQ0RFRURkR29oQ0NBQkFuOENRQU5BQWtBZ0JTQUlUdzBBSUFGQkFEc0JOQ0FGSUFFZ0FpQUNRUUVnQkJDSkFTQUJMUUEyRFFBQ1FDQUJMUUExUlEwQUlBRXRBRFFFUUVFQklRTWdBU2dDR0VFQlJnMEVRUUVoQjBFQklRWWdBQzBBQ0VFQ2NRMEJEQVFMUVFFaEJ5QUdJUU1nQUMwQUNFRUJjVVVOQXdzZ0JVRUlhaUVGREFFTEN5QUdJUU5CQkNBSFJRMEJHZ3RCQXdzMkFpd2dBMEVCY1EwQ0N5QUJJQUkyQWhRZ0FTQUJLQUlvUVFGcU5nSW9JQUVvQWlSQkFVY05BU0FCS0FJWVFRSkhEUUVnQVVFQk9nQTJEd3NnQUNnQ0RDRUdJQUJCRUdvaUJTQUJJQUlnQXlBRUVIb2dCa0VDU0EwQUlBVWdCa0VEZEdvaEJpQUFRUmhxSVFVQ1FDQUFLQUlJSWdCQkFuRkZCRUFnQVNnQ0pFRUJSdzBCQ3dOQUlBRXRBRFlOQWlBRklBRWdBaUFESUFRUWVpQUZRUWhxSWdVZ0Jra05BQXNNQVFzZ0FFRUJjVVVFUUFOQUlBRXRBRFlOQWlBQktBSWtRUUZHRFFJZ0JTQUJJQUlnQXlBRUVIb2dCVUVJYWlJRklBWkpEUUFNQWdzQUN3TkFJQUV0QURZTkFTQUJLQUlrUVFGR0JFQWdBU2dDR0VFQlJnMENDeUFGSUFFZ0FpQURJQVFRZWlBRlFRaHFJZ1VnQmtrTkFBc0xDMjhCQW44Z0FDQUJLQUlJUVFBUVF3UkFJQUVnQWlBREVJb0JEd3NnQUNnQ0RDRUVJQUJCRUdvaUJTQUJJQUlnQXhDM0FRSkFJQVJCQWtnTkFDQUZJQVJCQTNScUlRUWdBRUVZYWlFQUEwQWdBQ0FCSUFJZ0F4QzNBU0FCTFFBMkRRRWdBRUVJYWlJQUlBUkpEUUFMQ3dzWkFDQUFJQUVvQWdoQkFCQkRCRUFnQVNBQ0lBTVFpZ0VMQ3pJQUlBQWdBU2dDQ0VFQUVFTUVRQ0FCSUFJZ0F4Q0tBUThMSUFBb0FnZ2lBQ0FCSUFJZ0F5QUFLQUlBS0FJY0VRZ0FDL01CQUNBQUlBRW9BZ2dnQkJCREJFQWdBU0FDSUFNUWl3RVBDd0pBSUFBZ0FTZ0NBQ0FFRUVNRVFBSkFJQUlnQVNnQ0VFY0VRQ0FCS0FJVUlBSkhEUUVMSUFOQkFVY05BaUFCUVFFMkFpQVBDeUFCSUFNMkFpQUNRQ0FCS0FJc1FRUkdEUUFnQVVFQU93RTBJQUFvQWdnaUFDQUJJQUlnQWtFQklBUWdBQ2dDQUNnQ0ZCRU1BQ0FCTFFBMUJFQWdBVUVETmdJc0lBRXRBRFJGRFFFTUF3c2dBVUVFTmdJc0N5QUJJQUkyQWhRZ0FTQUJLQUlvUVFGcU5nSW9JQUVvQWlSQkFVY05BU0FCS0FJWVFRSkhEUUVnQVVFQk9nQTJEd3NnQUNnQ0NDSUFJQUVnQWlBRElBUWdBQ2dDQUNnQ0dCRUxBQXNMT0FBZ0FDQUJLQUlJSUFVUVF3UkFJQUVnQWlBRElBUVFqQUVQQ3lBQUtBSUlJZ0FnQVNBQ0lBTWdCQ0FGSUFBb0FnQW9BaFFSREFBTG9BSUJCSDhqQUVGQWFpSUJKQUFnQUNnQ0FDSUNRWHhxS0FJQUlRTWdBa0Y0YWlnQ0FDRUVJQUZCN09RQk5nSVFJQUVnQURZQ0RDQUJRZmprQVRZQ0NFRUFJUUlnQVVFVWFrRUFRU3NRS0JvZ0FDQUVhaUVBQWtBZ0EwSDQ1QUZCQUJCREJFQWdBVUVCTmdJNElBTWdBVUVJYWlBQUlBQkJBVUVBSUFNb0FnQW9BaFFSREFBZ0FFRUFJQUVvQWlCQkFVWWJJUUlNQVFzZ0F5QUJRUWhxSUFCQkFVRUFJQU1vQWdBb0FoZ1JDd0FDUUFKQUlBRW9BaXdPQWdBQkFnc2dBU2dDSEVFQUlBRW9BaWhCQVVZYlFRQWdBU2dDSkVFQlJodEJBQ0FCS0FJd1FRRkdHeUVDREFFTElBRW9BaUJCQVVjRVFDQUJLQUl3RFFFZ0FTZ0NKRUVCUncwQklBRW9BaWhCQVVjTkFRc2dBU2dDR0NFQ0N5QUJRVUJySkFBZ0FndWRBUUVCZnlNQVFVQnFJZ01rQUFKL1FRRWdBQ0FCUVFBUVF3MEFHa0VBSUFGRkRRQWFRUUFnQVJETkFpSUJSUTBBR2lBRFFRaHFRUVJ5UVFCQk5CQW9HaUFEUVFFMkFqZ2dBMEYvTmdJVUlBTWdBRFlDRUNBRElBRTJBZ2dnQVNBRFFRaHFJQUlvQWdCQkFTQUJLQUlBS0FJY0VRZ0FJQU1vQWlBaUFFRUJSZ1JBSUFJZ0F5Z0NHRFlDQUFzZ0FFRUJSZ3NoQUNBRFFVQnJKQUFnQUFzS0FDQUFJQUZCQUJCREN3d0FJQUFRalFFYUlBQVFPQXNIQUNBQUtBSUVDd2tBSUFBUWpRRVFPQXNHQUVHNTR3RUxQd0VCZjBFWkVHMGlBVUVBTmdJSUlBRkNqSUNBZ01BQk53SUFJQUZCREdvaUFVR3g0d0VwQUFBM0FBVWdBVUdzNHdFcEFBQTNBQUFnQUNBQk5nSUFDNEVCQVFOL0l3QkJFR3NpQUNRQUFrQWdBRUVNYWlBQVFRaHFFQlFOQUVIMDdBRWdBQ2dDREVFQ2RFRUVhaEJNSWdFMkFnQWdBVVVOQUNBQUtBSUlFRXdpQVVVRVFFSDA3QUZCQURZQ0FBd0JDMEgwN0FFb0FnQWlBaUFBS0FJTVFRSjBha0VBTmdJQUlBSWdBUkFUUlEwQVFmVHNBVUVBTmdJQUN5QUFRUkJxSkFBTGpnSUJBWDlCQVNFQ0FrQWdBQVIvSUFGQi93Qk5EUUVDUUVIYzdBRW9BZ0JGQkVBZ0FVR0FmM0ZCZ0w4RFJnMEREQUVMSUFGQi93OU5CRUFnQUNBQlFUOXhRWUFCY2pvQUFTQUFJQUZCQm5aQndBRnlPZ0FBUVFJUEN5QUJRWUN3QTA5QkFDQUJRWUJBY1VHQXdBTkhHMFVFUUNBQUlBRkJQM0ZCZ0FGeU9nQUNJQUFnQVVFTWRrSGdBWEk2QUFBZ0FDQUJRUVoyUVQ5eFFZQUJjam9BQVVFRER3c2dBVUdBZ0h4cVFmLy9QMDBFUUNBQUlBRkJQM0ZCZ0FGeU9nQURJQUFnQVVFU2RrSHdBWEk2QUFBZ0FDQUJRUVoyUVQ5eFFZQUJjam9BQWlBQUlBRkJESFpCUDNGQmdBRnlPZ0FCUVFRUEN3dEJzT3dCUVJrMkFnQkJmd1VnQWdzUEN5QUFJQUU2QUFCQkFRc0pBQ0FBS0FJOEVCVUx1QUVCQVg4Z0FVRUFSeUVDQWtBQ1FBSkFJQUZGSUFCQkEzRkZjZzBBQTBBZ0FDMEFBRVVOQWlBQVFRRnFJUUFnQVVGL2FpSUJRUUJISVFJZ0FVVU5BU0FBUVFOeERRQUxDeUFDUlEwQkFrQWdBQzBBQUVVZ0FVRUVTWElOQUFOQUlBQW9BZ0FpQWtGL2N5QUNRZi85KzNkcWNVR0FnWUtFZUhFTkFTQUFRUVJxSVFBZ0FVRjhhaUlCUVFOTERRQUxDeUFCUlEwQkN3TkFJQUF0QUFCRkJFQWdBQThMSUFCQkFXb2hBQ0FCUVg5cUlnRU5BQXNMUVFBTGd3RUNBMzhCZmdKQUlBQkNnSUNBZ0JCVUJFQWdBQ0VGREFFTEEwQWdBVUYvYWlJQklBQkNDb0FpQlVKMmZpQUFmS2RCTUhJNkFBQWdBRUwvLy8vL253RldJUUlnQlNFQUlBSU5BQXNMSUFXbklnSUVRQU5BSUFGQmYyb2lBU0FDUVFwdUlnTkJkbXdnQW1wQk1ISTZBQUFnQWtFSlN5RUVJQU1oQWlBRURRQUxDeUFCQ3kwQUlBQlFSUVJBQTBBZ0FVRi9haUlCSUFDblFRZHhRVEJ5T2dBQUlBQkNBNGdpQUVJQVVnMEFDd3NnQVFzMUFDQUFVRVVFUUFOQUlBRkJmMm9pQVNBQXAwRVBjVUd3MUFGcUxRQUFJQUp5T2dBQUlBQkNCSWdpQUVJQVVnMEFDd3NnQVF2UEFnRURmeU1BUWRBQmF5SURKQUFnQXlBQ05nTE1BVUVBSVFJZ0EwR2dBV3BCQUVFb0VDZ2FJQU1nQXlnQ3pBRTJBc2dCQWtCQkFDQUJJQU5CeUFGcUlBTkIwQUJxSUFOQm9BRnFFSTRCUVFCSURRQWdBQ2dDVEVFQVRnUkFRUUVoQWdzZ0FDZ0NBQ0VFSUFBc0FFcEJBRXdFUUNBQUlBUkJYM0UyQWdBTElBUkJJSEVoQlFKL0lBQW9BakFFUUNBQUlBRWdBMEhJQVdvZ0EwSFFBR29nQTBHZ0FXb1FqZ0VNQVFzZ0FFSFFBRFlDTUNBQUlBTkIwQUJxTmdJUUlBQWdBellDSENBQUlBTTJBaFFnQUNnQ0xDRUVJQUFnQXpZQ0xDQUFJQUVnQTBISUFXb2dBMEhRQUdvZ0EwR2dBV29RamdFZ0JFVU5BQm9nQUVFQVFRQWdBQ2dDSkJFQkFCb2dBRUVBTmdJd0lBQWdCRFlDTENBQVFRQTJBaHdnQUVFQU5nSVFJQUFvQWhRYUlBQkJBRFlDRkVFQUN4b2dBQ0FBS0FJQUlBVnlOZ0lBSUFKRkRRQUxJQU5CMEFGcUpBQUwxQUlCQjM4akFFRWdheUlESkFBZ0F5QUFLQUljSWdRMkFoQWdBQ2dDRkNFRklBTWdBallDSENBRElBRTJBaGdnQXlBRklBUnJJZ0UyQWhRZ0FTQUNhaUVFUVFJaEJ5QURRUkJxSVFFQ2Z3SkFBa0FnQUNnQ1BDQURRUkJxUVFJZ0EwRU1haEFGRUk4QlJRUkFBMEFnQkNBREtBSU1JZ1ZHRFFJZ0JVRi9UQTBESUFFZ0JTQUJLQUlFSWdoTElnWkJBM1JxSWdrZ0JTQUlRUUFnQmh0cklnZ2dDU2dDQUdvMkFnQWdBVUVNUVFRZ0JodHFJZ2tnQ1NnQ0FDQUlhellDQUNBRUlBVnJJUVFnQUNnQ1BDQUJRUWhxSUFFZ0Joc2lBU0FISUFacklnY2dBMEVNYWhBRkVJOEJSUTBBQ3dzZ0JFRi9SdzBCQ3lBQUlBQW9BaXdpQVRZQ0hDQUFJQUUyQWhRZ0FDQUJJQUFvQWpCcU5nSVFJQUlNQVFzZ0FFRUFOZ0ljSUFCQ0FEY0RFQ0FBSUFBb0FnQkJJSEkyQWdCQkFDQUhRUUpHRFFBYUlBSWdBU2dDQkdzTElRUWdBMEVnYWlRQUlBUUxKQUFnQUVFTFR3Ui9JQUJCRUdwQmNIRWlBQ0FBUVg5cUlnQWdBRUVMUmhzRlFRb0xDMElCQVg4akFFRVFheUlESkFBZ0FDZ0NQQ0FCcHlBQlFpQ0lweUFDUWY4QmNTQURRUWhxRUE4UWp3RWhBQ0FES1FNSUlRRWdBMEVRYWlRQVFuOGdBU0FBR3dzaEFRSi9JQUFROGdOQkFXb2lBUkJNSWdKRkJFQkJBQThMSUFJZ0FDQUJFQ29MS2dFQmZ5TUFRUkJySWdFa0FDQUJJQUEyQWd3Z0FTZ0NEQkNRQVJEZ0FpRUFJQUZCRUdva0FDQUFDeW9CQVg4akFFRVFheUlBSkFBZ0FFR215Z0UyQWd4QnlNb0JRUWNnQUNnQ0RCQUFJQUJCRUdva0FBc3FBUUYvSXdCQkVHc2lBQ1FBSUFCQmg4b0JOZ0lNUWZES0FVRUdJQUFvQWd3UUFDQUFRUkJxSkFBTEtnRUJmeU1BUVJCcklnQWtBQ0FBUVpuSUFUWUNERUdZeXdGQkJTQUFLQUlNRUFBZ0FFRVFhaVFBQ3lvQkFYOGpBRUVRYXlJQUpBQWdBRUg3eHdFMkFneEJ3TXNCUVFRZ0FDZ0NEQkFBSUFCQkVHb2tBQXVkQVFFQ2Z5QUNRWEJKQkVBQ1FDQUNRUXBOQkVBZ0FDQUNPZ0FMSUFBaEF3d0JDeUFBSUFJUTNnSkJBV29pQkJCdElnTTJBZ0FnQUNBRVFZQ0FnSUI0Y2pZQ0NDQUFJQUkyQWdRTElBSWlBQVJBSUFNZ0FTQUFFQ29hQ3lBQ0lBTnFRUUE2QUFBUEMwRUlFQTRpQVNJQ0lnQkIwT01CTmdJQUlBQkIvT01CTmdJQUlBQkJCR29RMUFJZ0FrR3M1QUUyQWdBZ0FVRzQ1QUZCRUJBTkFBc0hBQ0FBS0FJSUN5b0JBWDhqQUVFUWF5SUFKQUFnQUVHSHhnRTJBZ3hCc00wQlFRQWdBQ2dDREJBQUlBQkJFR29rQUFzcUFRRi9Jd0JCRUdzaUFDUUFJQUJCbU1VQk5nSU1RWWpvQVNBQUtBSU1RUWdRQmlBQVFSQnFKQUFMS2dFQmZ5TUFRUkJySWdBa0FDQUFRWkxGQVRZQ0RFSDg1d0VnQUNnQ0RFRUVFQVlnQUVFUWFpUUFDeTRCQVg4akFFRVFheUlBSkFBZ0FFR0V4UUUyQWd4QjhPY0JJQUFvQWd4QkJFRUFRWDhRQVNBQVFSQnFKQUFMTmdFQmZ5TUFRUkJySWdBa0FDQUFRZi9FQVRZQ0RFSGs1d0VnQUNnQ0RFRUVRWUNBZ0lCNFFmLy8vLzhIRUFFZ0FFRVFhaVFBQ3k0QkFYOGpBRUVRYXlJQUpBQWdBRUh5eEFFMkFneEIyT2NCSUFBb0FneEJCRUVBUVg4UUFTQUFRUkJxSkFBTE5nRUJmeU1BUVJCcklnQWtBQ0FBUWU3RUFUWUNERUhNNXdFZ0FDZ0NERUVFUVlDQWdJQjRRZi8vLy84SEVBRWdBRUVRYWlRQUN6QUJBWDhqQUVFUWF5SUFKQUFnQUVIZnhBRTJBZ3hCd09jQklBQW9BZ3hCQWtFQVFmLy9BeEFCSUFCQkVHb2tBQXN5QVFGL0l3QkJFR3NpQUNRQUlBQkIyY1FCTmdJTVFiVG5BU0FBS0FJTVFRSkJnSUIrUWYvL0FSQUJJQUJCRUdva0FBc3ZBUUYvSXdCQkVHc2lBQ1FBSUFCQnk4UUJOZ0lNUVp6bkFTQUFLQUlNUVFGQkFFSC9BUkFCSUFCQkVHb2tBQXN3QVFGL0l3QkJFR3NpQUNRQUlBQkJ2OFFCTmdJTVFham5BU0FBS0FJTVFRRkJnSDlCL3dBUUFTQUFRUkJxSkFBTE1BRUJmeU1BUVJCcklnQWtBQ0FBUWJyRUFUWUNERUdRNXdFZ0FDZ0NERUVCUVlCL1FmOEFFQUVnQUVFUWFpUUFDeVlCQVg4akFFRVFheUlBSkFBZ0FFR2s3QUUyQWd3Z0FDZ0NEQm9Rd3dFZ0FFRVFhaVFBQytnTEFnOS9BWDRqQUVId0FHc2lCeVFBSUFjZ0FDZ0M4T0VCSWdnMkFsUWdBU0FDYWlFT0lBZ2dBQ2dDZ09JQmFpRVBJQUVoQ2dKQUFrQWdCVVVOQUNBQUtBTEU0QUVoRUNBQUtBTEE0QUVoRVNBQUtBSzg0QUVoRFNBQVFRRTJBb3poQVNBSElBQkJ0TkFCYWlnQ0FEWUNSQ0FISUFCQnJOQUJhaUlTS1FJQU53SThJQWRCRUdvZ0F5QUVFRVVRSVFSQVFXd2hBQXdDQ3lBSFFUeHFJUk1nQjBFa2FpQUhRUkJxSUFBb0FnQVFhQ0FIUVN4cUlBZEJFR29nQUNnQ0NCQm9JQWRCTkdvZ0IwRVFhaUFBS0FJRUVHZ2dEa0ZnYWlFVUEwQUNRQUpBSUFWRklBZEJFR29RSTBFQ1MzSkZCRUFnQnlnQ0tDQUhLQUlrUVFOMGFpSUFMUUFDSVFJZ0J5Z0NPQ0FIS0FJMFFRTjBhaUlFTFFBQ0lRTWdCQ2dDQkNFTUlBQW9BZ1FoQkFKQUlBY29BakFnQnlnQ0xFRURkR29pQ0MwQUFpSUFSUVJBUVFBaENRd0JDeUFJS0FJRUlRZ2dCa1VnQUVFWlNYSkZCRUFnQ0NBSFFSQnFJQUJCSUNBSEtBSVVheUlJSUFnZ0FFc2JJZ2dRUWlBQUlBaHJJZ0IwYWlFSklBZEJFR29RSXhvZ0FFVU5BeUFIUVJCcUlBQVFRaUFKYWlFSkRBTUxJQWRCRUdvZ0FCQkNJQWhxSVFrZ0IwRVFhaEFqR2lBQVFRRkxEUUlMQWtBQ1FBSkFBa0FDUUNBSklBUkZhaUlBRGdRRUFRRUFBUXNnQnlnQ1BFRi9haUlBSUFCRmFpRUpEQUVMSUFCQkFuUWdCMm9vQWp3aUNDQUlSV29oQ1NBQVFRRkdEUUVMSUFjZ0J5Z0NRRFlDUkFzZ0J5QUhLQUk4TmdKQUlBY2dDVFlDUEF3REN5QUhLQUk4SVFrTUFnc2dCUVJBUVd3aEFBd0ZDMEZzSVFBZ0IwRVFhaEFqUVFKSkRRUWdFaUFUS1FJQU53SUFJQklnRXlnQ0NEWUNDQ0FIS0FKVUlRZ01Bd3NnQnlrQ1BDRVdJQWNnQ1RZQ1BDQUhJQlkzQTBBTElBSWdBMm9oQUNBREJIOGdCMEVRYWlBREVFSUZRUUFMSVFnZ0FFRVVUd1JBSUFkQkVHb1FJeG9MSUFnZ0RHb2hDeUFDQkg4Z0IwRVFhaUFDRUVJRlFRQUxJUWdnQjBFUWFoQWpHaUFISUFjb0FpZ2dCeWdDSkVFRGRHb2lBQzhCQUNBSFFSQnFJQUF0QUFNUVJtbzJBaVFnQnlBSEtBSTRJQWNvQWpSQkEzUnFJZ0F2QVFBZ0IwRVFhaUFBTFFBREVFWnFOZ0kwSUFkQkVHb1FJeG9nQnlBSEtBSXdJQWNvQWl4QkEzUnFJZ0F2QVFBZ0IwRVFhaUFBTFFBREVFWnFOZ0lzSUFjZ0JDQUlhaUlBTmdKWUlBY2dDVFlDWUNBSElBczJBbHdnQnlnQ1ZDRU1JQWNnQUNBS2FpSUVJQWxySWdJMkFtZ0Nmd0pBSUFvZ0FDQUxhaUlEYWlBVVRRUkFJQUFnREdvaUZTQVBUUTBCQ3lBSElBY3BBMkEzQXdnZ0J5QUhLUU5ZTndNQUlBb2dEaUFISUFkQjFBQnFJQThnRFNBUklCQVFrd0VNQVFzZ0NpQU1FQndDUUNBQVFSRkpEUUFnQ2tFUWFpQU1RUkJxSWdnUUhDQUtRU0JxSUF4QklHb1FIQ0FBUVhCcVFTRklEUUFnQ2tFd2FpRUFBMEFnQUNBSVFTQnFJZ3dRSENBQVFSQnFJQWhCTUdvUUhDQU1JUWdnQUVFZ2FpSUFJQVJKRFFBTEN5QUhJQlUyQWxRZ0J5QUVOZ0pzQWtBZ0NTQUVJQTFyU3dSQVFXd2dDU0FFSUJGclN3MENHaUFRSUFJZ0RXc2lBR29pQWlBTGFpQVFUUVJBSUFRZ0FpQUxFRW9hREFJTElBUWdBa0VBSUFCckVFb2hBaUFISUFBZ0Myb2lDellDWENBSElBSWdBR3NpQkRZQ2JDQUhJQTAyQW1nZ0RTRUNDeUFKUVJCUEJFQWdCQ0FDRUJ3Z0JFRVFhaUFDUVJCcUVCd2dDMEVoU0EwQklBUWdDMm9oQ0NBRVFTQnFJUUFEUUNBQUlBSkJJR29pQkJBY0lBQkJFR29nQWtFd2FoQWNJQVFoQWlBQVFTQnFJZ0FnQ0VrTkFBc01BUXNnQjBIc0FHb2dCMEhvQUdvZ0NSQjhJQXRCQ1VrTkFDQUxJQWNvQW13aUNHcEJlR29oQkNBSUlBY29BbWdpQUd0QkQwd0VRQU5BSUFnZ0FCQm5JQUJCQ0dvaEFDQUlRUWhxSWdnZ0JFa05BQXdDQ3dBTElBZ2dBQkFjSUFoQkVHb2dBRUVRYWhBY0lBdEJLVWdOQUNBSVFTQnFJUWdEUUNBSUlBQkJJR29pQWhBY0lBaEJFR29nQUVFd2FoQWNJQUloQUNBSVFTQnFJZ2dnQkVrTkFBc0xJQU1MSVFBZ0JVRi9haUVGSUFBZ0Ntb2hDaUFBRUNGRkRRQUxEQUVMUWJwL0lRQWdEeUFJYXlJQ0lBNGdDbXRMRFFBZ0NpQUlJQUlRS2lBQ2FpQUJheUVBQ3lBSFFmQUFhaVFBSUFBTGtCZ0NHWDhDZmlNQVFkQUJheUlISkFBZ0J5QUFLQUx3NFFFaUNEWUN0QUVnQVNBQ2FpRVNJQWdnQUNnQ2dPSUJhaUVUSUFFaENnSkFJQVVFUUNBQUtBTEU0QUVoRUNBQUtBTEE0QUVoRkNBQUtBSzg0QUVoRGlBQVFRRTJBb3poQVNBSElBQkJ0TkFCYWlnQ0FEWUNYQ0FISUFCQnJOQUJhaUlYS1FJQU53SlVJQWNnRURZQ1pDQUhJQTQyQW1BZ0J5QUJJQTVyTmdKb1FXd2hEeUFIUVNocUlBTWdCQkJGRUNFTkFTQUZRUVFnQlVFRVNCc2hGaUFIUVR4cUlBZEJLR29nQUNnQ0FCQm9JQWRCeEFCcUlBZEJLR29nQUNnQ0NCQm9JQWRCekFCcUlBZEJLR29nQUNnQ0JCQm9RUUFoQ0NBRlFRQktJUUlDUUNBRlFRRklJQWRCS0dvUUkwRUNTM0lOQUNBSFFlQUFhaUVMSUFkQjVBQnFJUXdEUUNBSEtBSkFJQWNvQWp4QkEzUnFJZ0F0QUFJaEF5QUhLQUpRSUFjb0FreEJBM1JxSWdJdEFBSWhCQ0FDS0FJRUlRMGdBQ2dDQkNFSlFRQWhBQUpBQWtBZ0J5Z0NTQ0FIS0FKRVFRTjBhaUlLTFFBQ0lnSUVRQ0FLS0FJRUlRQUNRQ0FHQkVBZ0FDQUhRU2hxSUFKQkdDQUNRUmhKR3lJQUVFSWdBaUFBYXlJS2RHb2hBQ0FIUVNocUVDTWFJQXBGRFFFZ0IwRW9haUFLRUVJZ0FHb2hBQXdCQ3lBSFFTaHFJQUlRUWlBQWFpRUFJQWRCS0dvUUl4b0xJQUpCQVVzTkFRc0NRQUpBQWtBQ1FBSkFJQUFnQ1VWcUlnSU9CQVFCQVFBQkN5QUhLQUpVUVg5cUlnQWdBRVZxSVFBTUFRc2dBa0VDZENBSGFpZ0NWQ0lBSUFCRmFpRUFJQUpCQVVZTkFRc2dCeUFIS0FKWU5nSmNDeUFISUFjb0FsUTJBbGdnQnlBQU5nSlVEQUlMSUFjb0FsUWhBQXdCQ3lBSEtRSlVJU0FnQnlBQU5nSlVJQWNnSURjRFdBc2dBeUFFYWlFQ0lBUUVmeUFIUVNocUlBUVFRZ1ZCQUFzaENpQUNRUlJQQkVBZ0IwRW9haEFqR2dzZ0NpQU5haUVFSUFNRWZ5QUhRU2hxSUFNUVFnVkJBQXNoQWlBSFFTaHFFQ01hSUFjZ0FpQUphaUlLSUFjb0FtaHFJZ01nQkdvMkFtZ2dEQ0FMSUFBZ0Ewc2JLQUlBSVFrZ0J5QUhLQUpBSUFjb0FqeEJBM1JxSWdJdkFRQWdCMEVvYWlBQ0xRQURFRVpxTmdJOElBY2dCeWdDVUNBSEtBSk1RUU4wYWlJQ0x3RUFJQWRCS0dvZ0FpMEFBeEJHYWpZQ1RDQUhRU2hxRUNNYUlBY29Ba2dnQnlnQ1JFRURkR29pQWk4QkFDRU5JQWRCS0dvZ0FpMEFBeEJHSVJFZ0IwSHdBR29nQ0VFRWRHb2lBaUFESUFscUlBQnJOZ0lNSUFJZ0FEWUNDQ0FDSUFRMkFnUWdBaUFLTmdJQUlBY2dEU0FSYWpZQ1JDQUlRUUZxSWdnZ0ZrZ2hBaUFIUVNocUVDTWhBQ0FJSUJaT0RRRWdBRUVEU1EwQUN3c2dBZzBCSUFnZ0JVZ2hBaUFIUVNocUVDTWhBQUpBSUFnZ0JVNEVRQ0FCSVFvTUFRc2dBRUVDU3dSQUlBRWhDZ3dCQ3lBU1FXQnFJUm9nQjBIZ0FHb2hHeUFIUWVRQWFpRWNJQUVoQ2dOQUlBY29Ba0FnQnlnQ1BFRURkR29pQUMwQUFpRURJQWNvQWxBZ0J5Z0NURUVEZEdvaUJDMEFBaUVDSUFRb0FnUWhEQ0FBS0FJRUlRUkJBQ0VMQWtBQ1FDQUhLQUpJSUFjb0FrUkJBM1JxSWdrdEFBSWlBQVJBSUFrb0FnUWhDUUpBSUFZRVFDQUpJQWRCS0dvZ0FFRVlJQUJCR0VrYklna1FRaUFBSUFscklnbDBhaUVMSUFkQktHb1FJeG9nQ1VVTkFTQUhRU2hxSUFrUVFpQUxhaUVMREFFTElBZEJLR29nQUJCQ0lBbHFJUXNnQjBFb2FoQWpHZ3NnQUVFQlN3MEJDd0pBQWtBQ1FBSkFBa0FnQ3lBRVJXb2lBQTRFQkFFQkFBRUxJQWNvQWxSQmYyb2lBQ0FBUldvaEN3d0JDeUFBUVFKMElBZHFLQUpVSWdrZ0NVVnFJUXNnQUVFQlJnMEJDeUFISUFjb0FsZzJBbHdMSUFjZ0J5Z0NWRFlDV0NBSElBczJBbFFNQWdzZ0J5Z0NWQ0VMREFFTElBY3BBbFFoSUNBSElBczJBbFFnQnlBZ053TllDeUFDSUFOcUlRQWdBZ1IvSUFkQktHb2dBaEJDQlVFQUN5RUNJQUJCRkU4RVFDQUhRU2hxRUNNYUN5QUNJQXhxSVJnZ0F3Ui9JQWRCS0dvZ0F4QkNCVUVBQ3lFQUlBZEJLR29RSXhvZ0J5QUFJQVJxSWgwZ0J5Z0NhR29pR1NBWWFqWUNhQ0FjSUJzZ0N5QVpTeHNvQWdBaEhpQUhJQWNvQWtBZ0J5Z0NQRUVEZEdvaUFDOEJBQ0FIUVNocUlBQXRBQU1RUm1vMkFqd2dCeUFIS0FKUUlBY29Ba3hCQTNScUlnQXZBUUFnQjBFb2FpQUFMUUFERUVacU5nSk1JQWRCS0dvUUl4b2dCeUFIS0FKSUlBY29Ba1JCQTNScUlnQXZBUUFnQjBFb2FpQUFMUUFERUVacU5nSkVJQWNnQjBId0FHb2dDRUVEY1VFRWRHb2lFU2tEQ0NJZ053UEFBU0FISUJFcEF3QWlJVGNEdUFFZ0J5Z0N0QUVoQUNBSEtBSzhBU0VOSUFjZ0NpQWhweUlKYWlJTUlDQ25JaFZySWdNMkFzZ0JBbjhDUUNBQUlBbHFJaDhnRTAwRVFDQUtJQWtnRFdvaUJHb2dHazBOQVFzZ0J5QUhLUVBBQVRjRElDQUhJQWNwQTdnQk53TVlJQW9nRWlBSFFSaHFJQWRCdEFGcUlCTWdEaUFVSUJBUWt3RU1BUXNnQ2lBQUVCd0NRQ0FKUVJGSkRRQWdDa0VRYWlBQVFSQnFJZ0lRSENBS1FTQnFJQUJCSUdvUUhDQUpRWEJxUVNGSURRQWdDa0V3YWlFQUEwQWdBQ0FDUVNCcUlna1FIQ0FBUVJCcUlBSkJNR29RSENBSklRSWdBRUVnYWlJQUlBeEpEUUFMQ3lBSElCODJBclFCSUFjZ0REWUN6QUVDUUNBVklBd2dEbXRMQkVCQmJDQVZJQXdnRkd0TERRSWFJQkFnQXlBT2F5SUFhaUlDSUExcUlCQk5CRUFnRENBQ0lBMFFTaG9NQWdzZ0RDQUNRUUFnQUdzUVNpRUNJQWNnQUNBTmFpSU5OZ0s4QVNBSElBSWdBR3NpRERZQ3pBRWdCeUFPTmdMSUFTQU9JUU1MSUJWQkVFOEVRQ0FNSUFNUUhDQU1RUkJxSUFOQkVHb1FIQ0FOUVNGSURRRWdEQ0FOYWlFSklBeEJJR29oQUFOQUlBQWdBMEVnYWlJQ0VCd2dBRUVRYWlBRFFUQnFFQndnQWlFRElBQkJJR29pQUNBSlNRMEFDd3dCQ3lBSFFjd0JhaUFIUWNnQmFpQVZFSHdnRFVFSlNRMEFJQTBnQnlnQ3pBRWlBbXBCZUdvaENTQUNJQWNvQXNnQklnQnJRUTlNQkVBRFFDQUNJQUFRWnlBQVFRaHFJUUFnQWtFSWFpSUNJQWxKRFFBTUFnc0FDeUFDSUFBUUhDQUNRUkJxSUFCQkVHb1FIQ0FOUVNsSURRQWdBa0VnYWlFQ0EwQWdBaUFBUVNCcUlnTVFIQ0FDUVJCcUlBQkJNR29RSENBRElRQWdBa0VnYWlJQ0lBbEpEUUFMQ3lBRUN5SUFFQ0VFUUNBQUlROE1CQXNnRVNBZE5nSUFJQkVnR1NBZWFpQUxhellDRENBUklBczJBZ2dnRVNBWU5nSUVJQUFnQ21vaENpQUlRUUZxSWdnZ0JVZ2hBaUFIUVNocUVDTWhBQ0FJSUFWT0RRRWdBRUVEU1EwQUN3c2dBZzBCSUFnZ0Ztc2lEQ0FGU0FSQUlCSkJZR29oRFFOQUlBY2dCMEh3QUdvZ0RFRURjVUVFZEdvaUFDa0RDQ0lnTndQQUFTQUhJQUFwQXdBaUlUY0R1QUVnQnlnQ3RBRWhBQ0FIS0FLOEFTRUxJQWNnQ2lBaHB5SUdhaUlFSUNDbklnbHJJZ0kyQXNnQkFuOENRQ0FBSUFacUlnOGdFMDBFUUNBS0lBWWdDMm9pQTJvZ0RVME5BUXNnQnlBSEtRUEFBVGNERUNBSElBY3BBN2dCTndNSUlBb2dFaUFIUVFocUlBZEJ0QUZxSUJNZ0RpQVVJQkFRa3dFTUFRc2dDaUFBRUJ3Q1FDQUdRUkZKRFFBZ0NrRVFhaUFBUVJCcUlnZ1FIQ0FLUVNCcUlBQkJJR29RSENBR1FYQnFRU0ZJRFFBZ0NrRXdhaUVBQTBBZ0FDQUlRU0JxSWdZUUhDQUFRUkJxSUFoQk1Hb1FIQ0FHSVFnZ0FFRWdhaUlBSUFSSkRRQUxDeUFISUE4MkFyUUJJQWNnQkRZQ3pBRUNRQ0FKSUFRZ0RtdExCRUJCYkNBSklBUWdGR3RMRFFJYUlCQWdBaUFPYXlJQWFpSUNJQXRxSUJCTkJFQWdCQ0FDSUFzUVNob01BZ3NnQkNBQ1FRQWdBR3NRU2lFQ0lBY2dBQ0FMYWlJTE5nSzhBU0FISUFJZ0FHc2lCRFlDekFFZ0J5QU9OZ0xJQVNBT0lRSUxJQWxCRUU4RVFDQUVJQUlRSENBRVFSQnFJQUpCRUdvUUhDQUxRU0ZJRFFFZ0JDQUxhaUVHSUFSQklHb2hBQU5BSUFBZ0FrRWdhaUlFRUJ3Z0FFRVFhaUFDUVRCcUVCd2dCQ0VDSUFCQklHb2lBQ0FHU1EwQUN3d0JDeUFIUWN3QmFpQUhRY2dCYWlBSkVId2dDMEVKU1EwQUlBc2dCeWdDekFFaUNHcEJlR29oQkNBSUlBY29Bc2dCSWdCclFROU1CRUFEUUNBSUlBQVFaeUFBUVFocUlRQWdDRUVJYWlJSUlBUkpEUUFNQWdzQUN5QUlJQUFRSENBSVFSQnFJQUJCRUdvUUhDQUxRU2xJRFFBZ0NFRWdhaUVJQTBBZ0NDQUFRU0JxSWdJUUhDQUlRUkJxSUFCQk1Hb1FIQ0FDSVFBZ0NFRWdhaUlJSUFSSkRRQUxDeUFEQ3lJUEVDRU5BeUFLSUE5cUlRb2dERUVCYWlJTUlBVkhEUUFMQ3lBWElBY3BBbFEzQWdBZ0Z5QUhLQUpjTmdJSUlBY29BclFCSVFnTFFicC9JUThnRXlBSWF5SUFJQklnQ210TERRQWdDaUFJSUFBUUtpQUFhaUFCYXlFUEN5QUhRZEFCYWlRQUlBOExRUUVEZnlBQVFRaHFJUU1nQUNnQ0JDRUNRUUFoQUFOQUlBRWdBeUFBUVFOMGFpMEFBa0VXUzJvaEFTQUFRUUZxSWdBZ0FuWkZEUUFMSUFGQkNDQUNhM1FMSlFBZ0FFSUFOd0lBSUFCQkFEc0JDQ0FBUVFBNkFBc2dBQ0FCTmdJTUlBQWdBam9BQ2d1VUF3RUZmMEc0ZnlFSEFrQUNRQ0FEUlEwQUlBSXRBQUFpQkVVTkFRSi9JQUpCQVdvaUJTQUVRUmgwUVJoMUlnWkJmMG9OQUJvZ0JrRi9SZ1JBSUFOQkEwZ05BaUFGTHdBQVFZRCtBV29oQkNBQ1FRTnFEQUVMSUFOQkFrZ05BU0FDTFFBQklBUkJDSFJ5UVlDQWZtb2hCQ0FDUVFKcUN5RUZJQUVnQkRZQ0FDQUZRUUZxSWdFZ0FpQURhaUlEU3cwQVFXd2hCeUFBUVJCcUlBQWdCUzBBQUNJRlFRWjJRU05CQ1NBQklBTWdBV3RCNExBQlFmQ3hBVUdBc3dFZ0FDZ0NqT0VCSUFBb0FwemlBU0FFRUpRQklnWVFJU0lJRFFBZ0FFR1lJR29nQUVFSWFpQUZRUVIyUVFOeFFSOUJDQ0FCSUFFZ0Jtb2dDQnNpQVNBRElBRnJRWkMzQVVHUXVBRkJrTGtCSUFBb0FvemhBU0FBS0FLYzRnRWdCQkNVQVNJR0VDRWlDQTBBSUFCQm9EQnFJQUJCQkdvZ0JVRUNka0VEY1VFMFFRa2dBU0FCSUFacUlBZ2JJZ0VnQXlBQmEwR2d1d0ZCZ0wwQlFlQytBU0FBS0FLTTRRRWdBQ2dDbk9JQklBUVFsQUVpQUJBaERRQWdBQ0FCYWlBQ2F5RUhDeUFIRHdzZ0FVRUFOZ0lBUVFGQnVIOGdBMEVCUmhzTHlnWUJDSDlCYkNFSUFrQWdBa0VEU1EwQUFrQUNRQUpBQWtBZ0FTMEFBQ0lFUVFOeElnbEJBV3NPQXdNQkFBSUxJQUFvQW9qaEFRMEFRV0lQQ3lBQ1FRVkpEUUpCQXlFR0lBRW9BQUFoQlFKL0FrQUNRQUpBSUFSQkFuWkJBM0VpQjBGK2FnNENBUUlBQ3lBRlFRNTJRZjhIY1NFRUlBVkJCSFpCL3dkeElRTWdCMFVNQWdzZ0JVRVNkaUVFUVFRaEJpQUZRUVIyUWYvL0FIRWhBMEVBREFFTElBVkJCSFpCLy84UGNTSURRWUNBQ0VzTkF5QUJMUUFFUVFwMElBVkJGblp5SVFSQkJTRUdRUUFMSVFVZ0JDQUdhaUlLSUFKTERRSUNRQ0FEUVlFR1NRMEFJQUFvQXB6aUFVVU5BRUVBSVFJRFFDQUNRY1QvQUVraEJ5QUNRVUJySVFJZ0J3MEFDd3NDZnlBSlFRTkdCRUFnQVNBR2FpRUJJQUJCNE9JQmFpRUNJQUFvQWd3aEJpQUZCRUFnQWlBRElBRWdCQ0FHRUpNRERBSUxJQUlnQXlBQklBUWdCaENRQXd3QkN5QUFRYmpRQVdvaEFpQUJJQVpxSVFFZ0FFSGc0Z0ZxSVFZZ0FFR28wQUJxSVFjZ0JRUkFJQWNnQmlBRElBRWdCQ0FDRUpFRERBRUxJQWNnQmlBRElBRWdCQ0FDRUk0REN4QWhEUUlnQUNBRE5nS0E0Z0VnQUVFQk5nS0k0UUVnQUNBQVFlRGlBV28yQXZEaEFTQUpRUUpHQkVBZ0FDQUFRYWpRQUdvMkFnd0xJQUFnQTJvaUFFSDQ0Z0ZxUWdBM0FBQWdBRUh3NGdGcVFnQTNBQUFnQUVIbzRnRnFRZ0EzQUFBZ0FFSGc0Z0ZxUWdBM0FBQWdDZzhMUVFJaEF3Si9Ba0FDUUFKQUlBUkJBblpCQTNGQmYyb09Bd0VBQWdBTFFRRWhBeUFFUVFOMkRBSUxJQUV2QUFCQkJIWU1BUXRCQXlFRElBRVFsUUZCQkhZTElnUWdBMm9pQlVFZ2FpQUNTd1JBSUFVZ0Frc05BaUFBUWVEaUFXb2dBU0FEYWlBRUVDb2hBU0FBSUFRMkFvRGlBU0FBSUFFMkF2RGhBU0FCSUFScUlnQkNBRGNBR0NBQVFnQTNBQkFnQUVJQU53QUlJQUJDQURjQUFDQUZEd3NnQUNBRU5nS0E0Z0VnQUNBQklBTnFOZ0x3NFFFZ0JROExRUUloQXdKL0FrQUNRQUpBSUFSQkFuWkJBM0ZCZjJvT0F3RUFBZ0FMUVFFaEF5QUVRUU4yREFJTElBRXZBQUJCQkhZTUFRc2dBa0VFU1NBQkVKVUJJZ0pCajRDQUFVdHlEUUZCQXlFRElBSkJCSFlMSVFJZ0FFSGc0Z0ZxSUFFZ0Eyb3RBQUFnQWtFZ2FoQW9JUUVnQUNBQ05nS0E0Z0VnQUNBQk5nTHc0UUVnQTBFQmFpRUlDeUFJQzhrREFRWi9Jd0JCZ0FGcklnTWtBRUZpSVFnQ1FDQUNRUWxKRFFBZ0FFR1kwQUJxSUFGQkNHb2lCQ0FDUVhocUlBQVF6Z0VpQlJBaElnWU5BQ0FEUVI4MkFud2dBeUFEUWZ3QWFpQURRZmdBYWlBRUlBUWdCV29nQmhzaUJDQUJJQUpxSWdJZ0JHc1FheUlGRUNFTkFDQURLQUo4SWdaQkgwc05BQ0FES0FKNElnZEJDVThOQUNBQVFZZ2dhaUFESUFaQjRLc0JRZUNzQVNBSEVIMGdBMEUwTmdKOElBTWdBMEg4QUdvZ0EwSDRBR29nQkNBRmFpSUVJQUlnQkdzUWF5SUZFQ0VOQUNBREtBSjhJZ1pCTkVzTkFDQURLQUo0SWdkQkNrOE5BQ0FBUVpBd2FpQURJQVpCNEswQlFaQ2tBU0FIRUgwZ0EwRWpOZ0o4SUFNZ0EwSDhBR29nQTBINEFHb2dCQ0FGYWlJRUlBSWdCR3NRYXlJRkVDRU5BQ0FES0FKOElnWkJJMHNOQUNBREtBSjRJZ2RCQ2s4TkFDQUFJQU1nQmtIQXJ3RkJzS2NCSUFjUWZTQUVJQVZxSWdSQkRHb2lCU0FDU3cwQUlBUW9BQUFpQmtGL2FpQUNJQVZySWdKUERRQWdBQ0FHTmdLYzBBRWdCRUVFYWlJRUtBQUFJZ1ZCZjJvZ0FrOE5BQ0FBUWFEUUFXb2dCVFlDQUNBRVFRUnFJZ1FvQUFBaUJVRi9haUFDVHcwQUlBQkJwTkFCYWlBRk5nSUFJQVFnQVd0QkJHb2hDQXNnQTBHQUFXb2tBQ0FJQ3kwQkFYOGdBQVJBUWJwL0lRUWdBeUFCVFFSL0lBQWdBaUFERUNnYUlBTUZJQVFMRHd0QnRuOUJBQ0FER3dzdEFRRi9JQUFFUUVHNmZ5RUVJQU1nQVUwRWZ5QUFJQUlnQXhBcUdpQURCU0FFQ3c4TFFiWi9RUUFnQXhzTHBBSUNCSDhCZmlNQVFSQnJJZ2NrQUVHNGZ5RUZBa0FnQkVILy93ZExEUUFnQUVIWTRBRnFLUU1BSVFrZ0FDQURJQVFRK2dJaUJSQWhJZ1lOQUNBQUtBS2M0Z0VoQ0NBQUlBZEJER29nQXlBRElBVnFJQVliSWdNZ0JFRUFJQVVnQmh0cklnWVErUUlpQlJBaERRQWdDVUtBZ0lBUVZpRUVJQVlnQldzaEJpQURJQVZxSVFVQ1FBSkFJQWdFUUNBQVFRQTJBcHppQVNBSEtBSU1JUU1NQVFzQ1FBSkFJQUFwQTlqZ0FVS0FnSUFJV0FSQUlBY29BZ3doQXd3QkN5QUhLQUlNSWdOQkJFb05BUXNnQUVFQU5nS2M0Z0VNQWdzZ0FDZ0NDQkQzQWlFSUlBQkJBRFlDbk9JQklBaEJGRWtOQVFzZ0FDQUJJQUlnQlNBR0lBTWdCQkQyQWlFRkRBRUxJQUFnQVNBQ0lBVWdCaUFESUFRUTlRSWhCUXNnQjBFUWFpUUFJQVVMYVFBZ0FFSFE0QUZxSUFFZ0FpQUFLQUxzNFFFUWlBTWlBUkFoQkVBZ0FROExRYmgvSVFJQ1FDQUJEUUFnQUVIczRBRnFLQUlBSWdFRVFFRmdJUUlnQUNnQ21PSUJJQUZIRFFFTFFRQWhBaUFBUWZEZ0FXb29BZ0JGRFFBZ0FFR1E0UUZxRUlZQ0N5QUNDMndCQVg4Q2Z3SkFBa0FnQWtFSFRRMEFJQUVvQUFCQnQ4akM0WDVIRFFBZ0FDQUJLQUFFTmdLWTRnRkJZaUFBUVJCcUlBRWdBaEQ3QWlJREVDRU5BaG9nQUVLQmdJQ0FFRGNEaU9FQklBQWdBU0FEYWlBQ0lBTnJFTVlCREFFTElBQWdBU0FDRU1ZQkMwRUFDd3ZJQXdJSGZ3RitJd0JCRUdzaUNTUUFRYmgvSVFjQ1FDQUVLQUlBSWdoQkJVRUpJQUFvQXV6aEFTSUZHMGtOQUNBREtBSUFJZ1pCQVVFRklBVWJJQVVRbHdFaUJSQWhCRUFnQlNFSERBRUxJQWdnQlVFRGFra05BQ0FBSUFZZ0JSRC9BaUlIRUNFTkFDQUZJQVpxSWdZZ0NDQUZheUlJSUFrUXh3RWlCUkFoQkVBZ0JTRUhEQUVMSUFFZ0Ftb2hDaUFBUVpEaEFXb2hDeUFCSVFJRFFDQUlRWDFxSWdnZ0JVa0VRRUc0ZnlFSERBSUxJQVpCQTJvaEJrRnNJUWNDZndKQUFrQUNRQ0FKS0FJQURnTUJBZ0FGQ3lBQUlBSWdDaUFDYXlBR0lBVVEvZ0lNQWdzZ0FpQUtJQUpySUFZZ0JSRDlBZ3dCQ3lBQ0lBb2dBbXNnQmkwQUFDQUpLQUlJRVB3Q0N5SUhFQ0VOQVNBQUtBTHc0QUVFUUNBTElBSWdCeENGQWdzZ0NDQUZheUVJSUFVZ0Jtb2hCaUFDSUFkcUlRSWdDU2dDQkVVRVFDQUdJQWdnQ1JESEFTSUZJUWNnQlJBaFJRMEJEQUlMQ3lBQUtRUFE0QUVpREVKL1VnUkFRV3doQnlBTUlBSWdBV3VzVWcwQkN5QURJQUFvQXZEZ0FRUi9RV29oQnlBSVFRUkpEUUVnQ3hDRUFpRU1JQVlvQUFBZ0RLZEhEUUVnQ0VGOGFpRUlJQVpCQkdvRklBWUxOZ0lBSUFRZ0NEWUNBQ0FDSUFGcklRY0xJQWxCRUdva0FDQUhDekFBSUFBUXlRRUNmMEVBUVFBUUlRMEFHaUFCUlNBQ1JYSkZCRUJCWWlBQUlBRWdBaENBQXhBaERRRWFDMEVBQ3dzNUFDQUJCRUFnQUNBQUtBTEU0QUVnQVNnQ0JDQUJLQUlJYWtjMkFwemlBUXNnQUJESkFVRUFFQ0VnQVVWeVJRUkFJQUFnQVJDWUF3c0xMd0FDZjBHNGZ5QUJRUWhKRFFBYVFYSWdBQ2dBQkNJQVFYZExEUUFhUWJoL0lBQkJDR29pQUNBQUlBRkxHd3NMM2dJQkIzOGpBRUVRYXlJSEpBQWdCUVIvSUFVb0FnUWhDaUFGS0FJSUJVRUFDeUVMQWtBQ1FDQUFLQUxzNFFFaUNSQnBJQVJMQkVBZ0FTRUlEQUVMSUFFaENBTkFBa0FnQXlnQUFFRndjVUhRMUxUQ0FVWUVRQ0FESUFRUWhBTWlCaEFoRFFFZ0F5QUdhaUVESUFRZ0Jtc2lCQ0FKRUdsUERRSWdCeUFFTmdJSUlBY2dBellDREF3REN5QUhJQVEyQWdnZ0J5QUROZ0lNQWtBZ0JRUkFJQUFnQlJDREEwRUFJUVpCQUJBaFJRMEJEQVVMSUFBZ0NpQUxFSUlESWdZUUlRMEVDeUFBSUFnUWh3TkJBQ0FBSUFnZ0FpQUhRUXhxSUFkQkNHb1FnUU1pQmlJRGEwRUFJQU1RSVJ0QkNrWWdESEVFUUVHNGZ5RUdEQVFMSUFZUUlRMERJQVlnQ0dvaENDQUhLQUlJSWdRZ0FDZ0M3T0VCSWdrUWFVa05BaUFDSUFacklRSkJBU0VNSUFjb0Fnd2hBd3dCQ3dzZ0J5QUVOZ0lJSUFjZ0F6WUNEQXdCQzBHNGZ5RUdJQVFOQUNBSUlBRnJJUVlMSUFkQkVHb2tBQ0FHQ3pNQUFrQUNRQUpBSUFBb0FxRGlBVUVCYWc0REFnQUJBQXNnQUJES0FVRUFEd3NnQUVFQU5nS2c0Z0VMSUFBb0FwVGlBUXRHQVFKL0lBRWdBQ2dDdU9BQklnSkhCRUFnQUNBQ05nTEU0QUVnQUNBQk5nSzQ0QUVnQUNnQ3ZPQUJJUU1nQUNBQk5nSzg0QUVnQUNBQklBTWdBbXRxTmdMQTRBRUxDN0VFQWdSL0FuNGdBRUlBTndNZ0lBQkNBRGNER0NBQVFnQTNBeEFnQUVJQU53TUlJQUJDQURjREFDQURFR2tpQkNBQ1N3UkFJQVFQQ3lBQlJRUkFRWDhQQ3dKQUFrQUNRQUpBQWtBQ1FBSi9JQU5CQVVZRVFDQUJJQUpCQVJDWEFRd0JDeUFCS0FBQUlnWkJxT3ErYVVjTkFTQUJJQUlnQXhDWEFRc2lBeUFDU3cwRklBQWdBellDR0VGeUlRTWdBU0FFYWlJRlFYOXFMUUFBSWdKQkNIRU5CU0FDUVNCeElnWkZCRUJCY0NFRElBVXRBQUFpQlVHbkFVc05CaUFGUVFkeHJVSUJJQVZCQTNaQkNtcXRoaUlJUWdPSWZpQUlmQ0VKSUFSQkFXb2hCQXNnQWtFR2RpRUZJQUpCQW5ZaEIwRUFJUU1nQWtFRGNVRi9hZzREQVFJREJBdEJkaUVESUFaQmNIRkIwTlMwd2dGSERRUkJDQ0VESUFKQkNFa05CQ0FBUWdBM0F3QWdBRUlBTndNZ0lBQkNBRGNER0NBQVFnQTNBeEFnQUVJQU53TUlJQUVvQUFRaEFTQUFRUUUyQWhRZ0FDQUJyVGNEQUVFQUR3c2dBU0FFYWkwQUFDRURJQVJCQVdvaEJBd0NDeUFCSUFScUx3QUFJUU1nQkVFQ2FpRUVEQUVMSUFFZ0JHb29BQUFoQXlBRVFRUnFJUVFMSUFkQkFYRWhBZ0orQWtBQ1FBSkFBa0FnQlVGL2FnNERBUUlEQUF0Q2Z5QUdSUTBER2lBQklBUnFNUUFBREFNTElBRWdCR292QUFDdFFvQUNmQXdDQ3lBQklBUnFLQUFBclF3QkN5QUJJQVJxS1FBQUN5RUlJQUFnQWpZQ0lDQUFJQU0yQWh3Z0FDQUlOd01BUVFBaEF5QUFRUUEyQWhRZ0FDQUlJQWtnQmhzaUNEY0RDQ0FBSUFoQ2dJQUlJQWhDZ0lBSVZCcytBaEFMSUFNTFhRRURmd0pBSUFCRkRRQWdBQ2dDaU9JQkRRQWdBRUg4NFFGcUtBSUFJUUVnQUVINDRRRnFLQUlBSVFJZ0FDZ0M5T0VCSVFNZ0FCREtBU0FBS0FLbzRnRWdBeUFDSUFFUVpDQUFRUUEyQXFqaUFTQUFJQU1nQWlBQkVHUUxDNmtCQVFGL0l3QkJJR3NpQVNRQUlBQkJnWUNBd0FBMkFyVGlBU0FBUVFBMkFvamlBU0FBUVFBMkF1emhBU0FBUWdBM0E1RGlBU0FBUVFBMkF0emlBU0FBUWdBM0FzemlBU0FBUVFBMkFyemlBU0FBUVFBMkFzVGdBU0FBUWdBM0FwemlBU0FBUWFUaUFXcENBRGNDQUNBQVFhemlBV3BCQURZQ0FDQUJRUkJxRU9BQklBRWdBU2tER0RjRENDQUJJQUVwQXhBM0F3QWdBQ0FCRU44Qk5nS000Z0VnQVVFZ2FpUUFDemtCQW45Qm1PTUpRUUJCQUJDSEFpSUFCSDhnQUVFQU5nTDg0UUVnQUVFQU5nTDQ0UUVnQUVFQU5nTDA0UUVnQUJDS0F5QUFCU0FCQ3dzOEFRRi9JQUFnQXlBRUlBVVF6d0VpQlJBaEJFQWdCUThMUWJoL0lRWWdCU0FFU1FSL0lBRWdBaUFESUFWcUlBUWdCV3NnQUJETEFRVWdCZ3NMUEFFQmZ5QUFJQU1nQkNBRkVNNEJJZ1VRSVFSQUlBVVBDMEc0ZnlFR0lBVWdCRWtFZnlBQklBSWdBeUFGYWlBRUlBVnJJQUFRekFFRklBWUxDejRBSUFKRkJFQkJ1bjhQQ3lBRVJRUkFRV3dQQ3lBQ0lBUVFsQU1FUUNBQUlBRWdBaUFESUFRZ0JSQ05BdzhMSUFBZ0FTQUNJQU1nQkNBRkVJd0RDd2NBSUFBUkNRQUxTd0VCZnlNQVFSQnJJZ1VrQUNBRlFRaHFJQVFvQWdBUU5BSi9JQVV0QUFrRVFDQUFJQUVnQWlBRElBUVF6QUVNQVFzZ0FDQUJJQUlnQXlBRUVNc0JDeUVFSUFWQkVHb2tBQ0FFQ3p3QkFYOGdBQ0FESUFRZ0JSRFBBU0lGRUNFRVFDQUZEd3RCdUg4aEJpQUZJQVJKQkg4Z0FTQUNJQU1nQldvZ0JDQUZheUFBRU0wQkJTQUdDd3YvQXdFRGZ5TUFRU0JySWdVa0FDQUZRUWhxSUFJZ0F4QkZJZ0lRSVVVRVFDQUZJQVFvQWdBUU5DQUVRUVJxSVFJZ0JTMEFBaUVEQWtBZ0JVRUlhaEFqSUFBZ0FXb2lCMEY5YWlJR0lBQk5jZzBBQTBBZ0FDQUNJQVVvQWdnZ0JTZ0NEQ0FERUNsQkFuUnFJZ1F2QVFBN0FBQWdCVUVJYWlBRUxRQUNFQ1lnQUNBRUxRQURhaUlFSUFJZ0JTZ0NDQ0FGS0FJTUlBTVFLVUVDZEdvaUFDOEJBRHNBQUNBRlFRaHFJQUF0QUFJUUppQUVJQUF0QUFOcUlRQWdCVUVJYWhBakRRRWdBQ0FHU1EwQUN3c0NRQ0FGUVFocUVDTWdBQ0FIUVg1cUlnUkxjZzBBQTBBZ0FDQUNJQVVvQWdnZ0JTZ0NEQ0FERUNsQkFuUnFJZ1l2QVFBN0FBQWdCVUVJYWlBR0xRQUNFQ1lnQUNBR0xRQURhaUVBSUFWQkNHb1FJdzBCSUFBZ0JFME5BQXNMSUFBZ0JFMEVRQU5BSUFBZ0FpQUZLQUlJSUFVb0Fnd2dBeEFwUVFKMGFpSUdMd0VBT3dBQUlBVkJDR29nQmkwQUFoQW1JQUFnQmkwQUEyb2lBQ0FFVFEwQUN3c0NRQ0FBSUFkUERRQWdBQ0FDSUFVb0FnZ2dCU2dDRENBREVDa2lBMEVDZEdvaUFDMEFBRG9BQUNBQUxRQURRUUZHQkVBZ0JVRUlhaUFBTFFBQ0VDWU1BUXNnQlNnQ0RFRWZTdzBBSUFWQkNHb2dBaUFEUVFKMGFpMEFBaEFtSUFVb0FneEJJVWtOQUNBRlFTQTJBZ3dMSUFGQmJDQUZLQUlNSUFVb0FoQWdCU2dDRkJCTEd5RUNDeUFGUVNCcUpBQWdBZ3RMQVFGL0l3QkJFR3NpQlNRQUlBVkJDR29nQkNnQ0FCQTBBbjhnQlMwQUNRUkFJQUFnQVNBQ0lBTWdCQkNTQXd3QkN5QUFJQUVnQWlBRElBUVF6UUVMSVFRZ0JVRVFhaVFBSUFRTFhRRUJmMEVQSVFJZ0FTQUFTUVJBSUFGQkJIUWdBRzRoQWdzZ0FFRUlkaUlCSUFKQkdHd2lBRUhNcUFGcUtBSUFiQ0FBUWNpb0FXb29BZ0JxSWdKQkEzWWdBbW9nQUVIQXFBRnFLQUlBSUFCQnhLZ0JhaWdDQUNBQmJHcEpDOHdDQVFSL0l3QkJRR29pQ1NRQUlBa2dBeWdDTURZQ01DQUpJQU1wQWlnM0F5Z2dDU0FES1FJZ053TWdJQWtnQXlrQ0dEY0RHQ0FKSUFNcEFoQTNBeEFnQ1NBREtRSUlOd01JSUFrZ0F5a0NBRGNEQUFKQUlBUkJBa2dOQUNBSklBUkJBblJxS0FJQUlRUWdDVUU4YWlBSUVDOGdDVUVCT2dBL0lBa2dBam9BUGlBRVJRMEFRUUFoQXlBSktBSThJUW9EUUNBQUlBTkJBblJxSUFvMkFRQWdBMEVCYWlJRElBUkhEUUFMQ3lBR0JFQkJBQ0VFQTBBZ0NTQUZJQVJCQVhScUlnb3RBQUVpQzBFQ2RHb2lEQ2dDQUNFRElBbEJQR29nQ2kwQUFFRUlkQ0FJYWtILy93TnhFQzhnQ1VFQ09nQS9JQWtnQnlBTGF5SUtJQUpxT2dBK0lBTkJBU0FCSUFwcmRHb2hDaUFKS0FJOElRc0RRQ0FBSUFOQkFuUnFJQXMyQVFBZ0EwRUJhaUlESUFwSkRRQUxJQXdnQ2pZQ0FDQUVRUUZxSWdRZ0JrY05BQXNMSUFsQlFHc2tBQXZkQWdFSmZ5TUFRZEFBYXlJSkpBQWdDVUZBYXlBRktBSXdOZ0lBSUFrZ0JTa0NLRGNET0NBSklBVXBBaUEzQXpBZ0NTQUZLUUlZTndNb0lBa2dCU2tDRURjRElDQUpJQVVwQWdBM0F4QWdDU0FGS1FJSU53TVlJQU1FUUNBSElBWnJJUThnQnlBQmF5RVFBMEJCQVNBQklBY2dBaUFMUVFGMGFpSUdMUUFCSWd4cklnaHJJZ3AwSVEwZ0JpMEFBQ0VPSUFsQkVHb2dERUVDZEdvaURDZ0NBQ0VHQWtBZ0NpQVBUd1JBSUFBZ0JrRUNkR29nQ2lBSUlBVWdDRUUwYkdvZ0NDQVFhaUlJUVFFZ0NFRUJTaHNpQ0NBQ0lBUWdDRUVDZEdvb0FnQWlDRUVCZEdvZ0F5QUlheUFISUE0UWxRTWdCaUFOYWlFSURBRUxJQWxCREdvZ0RoQXZJQWxCQVRvQUR5QUpJQWc2QUE0Z0JpQUdJQTFxSWdoUERRQWdDU2dDRENFS0EwQWdBQ0FHUVFKMGFpQUtOZ0VBSUFaQkFXb2lCaUFJUncwQUN3c2dEQ0FJTmdJQUlBdEJBV29pQ3lBRFJ3MEFDd3NnQ1VIUUFHb2tBQXMrQVFOL0lBQUVRQ0FBS0FJQUlBQkJ2TkFCYWlnQ0FDSUJJQUJCd05BQmFpZ0NBQ0lDSUFCQnhOQUJhaWdDQUNJREVHUWdBQ0FCSUFJZ0F4QmtDd3ZNQVFFQmZ5QUFJQUVvQXJUUUFUWUNtT0lCSUFBZ0FTZ0NCQ0lDTmdMQTRBRWdBQ0FDTmdLODRBRWdBQ0FDSUFFb0FnaHFJZ0kyQXJqZ0FTQUFJQUkyQXNUZ0FTQUJLQUs0MEFFRVFDQUFRb0dBZ0lBUU53T0k0UUVnQUNBQlFhVFFBR28yQWd3Z0FDQUJRWlFnYWpZQ0NDQUFJQUZCbkRCcU5nSUVJQUFnQVVFTWFqWUNBQ0FBUWF6UUFXb2dBVUdvMEFGcUtBSUFOZ0lBSUFCQnNOQUJhaUFCUWF6UUFXb29BZ0EyQWdBZ0FFRzAwQUZxSUFGQnNOQUJhaWdDQURZQ0FBOExJQUJDQURjRGlPRUJDNkpJQVM1L0l3QkI0QUJySWhJa0FDQUFLQUtFQVNFR0lBQW9BZ1FoQnlBQUtBS0lBU0VGSUFBb0Fnd2hDQ0FTSUFBb0FoZzJBbHdnQUNnQ1BDRWJJQUJCUUdzb0FnQWhIQ0FBUVN4cUlpWWdBeUFFUVFJUVdTQURJQWNnQ0dvZ0EwWnFJZzBnQXlBRWFpSU1RWGhxSWk1SkJFQWdCVUgvSHlBRlFmOGZTUnNoTHlBTVFXQnFJVEJCQTBFRUlBWkJBMFliSWkxQmYyb2hKd05BQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFBb0FnUWlCU0FBS0FJWUlnUnFJQTFMRFFBZ0RTQURheUVkSUFBb0FvUUJJUVlnQkNBTklBVnJJZ2RKQkVBRFFDQUFJQVFnQldvZ0RDQUdRUUVRUVNBRWFpSUVJQWRKRFFBTEN5QWRSU0VoSUFBZ0J6WUNHQUpBQWtBQ1FBSkFBa0FnQmtGOWFnNEZBQUVDQXdNQkMwRUFJUWxCQUNBTklBQW9BZ1FpR1dzaUNFRi9JQUFvQW5oQmYycDBRWDl6SWlScklnUWdCQ0FJU3hzaEZpQUFLQUlnSUEwZ0FDZ0NmRUVERUI1QkFuUnFJZ29vQWdBaEJTQUlJQUFvQWhBZ0FDZ0NGQ0FJSUFBb0FuUVFKeUlFYXlFWUlBUkJBU0FFR3lFVlFRTkJCQ0FkR3lFZUlBQW9BaWdpSHlBSUlDUnhRUU4wYWlJTFFRUnFJUlFnQUNnQ2lBRWlCRUgvSHlBRVFmOGZTUnNoRGlBTlFRTnFJUThnQ0VFSmFpRVJJQWdnQUNnQ0RDSVRheUVnSUJNZ0dXb2hHaUFBS0FJSUloQWdFMm9oRnlBQUtBS0FBU0VpSUNjaEJpQWhJUVFEUUFKQUFuOENmeUFFUVFOR0JFQWdBaWdDQUVGL2Fnd0JDeUFDSUFSQkFuUnFLQUlBQ3lJSFFYOXFJaU1nSUVrRVFDQU5RUU1RSHlBTklBZHJRUU1RSDBjTkFpQVBJQThnQjJzZ0RCQWREQUVMSUNNZ0dFOE5BU0FUSUFnZ0Iyc2lCMEYvYzJwQkEwa05BU0FOUVFNUUh5QUhJQkJxSWdkQkF4QWZSdzBCSUE4Z0IwRURhaUFNSUJjZ0doQWdDMEVEYWlJSElBWk5EUUFnR3lBSlFRTjBhaUlHSUFjMkFnUWdCaUFFSUNGck5nSUFJQWxCQVdvaENTQUhJQTVMRFFVZ0J5SUdJQTFxSUF4R0RRVUxJQVJCQVdvaUJDQWVTUTBBQ3dKQUlBWkJBa3NOQUVFQ0lRWWdHU0FBS0FJY0lBQW9BaVFnRWtIY0FHb2dEUkJBSWdRZ0ZVa05BQ0FJSUFScklnZEIvLzhQU3cwQUFuOGdCQ0FUVHdSQUlBMGdCQ0FaYWlBTUVCME1BUXNnRFNBRUlCQnFJQXdnRnlBYUVDQUxJZ1JCQTBrTkFDQWJJQVEyQWdRZ0d5QUhRUUpxTmdJQUlBUWdEazBFUUVFQklRa2dCQ0VHSUFRZ0RXb2dERWNOQVF0QkFTRUpJQUFnQ0VFQmFqWUNHQXdFQ3lBS0lBZzJBZ0FDUUNBRklCVkpEUUFnQ0VFQ2FpRVlRWDhnSW5SQmYzTWhDa0VBSVE1QkFDRVBBMEFDZnlBT0lBOGdEaUFQU1JzaUJDQUZhaUFUVHdSQUlBUWdEV29nQlNBWmFpQUVhaUFNRUIwZ0JHb2hCQ0FaREFFTElCQWdHU0FFSUExcUlBVWdFR29nQkdvZ0RDQVhJQm9RSUNBRWFpSUVJQVZxSUJOSkd3c2hDQ0FFSUFaTEJFQWdHeUFKUVFOMGFpSUdJQVEyQWdRZ0JpQVlJQVZyTmdJQUlBUWdCV29nRVNBRUlCRWdCV3RMR3lFUklBbEJBV29oQ1NBRVFZQWdTdzBDSUFRaEJpQUVJQTFxSUF4R0RRSUxJQjhnQlNBa2NVRURkR29oQndKQUFrQWdCU0FJYWlBRWFpMEFBQ0FFSUExcUxRQUFTUVJBSUFzZ0JUWUNBQ0FGSUJaTERRRWdFa0ZBYXlFTERBUUxJQlFnQlRZQ0FDQUZJQlpMQkVBZ0J5RVVJQVFoRHd3Q0N5QVNRVUJySVJRTUF3c2dCQ0VPSUFkQkJHb2lDeUVIQ3lBS1JRMEJJQXBCZjJvaENpQUhLQUlBSWdVZ0ZVOE5BQXNMSUJSQkFEWUNBQ0FMUVFBMkFnQWdBQ0FSUVhocU5nSVlEQU1MUVFBaENVRUFJQTBnQUNnQ0JDSVRheUlJUVg4Z0FDZ0NlRUYvYW5SQmYzTWlGV3NpQkNBRUlBaExHeUVhSUFBb0FpQWdEU0FBS0FKOFFRUVFIa0VDZEdvaURpZ0NBQ0VGSUFnZ0FDZ0NFQ0FBS0FJVUlBZ2dBQ2dDZEJBbklnUnJJUW9nQkVFQklBUWJJUmRCQTBFRUlCMGJJUmdnQUNnQ0tDSWVJQWdnRlhGQkEzUnFJaFJCQkdvaEdTQUFLQUtJQVNJRVFmOGZJQVJCL3g5Skd5RWZJQTFCQkdvaER5QUlRUWxxSVJFZ0NDQUFLQUlNSWd0cklTQWdDeUFUYWlFa0lBQW9BZ2dpRUNBTGFpRVdJQUFvQW9BQklTSWdKeUVHSUNFaEJBTkFBa0FDZndKL0lBUkJBMFlFUUNBQ0tBSUFRWDlxREFFTElBSWdCRUVDZEdvb0FnQUxJZ2RCZjJvaUl5QWdTUVJBSUExQkJCQWZJQTBnQjJ0QkJCQWZSdzBDSUE4Z0R5QUhheUFNRUIwTUFRc2dJeUFLVHcwQklBc2dDQ0FIYXlJSFFYOXpha0VEU1EwQklBMUJCQkFmSUFjZ0VHb2lCMEVFRUI5SERRRWdEeUFIUVFScUlBd2dGaUFrRUNBTFFRUnFJZ2NnQmswTkFDQWJJQWxCQTNScUlnWWdCellDQkNBR0lBUWdJV3MyQWdBZ0NVRUJhaUVKSUFjZ0gwc05CQ0FISWdZZ0RXb2dERVlOQkFzZ0JFRUJhaUlFSUJoSkRRQUxJQTRnQ0RZQ0FBSkFJQVVnRjBrTkFDQUlRUUpxSVJoQmZ5QWlkRUYvY3lFS1FRQWhEa0VBSVE4RFFBSi9JQTRnRHlBT0lBOUpHeUlFSUFWcUlBdFBCRUFnQkNBTmFpQUZJQk5xSUFScUlBd1FIU0FFYWlFRUlCTU1BUXNnRUNBVElBUWdEV29nQlNBUWFpQUVhaUFNSUJZZ0pCQWdJQVJxSWdRZ0JXb2dDMGtiQ3lFSUlBUWdCa3NFUUNBYklBbEJBM1JxSWdZZ0JEWUNCQ0FHSUJnZ0JXczJBZ0FnQkNBRmFpQVJJQVFnRVNBRmEwc2JJUkVnQ1VFQmFpRUpJQVJCZ0NCTERRSWdCQ0VHSUFRZ0RXb2dERVlOQWdzZ0hpQUZJQlZ4UVFOMGFpRUhBa0FDUUNBRklBaHFJQVJxTFFBQUlBUWdEV290QUFCSkJFQWdGQ0FGTmdJQUlBVWdHa3NOQVNBU1FVQnJJUlFNQkFzZ0dTQUZOZ0lBSUFVZ0drc0VRQ0FISVJrZ0JDRVBEQUlMSUJKQlFHc2hHUXdEQ3lBRUlRNGdCMEVFYWlJVUlRY0xJQXBGRFFFZ0NrRi9haUVLSUFjb0FnQWlCU0FYVHcwQUN3c2dHVUVBTmdJQUlCUkJBRFlDQUNBQUlCRkJlR28yQWhnTUFndEJBQ0VKUVFBZ0RTQUFLQUlFSWhOcklnaEJmeUFBS0FKNFFYOXFkRUYvY3lJVmF5SUVJQVFnQ0VzYklSb2dBQ2dDSUNBTklBQW9BbnhCQlJBZVFRSjBhaUlPS0FJQUlRVWdDQ0FBS0FJUUlBQW9BaFFnQ0NBQUtBSjBFQ2NpQkdzaENpQUVRUUVnQkJzaEYwRURRUVFnSFJzaEdDQUFLQUlvSWg0Z0NDQVZjVUVEZEdvaUdVRUVhaUVVSUFBb0FvZ0JJZ1JCL3g4Z0JFSC9IMGtiSVI4Z0RVRUVhaUVQSUFoQkNXb2hFU0FJSUFBb0Fnd2lDMnNoSUNBTElCTnFJU1FnQUNnQ0NDSVFJQXRxSVJZZ0FDZ0NnQUVoSWlBbklRWWdJU0VFQTBBQ1FBSi9BbjhnQkVFRFJnUkFJQUlvQWdCQmYyb01BUXNnQWlBRVFRSjBhaWdDQUFzaUIwRi9haUlqSUNCSkJFQWdEVUVFRUI4Z0RTQUhhMEVFRUI5SERRSWdEeUFQSUFkcklBd1FIUXdCQ3lBaklBcFBEUUVnQ3lBSUlBZHJJZ2RCZjNOcVFRTkpEUUVnRFVFRUVCOGdCeUFRYWlJSFFRUVFIMGNOQVNBUElBZEJCR29nRENBV0lDUVFJQXRCQkdvaUJ5QUdUUTBBSUJzZ0NVRURkR29pQmlBSE5nSUVJQVlnQkNBaGF6WUNBQ0FKUVFGcUlRa2dCeUFmU3cwRElBY2lCaUFOYWlBTVJnMERDeUFFUVFGcUlnUWdHRWtOQUFzZ0RpQUlOZ0lBQWtBZ0JTQVhTUTBBSUFoQkFtb2hHRUYvSUNKMFFYOXpJUXBCQUNFT1FRQWhEd05BQW44Z0RpQVBJQTRnRDBrYklnUWdCV29nQzA4RVFDQUVJQTFxSUFVZ0Uyb2dCR29nREJBZElBUnFJUVFnRXd3QkN5QVFJQk1nQkNBTmFpQUZJQkJxSUFScUlBd2dGaUFrRUNBZ0JHb2lCQ0FGYWlBTFNSc0xJUWdnQkNBR1N3UkFJQnNnQ1VFRGRHb2lCaUFFTmdJRUlBWWdHQ0FGYXpZQ0FDQUVJQVZxSUJFZ0JDQVJJQVZyU3hzaEVTQUpRUUZxSVFrZ0JFR0FJRXNOQWlBRUlRWWdCQ0FOYWlBTVJnMENDeUFlSUFVZ0ZYRkJBM1JxSVFjQ1FBSkFJQVVnQ0dvZ0JHb3RBQUFnQkNBTmFpMEFBRWtFUUNBWklBVTJBZ0FnQlNBYVN3MEJJQkpCUUdzaEdRd0VDeUFVSUFVMkFnQWdCU0FhU3dSQUlBY2hGQ0FFSVE4TUFnc2dFa0ZBYXlFVURBTUxJQVFoRGlBSFFRUnFJaGtoQndzZ0NrVU5BU0FLUVg5cUlRb2dCeWdDQUNJRklCZFBEUUFMQ3lBVVFRQTJBZ0FnR1VFQU5nSUFJQUFnRVVGNGFqWUNHQXdCQzBFQUlRbEJBQ0FOSUFBb0FnUWlFMnNpQ0VGL0lBQW9BbmhCZjJwMFFYOXpJaFZySWdRZ0JDQUlTeHNoR2lBQUtBSWdJQTBnQUNnQ2ZFRUdFQjVCQW5ScUlnNG9BZ0FoQlNBSUlBQW9BaEFnQUNnQ0ZDQUlJQUFvQW5RUUp5SUVheUVLSUFSQkFTQUVHeUVYUVFOQkJDQWRHeUVZSUFBb0FpZ2lIaUFJSUJWeFFRTjBhaUlaUVFScUlSUWdBQ2dDaUFFaUJFSC9IeUFFUWY4ZlNSc2hIeUFOUVFScUlROGdDRUVKYWlFUklBZ2dBQ2dDRENJTGF5RWdJQXNnRTJvaEpDQUFLQUlJSWhBZ0Myb2hGaUFBS0FLQUFTRWlJQ2NoQmlBaElRUURRQUpBQW44Q2Z5QUVRUU5HQkVBZ0FpZ0NBRUYvYWd3QkN5QUNJQVJCQW5ScUtBSUFDeUlIUVg5cUlpTWdJRWtFUUNBTlFRUVFIeUFOSUFkclFRUVFIMGNOQWlBUElBOGdCMnNnREJBZERBRUxJQ01nQ2s4TkFTQUxJQWdnQjJzaUIwRi9jMnBCQTBrTkFTQU5RUVFRSHlBSElCQnFJZ2RCQkJBZlJ3MEJJQThnQjBFRWFpQU1JQllnSkJBZ0MwRUVhaUlISUFaTkRRQWdHeUFKUVFOMGFpSUdJQWMyQWdRZ0JpQUVJQ0ZyTmdJQUlBbEJBV29oQ1NBSElCOUxEUUlnQnlJR0lBMXFJQXhHRFFJTElBUkJBV29pQkNBWVNRMEFDeUFPSUFnMkFnQUNRQ0FGSUJkSkRRQWdDRUVDYWlFWVFYOGdJblJCZjNNaENrRUFJUTVCQUNFUEEwQUNmeUFPSUE4Z0RpQVBTUnNpQkNBRmFpQUxUd1JBSUFRZ0RXb2dCU0FUYWlBRWFpQU1FQjBnQkdvaEJDQVREQUVMSUJBZ0V5QUVJQTFxSUFVZ0VHb2dCR29nRENBV0lDUVFJQ0FFYWlJRUlBVnFJQXRKR3dzaENDQUVJQVpMQkVBZ0d5QUpRUU4wYWlJR0lBUTJBZ1FnQmlBWUlBVnJOZ0lBSUFRZ0JXb2dFU0FFSUJFZ0JXdExHeUVSSUFsQkFXb2hDU0FFUVlBZ1N3MENJQVFoQmlBRUlBMXFJQXhHRFFJTElCNGdCU0FWY1VFRGRHb2hCd0pBQWtBZ0JTQUlhaUFFYWkwQUFDQUVJQTFxTFFBQVNRUkFJQmtnQlRZQ0FDQUZJQnBMRFFFZ0VrRkFheUVaREFRTElCUWdCVFlDQUNBRklCcExCRUFnQnlFVUlBUWhEd3dDQ3lBU1FVQnJJUlFNQXdzZ0JDRU9JQWRCQkdvaUdTRUhDeUFLUlEwQklBcEJmMm9oQ2lBSEtBSUFJZ1VnRjA4TkFBc0xJQlJCQURZQ0FDQVpRUUEyQWdBZ0FDQVJRWGhxTmdJWUN5QUpSUTBBSUJ3Z0FpZ0NBRFlDRUNBY0lBSW9BZ1EyQWhRZ0FpZ0NDQ0VFSUJ3Z0hUWUNEQ0FjUVFBMkFnZ2dIQ0FFTmdJWUlCd2dBeUFkSUNaQkFoQllJZ1UyQWdBZ0d5QUpRWDlxUVFOMGFpSUVLQUlFSWdjZ0wwc0VRQ0FFS0FJQUlRb01Bd3RCQVNFRVFRQWdKa0VDRUMwaEJnTkFJQndnQkVFY2JHcEJnSUNBZ0FRMkFnQWdCRUVCYWlJRUlDMUhEUUFMSUFVZ0Jtb2hDa0VBSVFnZ0xTRUhBMEFnR3lBSVFRTjBhaUlFS0FJRUlRWWdFa0ZBYXlBQ0lBUW9BZ0FpRHlBaEVEOGdCeUFHVFFSQUlBOUJBV29RSkNJT1FRaDBRWUFnYWlFUkEwQWdCMEY5YWlFRUFuOGdBQ2dDWkVFQlJnUkFJQVFRS3lBUmFnd0JDeUFBS0FKZ0lBQW9BamdnRGtFQ2RHb29BZ0FRSzJzZ0FDZ0NYR29nQkJBOFFRSjBJZ1JCa0tRQmFpZ0NBQ0FPYWtFSWRHb2dBQ2dDTkNBRWFpZ0NBQkFyYTBFemFnc2hCU0FjSUFkQkhHeHFJZ1FnSFRZQ0RDQUVJQTgyQWdRZ0JDQUhOZ0lJSUFRZ0JTQUthallDQUNBRUlCSXBBMEEzQWhBZ0JDQVNLQUpJTmdJWUlBZEJBV29pQnlBR1RRMEFDd3NnQ0VFQmFpSUlJQWxIRFFBTFFRRWhEd0pBSUFkQmYyb2lCRVVFUUVFQUlRUU1BUXNEUUVFQklRVWdIQ0FQUVg5cVFSeHNhaUlIS0FJSVJRUkFJQWNvQWd4QkFXb2hCUXNnRFNBUGFpSUxRWDlxUVFFZ0prRUNFRklnQnlnQ0FHb2dCU0FtUVFJUUxXb2dCVUYvYWlBbVFRSVFMV3NpQmlBY0lBOUJIR3hxSWhvb0FnQWlHVXdFUUNBYUlBVTJBZ3dnR2tJQU53SUVJQm9nQmpZQ0FDQWFJQWNvQWhnMkFoZ2dHaUFIS1FJUU53SVFJQVloR1FzQ1FDQUxJQzVMRFFBZ0JDQVBSZ1JBSUE4aEJBd0RDMEVBSVIwZ0dpZ0NDQ0lIUlFSQUlCb29BZ3doSFF0QkFDQW1RUUlRTFNFeUlBQW9BZ1FpQmlBQUtBSVlJZ1ZxSUF0TERRQWdBQ2dDaEFFaENDQUZJQXNnQm1zaUNVa0VRQU5BSUFBZ0JTQUdhaUFNSUFoQkFSQkJJQVZxSWdVZ0NVa05BQXNMSUFkQkFFY2hJU0FhUVJCcUlTUWdBQ0FKTmdJWUFrQUNRQUpBQWtBQ1FDQUlRWDFxRGdVQUFRSURBd0VMUVFBaEVFRUFJQXNnQUNnQ0JDSU9heUlKUVg4Z0FDZ0NlRUYvYW5SQmYzTWlJbXNpQlNBRklBbExHeUVqSUFBb0FpQWdDeUFBS0FKOFFRTVFIa0VDZEdvaUpTZ0NBQ0VHSUFrZ0FDZ0NFQ0FBS0FJVUlBa2dBQ2dDZEJBbklnVnJJU2dnQlVFQklBVWJJUjVCQkVFRElBY2JJU2tnQUNnQ0tDSXFJQWtnSW5GQkEzUnFJaFpCQkdvaEV5QUFLQUtJQVNJRlFmOGZJQVZCL3g5Skd5RVZJQXRCQTJvaEVTQUpRUWxxSVJRZ0NTQUFLQUlNSWhkcklTc2dEaUFYYWlFZklBQW9BZ2dpR0NBWGFpRWdJQUFvQW9BQklTd2dKeUVISUNFaEJRTkFBa0FDZndKL0lBVkJBMFlFUUNBa0tBSUFRWDlxREFFTElCb2dCVUVDZEdvb0FoQUxJZ3BCZjJvaUNDQXJTUVJBSUF0QkF4QWZJQXNnQ210QkF4QWZSdzBDSUJFZ0VTQUtheUFNRUIwTUFRc2dDQ0FvVHcwQklCY2dDU0FLYXlJSVFYOXpha0VEU1EwQklBdEJBeEFmSUFnZ0dHb2lDRUVERUI5SERRRWdFU0FJUVFOcUlBd2dJQ0FmRUNBTFFRTnFJZ2dnQjAwTkFDQWJJQkJCQTNScUlnY2dDRFlDQkNBSElBVWdJV3MyQWdBZ0VFRUJhaUVRSUFnZ0ZVc05CU0FJSWdjZ0Myb2dERVlOQlFzZ0JVRUJhaUlGSUNsSkRRQUxBa0FnQjBFQ1N3MEFRUUloQnlBT0lBQW9BaHdnQUNnQ0pDQVNRZHdBYWlBTEVFQWlCU0FlU1EwQUlBa2dCV3NpQ0VILy93OUxEUUFDZnlBRklCZFBCRUFnQ3lBRklBNXFJQXdRSFF3QkN5QUxJQVVnR0dvZ0RDQWdJQjhRSUFzaUJVRURTUTBBSUJzZ0JUWUNCQ0FiSUFoQkFtbzJBZ0FnQlNBVlRRUkFRUUVoRUNBRklRY2dCU0FMYWlBTVJ3MEJDMEVCSVJBZ0FDQUpRUUZxTmdJWURBUUxJQ1VnQ1RZQ0FBSkFJQVlnSGtrTkFDQUpRUUpxSVNWQmZ5QXNkRUYvY3lFVlFRQWhDVUVBSVFnRFFBSi9JQWtnQ0NBSklBaEpHeUlGSUFacUlCZFBCRUFnQlNBTGFpQUdJQTVxSUFWcUlBd1FIU0FGYWlFRklBNE1BUXNnR0NBT0lBVWdDMm9nQmlBWWFpQUZhaUFNSUNBZ0h4QWdJQVZxSWdVZ0Jtb2dGMGtiQ3lFUklBVWdCMHNFUUNBYklCQkJBM1JxSWdjZ0JUWUNCQ0FISUNVZ0JtczJBZ0FnQlNBR2FpQVVJQVVnRkNBR2Ewc2JJUlFnRUVFQmFpRVFJQVZCZ0NCTERRSWdCU0VISUFVZ0Myb2dERVlOQWdzZ0tpQUdJQ0p4UVFOMGFpRUtBa0FDUUNBR0lCRnFJQVZxTFFBQUlBVWdDMm90QUFCSkJFQWdGaUFHTmdJQUlBWWdJMHNOQVNBU1FVQnJJUllNQkFzZ0V5QUdOZ0lBSUFZZ0kwc0VRQ0FLSVJNZ0JTRUlEQUlMSUJKQlFHc2hFd3dEQ3lBRklRa2dDa0VFYWlJV0lRb0xJQlZGRFFFZ0ZVRi9haUVWSUFvb0FnQWlCaUFlVHcwQUN3c2dFMEVBTmdJQUlCWkJBRFlDQUNBQUlCUkJlR28yQWhnTUF3dEJBQ0VRUVFBZ0N5QUFLQUlFSWhOcklnbEJmeUFBS0FKNFFYOXFkRUYvY3lJZWF5SUZJQVVnQ1VzYklSOGdBQ2dDSUNBTElBQW9BbnhCQkJBZVFRSjBhaUlWS0FJQUlRWWdDU0FBS0FJUUlBQW9BaFFnQ1NBQUtBSjBFQ2NpQldzaEpTQUZRUUVnQlJzaElFRUVRUU1nQnhzaEtDQUFLQUlvSWlrZ0NTQWVjVUVEZEdvaUYwRUVhaUVPSUFBb0FvZ0JJZ1ZCL3g4Z0JVSC9IMGtiSVNvZ0MwRUVhaUVSSUFsQkNXb2hGQ0FKSUFBb0Fnd2lGbXNoS3lBVElCWnFJU0lnQUNnQ0NDSVlJQlpxSVNNZ0FDZ0NnQUVoTENBbklRY2dJU0VGQTBBQ1FBSi9BbjhnQlVFRFJnUkFJQ1FvQWdCQmYyb01BUXNnR2lBRlFRSjBhaWdDRUFzaUNrRi9haUlJSUN0SkJFQWdDMEVFRUI4Z0N5QUthMEVFRUI5SERRSWdFU0FSSUFwcklBd1FIUXdCQ3lBSUlDVlBEUUVnRmlBSklBcHJJZ2hCZjNOcVFRTkpEUUVnQzBFRUVCOGdDQ0FZYWlJSVFRUVFIMGNOQVNBUklBaEJCR29nRENBaklDSVFJQXRCQkdvaUNDQUhUUTBBSUJzZ0VFRURkR29pQnlBSU5nSUVJQWNnQlNBaGF6WUNBQ0FRUVFGcUlSQWdDQ0FxU3cwRUlBZ2lCeUFMYWlBTVJnMEVDeUFGUVFGcUlnVWdLRWtOQUFzZ0ZTQUpOZ0lBQWtBZ0JpQWdTUTBBSUFsQkFtb2hKVUYvSUN4MFFYOXpJUlZCQUNFSlFRQWhDQU5BQW44Z0NTQUlJQWtnQ0VrYklnVWdCbW9nRms4RVFDQUZJQXRxSUFZZ0Uyb2dCV29nREJBZElBVnFJUVVnRXd3QkN5QVlJQk1nQlNBTGFpQUdJQmhxSUFWcUlBd2dJeUFpRUNBZ0JXb2lCU0FHYWlBV1NSc0xJUkVnQlNBSFN3UkFJQnNnRUVFRGRHb2lCeUFGTmdJRUlBY2dKU0FHYXpZQ0FDQUZJQVpxSUJRZ0JTQVVJQVpyU3hzaEZDQVFRUUZxSVJBZ0JVR0FJRXNOQWlBRklRY2dCU0FMYWlBTVJnMENDeUFwSUFZZ0huRkJBM1JxSVFvQ1FBSkFJQVlnRVdvZ0JXb3RBQUFnQlNBTGFpMEFBRWtFUUNBWElBWTJBZ0FnQmlBZlN3MEJJQkpCUUdzaEZ3d0VDeUFPSUFZMkFnQWdCaUFmU3dSQUlBb2hEaUFGSVFnTUFnc2dFa0ZBYXlFT0RBTUxJQVVoQ1NBS1FRUnFJaGNoQ2dzZ0ZVVU5BU0FWUVg5cUlSVWdDaWdDQUNJR0lDQlBEUUFMQ3lBT1FRQTJBZ0FnRjBFQU5nSUFJQUFnRkVGNGFqWUNHQXdDQzBFQUlSQkJBQ0FMSUFBb0FnUWlFMnNpQ1VGL0lBQW9BbmhCZjJwMFFYOXpJaDVySWdVZ0JTQUpTeHNoSHlBQUtBSWdJQXNnQUNnQ2ZFRUZFQjVCQW5ScUloVW9BZ0FoQmlBSklBQW9BaEFnQUNnQ0ZDQUpJQUFvQW5RUUp5SUZheUVsSUFWQkFTQUZHeUVnUVFSQkF5QUhHeUVvSUFBb0FpZ2lLU0FKSUI1eFFRTjBhaUlYUVFScUlRNGdBQ2dDaUFFaUJVSC9IeUFGUWY4ZlNSc2hLaUFMUVFScUlSRWdDVUVKYWlFVUlBa2dBQ2dDRENJV2F5RXJJQk1nRm1vaElpQUFLQUlJSWhnZ0Ztb2hJeUFBS0FLQUFTRXNJQ2NoQnlBaElRVURRQUpBQW44Q2Z5QUZRUU5HQkVBZ0pDZ0NBRUYvYWd3QkN5QWFJQVZCQW5ScUtBSVFDeUlLUVg5cUlnZ2dLMGtFUUNBTFFRUVFIeUFMSUFwclFRUVFIMGNOQWlBUklCRWdDbXNnREJBZERBRUxJQWdnSlU4TkFTQVdJQWtnQ21zaUNFRi9jMnBCQTBrTkFTQUxRUVFRSHlBSUlCaHFJZ2hCQkJBZlJ3MEJJQkVnQ0VFRWFpQU1JQ01nSWhBZ0MwRUVhaUlJSUFkTkRRQWdHeUFRUVFOMGFpSUhJQWcyQWdRZ0J5QUZJQ0ZyTmdJQUlCQkJBV29oRUNBSUlDcExEUU1nQ0NJSElBdHFJQXhHRFFNTElBVkJBV29pQlNBb1NRMEFDeUFWSUFrMkFnQUNRQ0FHSUNCSkRRQWdDVUVDYWlFbFFYOGdMSFJCZjNNaEZVRUFJUWxCQUNFSUEwQUNmeUFKSUFnZ0NTQUlTUnNpQlNBR2FpQVdUd1JBSUFVZ0Myb2dCaUFUYWlBRmFpQU1FQjBnQldvaEJTQVREQUVMSUJnZ0V5QUZJQXRxSUFZZ0dHb2dCV29nRENBaklDSVFJQ0FGYWlJRklBWnFJQlpKR3dzaEVTQUZJQWRMQkVBZ0d5QVFRUU4wYWlJSElBVTJBZ1FnQnlBbElBWnJOZ0lBSUFVZ0Jtb2dGQ0FGSUJRZ0JtdExHeUVVSUJCQkFXb2hFQ0FGUVlBZ1N3MENJQVVoQnlBRklBdHFJQXhHRFFJTElDa2dCaUFlY1VFRGRHb2hDZ0pBQWtBZ0JpQVJhaUFGYWkwQUFDQUZJQXRxTFFBQVNRUkFJQmNnQmpZQ0FDQUdJQjlMRFFFZ0VrRkFheUVYREFRTElBNGdCallDQUNBR0lCOUxCRUFnQ2lFT0lBVWhDQXdDQ3lBU1FVQnJJUTRNQXdzZ0JTRUpJQXBCQkdvaUZ5RUtDeUFWUlEwQklCVkJmMm9oRlNBS0tBSUFJZ1lnSUU4TkFBc0xJQTVCQURZQ0FDQVhRUUEyQWdBZ0FDQVVRWGhxTmdJWURBRUxRUUFoRUVFQUlBc2dBQ2dDQkNJVGF5SUpRWDhnQUNnQ2VFRi9hblJCZjNNaUhtc2lCU0FGSUFsTEd5RWZJQUFvQWlBZ0N5QUFLQUo4UVFZUUhrRUNkR29pRlNnQ0FDRUdJQWtnQUNnQ0VDQUFLQUlVSUFrZ0FDZ0NkQkFuSWdWcklTVWdCVUVCSUFVYklTQkJCRUVESUFjYklTZ2dBQ2dDS0NJcElBa2dIbkZCQTNScUloZEJCR29oRGlBQUtBS0lBU0lGUWY4ZklBVkIveDlKR3lFcUlBdEJCR29oRVNBSlFRbHFJUlFnQ1NBQUtBSU1JaFpySVNzZ0V5QVdhaUVpSUFBb0FnZ2lHQ0FXYWlFaklBQW9Bb0FCSVN3Z0p5RUhJQ0VoQlFOQUFrQUNmd0ovSUFWQkEwWUVRQ0FrS0FJQVFYOXFEQUVMSUJvZ0JVRUNkR29vQWhBTElncEJmMm9pQ0NBclNRUkFJQXRCQkJBZklBc2dDbXRCQkJBZlJ3MENJQkVnRVNBS2F5QU1FQjBNQVFzZ0NDQWxUdzBCSUJZZ0NTQUtheUlJUVg5emFrRURTUTBCSUF0QkJCQWZJQWdnR0dvaUNFRUVFQjlIRFFFZ0VTQUlRUVJxSUF3Z0l5QWlFQ0FMUVFScUlnZ2dCMDBOQUNBYklCQkJBM1JxSWdjZ0NEWUNCQ0FISUFVZ0lXczJBZ0FnRUVFQmFpRVFJQWdnS2tzTkFpQUlJZ2NnQzJvZ0RFWU5BZ3NnQlVFQmFpSUZJQ2hKRFFBTElCVWdDVFlDQUFKQUlBWWdJRWtOQUNBSlFRSnFJU1ZCZnlBc2RFRi9jeUVWUVFBaENVRUFJUWdEUUFKL0lBa2dDQ0FKSUFoSkd5SUZJQVpxSUJaUEJFQWdCU0FMYWlBR0lCTnFJQVZxSUF3UUhTQUZhaUVGSUJNTUFRc2dHQ0FUSUFVZ0Myb2dCaUFZYWlBRmFpQU1JQ01nSWhBZ0lBVnFJZ1VnQm1vZ0Zra2JDeUVSSUFVZ0Iwc0VRQ0FiSUJCQkEzUnFJZ2NnQlRZQ0JDQUhJQ1VnQm1zMkFnQWdCU0FHYWlBVUlBVWdGQ0FHYTBzYklSUWdFRUVCYWlFUUlBVkJnQ0JMRFFJZ0JTRUhJQVVnQzJvZ0RFWU5BZ3NnS1NBR0lCNXhRUU4wYWlFS0FrQUNRQ0FHSUJGcUlBVnFMUUFBSUFVZ0Myb3RBQUJKQkVBZ0Z5QUdOZ0lBSUFZZ0gwc05BU0FTUVVCcklSY01CQXNnRGlBR05nSUFJQVlnSDBzRVFDQUtJUTRnQlNFSURBSUxJQkpCUUdzaERnd0RDeUFGSVFrZ0NrRUVhaUlYSVFvTElCVkZEUUVnRlVGL2FpRVZJQW9vQWdBaUJpQWdUdzBBQ3dzZ0RrRUFOZ0lBSUJkQkFEWUNBQ0FBSUJSQmVHbzJBaGdMSUJCRkRRQWdHeUFRUVg5cVFRTjBhaUlGS0FJRUlnY2dMMHNnQnlBUGFrR0FJRTl5RFFRZ0dTQXlhaUVSUVFBaEJ3TkFJQkpCUUdzZ0pDQWJJQWRCQTNScUlnWW9BZ0FpQ0NBaEVEOGdMU0VPQW44Z0J3UkFJQVpCZkdvb0FnQkJBV29oRGdzZ0JpZ0NCQ0lGSUE1UEN3UkFJQWhCQVdvUUpDSUpRUWgwUVlBZ2FpRVpBMEFnQlVGOWFpRUtJQVVnRDJvaEJnSi9JQUFvQW1SQkFVWUVRQ0FLRUNzZ0dXb01BUXNnQUNnQ1lDQUFLQUk0SUFsQkFuUnFLQUlBRUN0cklBQW9BbHhxSUFvUVBFRUNkQ0lLUVpDa0FXb29BZ0FnQ1dwQkNIUnFJQUFvQWpRZ0Ntb29BZ0FRSzJ0Qk0yb0xJQkZxSVFvQ1FBSkFJQVlnQkUwRVFDQUtJQndnQmtFY2JHb29BZ0JJRFFFTUFnc0RRQ0FjSUFSQkFXb2lCRUVjYkdwQmdJQ0FnQVEyQWdBZ0JDQUdTUTBBQ3dzZ0hDQUdRUnhzYWlJR0lCMDJBZ3dnQmlBSU5nSUVJQVlnQlRZQ0NDQUdJQW8yQWdBZ0JpQVNLUU5BTndJUUlBWWdFaWdDU0RZQ0dBc2dCVUYvYWlJRklBNVBEUUFMQ3lBSFFRRnFJZ2NnRUVjTkFBc0xJQTlCQVdvaUR5QUVUUTBBQ3dzZ0hDQUVRUnhzYWlJRktBSU1JUjBnQlNnQ0JDRUtJQVVvQWdBaE1TQUZLQUlJSVFjZ0VpQUZLQUlZTmdKWUlCSWdCU2tDRURjRFVDQVNJQVVwQWdnM0F5Z2dFaUFGS1FJUU53TXdJQklnQlNnQ0dEWUNPQ0FTSUFVcEFnQTNBeUJCQUNBRUlCSkJJR29RUG1zaUJTQUZJQVJMR3lFRURBTUxJQTFCQVdvaERRd0hDeUFGS0FJQUlRcEJBQ0VFSUE4Z0dpZ0NDQVIvSUFRRklCb29BZ3dMYXlJRVFZQWdUUTBCQ3lBY0lCMDJBaWdnSENBSE5nSWtJQndnQ2pZQ0lDQWNJREUyQWh3Z0hDQVNLQUpZTmdJMElCd2dFaWtEVURjQ0xBd0JDeUFjSUFSQkFXb2lDVUVjYkdvaUJTQWROZ0lNSUFVZ0J6WUNDQ0FGSUFvMkFnUWdCU0F4TmdJQUlBVWdFaWtEVURjQ0VDQUZJQklvQWxnMkFoZ2dDU0VkSUFRTkFRdEJBU0VkUVFFaENRd0JDd05BSUJJZ0hDQUVRUnhzYWlJRklnaEJHR29vQWdBMkFoZ2dFaUFGS1FJUU53TVFJQklnQlNrQ0NEY0RDQ0FTSUFVcEFnQTNBd0FnRWhBK0lRY2dIQ0FkUVg5cUloMUJIR3hxSWdZZ0NDZ0NHRFlDR0NBR0lBVXBBaEEzQWhBZ0JpQUZLUUlJTndJSUlBWWdCU2tDQURjQ0FDQUVJQWRMSVFWQkFDQUVJQWRySWdZZ0JpQUVTeHNoQkNBRkRRQUxJQjBnQ1VzTkFRc0RRQ0FjSUIxQkhHeHFJZ1FvQWd3aEJnSi9JQU1nQm1vZ0JDZ0NDQ0lQUlEwQUdnSkFBa0FnQkNnQ0JDSUlRUU5QQkVBZ0FpQUNLUUlBTndJRUlBaEJmbW9oQkF3QkN3SkFBa0FDUUFKQUlBZ2dCa1ZxSWdVT0JBVUJBUUFCQ3lBQ0tBSUFRWDlxSVFRTUFRc2dBaUFGUVFKMGFpZ0NBQ0VFSUFWQkFra05BUXNnQWlBQ0tBSUVOZ0lJQ3lBQ0lBSW9BZ0EyQWdRTElBSWdCRFlDQUFzZ0ppQUdJQU1nQ0NBUEVGY2dEMEY5YWlFT0lBRW9BZ3doQkFKQUFrQWdBeUFHYWlJRklEQk5CRUFnQkNBREVCd2dBU2dDRENFRUlBWkJFRTBFUUNBQklBUWdCbW8yQWd3TUF3c2dCRUVRYWlBRFFSQnFJZ2NRSENBRVFTQnFJQU5CSUdvUUhDQUdRVEZJRFFFZ0JDQUdhaUVLSUFSQk1Hb2hCQU5BSUFRZ0IwRWdhaUlGRUJ3Z0JFRVFhaUFIUVRCcUVCd2dCU0VISUFSQklHb2lCQ0FLU1EwQUN3d0JDeUFFSUFNZ0JTQXdFQ0lMSUFFZ0FTZ0NEQ0FHYWpZQ0RDQUdRWUNBQkVrTkFDQUJRUUUyQWlRZ0FTQUJLQUlFSUFFb0FnQnJRUU4xTmdJb0N5QUJLQUlFSWdRZ0NFRUJhallDQUNBRUlBWTdBUVFnRGtHQWdBUlBCRUFnQVVFQ05nSWtJQUVnQkNBQktBSUFhMEVEZFRZQ0tBc2dCQ0FPT3dFR0lBRWdCRUVJYWpZQ0JDQUdJQTlxSUFOcUlnTUxJUTBnSFVFQmFpSWRJQWxORFFBTEN5QW1RUUlRVVFzZ0RTQXVTUTBBQ3dzZ0VrSGdBR29rQUNBTUlBTnJDK05JQVM5L0l3QkI0QUJySWhFa0FDQUFLQUtFQVNFR0lBQW9BZ1FoQ0NBQUtBS0lBU0VGSUFBb0Fnd2hCeUFSSUFBb0FoZzJBbHdnQUNnQ1BDRWNJQUJCUUdzb0FnQWhHeUFBUVN4cUlpY2dBeUFFUVFBUVdTQURJQWNnQ0dvZ0EwWnFJZzBnQXlBRWFpSU1RWGhxSWk5SkJFQWdCVUgvSHlBRlFmOGZTUnNoTUNBTVFXQnFJVEZCQTBFRUlBWkJBMFliSWk1QmYyb2hLQU5BQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFBb0FnUWlCU0FBS0FJWUlnUnFJQTFMRFFBZ0RTQURheUVrSUFBb0FvUUJJUVlnQkNBTklBVnJJZ2hKQkVBRFFDQUFJQVFnQldvZ0RDQUdRUUVRUVNBRWFpSUVJQWhKRFFBTEN5QWtSU0VaSUFBZ0NEWUNHQUpBQWtBQ1FBSkFBa0FnQmtGOWFnNEZBQUVDQXdNQkMwRUFJUWxCQUNBTklBQW9BZ1FpQzJzaUIwRi9JQUFvQW5oQmYycDBRWDl6SWhWcklnUWdCQ0FIU3hzaEl5QUFLQUlnSUEwZ0FDZ0NmRUVERUI1QkFuUnFJZzRvQWdBaEJTQUhJQUFvQWhBZ0FDZ0NGQ0FISUFBb0FuUVFKeUlFYXlFVElBUkJBU0FFR3lFWFFRTkJCQ0FrR3lFZElBQW9BaWdpSHlBSElCVnhRUU4wYWlJS1FRUnFJUmdnQUNnQ2lBRWlCRUgvSHlBRVFmOGZTUnNoRmlBTlFRTnFJUThnQjBFSmFpRVNJQWNnQUNnQ0RDSWVheUVnSUFzZ0htb2hGQ0FBS0FJSUloQWdIbW9oR2lBQUtBS0FBU0VoSUNnaEJpQVpJUVFEUUFKQUFuOENmeUFFUVFOR0JFQWdBaWdDQUVGL2Fnd0JDeUFDSUFSQkFuUnFLQUlBQ3lJSVFYOXFJaUlnSUVrRVFDQU5RUU1RSHlBTklBaHJRUU1RSDBjTkFpQVBJQThnQ0dzZ0RCQWREQUVMSUNJZ0UwOE5BU0FlSUFjZ0NHc2lDRUYvYzJwQkEwa05BU0FOUVFNUUh5QUlJQkJxSWdoQkF4QWZSdzBCSUE4Z0NFRURhaUFNSUJvZ0ZCQWdDMEVEYWlJSUlBWk5EUUFnSENBSlFRTjBhaUlHSUFnMkFnUWdCaUFFSUJsck5nSUFJQWxCQVdvaENTQUlJQlpMRFFVZ0NDSUdJQTFxSUF4R0RRVUxJQVJCQVdvaUJDQWRTUTBBQ3dKQUlBWkJBa3NOQUVFQ0lRWWdDeUFBS0FJY0lBQW9BaVFnRVVIY0FHb2dEUkJBSWdRZ0Ywa05BQ0FISUFScklnaEIvLzhQU3cwQUFuOGdCQ0FlVHdSQUlBMGdCQ0FMYWlBTUVCME1BUXNnRFNBRUlCQnFJQXdnR2lBVUVDQUxJZ1JCQTBrTkFDQWNJQVEyQWdRZ0hDQUlRUUpxTmdJQUlBUWdGazBFUUVFQklRa2dCQ0VHSUFRZ0RXb2dERWNOQVF0QkFTRUpJQUFnQjBFQmFqWUNHQXdFQ3lBT0lBYzJBZ0FDUUNBRklCZEpEUUFnQjBFQ2FpRVRRWDhnSVhSQmYzTWhEa0VBSVE5QkFDRUhBMEFDZnlBUElBY2dEeUFIU1JzaUJDQUZhaUFlVHdSQUlBUWdEV29nQlNBTGFpQUVhaUFNRUIwZ0JHb2hCQ0FMREFFTElCQWdDeUFFSUExcUlBVWdFR29nQkdvZ0RDQWFJQlFRSUNBRWFpSUVJQVZxSUI1Skd3c2hGaUFFSUFaTEJFQWdIQ0FKUVFOMGFpSUdJQVEyQWdRZ0JpQVRJQVZyTmdJQUlBUWdCV29nRWlBRUlCSWdCV3RMR3lFU0lBbEJBV29oQ1NBRVFZQWdTdzBDSUFRaEJpQUVJQTFxSUF4R0RRSUxJQjhnQlNBVmNVRURkR29oQ0FKQUFrQWdCU0FXYWlBRWFpMEFBQ0FFSUExcUxRQUFTUVJBSUFvZ0JUWUNBQ0FGSUNOTERRRWdFVUZBYXlFS0RBUUxJQmdnQlRZQ0FDQUZJQ05MQkVBZ0NDRVlJQVFoQnd3Q0N5QVJRVUJySVJnTUF3c2dCQ0VQSUFoQkJHb2lDaUVJQ3lBT1JRMEJJQTVCZjJvaERpQUlLQUlBSWdVZ0YwOE5BQXNMSUJoQkFEWUNBQ0FLUVFBMkFnQWdBQ0FTUVhocU5nSVlEQU1MUVFBaENVRUFJQTBnQUNnQ0JDSVlheUlIUVg4Z0FDZ0NlRUYvYW5SQmYzTWlGMnNpQkNBRUlBZExHeUVVSUFBb0FpQWdEU0FBS0FKOFFRUVFIa0VDZEdvaUZpZ0NBQ0VGSUFjZ0FDZ0NFQ0FBS0FJVUlBY2dBQ2dDZEJBbklnUnJJUTRnQkVFQklBUWJJUnBCQTBFRUlDUWJJUk1nQUNnQ0tDSWRJQWNnRjNGQkEzUnFJaDVCQkdvaEN5QUFLQUtJQVNJRVFmOGZJQVJCL3g5Skd5RWZJQTFCQkdvaER5QUhRUWxxSVJJZ0J5QUFLQUlNSWdwcklTQWdDaUFZYWlFVklBQW9BZ2dpRUNBS2FpRWpJQUFvQW9BQklTRWdLQ0VHSUJraEJBTkFBa0FDZndKL0lBUkJBMFlFUUNBQ0tBSUFRWDlxREFFTElBSWdCRUVDZEdvb0FnQUxJZ2hCZjJvaUlpQWdTUVJBSUExQkJCQWZJQTBnQ0d0QkJCQWZSdzBDSUE4Z0R5QUlheUFNRUIwTUFRc2dJaUFPVHcwQklBb2dCeUFJYXlJSVFYOXpha0VEU1EwQklBMUJCQkFmSUFnZ0VHb2lDRUVFRUI5SERRRWdEeUFJUVFScUlBd2dJeUFWRUNBTFFRUnFJZ2dnQmswTkFDQWNJQWxCQTNScUlnWWdDRFlDQkNBR0lBUWdHV3MyQWdBZ0NVRUJhaUVKSUFnZ0gwc05CQ0FJSWdZZ0RXb2dERVlOQkFzZ0JFRUJhaUlFSUJOSkRRQUxJQllnQnpZQ0FBSkFJQVVnR2trTkFDQUhRUUpxSVJOQmZ5QWhkRUYvY3lFT1FRQWhEMEVBSVFjRFFBSi9JQThnQnlBUElBZEpHeUlFSUFWcUlBcFBCRUFnQkNBTmFpQUZJQmhxSUFScUlBd1FIU0FFYWlFRUlCZ01BUXNnRUNBWUlBUWdEV29nQlNBUWFpQUVhaUFNSUNNZ0ZSQWdJQVJxSWdRZ0JXb2dDa2tiQ3lFV0lBUWdCa3NFUUNBY0lBbEJBM1JxSWdZZ0JEWUNCQ0FHSUJNZ0JXczJBZ0FnQkNBRmFpQVNJQVFnRWlBRmEwc2JJUklnQ1VFQmFpRUpJQVJCZ0NCTERRSWdCQ0VHSUFRZ0RXb2dERVlOQWdzZ0hTQUZJQmR4UVFOMGFpRUlBa0FDUUNBRklCWnFJQVJxTFFBQUlBUWdEV290QUFCSkJFQWdIaUFGTmdJQUlBVWdGRXNOQVNBUlFVQnJJUjRNQkFzZ0N5QUZOZ0lBSUFVZ0ZFc0VRQ0FJSVFzZ0JDRUhEQUlMSUJGQlFHc2hDd3dEQ3lBRUlROGdDRUVFYWlJZUlRZ0xJQTVGRFFFZ0RrRi9haUVPSUFnb0FnQWlCU0FhVHcwQUN3c2dDMEVBTmdJQUlCNUJBRFlDQUNBQUlCSkJlR28yQWhnTUFndEJBQ0VKUVFBZ0RTQUFLQUlFSWhocklnZEJmeUFBS0FKNFFYOXFkRUYvY3lJWGF5SUVJQVFnQjBzYklSUWdBQ2dDSUNBTklBQW9BbnhCQlJBZVFRSjBhaUlXS0FJQUlRVWdCeUFBS0FJUUlBQW9BaFFnQnlBQUtBSjBFQ2NpQkdzaERpQUVRUUVnQkJzaEdrRURRUVFnSkJzaEV5QUFLQUlvSWgwZ0J5QVhjVUVEZEdvaUhrRUVhaUVMSUFBb0FvZ0JJZ1JCL3g4Z0JFSC9IMGtiSVI4Z0RVRUVhaUVQSUFkQkNXb2hFaUFISUFBb0Fnd2lDbXNoSUNBS0lCaHFJUlVnQUNnQ0NDSVFJQXBxSVNNZ0FDZ0NnQUVoSVNBb0lRWWdHU0VFQTBBQ1FBSi9BbjhnQkVFRFJnUkFJQUlvQWdCQmYyb01BUXNnQWlBRVFRSjBhaWdDQUFzaUNFRi9haUlpSUNCSkJFQWdEVUVFRUI4Z0RTQUlhMEVFRUI5SERRSWdEeUFQSUFocklBd1FIUXdCQ3lBaUlBNVBEUUVnQ2lBSElBaHJJZ2hCZjNOcVFRTkpEUUVnRFVFRUVCOGdDQ0FRYWlJSVFRUVFIMGNOQVNBUElBaEJCR29nRENBaklCVVFJQXRCQkdvaUNDQUdUUTBBSUJ3Z0NVRURkR29pQmlBSU5nSUVJQVlnQkNBWmF6WUNBQ0FKUVFGcUlRa2dDQ0FmU3cwRElBZ2lCaUFOYWlBTVJnMERDeUFFUVFGcUlnUWdFMGtOQUFzZ0ZpQUhOZ0lBQWtBZ0JTQWFTUTBBSUFkQkFtb2hFMEYvSUNGMFFYOXpJUTVCQUNFUFFRQWhCd05BQW44Z0R5QUhJQThnQjBrYklnUWdCV29nQ2s4RVFDQUVJQTFxSUFVZ0dHb2dCR29nREJBZElBUnFJUVFnR0F3QkN5QVFJQmdnQkNBTmFpQUZJQkJxSUFScUlBd2dJeUFWRUNBZ0JHb2lCQ0FGYWlBS1NSc0xJUllnQkNBR1N3UkFJQndnQ1VFRGRHb2lCaUFFTmdJRUlBWWdFeUFGYXpZQ0FDQUVJQVZxSUJJZ0JDQVNJQVZyU3hzaEVpQUpRUUZxSVFrZ0JFR0FJRXNOQWlBRUlRWWdCQ0FOYWlBTVJnMENDeUFkSUFVZ0YzRkJBM1JxSVFnQ1FBSkFJQVVnRm1vZ0JHb3RBQUFnQkNBTmFpMEFBRWtFUUNBZUlBVTJBZ0FnQlNBVVN3MEJJQkZCUUdzaEhnd0VDeUFMSUFVMkFnQWdCU0FVU3dSQUlBZ2hDeUFFSVFjTUFnc2dFVUZBYXlFTERBTUxJQVFoRHlBSVFRUnFJaDRoQ0FzZ0RrVU5BU0FPUVg5cUlRNGdDQ2dDQUNJRklCcFBEUUFMQ3lBTFFRQTJBZ0FnSGtFQU5nSUFJQUFnRWtGNGFqWUNHQXdCQzBFQUlRbEJBQ0FOSUFBb0FnUWlHR3NpQjBGL0lBQW9BbmhCZjJwMFFYOXpJaGRySWdRZ0JDQUhTeHNoRkNBQUtBSWdJQTBnQUNnQ2ZFRUdFQjVCQW5ScUloWW9BZ0FoQlNBSElBQW9BaEFnQUNnQ0ZDQUhJQUFvQW5RUUp5SUVheUVPSUFSQkFTQUVHeUVhUVFOQkJDQWtHeUVUSUFBb0FpZ2lIU0FISUJkeFFRTjBhaUllUVFScUlRc2dBQ2dDaUFFaUJFSC9IeUFFUWY4ZlNSc2hIeUFOUVFScUlROGdCMEVKYWlFU0lBY2dBQ2dDRENJS2F5RWdJQW9nR0dvaEZTQUFLQUlJSWhBZ0Ntb2hJeUFBS0FLQUFTRWhJQ2doQmlBWklRUURRQUpBQW44Q2Z5QUVRUU5HQkVBZ0FpZ0NBRUYvYWd3QkN5QUNJQVJCQW5ScUtBSUFDeUlJUVg5cUlpSWdJRWtFUUNBTlFRUVFIeUFOSUFoclFRUVFIMGNOQWlBUElBOGdDR3NnREJBZERBRUxJQ0lnRGs4TkFTQUtJQWNnQ0dzaUNFRi9jMnBCQTBrTkFTQU5RUVFRSHlBSUlCQnFJZ2hCQkJBZlJ3MEJJQThnQ0VFRWFpQU1JQ01nRlJBZ0MwRUVhaUlJSUFaTkRRQWdIQ0FKUVFOMGFpSUdJQWcyQWdRZ0JpQUVJQmxyTmdJQUlBbEJBV29oQ1NBSUlCOUxEUUlnQ0NJR0lBMXFJQXhHRFFJTElBUkJBV29pQkNBVFNRMEFDeUFXSUFjMkFnQUNRQ0FGSUJwSkRRQWdCMEVDYWlFVFFYOGdJWFJCZjNNaERrRUFJUTlCQUNFSEEwQUNmeUFQSUFjZ0R5QUhTUnNpQkNBRmFpQUtUd1JBSUFRZ0RXb2dCU0FZYWlBRWFpQU1FQjBnQkdvaEJDQVlEQUVMSUJBZ0dDQUVJQTFxSUFVZ0VHb2dCR29nRENBaklCVVFJQ0FFYWlJRUlBVnFJQXBKR3dzaEZpQUVJQVpMQkVBZ0hDQUpRUU4wYWlJR0lBUTJBZ1FnQmlBVElBVnJOZ0lBSUFRZ0JXb2dFaUFFSUJJZ0JXdExHeUVTSUFsQkFXb2hDU0FFUVlBZ1N3MENJQVFoQmlBRUlBMXFJQXhHRFFJTElCMGdCU0FYY1VFRGRHb2hDQUpBQWtBZ0JTQVdhaUFFYWkwQUFDQUVJQTFxTFFBQVNRUkFJQjRnQlRZQ0FDQUZJQlJMRFFFZ0VVRkFheUVlREFRTElBc2dCVFlDQUNBRklCUkxCRUFnQ0NFTElBUWhCd3dDQ3lBUlFVQnJJUXNNQXdzZ0JDRVBJQWhCQkdvaUhpRUlDeUFPUlEwQklBNUJmMm9oRGlBSUtBSUFJZ1VnR2s4TkFBc0xJQXRCQURZQ0FDQWVRUUEyQWdBZ0FDQVNRWGhxTmdJWUN5QUpSUTBBSUJzZ0FpZ0NBRFlDRUNBYklBSW9BZ1EyQWhRZ0FpZ0NDQ0VFSUJzZ0pEWUNEQ0FiUVFBMkFnZ2dHeUFFTmdJWUlCc2dBeUFrSUNkQkFCQllJZ1UyQWdBZ0hDQUpRWDlxUVFOMGFpSUVLQUlFSWdnZ01Fc0VRQ0FFS0FJQUlRY01Bd3RCQVNFRVFRQWdKMEVBRUMwaEJnTkFJQnNnQkVFY2JHcEJnSUNBZ0FRMkFnQWdCRUVCYWlJRUlDNUhEUUFMSUFVZ0Jtb2hGa0VBSVFzZ0xpRUlBMEFnSENBTFFRTjBhaUlFS0FJRUlRY2dFVUZBYXlBQ0lBUW9BZ0FpRHlBWkVEOGdDQ0FIVFFSQUlBOUJBV29RSkNJR1FRbDBRYk8wZjJwQk15QUdRUk5MR3lFWUlBWkJDSFJCZ0NCcUlRNERRQ0FJUVgxcUlRUUNmeUFBS0FKa1FRRkdCRUFnQkJBdUlBNXFEQUVMSUFBb0FtQWdHR29nQUNnQ09DQUdRUUowYWlnQ0FCQXVheUFBS0FKY2FpQUVFRHhCQW5RaUJFR1FwQUZxS0FJQUlBWnFRUWgwYWlBQUtBSTBJQVJxS0FJQUVDNXJDeUVGSUJzZ0NFRWNiR29pQkNBa05nSU1JQVFnRHpZQ0JDQUVJQWcyQWdnZ0JDQUZJQlpxTmdJQUlBUWdFU2tEUURjQ0VDQUVJQkVvQWtnMkFoZ2dDRUVCYWlJSUlBZE5EUUFMQ3lBTFFRRnFJZ3NnQ1VjTkFBdEJBU0VQQWtBZ0NFRi9haUlFUlFSQVFRQWhCQXdCQ3dOQVFRRWhCU0FiSUE5QmYycEJIR3hxSWdnb0FnaEZCRUFnQ0NnQ0RFRUJhaUVGQ3lBTklBOXFJZ3BCZjJwQkFTQW5RUUFRVWlBSUtBSUFhaUFGSUNkQkFCQXRhaUFGUVg5cUlDZEJBQkF0YXlJR0lCc2dEMEVjYkdvaUdpZ0NBQ0lXVEFSQUlCb2dCVFlDRENBYVFnQTNBZ1FnR2lBR05nSUFJQm9nQ0NnQ0dEWUNHQ0FhSUFncEFoQTNBaEFnQmlFV0N5QUtJQzlMQkg4Z0QwRUJhZ1VnQkNBUFJnUkFJQThoQkF3REN3SkFJQnNnRDBFQmFpSWVRUnhzYWlnQ0FDQVdRWUFCYWt3TkFFRUFJU1FnR2lnQ0NDSUlSUVJBSUJvb0Fnd2hKQXRCQUNBblFRQVFMU0V6SUFBb0FnUWlCaUFBS0FJWUlnVnFJQXBMRFFBZ0FDZ0NoQUVoQnlBRklBb2dCbXNpQ1VrRVFBTkFJQUFnQlNBR2FpQU1JQWRCQVJCQklBVnFJZ1VnQ1VrTkFBc0xJQWhCQUVjaEdDQWFRUkJxSVNNZ0FDQUpOZ0lZQWtBQ1FBSkFBa0FDUUNBSFFYMXFEZ1VBQVFJREF3RUxRUUFoRUVFQUlBb2dBQ2dDQkNJT2F5SUpRWDhnQUNnQ2VFRi9hblJCZjNNaUltc2lCU0FGSUFsTEd5RW1JQUFvQWlBZ0NpQUFLQUo4UVFNUUhrRUNkR29pRkNnQ0FDRUdJQWtnQUNnQ0VDQUFLQUlVSUFrZ0FDZ0NkQkFuSWdWcklTVWdCVUVCSUFVYklSOUJCRUVESUFnYklTa2dBQ2dDS0NJcUlBa2dJbkZCQTNScUloTkJCR29oRWlBQUtBS0lBU0lGUWY4ZklBVkIveDlKR3lFWklBcEJBMm9oQ3lBSlFRbHFJUmNnQ1NBQUtBSU1JaFZySVNzZ0RpQVZhaUVnSUFBb0FnZ2lIU0FWYWlFaElBQW9Bb0FCSVN3Z0tDRUlJQmdoQlFOQUFrQUNmd0ovSUFWQkEwWUVRQ0FqS0FJQVFYOXFEQUVMSUJvZ0JVRUNkR29vQWhBTElnZEJmMm9pTFNBclNRUkFJQXBCQXhBZklBb2dCMnRCQXhBZlJ3MENJQXNnQ3lBSGF5QU1FQjBNQVFzZ0xTQWxUdzBCSUJVZ0NTQUhheUlIUVg5emFrRURTUTBCSUFwQkF4QWZJQWNnSFdvaUIwRURFQjlIRFFFZ0N5QUhRUU5xSUF3Z0lTQWdFQ0FMUVFOcUlnY2dDRTBOQUNBY0lCQkJBM1JxSWdnZ0J6WUNCQ0FJSUFVZ0dHczJBZ0FnRUVFQmFpRVFJQWNnR1VzTkJTQUhJZ2dnQ21vZ0RFWU5CUXNnQlVFQmFpSUZJQ2xKRFFBTEFrQWdDRUVDU3cwQVFRSWhDQ0FPSUFBb0Fod2dBQ2dDSkNBUlFkd0FhaUFLRUVBaUJTQWZTUTBBSUFrZ0JXc2lCMEgvL3c5TERRQUNmeUFGSUJWUEJFQWdDaUFGSUE1cUlBd1FIUXdCQ3lBS0lBVWdIV29nRENBaElDQVFJQXNpQlVFRFNRMEFJQndnQlRZQ0JDQWNJQWRCQW1vMkFnQWdCU0FaVFFSQVFRRWhFQ0FGSVFnZ0JTQUthaUFNUncwQkMwRUJJUkFnQUNBSlFRRnFOZ0lZREFRTElCUWdDVFlDQUFKQUlBWWdIMGtOQUNBSlFRSnFJU1ZCZnlBc2RFRi9jeUVVUVFBaENVRUFJUXNEUUFKL0lBa2dDeUFKSUF0Skd5SUZJQVpxSUJWUEJFQWdCU0FLYWlBR0lBNXFJQVZxSUF3UUhTQUZhaUVGSUE0TUFRc2dIU0FPSUFVZ0Ntb2dCaUFkYWlBRmFpQU1JQ0VnSUJBZ0lBVnFJZ1VnQm1vZ0ZVa2JDeUVaSUFVZ0NFc0VRQ0FjSUJCQkEzUnFJZ2dnQlRZQ0JDQUlJQ1VnQm1zMkFnQWdCU0FHYWlBWElBVWdGeUFHYTBzYklSY2dFRUVCYWlFUUlBVkJnQ0JMRFFJZ0JTRUlJQVVnQ21vZ0RFWU5BZ3NnS2lBR0lDSnhRUU4wYWlFSEFrQUNRQ0FHSUJscUlBVnFMUUFBSUFVZ0Ntb3RBQUJKQkVBZ0V5QUdOZ0lBSUFZZ0prc05BU0FSUVVCcklSTU1CQXNnRWlBR05nSUFJQVlnSmtzRVFDQUhJUklnQlNFTERBSUxJQkZCUUdzaEVnd0RDeUFGSVFrZ0IwRUVhaUlUSVFjTElCUkZEUUVnRkVGL2FpRVVJQWNvQWdBaUJpQWZUdzBBQ3dzZ0VrRUFOZ0lBSUJOQkFEWUNBQ0FBSUJkQmVHbzJBaGdNQXd0QkFDRVFRUUFnQ2lBQUtBSUVJaEpySWdsQmZ5QUFLQUo0UVg5cWRFRi9jeUlmYXlJRklBVWdDVXNiSVNBZ0FDZ0NJQ0FLSUFBb0FueEJCQkFlUVFKMGFpSVpLQUlBSVFZZ0NTQUFLQUlRSUFBb0FoUWdDU0FBS0FKMEVDY2lCV3NoRkNBRlFRRWdCUnNoSVVFRVFRTWdDQnNoSlNBQUtBSW9JaWtnQ1NBZmNVRURkR29pRlVFRWFpRU9JQUFvQW9nQklnVkIveDhnQlVIL0gwa2JJU29nQ2tFRWFpRUxJQWxCQ1dvaEZ5QUpJQUFvQWd3aUUyc2hLeUFTSUJOcUlTSWdBQ2dDQ0NJZElCTnFJU1lnQUNnQ2dBRWhMQ0FvSVFnZ0dDRUZBMEFDUUFKL0FuOGdCVUVEUmdSQUlDTW9BZ0JCZjJvTUFRc2dHaUFGUVFKMGFpZ0NFQXNpQjBGL2FpSXRJQ3RKQkVBZ0NrRUVFQjhnQ2lBSGEwRUVFQjlIRFFJZ0N5QUxJQWRySUF3UUhRd0JDeUF0SUJSUERRRWdFeUFKSUFkcklnZEJmM05xUVFOSkRRRWdDa0VFRUI4Z0J5QWRhaUlIUVFRUUgwY05BU0FMSUFkQkJHb2dEQ0FtSUNJUUlBdEJCR29pQnlBSVRRMEFJQndnRUVFRGRHb2lDQ0FITmdJRUlBZ2dCU0FZYXpZQ0FDQVFRUUZxSVJBZ0J5QXFTdzBFSUFjaUNDQUthaUFNUmcwRUN5QUZRUUZxSWdVZ0pVa05BQXNnR1NBSk5nSUFBa0FnQmlBaFNRMEFJQWxCQW1vaEpVRi9JQ3gwUVg5eklSUkJBQ0VKUVFBaEN3TkFBbjhnQ1NBTElBa2dDMGtiSWdVZ0Jtb2dFMDhFUUNBRklBcHFJQVlnRW1vZ0JXb2dEQkFkSUFWcUlRVWdFZ3dCQ3lBZElCSWdCU0FLYWlBR0lCMXFJQVZxSUF3Z0ppQWlFQ0FnQldvaUJTQUdhaUFUU1JzTElSa2dCU0FJU3dSQUlCd2dFRUVEZEdvaUNDQUZOZ0lFSUFnZ0pTQUdhellDQUNBRklBWnFJQmNnQlNBWElBWnJTeHNoRnlBUVFRRnFJUkFnQlVHQUlFc05BaUFGSVFnZ0JTQUthaUFNUmcwQ0N5QXBJQVlnSDNGQkEzUnFJUWNDUUFKQUlBWWdHV29nQldvdEFBQWdCU0FLYWkwQUFFa0VRQ0FWSUFZMkFnQWdCaUFnU3cwQklCRkJRR3NoRlF3RUN5QU9JQVkyQWdBZ0JpQWdTd1JBSUFjaERpQUZJUXNNQWdzZ0VVRkFheUVPREFNTElBVWhDU0FIUVFScUloVWhCd3NnRkVVTkFTQVVRWDlxSVJRZ0J5Z0NBQ0lHSUNGUERRQUxDeUFPUVFBMkFnQWdGVUVBTmdJQUlBQWdGMEY0YWpZQ0dBd0NDMEVBSVJCQkFDQUtJQUFvQWdRaUVtc2lDVUYvSUFBb0FuaEJmMnAwUVg5ekloOXJJZ1VnQlNBSlN4c2hJQ0FBS0FJZ0lBb2dBQ2dDZkVFRkVCNUJBblJxSWhrb0FnQWhCaUFKSUFBb0FoQWdBQ2dDRkNBSklBQW9BblFRSnlJRmF5RVVJQVZCQVNBRkd5RWhRUVJCQXlBSUd5RWxJQUFvQWlnaUtTQUpJQjl4UVFOMGFpSVZRUVJxSVE0Z0FDZ0NpQUVpQlVIL0h5QUZRZjhmU1JzaEtpQUtRUVJxSVFzZ0NVRUphaUVYSUFrZ0FDZ0NEQ0lUYXlFcklCSWdFMm9oSWlBQUtBSUlJaDBnRTJvaEppQUFLQUtBQVNFc0lDZ2hDQ0FZSVFVRFFBSkFBbjhDZnlBRlFRTkdCRUFnSXlnQ0FFRi9hZ3dCQ3lBYUlBVkJBblJxS0FJUUN5SUhRWDlxSWkwZ0swa0VRQ0FLUVFRUUh5QUtJQWRyUVFRUUgwY05BaUFMSUFzZ0Iyc2dEQkFkREFFTElDMGdGRThOQVNBVElBa2dCMnNpQjBGL2MycEJBMGtOQVNBS1FRUVFIeUFISUIxcUlnZEJCQkFmUncwQklBc2dCMEVFYWlBTUlDWWdJaEFnQzBFRWFpSUhJQWhORFFBZ0hDQVFRUU4wYWlJSUlBYzJBZ1FnQ0NBRklCaHJOZ0lBSUJCQkFXb2hFQ0FISUNwTERRTWdCeUlJSUFwcUlBeEdEUU1MSUFWQkFXb2lCU0FsU1EwQUN5QVpJQWsyQWdBQ1FDQUdJQ0ZKRFFBZ0NVRUNhaUVsUVg4Z0xIUkJmM01oRkVFQUlRbEJBQ0VMQTBBQ2Z5QUpJQXNnQ1NBTFNSc2lCU0FHYWlBVFR3UkFJQVVnQ21vZ0JpQVNhaUFGYWlBTUVCMGdCV29oQlNBU0RBRUxJQjBnRWlBRklBcHFJQVlnSFdvZ0JXb2dEQ0FtSUNJUUlDQUZhaUlGSUFacUlCTkpHd3NoR1NBRklBaExCRUFnSENBUVFRTjBhaUlJSUFVMkFnUWdDQ0FsSUFack5nSUFJQVVnQm1vZ0Z5QUZJQmNnQm10TEd5RVhJQkJCQVdvaEVDQUZRWUFnU3cwQ0lBVWhDQ0FGSUFwcUlBeEdEUUlMSUNrZ0JpQWZjVUVEZEdvaEJ3SkFBa0FnQmlBWmFpQUZhaTBBQUNBRklBcHFMUUFBU1FSQUlCVWdCallDQUNBR0lDQkxEUUVnRVVGQWF5RVZEQVFMSUE0Z0JqWUNBQ0FHSUNCTEJFQWdCeUVPSUFVaEN3d0NDeUFSUVVCcklRNE1Bd3NnQlNFSklBZEJCR29pRlNFSEN5QVVSUTBCSUJSQmYyb2hGQ0FIS0FJQUlnWWdJVThOQUFzTElBNUJBRFlDQUNBVlFRQTJBZ0FnQUNBWFFYaHFOZ0lZREFFTFFRQWhFRUVBSUFvZ0FDZ0NCQ0lTYXlJSlFYOGdBQ2dDZUVGL2FuUkJmM01pSDJzaUJTQUZJQWxMR3lFZ0lBQW9BaUFnQ2lBQUtBSjhRUVlRSGtFQ2RHb2lHU2dDQUNFR0lBa2dBQ2dDRUNBQUtBSVVJQWtnQUNnQ2RCQW5JZ1ZySVJRZ0JVRUJJQVViSVNGQkJFRURJQWdiSVNVZ0FDZ0NLQ0lwSUFrZ0gzRkJBM1JxSWhWQkJHb2hEaUFBS0FLSUFTSUZRZjhmSUFWQi94OUpHeUVxSUFwQkJHb2hDeUFKUVFscUlSY2dDU0FBS0FJTUloTnJJU3NnRWlBVGFpRWlJQUFvQWdnaUhTQVRhaUVtSUFBb0FvQUJJU3dnS0NFSUlCZ2hCUU5BQWtBQ2Z3Si9JQVZCQTBZRVFDQWpLQUlBUVg5cURBRUxJQm9nQlVFQ2RHb29BaEFMSWdkQmYyb2lMU0FyU1FSQUlBcEJCQkFmSUFvZ0IydEJCQkFmUncwQ0lBc2dDeUFIYXlBTUVCME1BUXNnTFNBVVR3MEJJQk1nQ1NBSGF5SUhRWDl6YWtFRFNRMEJJQXBCQkJBZklBY2dIV29pQjBFRUVCOUhEUUVnQ3lBSFFRUnFJQXdnSmlBaUVDQUxRUVJxSWdjZ0NFME5BQ0FjSUJCQkEzUnFJZ2dnQnpZQ0JDQUlJQVVnR0dzMkFnQWdFRUVCYWlFUUlBY2dLa3NOQWlBSElnZ2dDbW9nREVZTkFnc2dCVUVCYWlJRklDVkpEUUFMSUJrZ0NUWUNBQUpBSUFZZ0lVa05BQ0FKUVFKcUlTVkJmeUFzZEVGL2N5RVVRUUFoQ1VFQUlRc0RRQUovSUFrZ0N5QUpJQXRKR3lJRklBWnFJQk5QQkVBZ0JTQUthaUFHSUJKcUlBVnFJQXdRSFNBRmFpRUZJQklNQVFzZ0hTQVNJQVVnQ21vZ0JpQWRhaUFGYWlBTUlDWWdJaEFnSUFWcUlnVWdCbW9nRTBrYkN5RVpJQVVnQ0VzRVFDQWNJQkJCQTNScUlnZ2dCVFlDQkNBSUlDVWdCbXMyQWdBZ0JTQUdhaUFYSUFVZ0Z5QUdhMHNiSVJjZ0VFRUJhaUVRSUFWQmdDQkxEUUlnQlNFSUlBVWdDbW9nREVZTkFnc2dLU0FHSUI5eFFRTjBhaUVIQWtBQ1FDQUdJQmxxSUFWcUxRQUFJQVVnQ21vdEFBQkpCRUFnRlNBR05nSUFJQVlnSUVzTkFTQVJRVUJySVJVTUJBc2dEaUFHTmdJQUlBWWdJRXNFUUNBSElRNGdCU0VMREFJTElCRkJRR3NoRGd3REN5QUZJUWtnQjBFRWFpSVZJUWNMSUJSRkRRRWdGRUYvYWlFVUlBY29BZ0FpQmlBaFR3MEFDd3NnRGtFQU5nSUFJQlZCQURZQ0FDQUFJQmRCZUdvMkFoZ0xJQkJGRFFBZ0hDQVFRWDlxUVFOMGFpSUZLQUlFSWdnZ01Fc2dDQ0FQYWtHQUlFOXlEUVVnRmlBemFpRVpRUUFoQ0FOQUlCRkJRR3NnSXlBY0lBaEJBM1JxSWdZb0FnQWlDU0FZRUQ4Z0xpRUhJQWdFUUNBR1FYeHFLQUlBUVFGcUlRY0xBa0FnQmlnQ0JDSUZJQWRKRFFBZ0NVRUJhaEFrSWhaQkNYUkJzN1IvYWtFeklCWkJFMHNiSVJJZ0ZrRUlkRUdBSUdvaENnTkFJQVZCZldvaEN5QUZJQTlxSVFZQ2Z5QUFLQUprUVFGR0JFQWdDeEF1SUFwcURBRUxJQUFvQW1BZ0Vtb2dBQ2dDT0NBV1FRSjBhaWdDQUJBdWF5QUFLQUpjYWlBTEVEeEJBblFpQzBHUXBBRnFLQUlBSUJacVFRaDBhaUFBS0FJMElBdHFLQUlBRUM1ckN5QVphaUVMQWtBZ0JpQUVUUVJBSUFzZ0d5QUdRUnhzYWlnQ0FFZ05BUXdEQ3dOQUlCc2dCRUVCYWlJRVFSeHNha0dBZ0lDQUJEWUNBQ0FFSUFaSkRRQUxDeUFiSUFaQkhHeHFJZ1lnSkRZQ0RDQUdJQWsyQWdRZ0JpQUZOZ0lJSUFZZ0N6WUNBQ0FHSUJFcEEwQTNBaEFnQmlBUktBSklOZ0lZSUFWQmYyb2lCU0FIVHcwQUN3c2dDRUVCYWlJSUlCQkhEUUFMQ3lBZUN5SVBJQVJORFFBTEN5QWJJQVJCSEd4cUlnVW9BZ3doSkNBRktBSUVJUWNnQlNnQ0FDRXlJQVVvQWdnaENDQVJJQVVvQWhnMkFsZ2dFU0FGS1FJUU53TlFJQkVnQlNrQ0NEY0RLQ0FSSUFVcEFoQTNBekFnRVNBRktBSVlOZ0k0SUJFZ0JTa0NBRGNESUVFQUlBUWdFVUVnYWhBK2F5SUZJQVVnQkVzYklRUU1Bd3NnRFVFQmFpRU5EQWNMSUFVb0FnQWhCMEVBSVFRZ0R5QWFLQUlJQkg4Z0JBVWdHaWdDREF0cklnUkJnQ0JORFFFTElCc2dKRFlDS0NBYklBZzJBaVFnR3lBSE5nSWdJQnNnTWpZQ0hDQWJJQkVvQWxnMkFqUWdHeUFSS1FOUU53SXNEQUVMSUJzZ0JFRUJhaUlXUVJ4c2FpSUZJQ1EyQWd3Z0JTQUlOZ0lJSUFVZ0J6WUNCQ0FGSURJMkFnQWdCU0FSS1FOUU53SVFJQVVnRVNnQ1dEWUNHQ0FXSVE0Z0JBMEJDMEVCSVE1QkFTRVdEQUVMQTBBZ0VTQWJJQVJCSEd4cUlnVWlCMEVZYWlnQ0FEWUNHQ0FSSUFVcEFoQTNBeEFnRVNBRktRSUlOd01JSUJFZ0JTa0NBRGNEQUNBUkVENGhDQ0FiSUE1QmYyb2lEa0VjYkdvaUJpQUhLQUlZTmdJWUlBWWdCU2tDRURjQ0VDQUdJQVVwQWdnM0FnZ2dCaUFGS1FJQU53SUFJQVFnQ0VzaEJVRUFJQVFnQ0dzaUJpQUdJQVJMR3lFRUlBVU5BQXNnRGlBV1N3MEJDd05BSUJzZ0RrRWNiR29pQkNnQ0RDRUdBbjhnQXlBR2FpQUVLQUlJSWc5RkRRQWFBa0FDUUNBRUtBSUVJZ2RCQTA4RVFDQUNJQUlwQWdBM0FnUWdCMEYrYWlFRURBRUxBa0FDUUFKQUFrQWdCeUFHUldvaUJRNEVCUUVCQUFFTElBSW9BZ0JCZjJvaEJBd0JDeUFDSUFWQkFuUnFLQUlBSVFRZ0JVRUNTUTBCQ3lBQ0lBSW9BZ1EyQWdnTElBSWdBaWdDQURZQ0JBc2dBaUFFTmdJQUN5QW5JQVlnQXlBSElBOFFWeUFQUVgxcUlRa2dBU2dDRENFRUFrQUNRQ0FESUFacUlnVWdNVTBFUUNBRUlBTVFIQ0FCS0FJTUlRUWdCa0VRVFFSQUlBRWdCQ0FHYWpZQ0RBd0RDeUFFUVJCcUlBTkJFR29pQ0JBY0lBUkJJR29nQTBFZ2FoQWNJQVpCTVVnTkFTQUVJQVpxSVFzZ0JFRXdhaUVFQTBBZ0JDQUlRU0JxSWdVUUhDQUVRUkJxSUFoQk1Hb1FIQ0FGSVFnZ0JFRWdhaUlFSUF0SkRRQUxEQUVMSUFRZ0F5QUZJREVRSWdzZ0FTQUJLQUlNSUFacU5nSU1JQVpCZ0lBRVNRMEFJQUZCQVRZQ0pDQUJJQUVvQWdRZ0FTZ0NBR3RCQTNVMkFpZ0xJQUVvQWdRaUJDQUhRUUZxTmdJQUlBUWdCanNCQkNBSlFZQ0FCRThFUUNBQlFRSTJBaVFnQVNBRUlBRW9BZ0JyUVFOMU5nSW9DeUFFSUFrN0FRWWdBU0FFUVFocU5nSUVJQVlnRDJvZ0Eyb2lBd3NoRFNBT1FRRnFJZzRnRmswTkFBc0xJQ2RCQUJCUkN5QU5JQzlKRFFBTEN5QVJRZUFBYWlRQUlBd2dBMnNMK2xzQk5uOGpBRUhnQUdzaUZTUUFJQUFvQW9RQklRWWdBQ2dDQkNFSElBQW9Bb2dCSVFVZ0FDZ0NEQ0VKSUJVZ0FDZ0NHRFlDWENBQUtBSThJUmtnQUVGQWF5Z0NBQ0VnSUFCQkxHb2lMU0FESUFSQkFoQlpJQU1nQnlBSmFpQURSbW9pRUNBRElBUnFJaEpCZUdvaU4wa0VRQ0FGUWY4ZklBVkIveDlKR3lFNElCSkJZR29oT1VFRFFRUWdCa0VEUmhzaU5rRi9haUV1QTBBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FDZ0NCQ0lGSUFBb0FoZ2lCR29nRUVzTkFDQVFJQU5ySVNJZ0FDZ0NoQUVoQmlBRUlCQWdCV3NpQjBrRVFBTkFJQUFnQkNBRmFpQVNJQVpCQUJCQklBUnFJZ1FnQjBrTkFBc0xJQ0pGSVNnZ0FDQUhOZ0lZQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQmtGOWFnNEZBQUVDQXdNQkMwRUFJUWxCQUNBUUlBQW9BZ1FpRkdzaURrRi9JQUFvQW5oQmYycDBRWDl6SWh0cklnUWdCQ0FPU3hzaEhDQUFLQUlnSUJBZ0FDZ0NmRUVERUI1QkFuUnFJaVFvQWdBaENDQUFLQUp3SWhFb0FnQWlIU0FSS0FJRUloTnJJaFpCZnlBUktBSjRRWDlxZEVGL2N5SWVheUFSS0FJUUlob2dGaUFhYXlBZVN4c2hIeUFBS0FJUUlBQW9BaFFnRGlBQUtBSjBFQ2NpQkVFQklBUWJJU1VnRXlBRUlCWnJJaGhySVNrZ0RpQWFheUFZYXlFcVFRTkJCQ0FpR3lFbUlBQW9BaWdpSXlBT0lCdHhRUU4wYWlJWFFRUnFJUTBnQUNnQ2lBRWlCRUgvSHlBRVFmOGZTUnNoQnlBUVFRTnFJUVlnRGtFSmFpRUxJQTRnQUNnQ0RDSVBheUVzSUE4Z0ZHb2hJU0FSS0FKOElTc2dBQ2dDZ0FFaEp5QXVJUXdnS0NFRUEwQUNRQUovQW44Z0JFRURSZ1JBSUFJb0FnQkJmMm9NQVFzZ0FpQUVRUUowYWlnQ0FBc2lDa0YvYWlJRklDeEpCRUFnRUVFREVCOGdFQ0FLYTBFREVCOUhEUUlnQmlBR0lBcHJJQklRSFF3QkN5QUZJQ3BQRFFFZ0R5QU9JQXBySWdWQmYzTnFRUU5KRFFFZ0VFRURFQjhnQlNBcGFpSUZRUU1RSDBjTkFTQUdJQVZCQTJvZ0VpQWRJQ0VRSUF0QkEyb2lCU0FNVFEwQUlCa2dDVUVEZEdvaURDQUZOZ0lFSUF3Z0JDQW9hellDQUNBSlFRRnFJUWtnQlNBSFN3ME5JQVVpRENBUWFpQVNSZzBOQ3lBRVFRRnFJZ1FnSmtrTkFBc0NRQ0FNUVFKTERRQkJBaUVNSUJRZ0FDZ0NIQ0FBS0FJa0lCVkIzQUJxSUJBUVFDSUVJQ1ZKRFFBZ0RpQUVheUlGUWYvL0Qwc05BQ0FRSUFRZ0ZHb2dFaEFkSWdSQkEwa05BQ0FaSUFRMkFnUWdHU0FGUVFKcU5nSUFJQVFnQjAwRVFFRUJJUWtnQkNJTUlCQnFJQkpIRFFFTFFRRWhDU0FBSUE1QkFXbzJBaGdNREFzZ0pDQU9OZ0lBUVg4Z0ozUkJmM01oRHdKQUlBZ2dKVWtFUUNBUElRVU1BUXNnRGtFQ2FpRWtRUUFoQjBFQUlRWURRQ0FRSUFjZ0JpQUhJQVpKR3lJRWFpQUlJQlJxSWdVZ0JHb2dFaEFkSUFScUlnUWdERXNFUUNBWklBbEJBM1JxSWd3Z0JEWUNCQ0FNSUNRZ0NHczJBZ0FnQkNBSWFpQUxJQVFnQ3lBSWEwc2JJUXNnQ1VFQmFpRUpJQVFnRUdvZ0VrWWdCRUdBSUV0eURRWWdCQ0VNQ3lBaklBZ2dHM0ZCQTNScUlRb0NRQUpBSUFRZ0JXb3RBQUFnQkNBUWFpMEFBRWtFUUNBWElBZzJBZ0FnQ0NBY1N3MEJJQlZCUUdzaEZ5QVBJUVVNQkFzZ0RTQUlOZ0lBSUFnZ0hFc0VRQ0FLSVEwZ0JDRUdEQUlMSUJWQlFHc2hEU0FQSVFVTUF3c2dCQ0VISUFwQkJHb2lGeUVLQ3lBUFFYOXFJZ1VnRDA4TkFTQUZJUThnQ2lnQ0FDSUlJQ1ZQRFFBTEN5QU5RUUEyQWdBZ0YwRUFOZ0lBSUFWRkRRb2dFU2dDSUNBUUlDdEJBeEFlUVFKMGFpZ0NBQ0lLSUJwTkRRb2dFU2dDS0NFSElBNUJBbW9oRnlBVUlCaHFJUTFCQUNFSVFRQWhEd05BSUJBZ0NDQVBJQWdnRDBrYklnUnFJQW9nRTJvZ0JHb2dFaUFkSUNFUUlDQUVhaUlFSUF4TEJFQWdHU0FKUVFOMGFpSUdJQVEyQWdRZ0JpQVhJQW9nR0dvaUJtczJBZ0FnQkNBR2FpQUxJQVFnQ3lBR2Ewc2JJUXNnQ1VFQmFpRUpJQVJCZ0NCTERRd2dCQ0lNSUJCcUlCSkdEUXdMSUFvZ0gwME5DeUFGUVg5cUlnVkZEUXNnQkNBSUlCTWdEU0FFSUFwcUlCWkpHeUFLYWlBRWFpMEFBQ0FFSUJCcUxRQUFTU0lHR3lFSUlBOGdCQ0FHR3lFUElBY2dDaUFlY1VFRGRHb2dCa0VDZEdvb0FnQWlDaUFhU3cwQUN3d0tDMEVBSVFsQkFDQVFJQUFvQWdRaUdtc2lDMEYvSUFBb0FuaEJmMnAwUVg5ekloaHJJZ1FnQkNBTFN4c2hHeUFBS0FJZ0lCQWdBQ2dDZkVFRUVCNUJBblJxSWc4b0FnQWhDQ0FBS0FKd0loRW9BZ0FpSENBUktBSUVJaE5ySWhaQmZ5QVJLQUo0UVg5cWRFRi9jeUlkYXlBUktBSVFJaFFnRmlBVWF5QWRTeHNoSkNBQUtBSVFJQUFvQWhRZ0N5QUFLQUowRUNjaUJFRUJJQVFiSVI0Z0V5QUVJQlpySWlWcklSOGdDeUFVYXlBbGF5RXBRUU5CQkNBaUd5RXFJQUFvQWlnaUppQUxJQmh4UVFOMGFpSVhRUVJxSVEwZ0FDZ0NpQUVpQkVIL0h5QUVRZjhmU1JzaEl5QVFRUVJxSVFZZ0MwRUphaUVPSUFzZ0FDZ0NEQ0lIYXlFc0lBY2dHbW9oSVNBUktBSjhJU3NnQUNnQ2dBRWhKeUF1SVF3Z0tDRUVBMEFDUUFKL0FuOGdCRUVEUmdSQUlBSW9BZ0JCZjJvTUFRc2dBaUFFUVFKMGFpZ0NBQXNpQ2tGL2FpSUZJQ3hKQkVBZ0VFRUVFQjhnRUNBS2EwRUVFQjlIRFFJZ0JpQUdJQXBySUJJUUhRd0JDeUFGSUNsUERRRWdCeUFMSUFwcklnVkJmM05xUVFOSkRRRWdFRUVFRUI4Z0JTQWZhaUlGUVFRUUgwY05BU0FHSUFWQkJHb2dFaUFjSUNFUUlBdEJCR29pQlNBTVRRMEFJQmtnQ1VFRGRHb2lEQ0FGTmdJRUlBd2dCQ0FvYXpZQ0FDQUpRUUZxSVFrZ0JTQWpTdzBNSUFVaURDQVFhaUFTUmcwTUN5QUVRUUZxSWdRZ0tra05BQXNnRHlBTE5nSUFRWDhnSjNSQmYzTWhEd0pBSUFnZ0hra0VRQ0FQSVFVTUFRc2dDMEVDYWlFZlFRQWhCMEVBSVFZRFFDQVFJQWNnQmlBSElBWkpHeUlFYWlBSUlCcHFJZ1VnQkdvZ0VoQWRJQVJxSWdRZ0RFc0VRQ0FaSUFsQkEzUnFJZ3dnQkRZQ0JDQU1JQjhnQ0dzMkFnQWdCQ0FJYWlBT0lBUWdEaUFJYTBzYklRNGdDVUVCYWlFSklBUWdFR29nRWtZZ0JFR0FJRXR5RFFZZ0JDRU1DeUFtSUFnZ0dIRkJBM1JxSVFvQ1FBSkFJQVFnQldvdEFBQWdCQ0FRYWkwQUFFa0VRQ0FYSUFnMkFnQWdDQ0FiU3cwQklCVkJRR3NoRnlBUElRVU1CQXNnRFNBSU5nSUFJQWdnRzBzRVFDQUtJUTBnQkNFR0RBSUxJQlZCUUdzaERTQVBJUVVNQXdzZ0JDRUhJQXBCQkdvaUZ5RUtDeUFQUVg5cUlnVWdEMDhOQVNBRklROGdDaWdDQUNJSUlCNVBEUUFMQ3lBTlFRQTJBZ0FnRjBFQU5nSUFJQVZGRFFnZ0VTZ0NJQ0FRSUN0QkJCQWVRUUowYWlnQ0FDSUtJQlJORFFnZ0VTZ0NLQ0VISUF0QkFtb2hGeUFhSUNWcUlRMUJBQ0VJUVFBaER3TkFJQkFnQ0NBUElBZ2dEMGtiSWdScUlBb2dFMm9nQkdvZ0VpQWNJQ0VRSUNBRWFpSUVJQXhMQkVBZ0dTQUpRUU4wYWlJR0lBUTJBZ1FnQmlBWElBb2dKV29pQm1zMkFnQWdCQ0FHYWlBT0lBUWdEaUFHYTBzYklRNGdDVUVCYWlFSklBUkJnQ0JMRFFvZ0JDSU1JQkJxSUJKR0RRb0xJQW9nSkUwTkNTQUZRWDlxSWdWRkRRa2dCQ0FJSUJNZ0RTQUVJQXBxSUJaSkd5QUthaUFFYWkwQUFDQUVJQkJxTFFBQVNTSUdHeUVJSUE4Z0JDQUdHeUVQSUFjZ0NpQWRjVUVEZEdvZ0JrRUNkR29vQWdBaUNpQVVTdzBBQ3d3SUMwRUFJUWxCQUNBUUlBQW9BZ1FpR21zaUMwRi9JQUFvQW5oQmYycDBRWDl6SWhocklnUWdCQ0FMU3hzaEd5QUFLQUlnSUJBZ0FDZ0NmRUVGRUI1QkFuUnFJZzhvQWdBaENDQUFLQUp3SWhFb0FnQWlIQ0FSS0FJRUloTnJJaFpCZnlBUktBSjRRWDlxZEVGL2N5SWRheUFSS0FJUUloUWdGaUFVYXlBZFN4c2hKQ0FBS0FJUUlBQW9BaFFnQ3lBQUtBSjBFQ2NpQkVFQklBUWJJUjRnRXlBRUlCWnJJaVZySVI4Z0N5QVVheUFsYXlFcFFRTkJCQ0FpR3lFcUlBQW9BaWdpSmlBTElCaHhRUU4wYWlJTlFRUnFJUmNnQUNnQ2lBRWlCRUgvSHlBRVFmOGZTUnNoSXlBUVFRUnFJUVlnQzBFSmFpRU9JQXNnQUNnQ0RDSUhheUVzSUFjZ0dtb2hJU0FSS0FKOElTc2dBQ2dDZ0FFaEp5QXVJUXdnS0NFRUEwQUNRQUovQW44Z0JFRURSZ1JBSUFJb0FnQkJmMm9NQVFzZ0FpQUVRUUowYWlnQ0FBc2lDa0YvYWlJRklDeEpCRUFnRUVFRUVCOGdFQ0FLYTBFRUVCOUhEUUlnQmlBR0lBcHJJQklRSFF3QkN5QUZJQ2xQRFFFZ0J5QUxJQXBySWdWQmYzTnFRUU5KRFFFZ0VFRUVFQjhnQlNBZmFpSUZRUVFRSDBjTkFTQUdJQVZCQkdvZ0VpQWNJQ0VRSUF0QkJHb2lCU0FNVFEwQUlCa2dDVUVEZEdvaURDQUZOZ0lFSUF3Z0JDQW9hellDQUNBSlFRRnFJUWtnQlNBalN3MExJQVVpRENBUWFpQVNSZzBMQ3lBRVFRRnFJZ1FnS2trTkFBc2dEeUFMTmdJQVFYOGdKM1JCZjNNaER3SkFJQWdnSGtrRVFDQVBJUVVNQVFzZ0MwRUNhaUVmUVFBaEIwRUFJUVlEUUNBUUlBY2dCaUFISUFaSkd5SUVhaUFJSUJwcUlnVWdCR29nRWhBZElBUnFJZ1FnREVzRVFDQVpJQWxCQTNScUlnd2dCRFlDQkNBTUlCOGdDR3MyQWdBZ0JDQUlhaUFPSUFRZ0RpQUlhMHNiSVE0Z0NVRUJhaUVKSUFRZ0VHb2dFa1lnQkVHQUlFdHlEUVlnQkNFTUN5QW1JQWdnR0hGQkEzUnFJUW9DUUFKQUlBUWdCV290QUFBZ0JDQVFhaTBBQUVrRVFDQU5JQWcyQWdBZ0NDQWJTdzBCSUJWQlFHc2hEU0FQSVFVTUJBc2dGeUFJTmdJQUlBZ2dHMHNFUUNBS0lSY2dCQ0VHREFJTElCVkJRR3NoRnlBUElRVU1Bd3NnQkNFSElBcEJCR29pRFNFS0N5QVBRWDlxSWdVZ0QwOE5BU0FGSVE4Z0NpZ0NBQ0lJSUI1UERRQUxDeUFYUVFBMkFnQWdEVUVBTmdJQUlBVkZEUVlnRVNnQ0lDQVFJQ3RCQlJBZVFRSjBhaWdDQUNJS0lCUk5EUVlnRVNnQ0tDRUhJQXRCQW1vaEZ5QWFJQ1ZxSVExQkFDRUlRUUFoRHdOQUlCQWdDQ0FQSUFnZ0Qwa2JJZ1JxSUFvZ0Uyb2dCR29nRWlBY0lDRVFJQ0FFYWlJRUlBeExCRUFnR1NBSlFRTjBhaUlHSUFRMkFnUWdCaUFYSUFvZ0pXb2lCbXMyQWdBZ0JDQUdhaUFPSUFRZ0RpQUdhMHNiSVE0Z0NVRUJhaUVKSUFSQmdDQkxEUWdnQkNJTUlCQnFJQkpHRFFnTElBb2dKRTBOQnlBRlFYOXFJZ1ZGRFFjZ0JDQUlJQk1nRFNBRUlBcHFJQlpKR3lBS2FpQUVhaTBBQUNBRUlCQnFMUUFBU1NJR0d5RUlJQThnQkNBR0d5RVBJQWNnQ2lBZGNVRURkR29nQmtFQ2RHb29BZ0FpQ2lBVVN3MEFDd3dHQzBFQUlRbEJBQ0FRSUFBb0FnUWlHbXNpQzBGL0lBQW9BbmhCZjJwMFFYOXpJaGhySWdRZ0JDQUxTeHNoR3lBQUtBSWdJQkFnQUNnQ2ZFRUdFQjVCQW5ScUlnOG9BZ0FoQ0NBQUtBSndJaEVvQWdBaUhDQVJLQUlFSWhOckloWkJmeUFSS0FKNFFYOXFkRUYvY3lJZGF5QVJLQUlRSWhRZ0ZpQVVheUFkU3hzaEpDQUFLQUlRSUFBb0FoUWdDeUFBS0FKMEVDY2lCRUVCSUFRYklSNGdFeUFFSUJacklpVnJJUjhnQ3lBVWF5QWxheUVwUVFOQkJDQWlHeUVxSUFBb0FpZ2lKaUFMSUJoeFFRTjBhaUlOUVFScUlSY2dBQ2dDaUFFaUJFSC9IeUFFUWY4ZlNSc2hJeUFRUVFScUlRWWdDMEVKYWlFT0lBc2dBQ2dDRENJSGF5RXNJQWNnR21vaElTQVJLQUo4SVNzZ0FDZ0NnQUVoSnlBdUlRd2dLQ0VFQTBBQ1FBSi9BbjhnQkVFRFJnUkFJQUlvQWdCQmYyb01BUXNnQWlBRVFRSjBhaWdDQUFzaUNrRi9haUlGSUN4SkJFQWdFRUVFRUI4Z0VDQUthMEVFRUI5SERRSWdCaUFHSUFwcklCSVFIUXdCQ3lBRklDbFBEUUVnQnlBTElBcHJJZ1ZCZjNOcVFRTkpEUUVnRUVFRUVCOGdCU0FmYWlJRlFRUVFIMGNOQVNBR0lBVkJCR29nRWlBY0lDRVFJQXRCQkdvaUJTQU1UUTBBSUJrZ0NVRURkR29pRENBRk5nSUVJQXdnQkNBb2F6WUNBQ0FKUVFGcUlRa2dCU0FqU3cwS0lBVWlEQ0FRYWlBU1JnMEtDeUFFUVFGcUlnUWdLa2tOQUFzZ0R5QUxOZ0lBUVg4Z0ozUkJmM01oRHdKQUlBZ2dIa2tFUUNBUElRVU1BUXNnQzBFQ2FpRWZRUUFoQjBFQUlRWURRQ0FRSUFjZ0JpQUhJQVpKR3lJRWFpQUlJQnBxSWdVZ0JHb2dFaEFkSUFScUlnUWdERXNFUUNBWklBbEJBM1JxSWd3Z0JEWUNCQ0FNSUI4Z0NHczJBZ0FnQkNBSWFpQU9JQVFnRGlBSWEwc2JJUTRnQ1VFQmFpRUpJQVFnRUdvZ0VrWWdCRUdBSUV0eURRWWdCQ0VNQ3lBbUlBZ2dHSEZCQTNScUlRb0NRQUpBSUFRZ0JXb3RBQUFnQkNBUWFpMEFBRWtFUUNBTklBZzJBZ0FnQ0NBYlN3MEJJQlZCUUdzaERTQVBJUVVNQkFzZ0Z5QUlOZ0lBSUFnZ0cwc0VRQ0FLSVJjZ0JDRUdEQUlMSUJWQlFHc2hGeUFQSVFVTUF3c2dCQ0VISUFwQkJHb2lEU0VLQ3lBUFFYOXFJZ1VnRDA4TkFTQUZJUThnQ2lnQ0FDSUlJQjVQRFFBTEN5QVhRUUEyQWdBZ0RVRUFOZ0lBSUFWRkRRUWdFU2dDSUNBUUlDdEJCaEFlUVFKMGFpZ0NBQ0lLSUJSTkRRUWdFU2dDS0NFSElBdEJBbW9oRnlBYUlDVnFJUTFCQUNFSVFRQWhEd05BSUJBZ0NDQVBJQWdnRDBrYklnUnFJQW9nRTJvZ0JHb2dFaUFjSUNFUUlDQUVhaUlFSUF4TEJFQWdHU0FKUVFOMGFpSUdJQVEyQWdRZ0JpQVhJQW9nSldvaUJtczJBZ0FnQkNBR2FpQU9JQVFnRGlBR2Ewc2JJUTRnQ1VFQmFpRUpJQVJCZ0NCTERRWWdCQ0lNSUJCcUlCSkdEUVlMSUFvZ0pFME5CU0FGUVg5cUlnVkZEUVVnQkNBSUlCTWdEU0FFSUFwcUlCWkpHeUFLYWlBRWFpMEFBQ0FFSUJCcUxRQUFTU0lHR3lFSUlBOGdCQ0FHR3lFUElBY2dDaUFkY1VFRGRHb2dCa0VDZEdvb0FnQWlDaUFVU3cwQUN3d0VDeUFOUVFBMkFnQWdGMEVBTmdJQURBWUxJQTFCQURZQ0FDQVhRUUEyQWdBTUJBc2dGMEVBTmdJQUlBMUJBRFlDQUF3Q0N5QVhRUUEyQWdBZ0RVRUFOZ0lBQ3lBQUlBNUJlR28yQWhnTUF3c2dBQ0FPUVhocU5nSVlEQUlMSUFBZ0RrRjRhallDR0F3QkN5QUFJQXRCZUdvMkFoZ0xJQWxGRFFBZ0lDQUNLQUlBTmdJUUlDQWdBaWdDQkRZQ0ZDQUNLQUlJSVFRZ0lDQWlOZ0lNSUNCQkFEWUNDQ0FnSUFRMkFoZ2dJQ0FESUNJZ0xVRUNFRmdpQlRZQ0FDQVpJQWxCZjJwQkEzUnFJZ1FvQWdRaUNpQTRTd1JBSUFRb0FnQWhDQXdEQzBFQklRUkJBQ0F0UVFJUUxTRUdBMEFnSUNBRVFSeHNha0dBZ0lDQUJEWUNBQ0FFUVFGcUlnUWdOa2NOQUFzZ0JTQUdhaUVJUVFBaEJpQTJJUW9EUUNBWklBWkJBM1JxSWdRb0FnUWhCeUFWUVVCcklBSWdCQ2dDQUNJTUlDZ1FQeUFLSUFkTkJFQWdERUVCYWhBa0lnOUJDSFJCZ0NCcUlSY0RRQ0FLUVgxcUlRUUNmeUFBS0FKa1FRRkdCRUFnQkJBcklCZHFEQUVMSUFBb0FtQWdBQ2dDT0NBUFFRSjBhaWdDQUJBcmF5QUFLQUpjYWlBRUVEeEJBblFpQkVHUXBBRnFLQUlBSUE5cVFRaDBhaUFBS0FJMElBUnFLQUlBRUN0clFUTnFDeUVGSUNBZ0NrRWNiR29pQkNBaU5nSU1JQVFnRERZQ0JDQUVJQW8yQWdnZ0JDQUZJQWhxTmdJQUlBUWdGU2tEUURjQ0VDQUVJQlVvQWtnMkFoZ2dDa0VCYWlJS0lBZE5EUUFMQ3lBR1FRRnFJZ1lnQ1VjTkFBdEJBU0VQQWtBZ0NrRi9haUlFUlFSQVFRQWhCQXdCQ3dOQVFRRWhCU0FnSUE5QmYycEJIR3hxSWdjb0FnaEZCRUFnQnlnQ0RFRUJhaUVGQ3lBUElCQnFJZ3RCZjJwQkFTQXRRUUlRVWlBSEtBSUFhaUFGSUMxQkFoQXRhaUFGUVg5cUlDMUJBaEF0YXlJR0lDQWdEMEVjYkdvaUdpZ0NBQ0lYVEFSQUlCb2dCVFlDRENBYVFnQTNBZ1FnR2lBR05nSUFJQm9nQnlnQ0dEWUNHQ0FhSUFjcEFoQTNBaEFnQmlFWEN3SkFJQXNnTjBzTkFDQUVJQTlHQkVBZ0R5RUVEQU1MUVFBaElpQWFLQUlJSWdaRkJFQWdHaWdDRENFaUMwRUFJQzFCQWhBdElTd2dBQ2dDQkNJSElBQW9BaGdpQldvZ0Mwc05BQ0FBS0FLRUFTRUpJQVVnQ3lBSGF5SU1TUVJBQTBBZ0FDQUZJQWRxSUJJZ0NVRUFFRUVnQldvaUJTQU1TUTBBQ3dzZ0JrRUFSeUVvSUJwQkVHb2hKU0FBSUF3MkFoZ0NRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUpRWDFxRGdVQUFRSURBd0VMUVFBaERrRUFJQXNnQUNnQ0JDSVdheUlSUVg4Z0FDZ0NlRUYvYW5SQmYzTWlKR3NpQlNBRklCRkxHeUVmSUFBb0FpQWdDeUFBS0FKOFFRTVFIa0VDZEdvaUt5Z0NBQ0VOSUFBb0FuQWlFeWdDQUNJcElCTW9BZ1FpSEdzaUhVRi9JQk1vQW5oQmYycDBRWDl6SWlwcklCTW9BaEFpR3lBZElCdHJJQ3BMR3lFbklBQW9BaEFnQUNnQ0ZDQVJJQUFvQW5RUUp5SUZRUUVnQlJzaEhpQWNJQVVnSFdzaUlXc2hMeUFSSUJ0cklDRnJJVEJCQkVFRElBWWJJVEVnQUNnQ0tDSXlJQkVnSkhGQkEzUnFJaGhCQkdvaERDQUFLQUtJQVNJRlFmOGZJQVZCL3g5Skd5RUtJQXRCQTJvaEJ5QVJRUWxxSVJRZ0VTQUFLQUlNSWlacklUTWdGaUFtYWlFaklCTW9BbndoTkNBQUtBS0FBU0UxSUM0aENTQW9JUVVEUUFKQUFuOENmeUFGUVFOR0JFQWdKU2dDQUVGL2Fnd0JDeUFhSUFWQkFuUnFLQUlRQ3lJSVFYOXFJZ1lnTTBrRVFDQUxRUU1RSHlBTElBaHJRUU1RSDBjTkFpQUhJQWNnQ0dzZ0VoQWREQUVMSUFZZ01FOE5BU0FtSUJFZ0NHc2lCa0YvYzJwQkEwa05BU0FMUVFNUUh5QUdJQzlxSWdaQkF4QWZSdzBCSUFjZ0JrRURhaUFTSUNrZ0l4QWdDMEVEYWlJR0lBbE5EUUFnR1NBT1FRTjBhaUlKSUFZMkFnUWdDU0FGSUNock5nSUFJQTVCQVdvaERpQUdJQXBMRFEwZ0JpSUpJQXRxSUJKR0RRMExJQVZCQVdvaUJTQXhTUTBBQ3dKQUlBbEJBa3NOQUVFQ0lRa2dGaUFBS0FJY0lBQW9BaVFnRlVIY0FHb2dDeEJBSWdVZ0hra05BQ0FSSUFWcklnWkIvLzhQU3cwQUlBc2dCU0FXYWlBU0VCMGlCVUVEU1EwQUlCa2dCVFlDQkNBWklBWkJBbW8yQWdBZ0JTQUtUUVJBUVFFaERpQUZJZ2tnQzJvZ0VrY05BUXRCQVNFT0lBQWdFVUVCYWpZQ0dBd01DeUFySUJFMkFnQkJmeUExZEVGL2N5RUdBa0FnRFNBZVNRUkFJQVloQnd3QkN5QVJRUUpxSVNaQkFDRUtRUUFoQlFOQUlBc2dDaUFGSUFvZ0JVa2JJZ2RxSUEwZ0Ztb2lLeUFIYWlBU0VCMGdCMm9pQnlBSlN3UkFJQmtnRGtFRGRHb2lDU0FITmdJRUlBa2dKaUFOYXpZQ0FDQUhJQTFxSUJRZ0J5QVVJQTFyU3hzaEZDQU9RUUZxSVE0Z0J5QUxhaUFTUmlBSFFZQWdTM0lOQmlBSElRa0xJRElnRFNBa2NVRURkR29oQ0FKQUFrQWdCeUFyYWkwQUFDQUhJQXRxTFFBQVNRUkFJQmdnRFRZQ0FDQU5JQjlMRFFFZ0ZVRkFheUVZSUFZaEJ3d0VDeUFNSUEwMkFnQWdEU0FmU3dSQUlBZ2hEQ0FISVFVTUFnc2dGVUZBYXlFTUlBWWhCd3dEQ3lBSElRb2dDRUVFYWlJWUlRZ0xJQVpCZjJvaUJ5QUdUdzBCSUFjaEJpQUlLQUlBSWcwZ0hrOE5BQXNMSUF4QkFEWUNBQ0FZUVFBMkFnQWdCMFVOQ2lBVEtBSWdJQXNnTkVFREVCNUJBblJxS0FJQUlnZ2dHMDBOQ2lBVEtBSW9JUW9nRVVFQ2FpRVJJQllnSVdvaEUwRUFJUTFCQUNFR0EwQWdDeUFOSUFZZ0RTQUdTUnNpQldvZ0NDQWNhaUFGYWlBU0lDa2dJeEFnSUFWcUlnVWdDVXNFUUNBWklBNUJBM1JxSWdrZ0JUWUNCQ0FKSUJFZ0NDQWhhaUlKYXpZQ0FDQUZJQWxxSUJRZ0JTQVVJQWxyU3hzaEZDQU9RUUZxSVE0Z0JVR0FJRXNORENBRklna2dDMm9nRWtZTkRBc2dDQ0FuVFEwTElBZEJmMm9pQjBVTkN5QUZJQTBnSENBVElBVWdDR29nSFVrYklBaHFJQVZxTFFBQUlBVWdDMm90QUFCSklnd2JJUTBnQmlBRklBd2JJUVlnQ2lBSUlDcHhRUU4wYWlBTVFRSjBhaWdDQUNJSUlCdExEUUFMREFvTFFRQWhEa0VBSUFzZ0FDZ0NCQ0liYXlJVFFYOGdBQ2dDZUVGL2FuUkJmM01pSVdzaUJTQUZJQk5MR3lFa0lBQW9BaUFnQ3lBQUtBSjhRUVFRSGtFQ2RHb2lJeWdDQUNFTklBQW9BbkFpRmlnQ0FDSWZJQllvQWdRaUhHc2lIVUYvSUJZb0FuaEJmMnAwUVg5eklpbHJJQllvQWhBaUdDQWRJQmhySUNsTEd5RXJJQUFvQWhBZ0FDZ0NGQ0FUSUFBb0FuUVFKeUlGUVFFZ0JSc2hLaUFjSUFVZ0hXc2lIbXNoSnlBVElCaHJJQjVySVM5QkJFRURJQVliSVRBZ0FDZ0NLQ0l4SUJNZ0lYRkJBM1JxSWhSQkJHb2hEQ0FBS0FLSUFTSUZRZjhmSUFWQi94OUpHeUV5SUF0QkJHb2hCeUFUUVFscUlSRWdFeUFBS0FJTUlncHJJVE1nQ2lBYmFpRW1JQllvQW53aE5DQUFLQUtBQVNFMUlDNGhDU0FvSVFVRFFBSkFBbjhDZnlBRlFRTkdCRUFnSlNnQ0FFRi9hZ3dCQ3lBYUlBVkJBblJxS0FJUUN5SUlRWDlxSWdZZ00wa0VRQ0FMUVFRUUh5QUxJQWhyUVFRUUgwY05BaUFISUFjZ0NHc2dFaEFkREFFTElBWWdMMDhOQVNBS0lCTWdDR3NpQmtGL2MycEJBMGtOQVNBTFFRUVFIeUFHSUNkcUlnWkJCQkFmUncwQklBY2dCa0VFYWlBU0lCOGdKaEFnQzBFRWFpSUdJQWxORFFBZ0dTQU9RUU4wYWlJSklBWTJBZ1FnQ1NBRklDaHJOZ0lBSUE1QkFXb2hEaUFHSURKTERRd2dCaUlKSUF0cUlCSkdEUXdMSUFWQkFXb2lCU0F3U1EwQUN5QWpJQk0yQWdCQmZ5QTFkRUYvY3lFR0FrQWdEU0FxU1FSQUlBWWhCd3dCQ3lBVFFRSnFJU05CQUNFS1FRQWhCUU5BSUFzZ0NpQUZJQW9nQlVrYklnZHFJQTBnRzJvaUp5QUhhaUFTRUIwZ0Iyb2lCeUFKU3dSQUlCa2dEa0VEZEdvaUNTQUhOZ0lFSUFrZ0l5QU5hellDQUNBSElBMXFJQkVnQnlBUklBMXJTeHNoRVNBT1FRRnFJUTRnQnlBTGFpQVNSaUFIUVlBZ1MzSU5CaUFISVFrTElERWdEU0FoY1VFRGRHb2hDQUpBQWtBZ0J5QW5haTBBQUNBSElBdHFMUUFBU1FSQUlCUWdEVFlDQUNBTklDUkxEUUVnRlVGQWF5RVVJQVloQnd3RUN5QU1JQTAyQWdBZ0RTQWtTd1JBSUFnaERDQUhJUVVNQWdzZ0ZVRkFheUVNSUFZaEJ3d0RDeUFISVFvZ0NFRUVhaUlVSVFnTElBWkJmMm9pQnlBR1R3MEJJQWNoQmlBSUtBSUFJZzBnS2s4TkFBc0xJQXhCQURZQ0FDQVVRUUEyQWdBZ0IwVU5DQ0FXS0FJZ0lBc2dORUVFRUI1QkFuUnFLQUlBSWdnZ0dFME5DQ0FXS0FJb0lRb2dFMEVDYWlFVUlCc2dIbW9oRTBFQUlRMUJBQ0VHQTBBZ0N5QU5JQVlnRFNBR1NSc2lCV29nQ0NBY2FpQUZhaUFTSUI4Z0poQWdJQVZxSWdVZ0NVc0VRQ0FaSUE1QkEzUnFJZ2tnQlRZQ0JDQUpJQlFnQ0NBZWFpSUphellDQUNBRklBbHFJQkVnQlNBUklBbHJTeHNoRVNBT1FRRnFJUTRnQlVHQUlFc05DaUFGSWdrZ0Myb2dFa1lOQ2dzZ0NDQXJUUTBKSUFkQmYyb2lCMFVOQ1NBRklBMGdIQ0FUSUFVZ0NHb2dIVWtiSUFocUlBVnFMUUFBSUFVZ0Myb3RBQUJKSWd3YklRMGdCaUFGSUF3YklRWWdDaUFJSUNseFFRTjBhaUFNUVFKMGFpZ0NBQ0lJSUJoTERRQUxEQWdMUVFBaERrRUFJQXNnQUNnQ0JDSWJheUlUUVg4Z0FDZ0NlRUYvYW5SQmYzTWlJV3NpQlNBRklCTkxHeUVrSUFBb0FpQWdDeUFBS0FKOFFRVVFIa0VDZEdvaUl5Z0NBQ0VOSUFBb0FuQWlGaWdDQUNJZklCWW9BZ1FpSEdzaUhVRi9JQllvQW5oQmYycDBRWDl6SWlscklCWW9BaEFpR0NBZElCaHJJQ2xMR3lFcklBQW9BaEFnQUNnQ0ZDQVRJQUFvQW5RUUp5SUZRUUVnQlJzaEtpQWNJQVVnSFdzaUhtc2hKeUFUSUJocklCNXJJUzlCQkVFRElBWWJJVEFnQUNnQ0tDSXhJQk1nSVhGQkEzUnFJaFJCQkdvaERDQUFLQUtJQVNJRlFmOGZJQVZCL3g5Skd5RXlJQXRCQkdvaEJ5QVRRUWxxSVJFZ0V5QUFLQUlNSWdwcklUTWdDaUFiYWlFbUlCWW9BbndoTkNBQUtBS0FBU0UxSUM0aENTQW9JUVVEUUFKQUFuOENmeUFGUVFOR0JFQWdKU2dDQUVGL2Fnd0JDeUFhSUFWQkFuUnFLQUlRQ3lJSVFYOXFJZ1lnTTBrRVFDQUxRUVFRSHlBTElBaHJRUVFRSDBjTkFpQUhJQWNnQ0dzZ0VoQWREQUVMSUFZZ0wwOE5BU0FLSUJNZ0NHc2lCa0YvYzJwQkEwa05BU0FMUVFRUUh5QUdJQ2RxSWdaQkJCQWZSdzBCSUFjZ0JrRUVhaUFTSUI4Z0poQWdDMEVFYWlJR0lBbE5EUUFnR1NBT1FRTjBhaUlKSUFZMkFnUWdDU0FGSUNock5nSUFJQTVCQVdvaERpQUdJREpMRFFzZ0JpSUpJQXRxSUJKR0RRc0xJQVZCQVdvaUJTQXdTUTBBQ3lBaklCTTJBZ0JCZnlBMWRFRi9jeUVHQWtBZ0RTQXFTUVJBSUFZaEJ3d0JDeUFUUVFKcUlTTkJBQ0VLUVFBaEJRTkFJQXNnQ2lBRklBb2dCVWtiSWdkcUlBMGdHMm9pSnlBSGFpQVNFQjBnQjJvaUJ5QUpTd1JBSUJrZ0RrRURkR29pQ1NBSE5nSUVJQWtnSXlBTmF6WUNBQ0FISUExcUlCRWdCeUFSSUExclN4c2hFU0FPUVFGcUlRNGdCeUFMYWlBU1JpQUhRWUFnUzNJTkJpQUhJUWtMSURFZ0RTQWhjVUVEZEdvaENBSkFBa0FnQnlBbmFpMEFBQ0FISUF0cUxRQUFTUVJBSUJRZ0RUWUNBQ0FOSUNSTERRRWdGVUZBYXlFVUlBWWhCd3dFQ3lBTUlBMDJBZ0FnRFNBa1N3UkFJQWdoRENBSElRVU1BZ3NnRlVGQWF5RU1JQVloQnd3REN5QUhJUW9nQ0VFRWFpSVVJUWdMSUFaQmYyb2lCeUFHVHcwQklBY2hCaUFJS0FJQUlnMGdLazhOQUFzTElBeEJBRFlDQUNBVVFRQTJBZ0FnQjBVTkJpQVdLQUlnSUFzZ05FRUZFQjVCQW5ScUtBSUFJZ2dnR0UwTkJpQVdLQUlvSVFvZ0UwRUNhaUVVSUJzZ0htb2hFMEVBSVExQkFDRUdBMEFnQ3lBTklBWWdEU0FHU1JzaUJXb2dDQ0FjYWlBRmFpQVNJQjhnSmhBZ0lBVnFJZ1VnQ1VzRVFDQVpJQTVCQTNScUlna2dCVFlDQkNBSklCUWdDQ0FlYWlJSmF6WUNBQ0FGSUFscUlCRWdCU0FSSUFsclN4c2hFU0FPUVFGcUlRNGdCVUdBSUVzTkNDQUZJZ2tnQzJvZ0VrWU5DQXNnQ0NBclRRMEhJQWRCZjJvaUIwVU5CeUFGSUEwZ0hDQVRJQVVnQ0dvZ0hVa2JJQWhxSUFWcUxRQUFJQVVnQzJvdEFBQkpJZ3diSVEwZ0JpQUZJQXdiSVFZZ0NpQUlJQ2x4UVFOMGFpQU1RUUowYWlnQ0FDSUlJQmhMRFFBTERBWUxRUUFoRGtFQUlBc2dBQ2dDQkNJYmF5SVRRWDhnQUNnQ2VFRi9hblJCZjNNaUlXc2lCU0FGSUJOTEd5RWtJQUFvQWlBZ0N5QUFLQUo4UVFZUUhrRUNkR29pSXlnQ0FDRU5JQUFvQW5BaUZpZ0NBQ0lmSUJZb0FnUWlIR3NpSFVGL0lCWW9BbmhCZjJwMFFYOXpJaWxySUJZb0FoQWlHQ0FkSUJocklDbExHeUVySUFBb0FoQWdBQ2dDRkNBVElBQW9BblFRSnlJRlFRRWdCUnNoS2lBY0lBVWdIV3NpSG1zaEp5QVRJQmhySUI1cklTOUJCRUVESUFZYklUQWdBQ2dDS0NJeElCTWdJWEZCQTNScUloUkJCR29oRENBQUtBS0lBU0lGUWY4ZklBVkIveDlKR3lFeUlBdEJCR29oQnlBVFFRbHFJUkVnRXlBQUtBSU1JZ3BySVRNZ0NpQWJhaUVtSUJZb0Fud2hOQ0FBS0FLQUFTRTFJQzRoQ1NBb0lRVURRQUpBQW44Q2Z5QUZRUU5HQkVBZ0pTZ0NBRUYvYWd3QkN5QWFJQVZCQW5ScUtBSVFDeUlJUVg5cUlnWWdNMGtFUUNBTFFRUVFIeUFMSUFoclFRUVFIMGNOQWlBSElBY2dDR3NnRWhBZERBRUxJQVlnTDA4TkFTQUtJQk1nQ0dzaUJrRi9jMnBCQTBrTkFTQUxRUVFRSHlBR0lDZHFJZ1pCQkJBZlJ3MEJJQWNnQmtFRWFpQVNJQjhnSmhBZ0MwRUVhaUlHSUFsTkRRQWdHU0FPUVFOMGFpSUpJQVkyQWdRZ0NTQUZJQ2hyTmdJQUlBNUJBV29oRGlBR0lESkxEUW9nQmlJSklBdHFJQkpHRFFvTElBVkJBV29pQlNBd1NRMEFDeUFqSUJNMkFnQkJmeUExZEVGL2N5RUdBa0FnRFNBcVNRUkFJQVloQnd3QkN5QVRRUUpxSVNOQkFDRUtRUUFoQlFOQUlBc2dDaUFGSUFvZ0JVa2JJZ2RxSUEwZ0cyb2lKeUFIYWlBU0VCMGdCMm9pQnlBSlN3UkFJQmtnRGtFRGRHb2lDU0FITmdJRUlBa2dJeUFOYXpZQ0FDQUhJQTFxSUJFZ0J5QVJJQTFyU3hzaEVTQU9RUUZxSVE0Z0J5QUxhaUFTUmlBSFFZQWdTM0lOQmlBSElRa0xJREVnRFNBaGNVRURkR29oQ0FKQUFrQWdCeUFuYWkwQUFDQUhJQXRxTFFBQVNRUkFJQlFnRFRZQ0FDQU5JQ1JMRFFFZ0ZVRkFheUVVSUFZaEJ3d0VDeUFNSUEwMkFnQWdEU0FrU3dSQUlBZ2hEQ0FISVFVTUFnc2dGVUZBYXlFTUlBWWhCd3dEQ3lBSElRb2dDRUVFYWlJVUlRZ0xJQVpCZjJvaUJ5QUdUdzBCSUFjaEJpQUlLQUlBSWcwZ0trOE5BQXNMSUF4QkFEWUNBQ0FVUVFBMkFnQWdCMFVOQkNBV0tBSWdJQXNnTkVFR0VCNUJBblJxS0FJQUlnZ2dHRTBOQkNBV0tBSW9JUW9nRTBFQ2FpRVVJQnNnSG1vaEUwRUFJUTFCQUNFR0EwQWdDeUFOSUFZZ0RTQUdTUnNpQldvZ0NDQWNhaUFGYWlBU0lCOGdKaEFnSUFWcUlnVWdDVXNFUUNBWklBNUJBM1JxSWdrZ0JUWUNCQ0FKSUJRZ0NDQWVhaUlKYXpZQ0FDQUZJQWxxSUJFZ0JTQVJJQWxyU3hzaEVTQU9RUUZxSVE0Z0JVR0FJRXNOQmlBRklna2dDMm9nRWtZTkJnc2dDQ0FyVFEwRklBZEJmMm9pQjBVTkJTQUZJQTBnSENBVElBVWdDR29nSFVrYklBaHFJQVZxTFFBQUlBVWdDMm90QUFCSklnd2JJUTBnQmlBRklBd2JJUVlnQ2lBSUlDbHhRUU4wYWlBTVFRSjBhaWdDQUNJSUlCaExEUUFMREFRTElBeEJBRFlDQUNBWVFRQTJBZ0FNQmdzZ0RFRUFOZ0lBSUJSQkFEWUNBQXdFQ3lBTVFRQTJBZ0FnRkVFQU5nSUFEQUlMSUF4QkFEWUNBQ0FVUVFBMkFnQUxJQUFnRVVGNGFqWUNHQXdEQ3lBQUlCRkJlR28yQWhnTUFnc2dBQ0FSUVhocU5nSVlEQUVMSUFBZ0ZFRjRhallDR0FzZ0RrVU5BQ0FaSUE1QmYycEJBM1JxSWdVb0FnUWlDaUE0U3lBS0lBOXFRWUFnVDNJTkJDQVhJQ3hxSVJkQkFDRUtBMEFnRlVGQWF5QWxJQmtnQ2tFRGRHb2lCaWdDQUNJSElDZ1FQeUEySVF3Q2Z5QUtCRUFnQmtGOGFpZ0NBRUVCYWlFTUN5QUdLQUlFSWdVZ0RFOExCRUFnQjBFQmFoQWtJZ2xCQ0hSQmdDQnFJUTBEUUNBRlFYMXFJUWdnQlNBUGFpRUdBbjhnQUNnQ1pFRUJSZ1JBSUFnUUt5QU5hZ3dCQ3lBQUtBSmdJQUFvQWpnZ0NVRUNkR29vQWdBUUsyc2dBQ2dDWEdvZ0NCQThRUUowSWdoQmtLUUJhaWdDQUNBSmFrRUlkR29nQUNnQ05DQUlhaWdDQUJBcmEwRXphZ3NnRjJvaENBSkFBa0FnQmlBRVRRUkFJQWdnSUNBR1FSeHNhaWdDQUVnTkFRd0NDd05BSUNBZ0JFRUJhaUlFUVJ4c2FrR0FnSUNBQkRZQ0FDQUVJQVpKRFFBTEN5QWdJQVpCSEd4cUlnWWdJallDRENBR0lBYzJBZ1FnQmlBRk5nSUlJQVlnQ0RZQ0FDQUdJQlVwQTBBM0FoQWdCaUFWS0FKSU5nSVlDeUFGUVg5cUlnVWdERThOQUFzTElBcEJBV29pQ2lBT1J3MEFDd3NnRDBFQmFpSVBJQVJORFFBTEN5QWdJQVJCSEd4cUlnVW9BZ3doSWlBRktBSUVJUWdnQlNnQ0FDRTZJQVVvQWdnaENpQVZJQVVvQWhnMkFsZ2dGU0FGS1FJUU53TlFJQlVnQlNrQ0NEY0RLQ0FWSUFVcEFoQTNBekFnRlNBRktBSVlOZ0k0SUJVZ0JTa0NBRGNESUVFQUlBUWdGVUVnYWhBK2F5SUZJQVVnQkVzYklRUU1Bd3NnRUVFQmFpRVFEQWNMSUFVb0FnQWhDRUVBSVFRZ0R5QWFLQUlJQkg4Z0JBVWdHaWdDREF0cklnUkJnQ0JORFFFTElDQWdJallDS0NBZ0lBbzJBaVFnSUNBSU5nSWdJQ0FnT2pZQ0hDQWdJQlVvQWxnMkFqUWdJQ0FWS1FOUU53SXNEQUVMSUNBZ0JFRUJhaUlKUVJ4c2FpSUZJQ0kyQWd3Z0JTQUtOZ0lJSUFVZ0NEWUNCQ0FGSURvMkFnQWdCU0FWS1FOUU53SVFJQVVnRlNnQ1dEWUNHQ0FKSVNJZ0JBMEJDMEVCSVNKQkFTRUpEQUVMQTBBZ0ZTQWdJQVJCSEd4cUlnVWlERUVZYWlnQ0FEWUNHQ0FWSUFVcEFoQTNBeEFnRlNBRktRSUlOd01JSUJVZ0JTa0NBRGNEQUNBVkVENGhCeUFnSUNKQmYyb2lJa0VjYkdvaUJpQU1LQUlZTmdJWUlBWWdCU2tDRURjQ0VDQUdJQVVwQWdnM0FnZ2dCaUFGS1FJQU53SUFJQVFnQjBzaEJVRUFJQVFnQjJzaUJpQUdJQVJMR3lFRUlBVU5BQXNnSWlBSlN3MEJDd05BSUNBZ0lrRWNiR29pQkNnQ0RDRUdBbjhnQXlBR2FpQUVLQUlJSWd4RkRRQWFBa0FDUUNBRUtBSUVJZ2RCQTA4RVFDQUNJQUlwQWdBM0FnUWdCMEYrYWlFRURBRUxBa0FDUUFKQUFrQWdCeUFHUldvaUJRNEVCUUVCQUFFTElBSW9BZ0JCZjJvaEJBd0JDeUFDSUFWQkFuUnFLQUlBSVFRZ0JVRUNTUTBCQ3lBQ0lBSW9BZ1EyQWdnTElBSWdBaWdDQURZQ0JBc2dBaUFFTmdJQUN5QXRJQVlnQXlBSElBd1FWeUFNUVgxcUlROGdBU2dDRENFRUFrQUNRQ0FESUFacUlnVWdPVTBFUUNBRUlBTVFIQ0FCS0FJTUlRUWdCa0VRVFFSQUlBRWdCQ0FHYWpZQ0RBd0RDeUFFUVJCcUlBTkJFR29pQ2hBY0lBUkJJR29nQTBFZ2FoQWNJQVpCTVVnTkFTQUVJQVpxSVFnZ0JFRXdhaUVFQTBBZ0JDQUtRU0JxSWdVUUhDQUVRUkJxSUFwQk1Hb1FIQ0FGSVFvZ0JFRWdhaUlFSUFoSkRRQUxEQUVMSUFRZ0F5QUZJRGtRSWdzZ0FTQUJLQUlNSUFacU5nSU1JQVpCZ0lBRVNRMEFJQUZCQVRZQ0pDQUJJQUVvQWdRZ0FTZ0NBR3RCQTNVMkFpZ0xJQUVvQWdRaUJDQUhRUUZxTmdJQUlBUWdCanNCQkNBUFFZQ0FCRThFUUNBQlFRSTJBaVFnQVNBRUlBRW9BZ0JyUVFOMU5nSW9DeUFFSUE4N0FRWWdBU0FFUVFocU5nSUVJQVlnREdvZ0Eyb2lBd3NoRUNBaVFRRnFJaUlnQ1UwTkFBc0xJQzFCQWhCUkN5QVFJRGRKRFFBTEN5QVZRZUFBYWlRQUlCSWdBMnNMdTF3Qk4zOGpBRUhnQUdzaUZ5UUFJQUFvQW9RQklRY2dBQ2dDQkNFR0lBQW9Bb2dCSVJFZ0FDZ0NEQ0VGSUJjZ0FDZ0NHRFlDWENBQUtBSThJUnNnQUVGQWF5Z0NBQ0VrSUFCQkxHb2lOU0FESUFSQkFCQlpJQU1nQlNBR2FpQURSbW9pRFNBRElBUnFJaEJCZUdvaU9Fa0VRQ0FSUWY4ZklCRkIveDlKR3lFNUlCQkJZR29oT2tFRFFRUWdCMEVEUmhzaU4wRi9haUUyQTBBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FDZ0NCQ0lISUFBb0FoZ2lCR29nRFVzTkFDQU5JQU5ySVM0Z0FDZ0NoQUVoQmlBRUlBMGdCMnNpQlVrRVFBTkFJQUFnQkNBSGFpQVFJQVpCQUJCQklBUnFJZ1FnQlVrTkFBc0xJQzVGSVN3Z0FDQUZOZ0lZQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQmtGOWFnNEZBQUVDQXdNQkMwRUFJUXRCQUNBTklBQW9BZ1FpR1dzaUQwRi9JQUFvQW5oQmYycDBRWDl6SWlacklnUWdCQ0FQU3hzaEp5QUFLQUlnSUEwZ0FDZ0NmRUVERUI1QkFuUnFJaThvQWdBaENTQUFLQUp3SWhZb0FnQWlLQ0FXS0FJRUloMXJJaDVCZnlBV0tBSjRRWDlxZEVGL2N5SXBheUFXS0FJUUlod2dIaUFjYXlBcFN4c2hNQ0FBS0FJUUlBQW9BaFFnRHlBQUtBSjBFQ2NpQkVFQklBUWJJUjhnSFNBRUlCNXJJaUpySVRFZ0R5QWNheUFpYXlFVVFRTkJCQ0F1R3lFZ0lBQW9BaWdpTWlBUElDWnhRUU4wYWlJTVFRUnFJUW9nQUNnQ2lBRWlCRUgvSHlBRVFmOGZTUnNoTkNBTlFRTnFJU1VnRDBFSmFpRVRJQThnQUNnQ0RDSXJheUVWSUJrZ0syb2hMU0FXS0FKOElTRWdBQ2dDZ0FFaEJ5QTJJUkVnTENFRUEwQUNRQUovQW44Z0JFRURSZ1JBSUFJb0FnQkJmMm9NQVFzZ0FpQUVRUUowYWlnQ0FBc2lDRUYvYWlJRklCVkpCRUFnRFVFREVCOGdEU0FJYTBFREVCOUhEUUlnSlNBbElBaHJJQkFRSFF3QkN5QUZJQlJQRFFFZ0t5QVBJQWhySWdWQmYzTnFRUU5KRFFFZ0RVRURFQjhnQlNBeGFpSUZRUU1RSDBjTkFTQWxJQVZCQTJvZ0VDQW9JQzBRSUF0QkEyb2lCU0FSVFEwQUlCc2dDMEVEZEdvaUJpQUZOZ0lFSUFZZ0JDQXNhellDQUNBTFFRRnFJUXNnQlNBMFN3ME5JQVVpRVNBTmFpQVFSZzBOQ3lBRVFRRnFJZ1FnSUVrTkFBc0NRQ0FSUVFKTERRQkJBaUVSSUJrZ0FDZ0NIQ0FBS0FJa0lCZEIzQUJxSUEwUVFDSUVJQjlKRFFBZ0R5QUVheUlGUWYvL0Qwc05BQ0FOSUFRZ0dXb2dFQkFkSWdSQkEwa05BQ0FiSUFRMkFnUWdHeUFGUVFKcU5nSUFJQVFnTkUwRVFFRUJJUXNnQkNJUklBMXFJQkJIRFFFTFFRRWhDeUFBSUE5QkFXbzJBaGdNREFzZ0x5QVBOZ0lBUVg4Z0IzUkJmM01oQlFKQUlBa2dIMGtFUUNBRklRY01BUXNnRDBFQ2FpRVVRUUFoQmtFQUlSVURRQ0FOSUFZZ0ZTQUdJQlZKR3lJRWFpQUpJQmxxSWlBZ0JHb2dFQkFkSUFScUlnUWdFVXNFUUNBYklBdEJBM1JxSWdjZ0JEWUNCQ0FISUJRZ0NXczJBZ0FnQkNBSmFpQVRJQVFnRXlBSmEwc2JJUk1nQzBFQmFpRUxJQVFnRFdvZ0VFWWdCRUdBSUV0eURRWWdCQ0VSQ3lBeUlBa2dKbkZCQTNScUlRZ0NRQUpBSUFRZ0lHb3RBQUFnQkNBTmFpMEFBRWtFUUNBTUlBazJBZ0FnQ1NBblN3MEJJQmRCUUdzaERDQUZJUWNNQkFzZ0NpQUpOZ0lBSUFrZ0owc0VRQ0FJSVFvZ0JDRVZEQUlMSUJkQlFHc2hDaUFGSVFjTUF3c2dCQ0VHSUFoQkJHb2lEQ0VJQ3lBRlFYOXFJZ2NnQlU4TkFTQUhJUVVnQ0NnQ0FDSUpJQjlQRFFBTEN5QUtRUUEyQWdBZ0RFRUFOZ0lBSUFkRkRRb2dGaWdDSUNBTklDRkJBeEFlUVFKMGFpZ0NBQ0lJSUJ4TkRRb2dGaWdDS0NFTUlBOUJBbW9oRlNBWklDSnFJUXBCQUNFSlFRQWhCUU5BSUEwZ0NTQUZJQWtnQlVrYklnUnFJQWdnSFdvZ0JHb2dFQ0FvSUMwUUlDQUVhaUlFSUJGTEJFQWdHeUFMUVFOMGFpSUdJQVEyQWdRZ0JpQVZJQWdnSW1vaUJtczJBZ0FnQkNBR2FpQVRJQVFnRXlBR2Ewc2JJUk1nQzBFQmFpRUxJQVJCZ0NCTERRd2dCQ0lSSUExcUlCQkdEUXdMSUFnZ01FME5DeUFIUVg5cUlnZEZEUXNnQkNBSklCMGdDaUFFSUFocUlCNUpHeUFJYWlBRWFpMEFBQ0FFSUExcUxRQUFTU0lHR3lFSklBVWdCQ0FHR3lFRklBd2dDQ0FwY1VFRGRHb2dCa0VDZEdvb0FnQWlDQ0FjU3cwQUN3d0tDMEVBSVF0QkFDQU5JQUFvQWdRaUhHc2lEMEYvSUFBb0FuaEJmMnAwUVg5eklpVnJJZ1FnQkNBUFN4c2hKaUFBS0FJZ0lBMGdBQ2dDZkVFRUVCNUJBblJxSWkwb0FnQWhDU0FBS0FKd0loWW9BZ0FpSnlBV0tBSUVJaDFySWg1QmZ5QVdLQUo0UVg5cWRFRi9jeUlvYXlBV0tBSVFJaGtnSGlBWmF5QW9TeHNoTHlBQUtBSVFJQUFvQWhRZ0R5QUFLQUowRUNjaUJFRUJJQVFiSVNrZ0hTQUVJQjVySWg5cklUQWdEeUFaYXlBZmF5RXhRUU5CQkNBdUd5RVVJQUFvQWlnaU1pQVBJQ1Z4UVFOMGFpSXFRUVJxSVF3Z0FDZ0NpQUVpQkVIL0h5QUVRZjhmU1JzaElDQU5RUVJxSVNJZ0QwRUphaUVLSUE4Z0FDZ0NEQ0kwYXlFVklCd2dOR29oS3lBV0tBSjhJU0VnQUNnQ2dBRWhCeUEySVJFZ0xDRUVBMEFDUUFKL0FuOGdCRUVEUmdSQUlBSW9BZ0JCZjJvTUFRc2dBaUFFUVFKMGFpZ0NBQXNpQ0VGL2FpSUZJQlZKQkVBZ0RVRUVFQjhnRFNBSWEwRUVFQjlIRFFJZ0lpQWlJQWhySUJBUUhRd0JDeUFGSURGUERRRWdOQ0FQSUFocklnVkJmM05xUVFOSkRRRWdEVUVFRUI4Z0JTQXdhaUlGUVFRUUgwY05BU0FpSUFWQkJHb2dFQ0FuSUNzUUlBdEJCR29pQlNBUlRRMEFJQnNnQzBFRGRHb2lCaUFGTmdJRUlBWWdCQ0FzYXpZQ0FDQUxRUUZxSVFzZ0JTQWdTdzBNSUFVaUVTQU5haUFRUmcwTUN5QUVRUUZxSWdRZ0ZFa05BQXNnTFNBUE5nSUFRWDhnQjNSQmYzTWhCUUpBSUFrZ0tVa0VRQ0FGSVFjTUFRc2dEMEVDYWlFVVFRQWhCa0VBSVJVRFFDQU5JQVlnRlNBR0lCVkpHeUlFYWlBSklCeHFJaUFnQkdvZ0VCQWRJQVJxSWdRZ0VVc0VRQ0FiSUF0QkEzUnFJZ2NnQkRZQ0JDQUhJQlFnQ1dzMkFnQWdCQ0FKYWlBS0lBUWdDaUFKYTBzYklRb2dDMEVCYWlFTElBUWdEV29nRUVZZ0JFR0FJRXR5RFFZZ0JDRVJDeUF5SUFrZ0pYRkJBM1JxSVFnQ1FBSkFJQVFnSUdvdEFBQWdCQ0FOYWkwQUFFa0VRQ0FxSUFrMkFnQWdDU0FtU3cwQklCZEJRR3NoS2lBRklRY01CQXNnRENBSk5nSUFJQWtnSmtzRVFDQUlJUXdnQkNFVkRBSUxJQmRCUUdzaERDQUZJUWNNQXdzZ0JDRUdJQWhCQkdvaUtpRUlDeUFGUVg5cUlnY2dCVThOQVNBSElRVWdDQ2dDQUNJSklDbFBEUUFMQ3lBTVFRQTJBZ0FnS2tFQU5nSUFJQWRGRFFnZ0ZpZ0NJQ0FOSUNGQkJCQWVRUUowYWlnQ0FDSUlJQmxORFFnZ0ZpZ0NLQ0VnSUE5QkFtb2hEQ0FjSUI5cUlSVkJBQ0VKUVFBaEJRTkFJQTBnQ1NBRklBa2dCVWtiSWdScUlBZ2dIV29nQkdvZ0VDQW5JQ3NRSUNBRWFpSUVJQkZMQkVBZ0d5QUxRUU4wYWlJR0lBUTJBZ1FnQmlBTUlBZ2dIMm9pQm1zMkFnQWdCQ0FHYWlBS0lBUWdDaUFHYTBzYklRb2dDMEVCYWlFTElBUkJnQ0JMRFFvZ0JDSVJJQTFxSUJCR0RRb0xJQWdnTDAwTkNTQUhRWDlxSWdkRkRRa2dCQ0FKSUIwZ0ZTQUVJQWhxSUI1Skd5QUlhaUFFYWkwQUFDQUVJQTFxTFFBQVNTSUdHeUVKSUFVZ0JDQUdHeUVGSUNBZ0NDQW9jVUVEZEdvZ0JrRUNkR29vQWdBaUNDQVpTdzBBQ3d3SUMwRUFJUXRCQUNBTklBQW9BZ1FpSEdzaUQwRi9JQUFvQW5oQmYycDBRWDl6SWlWcklnUWdCQ0FQU3hzaEppQUFLQUlnSUEwZ0FDZ0NmRUVGRUI1QkFuUnFJaTBvQWdBaENTQUFLQUp3SWhZb0FnQWlKeUFXS0FJRUloMXJJaDVCZnlBV0tBSjRRWDlxZEVGL2N5SW9heUFXS0FJUUloa2dIaUFaYXlBb1N4c2hMeUFBS0FJUUlBQW9BaFFnRHlBQUtBSjBFQ2NpQkVFQklBUWJJU2tnSFNBRUlCNXJJaDlySVRBZ0R5QVpheUFmYXlFeFFRTkJCQ0F1R3lFVUlBQW9BaWdpTWlBUElDVnhRUU4wYWlJcVFRUnFJUXdnQUNnQ2lBRWlCRUgvSHlBRVFmOGZTUnNoSUNBTlFRUnFJU0lnRDBFSmFpRUtJQThnQUNnQ0RDSTBheUVWSUJ3Z05Hb2hLeUFXS0FKOElTRWdBQ2dDZ0FFaEJ5QTJJUkVnTENFRUEwQUNRQUovQW44Z0JFRURSZ1JBSUFJb0FnQkJmMm9NQVFzZ0FpQUVRUUowYWlnQ0FBc2lDRUYvYWlJRklCVkpCRUFnRFVFRUVCOGdEU0FJYTBFRUVCOUhEUUlnSWlBaUlBaHJJQkFRSFF3QkN5QUZJREZQRFFFZ05DQVBJQWhySWdWQmYzTnFRUU5KRFFFZ0RVRUVFQjhnQlNBd2FpSUZRUVFRSDBjTkFTQWlJQVZCQkdvZ0VDQW5JQ3NRSUF0QkJHb2lCU0FSVFEwQUlCc2dDMEVEZEdvaUJpQUZOZ0lFSUFZZ0JDQXNhellDQUNBTFFRRnFJUXNnQlNBZ1N3MExJQVVpRVNBTmFpQVFSZzBMQ3lBRVFRRnFJZ1FnRkVrTkFBc2dMU0FQTmdJQVFYOGdCM1JCZjNNaEJRSkFJQWtnS1VrRVFDQUZJUWNNQVFzZ0QwRUNhaUVVUVFBaEJrRUFJUlVEUUNBTklBWWdGU0FHSUJWSkd5SUVhaUFKSUJ4cUlpQWdCR29nRUJBZElBUnFJZ1FnRVVzRVFDQWJJQXRCQTNScUlnY2dCRFlDQkNBSElCUWdDV3MyQWdBZ0JDQUphaUFLSUFRZ0NpQUphMHNiSVFvZ0MwRUJhaUVMSUFRZ0RXb2dFRVlnQkVHQUlFdHlEUVlnQkNFUkN5QXlJQWtnSlhGQkEzUnFJUWdDUUFKQUlBUWdJR290QUFBZ0JDQU5haTBBQUVrRVFDQXFJQWsyQWdBZ0NTQW1TdzBCSUJkQlFHc2hLaUFGSVFjTUJBc2dEQ0FKTmdJQUlBa2dKa3NFUUNBSUlRd2dCQ0VWREFJTElCZEJRR3NoRENBRklRY01Bd3NnQkNFR0lBaEJCR29pS2lFSUN5QUZRWDlxSWdjZ0JVOE5BU0FISVFVZ0NDZ0NBQ0lKSUNsUERRQUxDeUFNUVFBMkFnQWdLa0VBTmdJQUlBZEZEUVlnRmlnQ0lDQU5JQ0ZCQlJBZVFRSjBhaWdDQUNJSUlCbE5EUVlnRmlnQ0tDRWdJQTlCQW1vaERDQWNJQjlxSVJWQkFDRUpRUUFoQlFOQUlBMGdDU0FGSUFrZ0JVa2JJZ1JxSUFnZ0hXb2dCR29nRUNBbklDc1FJQ0FFYWlJRUlCRkxCRUFnR3lBTFFRTjBhaUlHSUFRMkFnUWdCaUFNSUFnZ0gyb2lCbXMyQWdBZ0JDQUdhaUFLSUFRZ0NpQUdhMHNiSVFvZ0MwRUJhaUVMSUFSQmdDQkxEUWdnQkNJUklBMXFJQkJHRFFnTElBZ2dMMDBOQnlBSFFYOXFJZ2RGRFFjZ0JDQUpJQjBnRlNBRUlBaHFJQjVKR3lBSWFpQUVhaTBBQUNBRUlBMXFMUUFBU1NJR0d5RUpJQVVnQkNBR0d5RUZJQ0FnQ0NBb2NVRURkR29nQmtFQ2RHb29BZ0FpQ0NBWlN3MEFDd3dHQzBFQUlRdEJBQ0FOSUFBb0FnUWlIR3NpRDBGL0lBQW9BbmhCZjJwMFFYOXpJaVZySWdRZ0JDQVBTeHNoSmlBQUtBSWdJQTBnQUNnQ2ZFRUdFQjVCQW5ScUlpMG9BZ0FoQ1NBQUtBSndJaFlvQWdBaUp5QVdLQUlFSWgxckloNUJmeUFXS0FKNFFYOXFkRUYvY3lJb2F5QVdLQUlRSWhrZ0hpQVpheUFvU3hzaEx5QUFLQUlRSUFBb0FoUWdEeUFBS0FKMEVDY2lCRUVCSUFRYklTa2dIU0FFSUI1ckloOXJJVEFnRHlBWmF5QWZheUV4UVFOQkJDQXVHeUVVSUFBb0FpZ2lNaUFQSUNWeFFRTjBhaUlxUVFScUlRd2dBQ2dDaUFFaUJFSC9IeUFFUWY4ZlNSc2hJQ0FOUVFScUlTSWdEMEVKYWlFS0lBOGdBQ2dDRENJMGF5RVZJQndnTkdvaEt5QVdLQUo4SVNFZ0FDZ0NnQUVoQnlBMklSRWdMQ0VFQTBBQ1FBSi9BbjhnQkVFRFJnUkFJQUlvQWdCQmYyb01BUXNnQWlBRVFRSjBhaWdDQUFzaUNFRi9haUlGSUJWSkJFQWdEVUVFRUI4Z0RTQUlhMEVFRUI5SERRSWdJaUFpSUFocklCQVFIUXdCQ3lBRklERlBEUUVnTkNBUElBaHJJZ1ZCZjNOcVFRTkpEUUVnRFVFRUVCOGdCU0F3YWlJRlFRUVFIMGNOQVNBaUlBVkJCR29nRUNBbklDc1FJQXRCQkdvaUJTQVJUUTBBSUJzZ0MwRURkR29pQmlBRk5nSUVJQVlnQkNBc2F6WUNBQ0FMUVFGcUlRc2dCU0FnU3cwS0lBVWlFU0FOYWlBUVJnMEtDeUFFUVFGcUlnUWdGRWtOQUFzZ0xTQVBOZ0lBUVg4Z0IzUkJmM01oQlFKQUlBa2dLVWtFUUNBRklRY01BUXNnRDBFQ2FpRVVRUUFoQmtFQUlSVURRQ0FOSUFZZ0ZTQUdJQlZKR3lJRWFpQUpJQnhxSWlBZ0JHb2dFQkFkSUFScUlnUWdFVXNFUUNBYklBdEJBM1JxSWdjZ0JEWUNCQ0FISUJRZ0NXczJBZ0FnQkNBSmFpQUtJQVFnQ2lBSmEwc2JJUW9nQzBFQmFpRUxJQVFnRFdvZ0VFWWdCRUdBSUV0eURRWWdCQ0VSQ3lBeUlBa2dKWEZCQTNScUlRZ0NRQUpBSUFRZ0lHb3RBQUFnQkNBTmFpMEFBRWtFUUNBcUlBazJBZ0FnQ1NBbVN3MEJJQmRCUUdzaEtpQUZJUWNNQkFzZ0RDQUpOZ0lBSUFrZ0prc0VRQ0FJSVF3Z0JDRVZEQUlMSUJkQlFHc2hEQ0FGSVFjTUF3c2dCQ0VHSUFoQkJHb2lLaUVJQ3lBRlFYOXFJZ2NnQlU4TkFTQUhJUVVnQ0NnQ0FDSUpJQ2xQRFFBTEN5QU1RUUEyQWdBZ0trRUFOZ0lBSUFkRkRRUWdGaWdDSUNBTklDRkJCaEFlUVFKMGFpZ0NBQ0lJSUJsTkRRUWdGaWdDS0NFZ0lBOUJBbW9oRENBY0lCOXFJUlZCQUNFSlFRQWhCUU5BSUEwZ0NTQUZJQWtnQlVrYklnUnFJQWdnSFdvZ0JHb2dFQ0FuSUNzUUlDQUVhaUlFSUJGTEJFQWdHeUFMUVFOMGFpSUdJQVEyQWdRZ0JpQU1JQWdnSDJvaUJtczJBZ0FnQkNBR2FpQUtJQVFnQ2lBR2Ewc2JJUW9nQzBFQmFpRUxJQVJCZ0NCTERRWWdCQ0lSSUExcUlCQkdEUVlMSUFnZ0wwME5CU0FIUVg5cUlnZEZEUVVnQkNBSklCMGdGU0FFSUFocUlCNUpHeUFJYWlBRWFpMEFBQ0FFSUExcUxRQUFTU0lHR3lFSklBVWdCQ0FHR3lFRklDQWdDQ0FvY1VFRGRHb2dCa0VDZEdvb0FnQWlDQ0FaU3cwQUN3d0VDeUFLUVFBMkFnQWdERUVBTmdJQURBWUxJQXhCQURZQ0FDQXFRUUEyQWdBTUJBc2dERUVBTmdJQUlDcEJBRFlDQUF3Q0N5QU1RUUEyQWdBZ0trRUFOZ0lBQ3lBQUlBcEJlR28yQWhnTUF3c2dBQ0FLUVhocU5nSVlEQUlMSUFBZ0NrRjRhallDR0F3QkN5QUFJQk5CZUdvMkFoZ0xJQXRGRFFBZ0pDQUNLQUlBTmdJUUlDUWdBaWdDQkRZQ0ZDQUNLQUlJSVFRZ0pDQXVOZ0lNSUNSQkFEWUNDQ0FrSUFRMkFoZ2dKQ0FESUM0Z05VRUFFRmdpQmpZQ0FDQWJJQXRCZjJwQkEzUnFJZ1FvQWdRaUNDQTVTd1JBSUFRb0FnQWhCUXdEQzBFQklRUkJBQ0ExUVFBUUxTRUZBMEFnSkNBRVFSeHNha0dBZ0lDQUJEWUNBQ0FFUVFGcUlnUWdOMGNOQUFzZ0JTQUdhaUVSUVFBaENpQTNJUWdEUUNBYklBcEJBM1JxSWdRb0FnUWhEQ0FYUVVCcklBSWdCQ2dDQUNJVklDd1FQeUFJSUF4TkJFQWdGVUVCYWhBa0lpQkJDWFJCczdSL2FrRXpJQ0JCRTBzYklRWWdJRUVJZEVHQUlHb2hCUU5BSUFoQmZXb2hCQUovSUFBb0FtUkJBVVlFUUNBRUVDNGdCV29NQVFzZ0FDZ0NZQ0FHYWlBQUtBSTRJQ0JCQW5ScUtBSUFFQzVySUFBb0FseHFJQVFRUEVFQ2RDSUVRWkNrQVdvb0FnQWdJR3BCQ0hScUlBQW9BalFnQkdvb0FnQVFMbXNMSVFjZ0pDQUlRUnhzYWlJRUlDNDJBZ3dnQkNBVk5nSUVJQVFnQ0RZQ0NDQUVJQWNnRVdvMkFnQWdCQ0FYS1FOQU53SVFJQVFnRnlnQ1NEWUNHQ0FJUVFGcUlnZ2dERTBOQUFzTElBcEJBV29pQ2lBTFJ3MEFDMEVCSVJFQ1FDQUlRWDlxSWdSRkJFQkJBQ0VFREFFTEEwQkJBU0VISUNRZ0VVRi9ha0VjYkdvaUJpZ0NDRVVFUUNBR0tBSU1RUUZxSVFjTElBMGdFV29pRWtGL2FrRUJJRFZCQUJCU0lBWW9BZ0JxSUFjZ05VRUFFQzFxSUFkQmYyb2dOVUVBRUMxcklnVWdKQ0FSUVJ4c2FpSXpLQUlBSWhWTUJFQWdNeUFITmdJTUlETkNBRGNDQkNBeklBVTJBZ0FnTXlBR0tBSVlOZ0lZSURNZ0Jpa0NFRGNDRUNBRklSVUxJQklnT0VzRWZ5QVJRUUZxQlNBRUlCRkdCRUFnRVNFRURBTUxBa0FnSkNBUlFRRnFJaUJCSEd4cUtBSUFJQlZCZ0FGcVRBMEFRUUFoTGlBektBSUlJZ3BGQkVBZ015Z0NEQ0V1QzBFQUlEVkJBQkF0SVRRZ0FDZ0NCQ0lMSUFBb0FoZ2lCMm9nRWtzTkFDQUFLQUtFQVNFR0lBY2dFaUFMYXlJRlNRUkFBMEFnQUNBSElBdHFJQkFnQmtFQUVFRWdCMm9pQnlBRlNRMEFDd3NnQ2tFQVJ5RXNJRE5CRUdvaEtpQUFJQVUyQWhnQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBR1FYMXFEZ1VBQVFJREF3RUxRUUFoRTBFQUlCSWdBQ2dDQkNJUGF5SWFRWDhnQUNnQ2VFRi9hblJCZjNNaUltc2lCU0FGSUJwTEd5RWxJQUFvQWlBZ0VpQUFLQUo4UVFNUUhrRUNkR29pTFNnQ0FDRU9JQUFvQW5BaUl5Z0NBQ0ltSUNNb0FnUWlHV3NpSEVGL0lDTW9BbmhCZjJwMFFYOXpJaWRySUNNb0FoQWlGaUFjSUJacklDZExHeUV2SUFBb0FoQWdBQ2dDRkNBYUlBQW9BblFRSnlJRlFRRWdCUnNoSFNBWklBVWdIR3NpSG1zaE1DQWFJQlpySUI1cklTRkJCRUVESUFvYklSUWdBQ2dDS0NJeElCb2dJbkZCQTNScUlneEJCR29oQ1NBQUtBS0lBU0lGUWY4ZklBVkIveDlKR3lFb0lCSkJBMm9oSHlBYVFRbHFJUmdnR2lBQUtBSU1JaWxySVFnZ0R5QXBhaUVySUNNb0Fud2hNaUFBS0FLQUFTRUtJRFloQ3lBc0lRY0RRQUpBQW44Q2Z5QUhRUU5HQkVBZ0tpZ0NBRUYvYWd3QkN5QXpJQWRCQW5ScUtBSVFDeUlGUVg5cUlnWWdDRWtFUUNBU1FRTVFIeUFTSUFWclFRTVFIMGNOQWlBZklCOGdCV3NnRUJBZERBRUxJQVlnSVU4TkFTQXBJQm9nQldzaUJVRi9jMnBCQTBrTkFTQVNRUU1RSHlBRklEQnFJZ1ZCQXhBZlJ3MEJJQjhnQlVFRGFpQVFJQ1lnS3hBZ0MwRURhaUlGSUF0TkRRQWdHeUFUUVFOMGFpSUdJQVUyQWdRZ0JpQUhJQ3hyTmdJQUlCTkJBV29oRXlBRklDaExEUTBnQlNJTElCSnFJQkJHRFEwTElBZEJBV29pQnlBVVNRMEFDd0pBSUF0QkFrc05BRUVDSVFzZ0R5QUFLQUljSUFBb0FpUWdGMEhjQUdvZ0VoQkFJZ1VnSFVrTkFDQWFJQVZySWdaQi8vOFBTdzBBSUJJZ0JTQVBhaUFRRUIwaUJVRURTUTBBSUJzZ0JUWUNCQ0FiSUFaQkFtbzJBZ0FnQlNBb1RRUkFRUUVoRXlBRklnc2dFbW9nRUVjTkFRdEJBU0VUSUFBZ0drRUJhallDR0F3TUN5QXRJQm8yQWdCQmZ5QUtkRUYvY3lFS0FrQWdEaUFkU1FSQUlBb2hCZ3dCQ3lBYVFRSnFJU0ZCQUNFSVFRQWhCd05BSUJJZ0NDQUhJQWdnQjBrYklnVnFJQTRnRDJvaUZDQUZhaUFRRUIwZ0JXb2lCaUFMU3dSQUlCc2dFMEVEZEdvaUJTQUdOZ0lFSUFVZ0lTQU9hellDQUNBR0lBNXFJQmdnQmlBWUlBNXJTeHNoR0NBVFFRRnFJUk1nQmlBU2FpQVFSaUFHUVlBZ1MzSU5CaUFHSVFzTElERWdEaUFpY1VFRGRHb2hCUUpBQWtBZ0JpQVVhaTBBQUNBR0lCSnFMUUFBU1FSQUlBd2dEallDQUNBT0lDVkxEUUVnRjBGQWF5RU1JQW9oQmd3RUN5QUpJQTQyQWdBZ0RpQWxTd1JBSUFVaENTQUdJUWNNQWdzZ0YwRkFheUVKSUFvaEJnd0RDeUFHSVFnZ0JVRUVhaUlNSVFVTElBcEJmMm9pQmlBS1R3MEJJQVloQ2lBRktBSUFJZzRnSFU4TkFBc0xJQWxCQURZQ0FDQU1RUUEyQWdBZ0JrVU5DaUFqS0FJZ0lCSWdNa0VERUI1QkFuUnFLQUlBSWdVZ0ZrME5DaUFqS0FJb0lRa2dHa0VDYWlFTUlBOGdIbW9oQ0VFQUlRNUJBQ0VLQTBBZ0VpQU9JQW9nRGlBS1NSc2lCMm9nQlNBWmFpQUhhaUFRSUNZZ0t4QWdJQWRxSWdjZ0Mwc0VRQ0FiSUJOQkEzUnFJZ3NnQnpZQ0JDQUxJQXdnQlNBZWFpSUxhellDQUNBSElBdHFJQmdnQnlBWUlBdHJTeHNoR0NBVFFRRnFJUk1nQjBHQUlFc05EQ0FISWdzZ0Vtb2dFRVlOREFzZ0JTQXZUUTBMSUFaQmYyb2lCa1VOQ3lBSElBNGdHU0FJSUFVZ0Iyb2dIRWtiSUFWcUlBZHFMUUFBSUFjZ0Vtb3RBQUJKSWhRYklRNGdDaUFISUJRYklRb2dDU0FGSUNkeFFRTjBhaUFVUVFKMGFpZ0NBQ0lGSUJaTERRQUxEQW9MUVFBaEUwRUFJQklnQUNnQ0JDSVdheUlZUVg4Z0FDZ0NlRUYvYW5SQmYzTWlIMnNpQlNBRklCaExHeUVpSUFBb0FpQWdFaUFBS0FKOFFRUVFIa0VDZEdvaUt5Z0NBQ0VPSUFBb0FuQWlJeWdDQUNJbElDTW9BZ1FpR1dzaUhFRi9JQ01vQW5oQmYycDBRWDl6SWlacklDTW9BaEFpRHlBY0lBOXJJQ1pMR3lFdElBQW9BaEFnQUNnQ0ZDQVlJQUFvQW5RUUp5SUZRUUVnQlJzaEp5QVpJQVVnSEdzaUhXc2hMeUFZSUE5cklCMXJJVEJCQkVFRElBb2JJU0VnQUNnQ0tDSXhJQmdnSDNGQkEzUnFJZ2xCQkdvaERDQUFLQUtJQVNJRlFmOGZJQVZCL3g5Skd5RVVJQkpCQkdvaEhpQVlRUWxxSVJvZ0dDQUFLQUlNSWlocklRZ2dGaUFvYWlFcElDTW9BbndoTWlBQUtBS0FBU0VLSURZaEN5QXNJUWNEUUFKQUFuOENmeUFIUVFOR0JFQWdLaWdDQUVGL2Fnd0JDeUF6SUFkQkFuUnFLQUlRQ3lJRlFYOXFJZ1lnQ0VrRVFDQVNRUVFRSHlBU0lBVnJRUVFRSDBjTkFpQWVJQjRnQldzZ0VCQWREQUVMSUFZZ01FOE5BU0FvSUJnZ0JXc2lCVUYvYzJwQkEwa05BU0FTUVFRUUh5QUZJQzlxSWdWQkJCQWZSdzBCSUI0Z0JVRUVhaUFRSUNVZ0tSQWdDMEVFYWlJRklBdE5EUUFnR3lBVFFRTjBhaUlHSUFVMkFnUWdCaUFISUN4ck5nSUFJQk5CQVdvaEV5QUZJQlJMRFF3Z0JTSUxJQkpxSUJCR0RRd0xJQWRCQVdvaUJ5QWhTUTBBQ3lBcklCZzJBZ0JCZnlBS2RFRi9jeUVLQWtBZ0RpQW5TUVJBSUFvaEJnd0JDeUFZUVFKcUlTRkJBQ0VJUVFBaEJ3TkFJQklnQ0NBSElBZ2dCMGtiSWdWcUlBNGdGbW9pRkNBRmFpQVFFQjBnQldvaUJpQUxTd1JBSUJzZ0UwRURkR29pQlNBR05nSUVJQVVnSVNBT2F6WUNBQ0FHSUE1cUlCb2dCaUFhSUE1clN4c2hHaUFUUVFGcUlSTWdCaUFTYWlBUVJpQUdRWUFnUzNJTkJpQUdJUXNMSURFZ0RpQWZjVUVEZEdvaEJRSkFBa0FnQmlBVWFpMEFBQ0FHSUJKcUxRQUFTUVJBSUFrZ0RqWUNBQ0FPSUNKTERRRWdGMEZBYXlFSklBb2hCZ3dFQ3lBTUlBNDJBZ0FnRGlBaVN3UkFJQVVoRENBR0lRY01BZ3NnRjBGQWF5RU1JQW9oQmd3REN5QUdJUWdnQlVFRWFpSUpJUVVMSUFwQmYyb2lCaUFLVHcwQklBWWhDaUFGS0FJQUlnNGdKMDhOQUFzTElBeEJBRFlDQUNBSlFRQTJBZ0FnQmtVTkNDQWpLQUlnSUJJZ01rRUVFQjVCQW5ScUtBSUFJZ1VnRDAwTkNDQWpLQUlvSVFrZ0dFRUNhaUVNSUJZZ0hXb2hDRUVBSVE1QkFDRUtBMEFnRWlBT0lBb2dEaUFLU1JzaUIyb2dCU0FaYWlBSGFpQVFJQ1VnS1JBZ0lBZHFJZ2NnQzBzRVFDQWJJQk5CQTNScUlnc2dCellDQkNBTElBd2dCU0FkYWlJTGF6WUNBQ0FISUF0cUlCb2dCeUFhSUF0clN4c2hHaUFUUVFGcUlSTWdCMEdBSUVzTkNpQUhJZ3NnRW1vZ0VFWU5DZ3NnQlNBdFRRMEpJQVpCZjJvaUJrVU5DU0FISUE0Z0dTQUlJQVVnQjJvZ0hFa2JJQVZxSUFkcUxRQUFJQWNnRW1vdEFBQkpJaFFiSVE0Z0NpQUhJQlFiSVFvZ0NTQUZJQ1p4UVFOMGFpQVVRUUowYWlnQ0FDSUZJQTlMRFFBTERBZ0xRUUFoRTBFQUlCSWdBQ2dDQkNJV2F5SVlRWDhnQUNnQ2VFRi9hblJCZjNNaUgyc2lCU0FGSUJoTEd5RWlJQUFvQWlBZ0VpQUFLQUo4UVFVUUhrRUNkR29pS3lnQ0FDRU9JQUFvQW5BaUl5Z0NBQ0lsSUNNb0FnUWlHV3NpSEVGL0lDTW9BbmhCZjJwMFFYOXpJaVpySUNNb0FoQWlEeUFjSUE5cklDWkxHeUV0SUFBb0FoQWdBQ2dDRkNBWUlBQW9BblFRSnlJRlFRRWdCUnNoSnlBWklBVWdIR3NpSFdzaEx5QVlJQTlySUIxcklUQkJCRUVESUFvYklTRWdBQ2dDS0NJeElCZ2dIM0ZCQTNScUlnbEJCR29oRENBQUtBS0lBU0lGUWY4ZklBVkIveDlKR3lFVUlCSkJCR29oSGlBWVFRbHFJUm9nR0NBQUtBSU1JaWhySVFnZ0ZpQW9haUVwSUNNb0Fud2hNaUFBS0FLQUFTRUtJRFloQ3lBc0lRY0RRQUpBQW44Q2Z5QUhRUU5HQkVBZ0tpZ0NBRUYvYWd3QkN5QXpJQWRCQW5ScUtBSVFDeUlGUVg5cUlnWWdDRWtFUUNBU1FRUVFIeUFTSUFWclFRUVFIMGNOQWlBZUlCNGdCV3NnRUJBZERBRUxJQVlnTUU4TkFTQW9JQmdnQldzaUJVRi9jMnBCQTBrTkFTQVNRUVFRSHlBRklDOXFJZ1ZCQkJBZlJ3MEJJQjRnQlVFRWFpQVFJQ1VnS1JBZ0MwRUVhaUlGSUF0TkRRQWdHeUFUUVFOMGFpSUdJQVUyQWdRZ0JpQUhJQ3hyTmdJQUlCTkJBV29oRXlBRklCUkxEUXNnQlNJTElCSnFJQkJHRFFzTElBZEJBV29pQnlBaFNRMEFDeUFySUJnMkFnQkJmeUFLZEVGL2N5RUtBa0FnRGlBblNRUkFJQW9oQmd3QkN5QVlRUUpxSVNGQkFDRUlRUUFoQndOQUlCSWdDQ0FISUFnZ0Iwa2JJZ1ZxSUE0Z0Ztb2lGQ0FGYWlBUUVCMGdCV29pQmlBTFN3UkFJQnNnRTBFRGRHb2lCU0FHTmdJRUlBVWdJU0FPYXpZQ0FDQUdJQTVxSUJvZ0JpQWFJQTVyU3hzaEdpQVRRUUZxSVJNZ0JpQVNhaUFRUmlBR1FZQWdTM0lOQmlBR0lRc0xJREVnRGlBZmNVRURkR29oQlFKQUFrQWdCaUFVYWkwQUFDQUdJQkpxTFFBQVNRUkFJQWtnRGpZQ0FDQU9JQ0pMRFFFZ0YwRkFheUVKSUFvaEJnd0VDeUFNSUE0MkFnQWdEaUFpU3dSQUlBVWhEQ0FHSVFjTUFnc2dGMEZBYXlFTUlBb2hCZ3dEQ3lBR0lRZ2dCVUVFYWlJSklRVUxJQXBCZjJvaUJpQUtUdzBCSUFZaENpQUZLQUlBSWc0Z0owOE5BQXNMSUF4QkFEWUNBQ0FKUVFBMkFnQWdCa1VOQmlBaktBSWdJQklnTWtFRkVCNUJBblJxS0FJQUlnVWdEMDBOQmlBaktBSW9JUWtnR0VFQ2FpRU1JQllnSFdvaENFRUFJUTVCQUNFS0EwQWdFaUFPSUFvZ0RpQUtTUnNpQjJvZ0JTQVphaUFIYWlBUUlDVWdLUkFnSUFkcUlnY2dDMHNFUUNBYklCTkJBM1JxSWdzZ0J6WUNCQ0FMSUF3Z0JTQWRhaUlMYXpZQ0FDQUhJQXRxSUJvZ0J5QWFJQXRyU3hzaEdpQVRRUUZxSVJNZ0IwR0FJRXNOQ0NBSElnc2dFbW9nRUVZTkNBc2dCU0F0VFEwSElBWkJmMm9pQmtVTkJ5QUhJQTRnR1NBSUlBVWdCMm9nSEVrYklBVnFJQWRxTFFBQUlBY2dFbW90QUFCSkloUWJJUTRnQ2lBSElCUWJJUW9nQ1NBRklDWnhRUU4wYWlBVVFRSjBhaWdDQUNJRklBOUxEUUFMREFZTFFRQWhFMEVBSUJJZ0FDZ0NCQ0lXYXlJWVFYOGdBQ2dDZUVGL2FuUkJmM01pSDJzaUJTQUZJQmhMR3lFaUlBQW9BaUFnRWlBQUtBSjhRUVlRSGtFQ2RHb2lLeWdDQUNFT0lBQW9BbkFpSXlnQ0FDSWxJQ01vQWdRaUdXc2lIRUYvSUNNb0FuaEJmMnAwUVg5eklpWnJJQ01vQWhBaUR5QWNJQTlySUNaTEd5RXRJQUFvQWhBZ0FDZ0NGQ0FZSUFBb0FuUVFKeUlGUVFFZ0JSc2hKeUFaSUFVZ0hHc2lIV3NoTHlBWUlBOXJJQjFySVRCQkJFRURJQW9iSVNFZ0FDZ0NLQ0l4SUJnZ0gzRkJBM1JxSWd4QkJHb2hDU0FBS0FLSUFTSUZRZjhmSUFWQi94OUpHeUVVSUJKQkJHb2hIaUFZUVFscUlSb2dHQ0FBS0FJTUlpaHJJUWdnRmlBb2FpRXBJQ01vQW53aE1pQUFLQUtBQVNFS0lEWWhDeUFzSVFjRFFBSkFBbjhDZnlBSFFRTkdCRUFnS2lnQ0FFRi9hZ3dCQ3lBeklBZEJBblJxS0FJUUN5SUZRWDlxSWdZZ0NFa0VRQ0FTUVFRUUh5QVNJQVZyUVFRUUgwY05BaUFlSUI0Z0JXc2dFQkFkREFFTElBWWdNRThOQVNBb0lCZ2dCV3NpQlVGL2MycEJBMGtOQVNBU1FRUVFIeUFGSUM5cUlnVkJCQkFmUncwQklCNGdCVUVFYWlBUUlDVWdLUkFnQzBFRWFpSUZJQXRORFFBZ0d5QVRRUU4wYWlJR0lBVTJBZ1FnQmlBSElDeHJOZ0lBSUJOQkFXb2hFeUFGSUJSTERRb2dCU0lMSUJKcUlCQkdEUW9MSUFkQkFXb2lCeUFoU1EwQUN5QXJJQmcyQWdCQmZ5QUtkRUYvY3lFS0FrQWdEaUFuU1FSQUlBb2hCZ3dCQ3lBWVFRSnFJU0ZCQUNFSVFRQWhCd05BSUJJZ0NDQUhJQWdnQjBrYklnVnFJQTRnRm1vaUZDQUZhaUFRRUIwZ0JXb2lCaUFMU3dSQUlCc2dFMEVEZEdvaUJTQUdOZ0lFSUFVZ0lTQU9hellDQUNBR0lBNXFJQm9nQmlBYUlBNXJTeHNoR2lBVFFRRnFJUk1nQmlBU2FpQVFSaUFHUVlBZ1MzSU5CaUFHSVFzTElERWdEaUFmY1VFRGRHb2hCUUpBQWtBZ0JpQVVhaTBBQUNBR0lCSnFMUUFBU1FSQUlBd2dEallDQUNBT0lDSkxEUUVnRjBGQWF5RU1JQW9oQmd3RUN5QUpJQTQyQWdBZ0RpQWlTd1JBSUFVaENTQUdJUWNNQWdzZ0YwRkFheUVKSUFvaEJnd0RDeUFHSVFnZ0JVRUVhaUlNSVFVTElBcEJmMm9pQmlBS1R3MEJJQVloQ2lBRktBSUFJZzRnSjA4TkFBc0xJQWxCQURZQ0FDQU1RUUEyQWdBZ0JrVU5CQ0FqS0FJZ0lCSWdNa0VHRUI1QkFuUnFLQUlBSWdVZ0QwME5CQ0FqS0FJb0lRa2dHRUVDYWlFTUlCWWdIV29oQ0VFQUlRNUJBQ0VLQTBBZ0VpQU9JQW9nRGlBS1NSc2lCMm9nQlNBWmFpQUhhaUFRSUNVZ0tSQWdJQWRxSWdjZ0Mwc0VRQ0FiSUJOQkEzUnFJZ3NnQnpZQ0JDQUxJQXdnQlNBZGFpSUxhellDQUNBSElBdHFJQm9nQnlBYUlBdHJTeHNoR2lBVFFRRnFJUk1nQjBHQUlFc05CaUFISWdzZ0Vtb2dFRVlOQmdzZ0JTQXRUUTBGSUFaQmYyb2lCa1VOQlNBSElBNGdHU0FJSUFVZ0Iyb2dIRWtiSUFWcUlBZHFMUUFBSUFjZ0Vtb3RBQUJKSWhRYklRNGdDaUFISUJRYklRb2dDU0FGSUNaeFFRTjBhaUFVUVFKMGFpZ0NBQ0lGSUE5TERRQUxEQVFMSUFsQkFEWUNBQ0FNUVFBMkFnQU1CZ3NnREVFQU5nSUFJQWxCQURZQ0FBd0VDeUFNUVFBMkFnQWdDVUVBTmdJQURBSUxJQWxCQURZQ0FDQU1RUUEyQWdBTElBQWdHa0Y0YWpZQ0dBd0RDeUFBSUJwQmVHbzJBaGdNQWdzZ0FDQWFRWGhxTmdJWURBRUxJQUFnR0VGNGFqWUNHQXNnRTBVTkFDQWJJQk5CZjJwQkEzUnFJZ1VvQWdRaUNDQTVTeUFJSUJGcVFZQWdUM0lOQlNBVklEUnFJUlZCQUNFSUEwQWdGMEZBYXlBcUlCc2dDRUVEZEdvaUJpZ0NBQ0lNSUN3UVB5QTNJUVVnQ0FSQUlBWkJmR29vQWdCQkFXb2hCUXNDUUNBR0tBSUVJZ2NnQlVrTkFDQU1RUUZxRUNRaUlVRUpkRUd6dEg5cVFUTWdJVUVUU3hzaENpQWhRUWgwUVlBZ2FpRUxBMEFnQjBGOWFpRUdJQWNnRVdvaEZBSi9JQUFvQW1SQkFVWUVRQ0FHRUM0Z0Myb01BUXNnQUNnQ1lDQUthaUFBS0FJNElDRkJBblJxS0FJQUVDNXJJQUFvQWx4cUlBWVFQRUVDZENJR1FaQ2tBV29vQWdBZ0lXcEJDSFJxSUFBb0FqUWdCbW9vQWdBUUxtc0xJQlZxSVFZQ1FDQVVJQVJOQkVBZ0JpQWtJQlJCSEd4cUtBSUFTQTBCREFNTEEwQWdKQ0FFUVFGcUlnUkJIR3hxUVlDQWdJQUVOZ0lBSUFRZ0ZFa05BQXNMSUNRZ0ZFRWNiR29pQ1NBdU5nSU1JQWtnRERZQ0JDQUpJQWMyQWdnZ0NTQUdOZ0lBSUFrZ0Z5a0RRRGNDRUNBSklCY29Ba2cyQWhnZ0IwRi9haUlISUFWUERRQUxDeUFJUVFGcUlnZ2dFMGNOQUFzTElDQUxJaEVnQkUwTkFBc0xJQ1FnQkVFY2JHb2lCaWdDRENFdUlBWW9BZ1FoQlNBR0tBSUFJVHNnQmlnQ0NDRUlJQmNnQmlnQ0dEWUNXQ0FYSUFZcEFoQTNBMUFnRnlBR0tRSUlOd01vSUJjZ0Jpa0NFRGNETUNBWElBWW9BaGcyQWpnZ0Z5QUdLUUlBTndNZ1FRQWdCQ0FYUVNCcUVENXJJZ1lnQmlBRVN4c2hCQXdEQ3lBTlFRRnFJUTBNQndzZ0JTZ0NBQ0VGUVFBaEJDQVJJRE1vQWdnRWZ5QUVCU0F6S0FJTUMyc2lCRUdBSUUwTkFRc2dKQ0F1TmdJb0lDUWdDRFlDSkNBa0lBVTJBaUFnSkNBN05nSWNJQ1FnRnlnQ1dEWUNOQ0FrSUJjcEExQTNBaXdNQVFzZ0pDQUVRUUZxSWhWQkhHeHFJZ1lnTGpZQ0RDQUdJQWcyQWdnZ0JpQUZOZ0lFSUFZZ096WUNBQ0FHSUJjcEExQTNBaEFnQmlBWEtBSllOZ0lZSUJVaENTQUVEUUVMUVFFaENVRUJJUlVNQVFzRFFDQVhJQ1FnQkVFY2JHb2lFU0lGUVJocUtBSUFOZ0lZSUJjZ0VTa0NFRGNERUNBWElCRXBBZ2czQXdnZ0Z5QVJLUUlBTndNQUlCY1FQaUVISUNRZ0NVRi9haUlKUVJ4c2FpSUdJQVVvQWhnMkFoZ2dCaUFSS1FJUU53SVFJQVlnRVNrQ0NEY0NDQ0FHSUJFcEFnQTNBZ0FnQkNBSFN5RUdRUUFnQkNBSGF5SUZJQVVnQkVzYklRUWdCZzBBQ3lBSklCVkxEUUVMQTBBZ0pDQUpRUnhzYWlJRUtBSU1JUW9DZnlBRElBcHFJQVFvQWdnaUVVVU5BQm9DUUFKQUlBUW9BZ1FpQzBFRFR3UkFJQUlnQWlrQ0FEY0NCQ0FMUVg1cUlRUU1BUXNDUUFKQUFrQUNRQ0FMSUFwRmFpSUZEZ1FGQVFFQUFRc2dBaWdDQUVGL2FpRUVEQUVMSUFJZ0JVRUNkR29vQWdBaEJDQUZRUUpKRFFFTElBSWdBaWdDQkRZQ0NBc2dBaUFDS0FJQU5nSUVDeUFDSUFRMkFnQUxJRFVnQ2lBRElBc2dFUkJYSUJGQmZXb2hCeUFCS0FJTUlRVUNRQUpBSUFNZ0Ntb2lCQ0E2VFFSQUlBVWdBeEFjSUFFb0Fnd2hCQ0FLUVJCTkJFQWdBU0FFSUFwcU5nSU1EQU1MSUFSQkVHb2dBMEVRYWlJSUVCd2dCRUVnYWlBRFFTQnFFQndnQ2tFeFNBMEJJQVFnQ21vaEJpQUVRVEJxSVFRRFFDQUVJQWhCSUdvaUJSQWNJQVJCRUdvZ0NFRXdhaEFjSUFVaENDQUVRU0JxSWdRZ0Jra05BQXNNQVFzZ0JTQURJQVFnT2hBaUN5QUJJQUVvQWd3Z0NtbzJBZ3dnQ2tHQWdBUkpEUUFnQVVFQk5nSWtJQUVnQVNnQ0JDQUJLQUlBYTBFRGRUWUNLQXNnQVNnQ0JDSUVJQXRCQVdvMkFnQWdCQ0FLT3dFRUlBZEJnSUFFVHdSQUlBRkJBallDSkNBQklBUWdBU2dDQUd0QkEzVTJBaWdMSUFRZ0J6c0JCaUFCSUFSQkNHbzJBZ1FnQ2lBUmFpQURhaUlEQ3lFTklBbEJBV29pQ1NBVlRRMEFDd3NnTlVFQUVGRUxJQTBnT0VrTkFBc0xJQmRCNEFCcUpBQWdFQ0FEYXdzTEFFR0k3QUVvQWdBUU9BdElBQ0FBUVVCcktBSUFFSEFFUUNBQUlBQW9BZ0JCL3dFUWZqWUNHQXNnQUNBQUtBSUVRU01RZmpZQ0hDQUFJQUFvQWdoQk5CQitOZ0lnSUFBZ0FDZ0NERUVmRUg0MkFpUUw2VDRCS1g4akFFSHdBR3NpRENRQUlBd2dBaWdDQ0RZQ1NDQU1JQUlwQWdBM0EwQWdBQ2dDaEFFaEJTQUFLQUlFSVFrZ0FDZ0NpQUVoQWlBQUtBSU1JUWNnRENBQUtBSVlOZ0pzSUFBb0Fqd2hGeUFBUVVCcktBSUFJUmdnQUVFc2FpSWlJQU1nQkVFQ0VGa2dBeUFISUFscUlBTkdhaUlQSUFNZ0JHb2lFa0Y0YWlJcFNRUkFJQUpCL3g4Z0FrSC9IMGtiSVNvZ0VrRmdhaUVyUVFOQkJDQUZRUU5HR3lJb1FYOXFJU01EUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBQUtBSUVJZ1VnQUNnQ0dDSUNhaUFQU3cwQUlBOGdBMnNoR1NBQUtBS0VBU0VKSUFJZ0R5QUZheUlIU1FSQUEwQWdBQ0FDSUFWcUlCSWdDVUVBRUVFZ0Ftb2lBaUFIU1EwQUN3c2dHVVVoSFNBQUlBYzJBaGdDUUFKQUFrQUNRQUpBSUFsQmZXb09CUUFCQWdNREFRdEJBQ0VLUVFBZ0R5QUFLQUlFSWhOcklnWkJmeUFBS0FKNFFYOXFkRUYvY3lJUWF5SUNJQUlnQmtzYklSVWdBQ2dDSUNBUElBQW9BbnhCQXhBZVFRSjBhaUlhS0FJQUlRZ2dBQ2dDRUNBQUtBSVVJQVlnQUNnQ2RCQW5JZ0pCQVNBQ0d5RU5RUU5CQkNBWkd5RWJJQUFvQWlnaUhDQUdJQkJ4UVFOMGFpSU9RUVJxSVJZZ0FDZ0NpQUVpQWtIL0h5QUNRZjhmU1JzaEN5QVBRUU5xSVJRZ0JrRUphaUVKSUFZZ0FDZ0NER3NoSGlBTUtBSkFRWDlxSVJFZ0FDZ0NnQUVoSHlBaklRVWdIU0VDQTBBZ0VTRUhJQUpCQTBjRVFDQU1RVUJySUFKQkFuUnFLQUlBSVFjTEFrQWdCMEYvYWlBZVR3MEFJQTlCQXhBZklBOGdCMnRCQXhBZlJ3MEFJQlFnRkNBSGF5QVNFQjFCQTJvaUJ5QUZUUTBBSUJjZ0NrRURkR29pQlNBSE5nSUVJQVVnQWlBZGF6WUNBQ0FLUVFGcUlRb2dCeUFMU3cwRklBY2lCU0FQYWlBU1JnMEZDeUFDUVFGcUlnSWdHMGtOQUFzQ1FDQUZRUUpMRFFCQkFpRUZJQk1nQUNnQ0hDQUFLQUlrSUF4QjdBQnFJQThRUUNJQ0lBMUpEUUFnQmlBQ2F5SUhRZi8vRDBzTkFDQVBJQUlnRTJvZ0VoQWRJZ0pCQTBrTkFDQVhJQUkyQWdRZ0Z5QUhRUUpxTmdJQUlBSWdDMDBFUUVFQklRb2dBaUlGSUE5cUlCSkhEUUVMUVFFaENpQUFJQVpCQVdvMkFoZ01CQXNnR2lBR05nSUFBa0FnQ0NBTlNRMEFJQVpCQW1vaEZFRi9JQjkwUVg5eklRdEJBQ0VHUVFBaEVRTkFJQThnQmlBUklBWWdFVWtiSWdKcUlBZ2dFMm9pR2lBQ2FpQVNFQjBnQW1vaUFpQUZTd1JBSUJjZ0NrRURkR29pQlNBQ05nSUVJQVVnRkNBSWF6WUNBQ0FDSUFocUlBa2dBaUFKSUFoclN4c2hDU0FLUVFGcUlRb2dBa0dBSUVzTkFpQUNJZ1VnRDJvZ0VrWU5BZ3NnSENBSUlCQnhRUU4wYWlFSEFrQUNRQ0FDSUJwcUxRQUFJQUlnRDJvdEFBQkpCRUFnRGlBSU5nSUFJQWdnRlVzTkFTQU1RZEFBYWlFT0RBUUxJQllnQ0RZQ0FDQUlJQlZMQkVBZ0J5RVdJQUloRVF3Q0N5QU1RZEFBYWlFV0RBTUxJQUloQmlBSFFRUnFJZzRoQndzZ0MwVU5BU0FMUVg5cUlRc2dCeWdDQUNJSUlBMVBEUUFMQ3lBV1FRQTJBZ0FnRGtFQU5nSUFJQUFnQ1VGNGFqWUNHQXdEQzBFQUlRcEJBQ0FQSUFBb0FnUWlGV3NpQmtGL0lBQW9BbmhCZjJwMFFYOXpJaE5ySWdJZ0FpQUdTeHNoRFNBQUtBSWdJQThnQUNnQ2ZFRUVFQjVCQW5ScUloUW9BZ0FoQ0NBQUtBSVFJQUFvQWhRZ0JpQUFLQUowRUNjaUFrRUJJQUliSVJCQkEwRUVJQmtiSVJvZ0FDZ0NLQ0liSUFZZ0UzRkJBM1JxSWc1QkJHb2hGaUFBS0FLSUFTSUNRZjhmSUFKQi94OUpHeUVjSUE5QkJHb2hDeUFHUVFscUlRa2dCaUFBS0FJTWF5RWVJQXdvQWtCQmYyb2hFU0FBS0FLQUFTRWZJQ01oQlNBZElRSURRQ0FSSVFjZ0FrRURSd1JBSUF4QlFHc2dBa0VDZEdvb0FnQWhCd3NDUUNBSFFYOXFJQjVQRFFBZ0QwRUVFQjhnRHlBSGEwRUVFQjlIRFFBZ0N5QUxJQWRySUJJUUhVRUVhaUlISUFWTkRRQWdGeUFLUVFOMGFpSUZJQWMyQWdRZ0JTQUNJQjFyTmdJQUlBcEJBV29oQ2lBSElCeExEUVFnQnlJRklBOXFJQkpHRFFRTElBSkJBV29pQWlBYVNRMEFDeUFVSUFZMkFnQUNRQ0FJSUJCSkRRQWdCa0VDYWlFVVFYOGdIM1JCZjNNaEMwRUFJUVpCQUNFUkEwQWdEeUFHSUJFZ0JpQVJTUnNpQW1vZ0NDQVZhaUlhSUFKcUlCSVFIU0FDYWlJQ0lBVkxCRUFnRnlBS1FRTjBhaUlGSUFJMkFnUWdCU0FVSUFock5nSUFJQUlnQ0dvZ0NTQUNJQWtnQ0d0TEd5RUpJQXBCQVdvaENpQUNRWUFnU3cwQ0lBSWlCU0FQYWlBU1JnMENDeUFiSUFnZ0UzRkJBM1JxSVFjQ1FBSkFJQUlnR21vdEFBQWdBaUFQYWkwQUFFa0VRQ0FPSUFnMkFnQWdDQ0FOU3cwQklBeEIwQUJxSVE0TUJBc2dGaUFJTmdJQUlBZ2dEVXNFUUNBSElSWWdBaUVSREFJTElBeEIwQUJxSVJZTUF3c2dBaUVHSUFkQkJHb2lEaUVIQ3lBTFJRMEJJQXRCZjJvaEN5QUhLQUlBSWdnZ0VFOE5BQXNMSUJaQkFEWUNBQ0FPUVFBMkFnQWdBQ0FKUVhocU5nSVlEQUlMUVFBaENrRUFJQThnQUNnQ0JDSVZheUlHUVg4Z0FDZ0NlRUYvYW5SQmYzTWlFMnNpQWlBQ0lBWkxHeUVOSUFBb0FpQWdEeUFBS0FKOFFRVVFIa0VDZEdvaUZDZ0NBQ0VJSUFBb0FoQWdBQ2dDRkNBR0lBQW9BblFRSnlJQ1FRRWdBaHNoRUVFRFFRUWdHUnNoR2lBQUtBSW9JaHNnQmlBVGNVRURkR29pRmtFRWFpRU9JQUFvQW9nQklnSkIveDhnQWtIL0gwa2JJUndnRDBFRWFpRUxJQVpCQ1dvaENTQUdJQUFvQWd4cklSNGdEQ2dDUUVGL2FpRVJJQUFvQW9BQklSOGdJeUVGSUIwaEFnTkFJQkVoQnlBQ1FRTkhCRUFnREVGQWF5QUNRUUowYWlnQ0FDRUhDd0pBSUFkQmYyb2dIazhOQUNBUFFRUVFIeUFQSUFkclFRUVFIMGNOQUNBTElBc2dCMnNnRWhBZFFRUnFJZ2NnQlUwTkFDQVhJQXBCQTNScUlnVWdCellDQkNBRklBSWdIV3MyQWdBZ0NrRUJhaUVLSUFjZ0hFc05BeUFISWdVZ0Qyb2dFa1lOQXdzZ0FrRUJhaUlDSUJwSkRRQUxJQlFnQmpZQ0FBSkFJQWdnRUVrTkFDQUdRUUpxSVJSQmZ5QWZkRUYvY3lFTFFRQWhCa0VBSVJFRFFDQVBJQVlnRVNBR0lCRkpHeUlDYWlBSUlCVnFJaG9nQW1vZ0VoQWRJQUpxSWdJZ0JVc0VRQ0FYSUFwQkEzUnFJZ1VnQWpZQ0JDQUZJQlFnQ0dzMkFnQWdBaUFJYWlBSklBSWdDU0FJYTBzYklRa2dDa0VCYWlFS0lBSkJnQ0JMRFFJZ0FpSUZJQTlxSUJKR0RRSUxJQnNnQ0NBVGNVRURkR29oQndKQUFrQWdBaUFhYWkwQUFDQUNJQTlxTFFBQVNRUkFJQllnQ0RZQ0FDQUlJQTFMRFFFZ0RFSFFBR29oRmd3RUN5QU9JQWcyQWdBZ0NDQU5Td1JBSUFjaERpQUNJUkVNQWdzZ0RFSFFBR29oRGd3REN5QUNJUVlnQjBFRWFpSVdJUWNMSUF0RkRRRWdDMEYvYWlFTElBY29BZ0FpQ0NBUVR3MEFDd3NnRGtFQU5nSUFJQlpCQURZQ0FDQUFJQWxCZUdvMkFoZ01BUXRCQUNFS1FRQWdEeUFBS0FJRUloVnJJZ1pCZnlBQUtBSjRRWDlxZEVGL2N5SVRheUlDSUFJZ0Jrc2JJUTBnQUNnQ0lDQVBJQUFvQW54QkJoQWVRUUowYWlJVUtBSUFJUWdnQUNnQ0VDQUFLQUlVSUFZZ0FDZ0NkQkFuSWdKQkFTQUNHeUVRUVFOQkJDQVpHeUVhSUFBb0FpZ2lHeUFHSUJOeFFRTjBhaUlXUVFScUlRNGdBQ2dDaUFFaUFrSC9IeUFDUWY4ZlNSc2hIQ0FQUVFScUlRc2dCa0VKYWlFSklBWWdBQ2dDREdzaEhpQU1LQUpBUVg5cUlSRWdBQ2dDZ0FFaEh5QWpJUVVnSFNFQ0EwQWdFU0VISUFKQkEwY0VRQ0FNUVVCcklBSkJBblJxS0FJQUlRY0xBa0FnQjBGL2FpQWVUdzBBSUE5QkJCQWZJQThnQjJ0QkJCQWZSdzBBSUFzZ0N5QUhheUFTRUIxQkJHb2lCeUFGVFEwQUlCY2dDa0VEZEdvaUJTQUhOZ0lFSUFVZ0FpQWRhellDQUNBS1FRRnFJUW9nQnlBY1N3MENJQWNpQlNBUGFpQVNSZzBDQ3lBQ1FRRnFJZ0lnR2trTkFBc2dGQ0FHTmdJQUFrQWdDQ0FRU1EwQUlBWkJBbW9oRkVGL0lCOTBRWDl6SVF0QkFDRUdRUUFoRVFOQUlBOGdCaUFSSUFZZ0VVa2JJZ0pxSUFnZ0ZXb2lHaUFDYWlBU0VCMGdBbW9pQWlBRlN3UkFJQmNnQ2tFRGRHb2lCU0FDTmdJRUlBVWdGQ0FJYXpZQ0FDQUNJQWhxSUFrZ0FpQUpJQWhyU3hzaENTQUtRUUZxSVFvZ0FrR0FJRXNOQWlBQ0lnVWdEMm9nRWtZTkFnc2dHeUFJSUJOeFFRTjBhaUVIQWtBQ1FDQUNJQnBxTFFBQUlBSWdEMm90QUFCSkJFQWdGaUFJTmdJQUlBZ2dEVXNOQVNBTVFkQUFhaUVXREFRTElBNGdDRFlDQUNBSUlBMUxCRUFnQnlFT0lBSWhFUXdDQ3lBTVFkQUFhaUVPREFNTElBSWhCaUFIUVFScUloWWhCd3NnQzBVTkFTQUxRWDlxSVFzZ0J5Z0NBQ0lJSUJCUERRQUxDeUFPUVFBMkFnQWdGa0VBTmdJQUlBQWdDVUY0YWpZQ0dBc2dDa1VOQUNBWUlBd29Ba0EyQWhBZ0dDQU1LQUpFTmdJVUlBd29Ba2doQWlBWUlCazJBZ3dnR0VFQU5nSUlJQmdnQWpZQ0dDQVlJQU1nR1NBaVFRSVFXQ0lGTmdJQUlCY2dDa0YvYWtFRGRHb2lBaWdDQkNJSElDcExCRUFnQWlnQ0FDRUxEQU1MUVFFaEFrRUFJQ0pCQWhBdElRa0RRQ0FZSUFKQkhHeHFRWUNBZ0lBRU5nSUFJQUpCQVdvaUFpQW9SdzBBQ3lBRklBbHFJUXRCQUNFSklDZ2hCd05BSUJjZ0NVRURkR29pQWlnQ0JDRUZJQXhCMEFCcUlBeEJRR3NnQWlnQ0FDSVJJQjBRUHlBSElBVk5CRUFnRVVFQmFoQWtJZ1pCQ0hSQmdDQnFJUTREUUNBSFFYMXFJUUlDZnlBQUtBSmtRUUZHQkVBZ0FoQXJJQTVxREFFTElBQW9BbUFnQUNnQ09DQUdRUUowYWlnQ0FCQXJheUFBS0FKY2FpQUNFRHhCQW5RaUFrR1FwQUZxS0FJQUlBWnFRUWgwYWlBQUtBSTBJQUpxS0FJQUVDdHJRVE5xQ3lFSUlCZ2dCMEVjYkdvaUFpQVpOZ0lNSUFJZ0VUWUNCQ0FDSUFjMkFnZ2dBaUFJSUF0cU5nSUFJQUlnRENrRFVEY0NFQ0FDSUF3b0FsZzJBaGdnQjBFQmFpSUhJQVZORFFBTEN5QUpRUUZxSWdrZ0NrY05BQXRCQVNFUkFrQWdCMEYvYWlJQ1JRUkFRUUFoQWd3QkN3TkFRUUVoQ0NBWUlCRkJmMnBCSEd4cUlna29BZ2hGQkVBZ0NTZ0NERUVCYWlFSUN5QVBJQkZxSWcxQmYycEJBU0FpUVFJUVVpQUpLQUlBYWlBSUlDSkJBaEF0YWlBSVFYOXFJQ0pCQWhBdGF5SUZJQmdnRVVFY2JHb2lGQ2dDQUNJV1RBUkFJQlFnQ0RZQ0RDQVVRZ0EzQWdRZ0ZDQUZOZ0lBSUJRZ0NTZ0NHRFlDR0NBVUlBa3BBaEEzQWhBZ0JTRVdDd0pBSUEwZ0tVc05BQ0FDSUJGR0JFQWdFU0VDREFNTFFRQWhHU0FVS0FJSUlnbEZCRUFnRkNnQ0RDRVpDMEVBSUNKQkFoQXRJUzBnQUNnQ0JDSUZJQUFvQWhnaUNHb2dEVXNOQUNBQUtBS0VBU0VISUFnZ0RTQUZheUlLU1FSQUEwQWdBQ0FGSUFocUlCSWdCMEVBRUVFZ0NHb2lDQ0FLU1EwQUN3c2dDVUVBUnlFZElCUkJFR29oR2lBQUlBbzJBaGdDUUFKQUFrQUNRQUpBSUFkQmZXb09CUUFCQWdNREFRdEJBQ0VRUVFBZ0RTQUFLQUlFSWh0cklnWkJmeUFBS0FKNFFYOXFkRUYvY3lJZWF5SUZJQVVnQmtzYklSOGdBQ2dDSUNBTklBQW9BbnhCQXhBZVFRSjBhaUloS0FJQUlRVWdBQ2dDRUNBQUtBSVVJQVlnQUNnQ2RCQW5JZ2RCQVNBSEd5RWNRUVJCQXlBSkd5RWtJQUFvQWlnaUpTQUdJQjV4UVFOMGFpSUhRUVJxSVJNZ0FDZ0NpQUVpQ1VIL0h5QUpRZjhmU1JzaERpQU5RUU5xSVNBZ0JrRUphaUVWSUFZZ0FDZ0NER3NoSmlBQUtBS0FBU0VuSUNNaENTQWRJUWdEUUFKQUFuOGdDRUVEUmdSQUlCb29BZ0JCZjJvTUFRc2dGQ0FJUVFKMGFpZ0NFQXNpQzBGL2FpQW1UdzBBSUExQkF4QWZJQTBnQzJ0QkF4QWZSdzBBSUNBZ0lDQUxheUFTRUIxQkEyb2lDaUFKVFEwQUlCY2dFRUVEZEdvaUNTQUtOZ0lFSUFrZ0NDQWRhellDQUNBUVFRRnFJUkFnQ2lBT1N3MEZJQW9pQ1NBTmFpQVNSZzBGQ3lBSVFRRnFJZ2dnSkVrTkFBc0NRQ0FKUVFKTERRQkJBaUVKSUJzZ0FDZ0NIQ0FBS0FJa0lBeEI3QUJxSUEwUVFDSUtJQnhKRFFBZ0JpQUtheUlJUWYvL0Qwc05BQ0FOSUFvZ0cyb2dFaEFkSWdwQkEwa05BQ0FYSUFvMkFnUWdGeUFJUVFKcU5nSUFJQW9nRGswRVFFRUJJUkFnQ2lJSklBMXFJQkpIRFFFTFFRRWhFQ0FBSUFaQkFXbzJBaGdNQkFzZ0lTQUdOZ0lBQWtBZ0JTQWNTUTBBSUFaQkFtb2hJRUYvSUNkMFFYOXpJUWhCQUNFS1FRQWhEZ05BSUEwZ0NpQU9JQW9nRGtrYklnWnFJQVVnRzJvaUlTQUdhaUFTRUIwZ0Jtb2lCaUFKU3dSQUlCY2dFRUVEZEdvaUNTQUdOZ0lFSUFrZ0lDQUZhellDQUNBRklBWnFJQlVnQmlBVklBVnJTeHNoRlNBUVFRRnFJUkFnQmtHQUlFc05BaUFHSWdrZ0RXb2dFa1lOQWdzZ0pTQUZJQjV4UVFOMGFpRUxBa0FDUUNBR0lDRnFMUUFBSUFZZ0RXb3RBQUJKQkVBZ0J5QUZOZ0lBSUFVZ0gwc05BU0FNUWRBQWFpRUhEQVFMSUJNZ0JUWUNBQ0FGSUI5TEJFQWdDeUVUSUFZaERnd0NDeUFNUWRBQWFpRVREQU1MSUFZaENpQUxRUVJxSWdjaEN3c2dDRVVOQVNBSVFYOXFJUWdnQ3lnQ0FDSUZJQnhQRFFBTEN5QVRRUUEyQWdBZ0IwRUFOZ0lBSUFBZ0ZVRjRhallDR0F3REMwRUFJUkJCQUNBTklBQW9BZ1FpSDJzaUJrRi9JQUFvQW5oQmYycDBRWDl6SWh0cklnVWdCU0FHU3hzaEhDQUFLQUlnSUEwZ0FDZ0NmRUVFRUI1QkFuUnFJaUFvQWdBaEJTQUFLQUlRSUFBb0FoUWdCaUFBS0FKMEVDY2lCMEVCSUFjYklSNUJCRUVESUFrYklTRWdBQ2dDS0NJa0lBWWdHM0ZCQTNScUloTkJCR29oQnlBQUtBS0lBU0lKUWY4ZklBbEIveDlKR3lFbElBMUJCR29oRGlBR1FRbHFJUlVnQmlBQUtBSU1heUVtSUFBb0FvQUJJU2NnSXlFSklCMGhDQU5BQWtBQ2Z5QUlRUU5HQkVBZ0dpZ0NBRUYvYWd3QkN5QVVJQWhCQW5ScUtBSVFDeUlMUVg5cUlDWlBEUUFnRFVFRUVCOGdEU0FMYTBFRUVCOUhEUUFnRGlBT0lBdHJJQklRSFVFRWFpSUtJQWxORFFBZ0Z5QVFRUU4wYWlJSklBbzJBZ1FnQ1NBSUlCMXJOZ0lBSUJCQkFXb2hFQ0FLSUNWTERRUWdDaUlKSUExcUlCSkdEUVFMSUFoQkFXb2lDQ0FoU1EwQUN5QWdJQVkyQWdBQ1FDQUZJQjVKRFFBZ0JrRUNhaUVnUVg4Z0ozUkJmM01oQ0VFQUlRcEJBQ0VPQTBBZ0RTQUtJQTRnQ2lBT1NSc2lCbW9nQlNBZmFpSWhJQVpxSUJJUUhTQUdhaUlHSUFsTEJFQWdGeUFRUVFOMGFpSUpJQVkyQWdRZ0NTQWdJQVZyTmdJQUlBVWdCbW9nRlNBR0lCVWdCV3RMR3lFVklCQkJBV29oRUNBR1FZQWdTdzBDSUFZaUNTQU5haUFTUmcwQ0N5QWtJQVVnRzNGQkEzUnFJUXNDUUFKQUlBWWdJV290QUFBZ0JpQU5haTBBQUVrRVFDQVRJQVUyQWdBZ0JTQWNTdzBCSUF4QjBBQnFJUk1NQkFzZ0J5QUZOZ0lBSUFVZ0hFc0VRQ0FMSVFjZ0JpRU9EQUlMSUF4QjBBQnFJUWNNQXdzZ0JpRUtJQXRCQkdvaUV5RUxDeUFJUlEwQklBaEJmMm9oQ0NBTEtBSUFJZ1VnSGs4TkFBc0xJQWRCQURZQ0FDQVRRUUEyQWdBZ0FDQVZRWGhxTmdJWURBSUxRUUFoRUVFQUlBMGdBQ2dDQkNJZmF5SUdRWDhnQUNnQ2VFRi9hblJCZjNNaUcyc2lCU0FGSUFaTEd5RWNJQUFvQWlBZ0RTQUFLQUo4UVFVUUhrRUNkR29pSUNnQ0FDRUZJQUFvQWhBZ0FDZ0NGQ0FHSUFBb0FuUVFKeUlIUVFFZ0J4c2hIa0VFUVFNZ0NSc2hJU0FBS0FJb0lpUWdCaUFiY1VFRGRHb2lFMEVFYWlFSElBQW9Bb2dCSWdsQi94OGdDVUgvSDBrYklTVWdEVUVFYWlFT0lBWkJDV29oRlNBR0lBQW9BZ3hySVNZZ0FDZ0NnQUVoSnlBaklRa2dIU0VJQTBBQ1FBSi9JQWhCQTBZRVFDQWFLQUlBUVg5cURBRUxJQlFnQ0VFQ2RHb29BaEFMSWd0QmYyb2dKazhOQUNBTlFRUVFIeUFOSUF0clFRUVFIMGNOQUNBT0lBNGdDMnNnRWhBZFFRUnFJZ29nQ1UwTkFDQVhJQkJCQTNScUlna2dDallDQkNBSklBZ2dIV3MyQWdBZ0VFRUJhaUVRSUFvZ0pVc05BeUFLSWdrZ0RXb2dFa1lOQXdzZ0NFRUJhaUlJSUNGSkRRQUxJQ0FnQmpZQ0FBSkFJQVVnSGtrTkFDQUdRUUpxSVNCQmZ5QW5kRUYvY3lFSVFRQWhDa0VBSVE0RFFDQU5JQW9nRGlBS0lBNUpHeUlHYWlBRklCOXFJaUVnQm1vZ0VoQWRJQVpxSWdZZ0NVc0VRQ0FYSUJCQkEzUnFJZ2tnQmpZQ0JDQUpJQ0FnQldzMkFnQWdCU0FHYWlBVklBWWdGU0FGYTBzYklSVWdFRUVCYWlFUUlBWkJnQ0JMRFFJZ0JpSUpJQTFxSUJKR0RRSUxJQ1FnQlNBYmNVRURkR29oQ3dKQUFrQWdCaUFoYWkwQUFDQUdJQTFxTFFBQVNRUkFJQk1nQlRZQ0FDQUZJQnhMRFFFZ0RFSFFBR29oRXd3RUN5QUhJQVUyQWdBZ0JTQWNTd1JBSUFzaEJ5QUdJUTRNQWdzZ0RFSFFBR29oQnd3REN5QUdJUW9nQzBFRWFpSVRJUXNMSUFoRkRRRWdDRUYvYWlFSUlBc29BZ0FpQlNBZVR3MEFDd3NnQjBFQU5nSUFJQk5CQURZQ0FDQUFJQlZCZUdvMkFoZ01BUXRCQUNFUVFRQWdEU0FBS0FJRUloOXJJZ1pCZnlBQUtBSjRRWDlxZEVGL2N5SWJheUlGSUFVZ0Jrc2JJUndnQUNnQ0lDQU5JQUFvQW54QkJoQWVRUUowYWlJZ0tBSUFJUVVnQUNnQ0VDQUFLQUlVSUFZZ0FDZ0NkQkFuSWdkQkFTQUhHeUVlUVFSQkF5QUpHeUVoSUFBb0FpZ2lKQ0FHSUJ0eFFRTjBhaUlUUVFScUlRY2dBQ2dDaUFFaUNVSC9IeUFKUWY4ZlNSc2hKU0FOUVFScUlRNGdCa0VKYWlFVklBWWdBQ2dDREdzaEppQUFLQUtBQVNFbklDTWhDU0FkSVFnRFFBSkFBbjhnQ0VFRFJnUkFJQm9vQWdCQmYyb01BUXNnRkNBSVFRSjBhaWdDRUFzaUMwRi9haUFtVHcwQUlBMUJCQkFmSUEwZ0MydEJCQkFmUncwQUlBNGdEaUFMYXlBU0VCMUJCR29pQ2lBSlRRMEFJQmNnRUVFRGRHb2lDU0FLTmdJRUlBa2dDQ0FkYXpZQ0FDQVFRUUZxSVJBZ0NpQWxTdzBDSUFvaUNTQU5haUFTUmcwQ0N5QUlRUUZxSWdnZ0lVa05BQXNnSUNBR05nSUFBa0FnQlNBZVNRMEFJQVpCQW1vaElFRi9JQ2QwUVg5eklRaEJBQ0VLUVFBaERnTkFJQTBnQ2lBT0lBb2dEa2tiSWdacUlBVWdIMm9pSVNBR2FpQVNFQjBnQm1vaUJpQUpTd1JBSUJjZ0VFRURkR29pQ1NBR05nSUVJQWtnSUNBRmF6WUNBQ0FGSUFacUlCVWdCaUFWSUFWclN4c2hGU0FRUVFGcUlSQWdCa0dBSUVzTkFpQUdJZ2tnRFdvZ0VrWU5BZ3NnSkNBRklCdHhRUU4wYWlFTEFrQUNRQ0FHSUNGcUxRQUFJQVlnRFdvdEFBQkpCRUFnRXlBRk5nSUFJQVVnSEVzTkFTQU1RZEFBYWlFVERBUUxJQWNnQlRZQ0FDQUZJQnhMQkVBZ0N5RUhJQVloRGd3Q0N5QU1RZEFBYWlFSERBTUxJQVloQ2lBTFFRUnFJaE1oQ3dzZ0NFVU5BU0FJUVg5cUlRZ2dDeWdDQUNJRklCNVBEUUFMQ3lBSFFRQTJBZ0FnRTBFQU5nSUFJQUFnRlVGNGFqWUNHQXNnRUVVTkFDQVhJQkJCZjJwQkEzUnFJZ1VvQWdRaUJ5QXFTeUFISUJGcVFZQWdUM0lOQkNBV0lDMXFJUTVCQUNFV0EwQWdERUhRQUdvZ0dpQVhJQlpCQTNScUlnVW9BZ0FpQ1NBZEVEOGdLQ0VHQW44Z0ZnUkFJQVZCZkdvb0FnQkJBV29oQmdzZ0JTZ0NCQ0lJSUFaUEN3UkFJQWxCQVdvUUpDSUhRUWgwUVlBZ2FpRVRBMEFnQ0VGOWFpRUtJQWdnRVdvaEJRSi9JQUFvQW1SQkFVWUVRQ0FLRUNzZ0Uyb01BUXNnQUNnQ1lDQUFLQUk0SUFkQkFuUnFLQUlBRUN0cklBQW9BbHhxSUFvUVBFRUNkQ0lLUVpDa0FXb29BZ0FnQjJwQkNIUnFJQUFvQWpRZ0Ntb29BZ0FRSzJ0Qk0yb0xJQTVxSVFvQ1FBSkFJQVVnQWswRVFDQUtJQmdnQlVFY2JHb29BZ0JJRFFFTUFnc0RRQ0FZSUFKQkFXb2lBa0VjYkdwQmdJQ0FnQVEyQWdBZ0FpQUZTUTBBQ3dzZ0dDQUZRUnhzYWlJRklCazJBZ3dnQlNBSk5nSUVJQVVnQ0RZQ0NDQUZJQW8yQWdBZ0JTQU1LUU5RTndJUUlBVWdEQ2dDV0RZQ0dBc2dDRUYvYWlJSUlBWlBEUUFMQ3lBV1FRRnFJaFlnRUVjTkFBc0xJQkZCQVdvaUVTQUNUUTBBQ3dzZ0dDQUNRUnhzYWlJRktBSU1JUmtnQlNnQ0JDRUxJQVVvQWdBaExDQUZLQUlJSVFjZ0RDQUZLQUlZTmdKb0lBd2dCU2tDRURjRFlDQU1JQVVwQWdnM0F5Z2dEQ0FGS1FJUU53TXdJQXdnQlNnQ0dEWUNPQ0FNSUFVcEFnQTNBeUJCQUNBQ0lBeEJJR29RUG1zaUJTQUZJQUpMR3lFQ0RBTUxJQTlCQVdvaER3d0hDeUFGS0FJQUlRdEJBQ0VDSUJFZ0ZDZ0NDQVIvSUFJRklCUW9BZ3dMYXlJQ1FZQWdUUTBCQ3lBWUlCazJBaWdnR0NBSE5nSWtJQmdnQ3pZQ0lDQVlJQ3cyQWh3Z0dDQU1LQUpvTmdJMElCZ2dEQ2tEWURjQ0xBd0JDeUFZSUFKQkFXb2lDa0VjYkdvaUJTQVpOZ0lNSUFVZ0J6WUNDQ0FGSUFzMkFnUWdCU0FzTmdJQUlBVWdEQ2tEWURjQ0VDQUZJQXdvQW1nMkFoZ2dDaUVaSUFJTkFRdEJBU0VaUVFFaENnd0JDd05BSUF3Z0dDQUNRUnhzYWlJRkloRkJHR29vQWdBMkFoZ2dEQ0FGS1FJUU53TVFJQXdnQlNrQ0NEY0RDQ0FNSUFVcEFnQTNBd0FnREJBK0lRY2dHQ0FaUVg5cUlobEJIR3hxSWdrZ0VTZ0NHRFlDR0NBSklBVXBBaEEzQWhBZ0NTQUZLUUlJTndJSUlBa2dCU2tDQURjQ0FDQUNJQWRMSVFWQkFDQUNJQWRySWdrZ0NTQUNTeHNoQWlBRkRRQUxJQmtnQ2tzTkFRc0RRQ0FZSUJsQkhHeHFJZ0lvQWd3aENRSi9JQU1nQ1dvZ0FpZ0NDQ0lHUlEwQUdnSkFJQUlvQWdRaUVVRURUd1JBSUF3Z0RDa0RRRGNDUkNBTUlCRkJmbW8yQWtBTUFRc0NRQUpBQWtBQ1FDQVJJQWxGYWlJQ0RnUUVBUUVBQVFzZ0RDZ0NRRUYvYWlFSERBRUxJQXhCUUdzZ0FrRUNkR29vQWdBaEJ5QUNRUUpKRFFFTElBd2dEQ2dDUkRZQ1NBc2dEQ0FNS0FKQU5nSkVJQXdnQnpZQ1FBc2dJaUFKSUFNZ0VTQUdFRmNnQmtGOWFpRUlJQUVvQWd3aEFnSkFBa0FnQXlBSmFpSUZJQ3ROQkVBZ0FpQURFQndnQVNnQ0RDRUNJQWxCRUUwRVFDQUJJQUlnQ1dvMkFnd01Bd3NnQWtFUWFpQURRUkJxSWdjUUhDQUNRU0JxSUFOQklHb1FIQ0FKUVRGSURRRWdBaUFKYWlFTElBSkJNR29oQWdOQUlBSWdCMEVnYWlJRkVCd2dBa0VRYWlBSFFUQnFFQndnQlNFSElBSkJJR29pQWlBTFNRMEFDd3dCQ3lBQ0lBTWdCU0FyRUNJTElBRWdBU2dDRENBSmFqWUNEQ0FKUVlDQUJFa05BQ0FCUVFFMkFpUWdBU0FCS0FJRUlBRW9BZ0JyUVFOMU5nSW9DeUFCS0FJRUlnSWdFVUVCYWpZQ0FDQUNJQWs3QVFRZ0NFR0FnQVJQQkVBZ0FVRUNOZ0lrSUFFZ0FpQUJLQUlBYTBFRGRUWUNLQXNnQWlBSU93RUdJQUVnQWtFSWFqWUNCQ0FHSUFscUlBTnFJZ01MSVE4Z0dVRUJhaUlaSUFwTkRRQUxDeUFpUVFJUVVRc2dEeUFwU1EwQUN3c2dBUkR5QVNBQUlBQW9BZ1FnQkdzMkFnUWdBQ0FBS0FJTUlBUnFJZ0UyQWd3Z0FDQUJOZ0lZSUFBZ0FUWUNFQ0FpRUo0RElBeEI4QUJxSkFBTHdENEJLWDhqQUVIZ0FHc2lFU1FBSUFBb0FnUWhCUUpBSUFBb0FrZ05BQ0FCS0FJRUlBRW9BZ0JIRFFBZ0FDZ0NEQ0lKSUFBb0FoQkhJQVJCZ1FoSmNpQURJQVZySUFsSGNnMEFJQUFnQVNBQ0lBTWdCQkNmQXlBQUtBSUVJUVVMSUFBb0FvUUJJUWNnQUNnQ2lBRWhDU0FBS0FJTUlTRWdFU0FBS0FJWU5nSmNJQUFvQWp3aEdDQUFRVUJyS0FJQUlSa2dBRUVzYWlJaUlBTWdCRUVDRUZrZ0F5QUZJQ0ZxSUFOR2FpSVBJQU1nQkdvaUVrRjRhaUlwU1FSQUlBbEIveDhnQ1VIL0gwa2JJU29nRWtGZ2FpRXJRUU5CQkNBSFFRTkdHeUlvUVg5cUlTRURRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FBS0FJRUlna2dBQ2dDR0NJRWFpQVBTdzBBSUE4Z0Eyc2hHaUFBS0FLRUFTRUhJQVFnRHlBSmF5SUZTUVJBQTBBZ0FDQUVJQWxxSUJJZ0IwRUFFRUVnQkdvaUJDQUZTUTBBQ3dzZ0drVWhIQ0FBSUFVMkFoZ0NRQUpBQWtBQ1FBSkFJQWRCZldvT0JRQUJBZ01EQVF0QkFDRUxRUUFnRHlBQUtBSUVJaE5ySWdaQmZ5QUFLQUo0UVg5cWRFRi9jeUlRYXlJRUlBUWdCa3NiSVJVZ0FDZ0NJQ0FQSUFBb0FueEJBeEFlUVFKMGFpSVVLQUlBSVFnZ0FDZ0NFQ0FBS0FJVUlBWWdBQ2dDZEJBbklnUkJBU0FFR3lFT1FRTkJCQ0FhR3lFZklBQW9BaWdpRnlBR0lCQnhRUU4wYWlJV1FRUnFJUW9nQUNnQ2lBRWlCRUgvSHlBRVFmOGZTUnNoRFNBUFFRTnFJUXdnQmtFSmFpRUhJQVlnQUNnQ0RHc2hHeUFBS0FLQUFTRWRJQ0VoQ1NBY0lRUURRQUpBQW44Z0JFRURSZ1JBSUFJb0FnQkJmMm9NQVFzZ0FpQUVRUUowYWlnQ0FBc2lCVUYvYWlBYlR3MEFJQTlCQXhBZklBOGdCV3RCQXhBZlJ3MEFJQXdnRENBRmF5QVNFQjFCQTJvaUJTQUpUUTBBSUJnZ0MwRURkR29pQ1NBRk5nSUVJQWtnQkNBY2F6WUNBQ0FMUVFGcUlRc2dCU0FOU3cwRklBVWlDU0FQYWlBU1JnMEZDeUFFUVFGcUlnUWdIMGtOQUFzQ1FDQUpRUUpMRFFCQkFpRUpJQk1nQUNnQ0hDQUFLQUlrSUJGQjNBQnFJQThRUUNJRUlBNUpEUUFnQmlBRWF5SUZRZi8vRDBzTkFDQVBJQVFnRTJvZ0VoQWRJZ1JCQTBrTkFDQVlJQVEyQWdRZ0dDQUZRUUpxTmdJQUlBUWdEVTBFUUVFQklRc2dCQ0lKSUE5cUlCSkhEUUVMUVFFaEN5QUFJQVpCQVdvMkFoZ01CQXNnRkNBR05nSUFBa0FnQ0NBT1NRMEFJQVpCQW1vaEZFRi9JQjEwUVg5eklRMUJBQ0VHUVFBaERBTkFJQThnQmlBTUlBWWdERWtiSWdScUlBZ2dFMm9pSHlBRWFpQVNFQjBnQkdvaUJDQUpTd1JBSUJnZ0MwRURkR29pQ1NBRU5nSUVJQWtnRkNBSWF6WUNBQ0FFSUFocUlBY2dCQ0FISUFoclN4c2hCeUFMUVFGcUlRc2dCRUdBSUVzTkFpQUVJZ2tnRDJvZ0VrWU5BZ3NnRnlBSUlCQnhRUU4wYWlFRkFrQUNRQ0FFSUI5cUxRQUFJQVFnRDJvdEFBQkpCRUFnRmlBSU5nSUFJQWdnRlVzTkFTQVJRVUJySVJZTUJBc2dDaUFJTmdJQUlBZ2dGVXNFUUNBRklRb2dCQ0VNREFJTElCRkJRR3NoQ2d3REN5QUVJUVlnQlVFRWFpSVdJUVVMSUExRkRRRWdEVUYvYWlFTklBVW9BZ0FpQ0NBT1R3MEFDd3NnQ2tFQU5nSUFJQlpCQURZQ0FDQUFJQWRCZUdvMkFoZ01Bd3RCQUNFTFFRQWdEeUFBS0FJRUloVnJJZ1pCZnlBQUtBSjRRWDlxZEVGL2N5SVRheUlFSUFRZ0Jrc2JJUTRnQUNnQ0lDQVBJQUFvQW54QkJCQWVRUUowYWlJTUtBSUFJUWdnQUNnQ0VDQUFLQUlVSUFZZ0FDZ0NkQkFuSWdSQkFTQUVHeUVRUVFOQkJDQWFHeUVVSUFBb0FpZ2lIeUFHSUJOeFFRTjBhaUlLUVFScUlSWWdBQ2dDaUFFaUJFSC9IeUFFUWY4ZlNSc2hGeUFQUVFScUlRMGdCa0VKYWlFSElBWWdBQ2dDREdzaEd5QUFLQUtBQVNFZElDRWhDU0FjSVFRRFFBSkFBbjhnQkVFRFJnUkFJQUlvQWdCQmYyb01BUXNnQWlBRVFRSjBhaWdDQUFzaUJVRi9haUFiVHcwQUlBOUJCQkFmSUE4Z0JXdEJCQkFmUncwQUlBMGdEU0FGYXlBU0VCMUJCR29pQlNBSlRRMEFJQmdnQzBFRGRHb2lDU0FGTmdJRUlBa2dCQ0FjYXpZQ0FDQUxRUUZxSVFzZ0JTQVhTdzBFSUFVaUNTQVBhaUFTUmcwRUN5QUVRUUZxSWdRZ0ZFa05BQXNnRENBR05nSUFBa0FnQ0NBUVNRMEFJQVpCQW1vaEZFRi9JQjEwUVg5eklRMUJBQ0VHUVFBaERBTkFJQThnQmlBTUlBWWdERWtiSWdScUlBZ2dGV29pRnlBRWFpQVNFQjBnQkdvaUJDQUpTd1JBSUJnZ0MwRURkR29pQ1NBRU5nSUVJQWtnRkNBSWF6WUNBQ0FFSUFocUlBY2dCQ0FISUFoclN4c2hCeUFMUVFGcUlRc2dCRUdBSUVzTkFpQUVJZ2tnRDJvZ0VrWU5BZ3NnSHlBSUlCTnhRUU4wYWlFRkFrQUNRQ0FFSUJkcUxRQUFJQVFnRDJvdEFBQkpCRUFnQ2lBSU5nSUFJQWdnRGtzTkFTQVJRVUJySVFvTUJBc2dGaUFJTmdJQUlBZ2dEa3NFUUNBRklSWWdCQ0VNREFJTElCRkJRR3NoRmd3REN5QUVJUVlnQlVFRWFpSUtJUVVMSUExRkRRRWdEVUYvYWlFTklBVW9BZ0FpQ0NBUVR3MEFDd3NnRmtFQU5nSUFJQXBCQURZQ0FDQUFJQWRCZUdvMkFoZ01BZ3RCQUNFTFFRQWdEeUFBS0FJRUloVnJJZ1pCZnlBQUtBSjRRWDlxZEVGL2N5SVRheUlFSUFRZ0Jrc2JJUTRnQUNnQ0lDQVBJQUFvQW54QkJSQWVRUUowYWlJTUtBSUFJUWdnQUNnQ0VDQUFLQUlVSUFZZ0FDZ0NkQkFuSWdSQkFTQUVHeUVRUVFOQkJDQWFHeUVVSUFBb0FpZ2lIeUFHSUJOeFFRTjBhaUlLUVFScUlSWWdBQ2dDaUFFaUJFSC9IeUFFUWY4ZlNSc2hGeUFQUVFScUlRMGdCa0VKYWlFSElBWWdBQ2dDREdzaEd5QUFLQUtBQVNFZElDRWhDU0FjSVFRRFFBSkFBbjhnQkVFRFJnUkFJQUlvQWdCQmYyb01BUXNnQWlBRVFRSjBhaWdDQUFzaUJVRi9haUFiVHcwQUlBOUJCQkFmSUE4Z0JXdEJCQkFmUncwQUlBMGdEU0FGYXlBU0VCMUJCR29pQlNBSlRRMEFJQmdnQzBFRGRHb2lDU0FGTmdJRUlBa2dCQ0FjYXpZQ0FDQUxRUUZxSVFzZ0JTQVhTdzBESUFVaUNTQVBhaUFTUmcwREN5QUVRUUZxSWdRZ0ZFa05BQXNnRENBR05nSUFBa0FnQ0NBUVNRMEFJQVpCQW1vaEZFRi9JQjEwUVg5eklRMUJBQ0VHUVFBaERBTkFJQThnQmlBTUlBWWdERWtiSWdScUlBZ2dGV29pRnlBRWFpQVNFQjBnQkdvaUJDQUpTd1JBSUJnZ0MwRURkR29pQ1NBRU5nSUVJQWtnRkNBSWF6WUNBQ0FFSUFocUlBY2dCQ0FISUFoclN4c2hCeUFMUVFGcUlRc2dCRUdBSUVzTkFpQUVJZ2tnRDJvZ0VrWU5BZ3NnSHlBSUlCTnhRUU4wYWlFRkFrQUNRQ0FFSUJkcUxRQUFJQVFnRDJvdEFBQkpCRUFnQ2lBSU5nSUFJQWdnRGtzTkFTQVJRVUJySVFvTUJBc2dGaUFJTmdJQUlBZ2dEa3NFUUNBRklSWWdCQ0VNREFJTElCRkJRR3NoRmd3REN5QUVJUVlnQlVFRWFpSUtJUVVMSUExRkRRRWdEVUYvYWlFTklBVW9BZ0FpQ0NBUVR3MEFDd3NnRmtFQU5nSUFJQXBCQURZQ0FDQUFJQWRCZUdvMkFoZ01BUXRCQUNFTFFRQWdEeUFBS0FJRUloVnJJZ1pCZnlBQUtBSjRRWDlxZEVGL2N5SVRheUlFSUFRZ0Jrc2JJUTRnQUNnQ0lDQVBJQUFvQW54QkJoQWVRUUowYWlJTUtBSUFJUWdnQUNnQ0VDQUFLQUlVSUFZZ0FDZ0NkQkFuSWdSQkFTQUVHeUVRUVFOQkJDQWFHeUVVSUFBb0FpZ2lIeUFHSUJOeFFRTjBhaUlLUVFScUlSWWdBQ2dDaUFFaUJFSC9IeUFFUWY4ZlNSc2hGeUFQUVFScUlRMGdCa0VKYWlFSElBWWdBQ2dDREdzaEd5QUFLQUtBQVNFZElDRWhDU0FjSVFRRFFBSkFBbjhnQkVFRFJnUkFJQUlvQWdCQmYyb01BUXNnQWlBRVFRSjBhaWdDQUFzaUJVRi9haUFiVHcwQUlBOUJCQkFmSUE4Z0JXdEJCQkFmUncwQUlBMGdEU0FGYXlBU0VCMUJCR29pQlNBSlRRMEFJQmdnQzBFRGRHb2lDU0FGTmdJRUlBa2dCQ0FjYXpZQ0FDQUxRUUZxSVFzZ0JTQVhTdzBDSUFVaUNTQVBhaUFTUmcwQ0N5QUVRUUZxSWdRZ0ZFa05BQXNnRENBR05nSUFBa0FnQ0NBUVNRMEFJQVpCQW1vaEZFRi9JQjEwUVg5eklRMUJBQ0VHUVFBaERBTkFJQThnQmlBTUlBWWdERWtiSWdScUlBZ2dGV29pRnlBRWFpQVNFQjBnQkdvaUJDQUpTd1JBSUJnZ0MwRURkR29pQ1NBRU5nSUVJQWtnRkNBSWF6WUNBQ0FFSUFocUlBY2dCQ0FISUFoclN4c2hCeUFMUVFGcUlRc2dCRUdBSUVzTkFpQUVJZ2tnRDJvZ0VrWU5BZ3NnSHlBSUlCTnhRUU4wYWlFRkFrQUNRQ0FFSUJkcUxRQUFJQVFnRDJvdEFBQkpCRUFnQ2lBSU5nSUFJQWdnRGtzTkFTQVJRVUJySVFvTUJBc2dGaUFJTmdJQUlBZ2dEa3NFUUNBRklSWWdCQ0VNREFJTElCRkJRR3NoRmd3REN5QUVJUVlnQlVFRWFpSUtJUVVMSUExRkRRRWdEVUYvYWlFTklBVW9BZ0FpQ0NBUVR3MEFDd3NnRmtFQU5nSUFJQXBCQURZQ0FDQUFJQWRCZUdvMkFoZ0xJQXRGRFFBZ0dTQUNLQUlBTmdJUUlCa2dBaWdDQkRZQ0ZDQUNLQUlJSVFRZ0dTQWFOZ0lNSUJsQkFEWUNDQ0FaSUFRMkFoZ2dHU0FESUJvZ0lrRUNFRmdpQ1RZQ0FDQVlJQXRCZjJwQkEzUnFJZ1FvQWdRaUJTQXFTd1JBSUFRb0FnQWhEUXdEQzBFQklRUkJBQ0FpUVFJUUxTRUhBMEFnR1NBRVFSeHNha0dBZ0lDQUJEWUNBQ0FFUVFGcUlnUWdLRWNOQUFzZ0J5QUphaUVOUVFBaEJ5QW9JUVVEUUNBWUlBZEJBM1JxSWdRb0FnUWhDU0FSUVVCcklBSWdCQ2dDQUNJS0lCd1FQeUFGSUFsTkJFQWdDa0VCYWhBa0lnWkJDSFJCZ0NCcUlRd0RRQ0FGUVgxcUlRUUNmeUFBS0FKa1FRRkdCRUFnQkJBcklBeHFEQUVMSUFBb0FtQWdBQ2dDT0NBR1FRSjBhaWdDQUJBcmF5QUFLQUpjYWlBRUVEeEJBblFpQkVHUXBBRnFLQUlBSUFacVFRaDBhaUFBS0FJMElBUnFLQUlBRUN0clFUTnFDeUVJSUJrZ0JVRWNiR29pQkNBYU5nSU1JQVFnQ2pZQ0JDQUVJQVUyQWdnZ0JDQUlJQTFxTmdJQUlBUWdFU2tEUURjQ0VDQUVJQkVvQWtnMkFoZ2dCVUVCYWlJRklBbE5EUUFMQ3lBSFFRRnFJZ2NnQzBjTkFBdEJBU0VKQWtBZ0JVRi9haUlFUlFSQVFRQWhCQXdCQ3dOQVFRRWhDQ0FaSUFsQmYycEJIR3hxSWdVb0FnaEZCRUFnQlNnQ0RFRUJhaUVJQ3lBSklBOXFJZzVCZjJwQkFTQWlRUUlRVWlBRktBSUFhaUFJSUNKQkFoQXRhaUFJUVg5cUlDSkJBaEF0YXlJSElCa2dDVUVjYkdvaUZDZ0NBQ0lXVEFSQUlCUWdDRFlDRENBVVFnQTNBZ1FnRkNBSE5nSUFJQlFnQlNnQ0dEWUNHQ0FVSUFVcEFoQTNBaEFnQnlFV0N3SkFJQTRnS1VzTkFDQUVJQWxHQkVBZ0NTRUVEQU1MUVFBaEdpQVVLQUlJSWdkRkJFQWdGQ2dDRENFYUMwRUFJQ0pCQWhBdElTMGdBQ2dDQkNJRklBQW9BaGdpQ0dvZ0Rrc05BQ0FBS0FLRUFTRUxJQWdnRGlBRmF5SUtTUVJBQTBBZ0FDQUZJQWhxSUJJZ0MwRUFFRUVnQ0dvaUNDQUtTUTBBQ3dzZ0IwRUFSeUVjSUJSQkVHb2hIeUFBSUFvMkFoZ0NRQUpBQWtBQ1FBSkFJQXRCZldvT0JRQUJBZ01EQVF0QkFDRVFRUUFnRGlBQUtBSUVJaGRySWdwQmZ5QUFLQUo0UVg5cWRFRi9jeUlkYXlJRklBVWdDa3NiSVNNZ0FDZ0NJQ0FPSUFBb0FueEJBeEFlUVFKMGFpSWdLQUlBSVF3Z0FDZ0NFQ0FBS0FJVUlBb2dBQ2dDZEJBbklnVkJBU0FGR3lFYlFRUkJBeUFIR3lFa0lBQW9BaWdpSlNBS0lCMXhRUU4wYWlJRlFRUnFJUk1nQUNnQ2lBRWlCMEgvSHlBSFFmOGZTUnNoQmlBT1FRTnFJUjRnQ2tFSmFpRVZJQW9nQUNnQ0RHc2hKaUFBS0FLQUFTRW5JQ0VoQnlBY0lRZ0RRQUpBQW44Z0NFRURSZ1JBSUI4b0FnQkJmMm9NQVFzZ0ZDQUlRUUowYWlnQ0VBc2lEVUYvYWlBbVR3MEFJQTVCQXhBZklBNGdEV3RCQXhBZlJ3MEFJQjRnSGlBTmF5QVNFQjFCQTJvaUN5QUhUUTBBSUJnZ0VFRURkR29pQnlBTE5nSUVJQWNnQ0NBY2F6WUNBQ0FRUVFGcUlSQWdDeUFHU3cwRklBc2lCeUFPYWlBU1JnMEZDeUFJUVFGcUlnZ2dKRWtOQUFzQ1FDQUhRUUpMRFFCQkFpRUhJQmNnQUNnQ0hDQUFLQUlrSUJGQjNBQnFJQTRRUUNJTElCdEpEUUFnQ2lBTGF5SUlRZi8vRDBzTkFDQU9JQXNnRjJvZ0VoQWRJZ3RCQTBrTkFDQVlJQXMyQWdRZ0dDQUlRUUpxTmdJQUlBc2dCazBFUUVFQklSQWdDeUlISUE1cUlCSkhEUUVMUVFFaEVDQUFJQXBCQVdvMkFoZ01CQXNnSUNBS05nSUFBa0FnRENBYlNRMEFJQXBCQW1vaEhrRi9JQ2QwUVg5eklRaEJBQ0VMUVFBaENnTkFJQTRnQ3lBS0lBc2dDa2tiSWdacUlBd2dGMm9pSUNBR2FpQVNFQjBnQm1vaUJpQUhTd1JBSUJnZ0VFRURkR29pQnlBR05nSUVJQWNnSGlBTWF6WUNBQ0FHSUF4cUlCVWdCaUFWSUF4clN4c2hGU0FRUVFGcUlSQWdCa0dBSUVzTkFpQUdJZ2NnRG1vZ0VrWU5BZ3NnSlNBTUlCMXhRUU4wYWlFTkFrQUNRQ0FHSUNCcUxRQUFJQVlnRG1vdEFBQkpCRUFnQlNBTU5nSUFJQXdnSTBzTkFTQVJRVUJySVFVTUJBc2dFeUFNTmdJQUlBd2dJMHNFUUNBTklSTWdCaUVLREFJTElCRkJRR3NoRXd3REN5QUdJUXNnRFVFRWFpSUZJUTBMSUFoRkRRRWdDRUYvYWlFSUlBMG9BZ0FpRENBYlR3MEFDd3NnRTBFQU5nSUFJQVZCQURZQ0FDQUFJQlZCZUdvMkFoZ01Bd3RCQUNFUVFRQWdEaUFBS0FJRUlpTnJJZ3BCZnlBQUtBSjRRWDlxZEVGL2N5SVhheUlGSUFVZ0Nrc2JJUnNnQUNnQ0lDQU9JQUFvQW54QkJCQWVRUUowYWlJZUtBSUFJUXdnQUNnQ0VDQUFLQUlVSUFvZ0FDZ0NkQkFuSWdWQkFTQUZHeUVkUVFSQkF5QUhHeUVnSUFBb0FpZ2lKQ0FLSUJkeFFRTjBhaUlUUVFScUlRVWdBQ2dDaUFFaUIwSC9IeUFIUWY4ZlNSc2hKU0FPUVFScUlRWWdDa0VKYWlFVklBb2dBQ2dDREdzaEppQUFLQUtBQVNFbklDRWhCeUFjSVFnRFFBSkFBbjhnQ0VFRFJnUkFJQjhvQWdCQmYyb01BUXNnRkNBSVFRSjBhaWdDRUFzaURVRi9haUFtVHcwQUlBNUJCQkFmSUE0Z0RXdEJCQkFmUncwQUlBWWdCaUFOYXlBU0VCMUJCR29pQ3lBSFRRMEFJQmdnRUVFRGRHb2lCeUFMTmdJRUlBY2dDQ0FjYXpZQ0FDQVFRUUZxSVJBZ0N5QWxTdzBFSUFzaUJ5QU9haUFTUmcwRUN5QUlRUUZxSWdnZ0lFa05BQXNnSGlBS05nSUFBa0FnRENBZFNRMEFJQXBCQW1vaEhrRi9JQ2QwUVg5eklRaEJBQ0VMUVFBaENnTkFJQTRnQ3lBS0lBc2dDa2tiSWdacUlBd2dJMm9pSUNBR2FpQVNFQjBnQm1vaUJpQUhTd1JBSUJnZ0VFRURkR29pQnlBR05nSUVJQWNnSGlBTWF6WUNBQ0FHSUF4cUlCVWdCaUFWSUF4clN4c2hGU0FRUVFGcUlSQWdCa0dBSUVzTkFpQUdJZ2NnRG1vZ0VrWU5BZ3NnSkNBTUlCZHhRUU4wYWlFTkFrQUNRQ0FHSUNCcUxRQUFJQVlnRG1vdEFBQkpCRUFnRXlBTU5nSUFJQXdnRzBzTkFTQVJRVUJySVJNTUJBc2dCU0FNTmdJQUlBd2dHMHNFUUNBTklRVWdCaUVLREFJTElCRkJRR3NoQlF3REN5QUdJUXNnRFVFRWFpSVRJUTBMSUFoRkRRRWdDRUYvYWlFSUlBMG9BZ0FpRENBZFR3MEFDd3NnQlVFQU5nSUFJQk5CQURZQ0FDQUFJQlZCZUdvMkFoZ01BZ3RCQUNFUVFRQWdEaUFBS0FJRUlpTnJJZ3BCZnlBQUtBSjRRWDlxZEVGL2N5SVhheUlGSUFVZ0Nrc2JJUnNnQUNnQ0lDQU9JQUFvQW54QkJSQWVRUUowYWlJZUtBSUFJUXdnQUNnQ0VDQUFLQUlVSUFvZ0FDZ0NkQkFuSWdWQkFTQUZHeUVkUVFSQkF5QUhHeUVnSUFBb0FpZ2lKQ0FLSUJkeFFRTjBhaUlUUVFScUlRVWdBQ2dDaUFFaUIwSC9IeUFIUWY4ZlNSc2hKU0FPUVFScUlRWWdDa0VKYWlFVklBb2dBQ2dDREdzaEppQUFLQUtBQVNFbklDRWhCeUFjSVFnRFFBSkFBbjhnQ0VFRFJnUkFJQjhvQWdCQmYyb01BUXNnRkNBSVFRSjBhaWdDRUFzaURVRi9haUFtVHcwQUlBNUJCQkFmSUE0Z0RXdEJCQkFmUncwQUlBWWdCaUFOYXlBU0VCMUJCR29pQ3lBSFRRMEFJQmdnRUVFRGRHb2lCeUFMTmdJRUlBY2dDQ0FjYXpZQ0FDQVFRUUZxSVJBZ0N5QWxTdzBESUFzaUJ5QU9haUFTUmcwREN5QUlRUUZxSWdnZ0lFa05BQXNnSGlBS05nSUFBa0FnRENBZFNRMEFJQXBCQW1vaEhrRi9JQ2QwUVg5eklRaEJBQ0VMUVFBaENnTkFJQTRnQ3lBS0lBc2dDa2tiSWdacUlBd2dJMm9pSUNBR2FpQVNFQjBnQm1vaUJpQUhTd1JBSUJnZ0VFRURkR29pQnlBR05nSUVJQWNnSGlBTWF6WUNBQ0FHSUF4cUlCVWdCaUFWSUF4clN4c2hGU0FRUVFGcUlSQWdCa0dBSUVzTkFpQUdJZ2NnRG1vZ0VrWU5BZ3NnSkNBTUlCZHhRUU4wYWlFTkFrQUNRQ0FHSUNCcUxRQUFJQVlnRG1vdEFBQkpCRUFnRXlBTU5nSUFJQXdnRzBzTkFTQVJRVUJySVJNTUJBc2dCU0FNTmdJQUlBd2dHMHNFUUNBTklRVWdCaUVLREFJTElCRkJRR3NoQlF3REN5QUdJUXNnRFVFRWFpSVRJUTBMSUFoRkRRRWdDRUYvYWlFSUlBMG9BZ0FpRENBZFR3MEFDd3NnQlVFQU5nSUFJQk5CQURZQ0FDQUFJQlZCZUdvMkFoZ01BUXRCQUNFUVFRQWdEaUFBS0FJRUlpTnJJZ3BCZnlBQUtBSjRRWDlxZEVGL2N5SVhheUlGSUFVZ0Nrc2JJUnNnQUNnQ0lDQU9JQUFvQW54QkJoQWVRUUowYWlJZUtBSUFJUXdnQUNnQ0VDQUFLQUlVSUFvZ0FDZ0NkQkFuSWdWQkFTQUZHeUVkUVFSQkF5QUhHeUVnSUFBb0FpZ2lKQ0FLSUJkeFFRTjBhaUlUUVFScUlRVWdBQ2dDaUFFaUIwSC9IeUFIUWY4ZlNSc2hKU0FPUVFScUlRWWdDa0VKYWlFVklBb2dBQ2dDREdzaEppQUFLQUtBQVNFbklDRWhCeUFjSVFnRFFBSkFBbjhnQ0VFRFJnUkFJQjhvQWdCQmYyb01BUXNnRkNBSVFRSjBhaWdDRUFzaURVRi9haUFtVHcwQUlBNUJCQkFmSUE0Z0RXdEJCQkFmUncwQUlBWWdCaUFOYXlBU0VCMUJCR29pQ3lBSFRRMEFJQmdnRUVFRGRHb2lCeUFMTmdJRUlBY2dDQ0FjYXpZQ0FDQVFRUUZxSVJBZ0N5QWxTdzBDSUFzaUJ5QU9haUFTUmcwQ0N5QUlRUUZxSWdnZ0lFa05BQXNnSGlBS05nSUFBa0FnRENBZFNRMEFJQXBCQW1vaEhrRi9JQ2QwUVg5eklRaEJBQ0VMUVFBaENnTkFJQTRnQ3lBS0lBc2dDa2tiSWdacUlBd2dJMm9pSUNBR2FpQVNFQjBnQm1vaUJpQUhTd1JBSUJnZ0VFRURkR29pQnlBR05nSUVJQWNnSGlBTWF6WUNBQ0FHSUF4cUlCVWdCaUFWSUF4clN4c2hGU0FRUVFGcUlSQWdCa0dBSUVzTkFpQUdJZ2NnRG1vZ0VrWU5BZ3NnSkNBTUlCZHhRUU4wYWlFTkFrQUNRQ0FHSUNCcUxRQUFJQVlnRG1vdEFBQkpCRUFnRXlBTU5nSUFJQXdnRzBzTkFTQVJRVUJySVJNTUJBc2dCU0FNTmdJQUlBd2dHMHNFUUNBTklRVWdCaUVLREFJTElCRkJRR3NoQlF3REN5QUdJUXNnRFVFRWFpSVRJUTBMSUFoRkRRRWdDRUYvYWlFSUlBMG9BZ0FpRENBZFR3MEFDd3NnQlVFQU5nSUFJQk5CQURZQ0FDQUFJQlZCZUdvMkFoZ0xJQkJGRFFBZ0dDQVFRWDlxUVFOMGFpSUhLQUlFSWdVZ0trc2dCU0FKYWtHQUlFOXlEUVFnRmlBdGFpRU1RUUFoRmdOQUlCRkJRR3NnSHlBWUlCWkJBM1JxSWdjb0FnQWlCU0FjRUQ4Z0tDRUdBbjhnRmdSQUlBZEJmR29vQWdCQkFXb2hCZ3NnQnlnQ0JDSUlJQVpQQ3dSQUlBVkJBV29RSkNJTFFRaDBRWUFnYWlFVEEwQWdDRUY5YWlFS0lBZ2dDV29oQndKL0lBQW9BbVJCQVVZRVFDQUtFQ3NnRTJvTUFRc2dBQ2dDWUNBQUtBSTRJQXRCQW5ScUtBSUFFQ3RySUFBb0FseHFJQW9RUEVFQ2RDSUtRWkNrQVdvb0FnQWdDMnBCQ0hScUlBQW9BalFnQ21vb0FnQVFLMnRCTTJvTElBeHFJUW9DUUFKQUlBY2dCRTBFUUNBS0lCa2dCMEVjYkdvb0FnQklEUUVNQWdzRFFDQVpJQVJCQVdvaUJFRWNiR3BCZ0lDQWdBUTJBZ0FnQkNBSFNRMEFDd3NnR1NBSFFSeHNhaUlISUJvMkFnd2dCeUFGTmdJRUlBY2dDRFlDQ0NBSElBbzJBZ0FnQnlBUktRTkFOd0lRSUFjZ0VTZ0NTRFlDR0FzZ0NFRi9haUlJSUFaUERRQUxDeUFXUVFGcUloWWdFRWNOQUFzTElBbEJBV29pQ1NBRVRRMEFDd3NnR1NBRVFSeHNhaUlKS0FJTUlSb2dDU2dDQkNFTklBa29BZ0FoTENBSktBSUlJUVVnRVNBSktBSVlOZ0pZSUJFZ0NTa0NFRGNEVUNBUklBa3BBZ2czQXlnZ0VTQUpLUUlRTndNd0lCRWdDU2dDR0RZQ09DQVJJQWtwQWdBM0F5QkJBQ0FFSUJGQklHb1FQbXNpQ1NBSklBUkxHeUVFREFNTElBOUJBV29oRHd3SEN5QUhLQUlBSVExQkFDRUVJQWtnRkNnQ0NBUi9JQVFGSUJRb0Fnd0xheUlFUVlBZ1RRMEJDeUFaSUJvMkFpZ2dHU0FGTmdJa0lCa2dEVFlDSUNBWklDdzJBaHdnR1NBUktBSllOZ0kwSUJrZ0VTa0RVRGNDTEF3QkN5QVpJQVJCQVdvaUMwRWNiR29pQ1NBYU5nSU1JQWtnQlRZQ0NDQUpJQTAyQWdRZ0NTQXNOZ0lBSUFrZ0VTa0RVRGNDRUNBSklCRW9BbGcyQWhnZ0N5RWFJQVFOQVF0QkFTRWFRUUVoQ3d3QkN3TkFJQkVnR1NBRVFSeHNhaUlKSWdwQkdHb29BZ0EyQWhnZ0VTQUpLUUlRTndNUUlCRWdDU2tDQ0RjRENDQVJJQWtwQWdBM0F3QWdFUkErSVFVZ0dTQWFRWDlxSWhwQkhHeHFJZ2NnQ2lnQ0dEWUNHQ0FISUFrcEFoQTNBaEFnQnlBSktRSUlOd0lJSUFjZ0NTa0NBRGNDQUNBRUlBVkxJUWxCQUNBRUlBVnJJZ2NnQnlBRVN4c2hCQ0FKRFFBTElCb2dDMHNOQVFzRFFDQVpJQnBCSEd4cUlnUW9BZ3doQndKL0lBTWdCMm9nQkNnQ0NDSUdSUTBBR2dKQUFrQWdCQ2dDQkNJS1FRTlBCRUFnQWlBQ0tRSUFOd0lFSUFwQmZtb2hCQXdCQ3dKQUFrQUNRQUpBSUFvZ0IwVnFJZ2tPQkFVQkFRQUJDeUFDS0FJQVFYOXFJUVFNQVFzZ0FpQUpRUUowYWlnQ0FDRUVJQWxCQWtrTkFRc2dBaUFDS0FJRU5nSUlDeUFDSUFJb0FnQTJBZ1FMSUFJZ0JEWUNBQXNnSWlBSElBTWdDaUFHRUZjZ0JrRjlhaUVJSUFFb0Fnd2hCQUpBQWtBZ0F5QUhhaUlKSUN0TkJFQWdCQ0FERUJ3Z0FTZ0NEQ0VFSUFkQkVFMEVRQ0FCSUFRZ0IybzJBZ3dNQXdzZ0JFRVFhaUFEUVJCcUlnVVFIQ0FFUVNCcUlBTkJJR29RSENBSFFURklEUUVnQkNBSGFpRU5JQVJCTUdvaEJBTkFJQVFnQlVFZ2FpSUpFQndnQkVFUWFpQUZRVEJxRUJ3Z0NTRUZJQVJCSUdvaUJDQU5TUTBBQ3d3QkN5QUVJQU1nQ1NBckVDSUxJQUVnQVNnQ0RDQUhhallDRENBSFFZQ0FCRWtOQUNBQlFRRTJBaVFnQVNBQktBSUVJQUVvQWdCclFRTjFOZ0lvQ3lBQktBSUVJZ1FnQ2tFQmFqWUNBQ0FFSUFjN0FRUWdDRUdBZ0FSUEJFQWdBVUVDTmdJa0lBRWdCQ0FCS0FJQWEwRURkVFlDS0FzZ0JDQUlPd0VHSUFFZ0JFRUlhallDQkNBR0lBZHFJQU5xSWdNTElROGdHa0VCYWlJYUlBdE5EUUFMQ3lBaVFRSVFVUXNnRHlBcFNRMEFDd3NnRVVIZ0FHb2tBQ0FTSUFOckMvWTlBU2wvSXdCQjRBQnJJaEVrQUNBQUtBS0VBU0VISUFBb0FnUWhJU0FBS0FLSUFTRUpJQUFvQWd3aEJpQVJJQUFvQWhnMkFsd2dBQ2dDUENFWUlBQkJRR3NvQWdBaEdTQUFRU3hxSWlJZ0F5QUVRUUlRV1NBRElBWWdJV29nQTBacUlnOGdBeUFFYWlJU1FYaHFJaWxKQkVBZ0NVSC9IeUFKUWY4ZlNSc2hLaUFTUVdCcUlTdEJBMEVFSUFkQkEwWWJJaWhCZjJvaElRTkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUFvQWdRaUNTQUFLQUlZSWdScUlBOUxEUUFnRHlBRGF5RWFJQUFvQW9RQklRY2dCQ0FQSUFscklnWkpCRUFEUUNBQUlBUWdDV29nRWlBSFFRQVFRU0FFYWlJRUlBWkpEUUFMQ3lBYVJTRWNJQUFnQmpZQ0dBSkFBa0FDUUFKQUFrQWdCMEY5YWc0RkFBRUNBd01CQzBFQUlRdEJBQ0FQSUFBb0FnUWlFMnNpQlVGL0lBQW9BbmhCZjJwMFFYOXpJaEJySWdRZ0JDQUZTeHNoRlNBQUtBSWdJQThnQUNnQ2ZFRURFQjVCQW5ScUloUW9BZ0FoQ0NBQUtBSVFJQUFvQWhRZ0JTQUFLQUowRUNjaUJFRUJJQVFiSVE1QkEwRUVJQm9iSVI4Z0FDZ0NLQ0lYSUFVZ0VIRkJBM1JxSWhaQkJHb2hDaUFBS0FLSUFTSUVRZjhmSUFSQi94OUpHeUVOSUE5QkEyb2hEQ0FGUVFscUlRY2dCU0FBS0FJTWF5RWJJQUFvQW9BQklSMGdJU0VKSUJ3aEJBTkFBa0FDZnlBRVFRTkdCRUFnQWlnQ0FFRi9hZ3dCQ3lBQ0lBUkJBblJxS0FJQUN5SUdRWDlxSUJ0UERRQWdEMEVERUI4Z0R5QUdhMEVERUI5SERRQWdEQ0FNSUFacklCSVFIVUVEYWlJR0lBbE5EUUFnR0NBTFFRTjBhaUlKSUFZMkFnUWdDU0FFSUJ4ck5nSUFJQXRCQVdvaEN5QUdJQTFMRFFVZ0JpSUpJQTlxSUJKR0RRVUxJQVJCQVdvaUJDQWZTUTBBQ3dKQUlBbEJBa3NOQUVFQ0lRa2dFeUFBS0FJY0lBQW9BaVFnRVVIY0FHb2dEeEJBSWdRZ0Rra05BQ0FGSUFScklnWkIvLzhQU3cwQUlBOGdCQ0FUYWlBU0VCMGlCRUVEU1EwQUlCZ2dCRFlDQkNBWUlBWkJBbW8yQWdBZ0JDQU5UUVJBUVFFaEN5QUVJZ2tnRDJvZ0VrY05BUXRCQVNFTElBQWdCVUVCYWpZQ0dBd0VDeUFVSUFVMkFnQUNRQ0FJSUE1SkRRQWdCVUVDYWlFVVFYOGdIWFJCZjNNaERVRUFJUVZCQUNFTUEwQWdEeUFGSUF3Z0JTQU1TUnNpQkdvZ0NDQVRhaUlmSUFScUlCSVFIU0FFYWlJRUlBbExCRUFnR0NBTFFRTjBhaUlKSUFRMkFnUWdDU0FVSUFock5nSUFJQVFnQ0dvZ0J5QUVJQWNnQ0d0TEd5RUhJQXRCQVdvaEN5QUVRWUFnU3cwQ0lBUWlDU0FQYWlBU1JnMENDeUFYSUFnZ0VIRkJBM1JxSVFZQ1FBSkFJQVFnSDJvdEFBQWdCQ0FQYWkwQUFFa0VRQ0FXSUFnMkFnQWdDQ0FWU3cwQklCRkJRR3NoRmd3RUN5QUtJQWcyQWdBZ0NDQVZTd1JBSUFZaENpQUVJUXdNQWdzZ0VVRkFheUVLREFNTElBUWhCU0FHUVFScUloWWhCZ3NnRFVVTkFTQU5RWDlxSVEwZ0JpZ0NBQ0lJSUE1UERRQUxDeUFLUVFBMkFnQWdGa0VBTmdJQUlBQWdCMEY0YWpZQ0dBd0RDMEVBSVF0QkFDQVBJQUFvQWdRaUZXc2lCVUYvSUFBb0FuaEJmMnAwUVg5ekloTnJJZ1FnQkNBRlN4c2hEaUFBS0FJZ0lBOGdBQ2dDZkVFRUVCNUJBblJxSWd3b0FnQWhDQ0FBS0FJUUlBQW9BaFFnQlNBQUtBSjBFQ2NpQkVFQklBUWJJUkJCQTBFRUlCb2JJUlFnQUNnQ0tDSWZJQVVnRTNGQkEzUnFJaFpCQkdvaENpQUFLQUtJQVNJRVFmOGZJQVJCL3g5Skd5RVhJQTlCQkdvaERTQUZRUWxxSVFjZ0JTQUFLQUlNYXlFYklBQW9Bb0FCSVIwZ0lTRUpJQndoQkFOQUFrQUNmeUFFUVFOR0JFQWdBaWdDQUVGL2Fnd0JDeUFDSUFSQkFuUnFLQUlBQ3lJR1FYOXFJQnRQRFFBZ0QwRUVFQjhnRHlBR2EwRUVFQjlIRFFBZ0RTQU5JQVpySUJJUUhVRUVhaUlHSUFsTkRRQWdHQ0FMUVFOMGFpSUpJQVkyQWdRZ0NTQUVJQnhyTmdJQUlBdEJBV29oQ3lBR0lCZExEUVFnQmlJSklBOXFJQkpHRFFRTElBUkJBV29pQkNBVVNRMEFDeUFNSUFVMkFnQUNRQ0FJSUJCSkRRQWdCVUVDYWlFVVFYOGdIWFJCZjNNaERVRUFJUVZCQUNFTUEwQWdEeUFGSUF3Z0JTQU1TUnNpQkdvZ0NDQVZhaUlYSUFScUlCSVFIU0FFYWlJRUlBbExCRUFnR0NBTFFRTjBhaUlKSUFRMkFnUWdDU0FVSUFock5nSUFJQVFnQ0dvZ0J5QUVJQWNnQ0d0TEd5RUhJQXRCQVdvaEN5QUVRWUFnU3cwQ0lBUWlDU0FQYWlBU1JnMENDeUFmSUFnZ0UzRkJBM1JxSVFZQ1FBSkFJQVFnRjJvdEFBQWdCQ0FQYWkwQUFFa0VRQ0FXSUFnMkFnQWdDQ0FPU3cwQklCRkJRR3NoRmd3RUN5QUtJQWcyQWdBZ0NDQU9Td1JBSUFZaENpQUVJUXdNQWdzZ0VVRkFheUVLREFNTElBUWhCU0FHUVFScUloWWhCZ3NnRFVVTkFTQU5RWDlxSVEwZ0JpZ0NBQ0lJSUJCUERRQUxDeUFLUVFBMkFnQWdGa0VBTmdJQUlBQWdCMEY0YWpZQ0dBd0NDMEVBSVF0QkFDQVBJQUFvQWdRaUZXc2lCVUYvSUFBb0FuaEJmMnAwUVg5ekloTnJJZ1FnQkNBRlN4c2hEaUFBS0FJZ0lBOGdBQ2dDZkVFRkVCNUJBblJxSWd3b0FnQWhDQ0FBS0FJUUlBQW9BaFFnQlNBQUtBSjBFQ2NpQkVFQklBUWJJUkJCQTBFRUlCb2JJUlFnQUNnQ0tDSWZJQVVnRTNGQkEzUnFJZ3BCQkdvaEZpQUFLQUtJQVNJRVFmOGZJQVJCL3g5Skd5RVhJQTlCQkdvaERTQUZRUWxxSVFjZ0JTQUFLQUlNYXlFYklBQW9Bb0FCSVIwZ0lTRUpJQndoQkFOQUFrQUNmeUFFUVFOR0JFQWdBaWdDQUVGL2Fnd0JDeUFDSUFSQkFuUnFLQUlBQ3lJR1FYOXFJQnRQRFFBZ0QwRUVFQjhnRHlBR2EwRUVFQjlIRFFBZ0RTQU5JQVpySUJJUUhVRUVhaUlHSUFsTkRRQWdHQ0FMUVFOMGFpSUpJQVkyQWdRZ0NTQUVJQnhyTmdJQUlBdEJBV29oQ3lBR0lCZExEUU1nQmlJSklBOXFJQkpHRFFNTElBUkJBV29pQkNBVVNRMEFDeUFNSUFVMkFnQUNRQ0FJSUJCSkRRQWdCVUVDYWlFVVFYOGdIWFJCZjNNaERVRUFJUVZCQUNFTUEwQWdEeUFGSUF3Z0JTQU1TUnNpQkdvZ0NDQVZhaUlYSUFScUlCSVFIU0FFYWlJRUlBbExCRUFnR0NBTFFRTjBhaUlKSUFRMkFnUWdDU0FVSUFock5nSUFJQVFnQ0dvZ0J5QUVJQWNnQ0d0TEd5RUhJQXRCQVdvaEN5QUVRWUFnU3cwQ0lBUWlDU0FQYWlBU1JnMENDeUFmSUFnZ0UzRkJBM1JxSVFZQ1FBSkFJQVFnRjJvdEFBQWdCQ0FQYWkwQUFFa0VRQ0FLSUFnMkFnQWdDQ0FPU3cwQklCRkJRR3NoQ2d3RUN5QVdJQWcyQWdBZ0NDQU9Td1JBSUFZaEZpQUVJUXdNQWdzZ0VVRkFheUVXREFNTElBUWhCU0FHUVFScUlnb2hCZ3NnRFVVTkFTQU5RWDlxSVEwZ0JpZ0NBQ0lJSUJCUERRQUxDeUFXUVFBMkFnQWdDa0VBTmdJQUlBQWdCMEY0YWpZQ0dBd0JDMEVBSVF0QkFDQVBJQUFvQWdRaUZXc2lCVUYvSUFBb0FuaEJmMnAwUVg5ekloTnJJZ1FnQkNBRlN4c2hEaUFBS0FJZ0lBOGdBQ2dDZkVFR0VCNUJBblJxSWd3b0FnQWhDQ0FBS0FJUUlBQW9BaFFnQlNBQUtBSjBFQ2NpQkVFQklBUWJJUkJCQTBFRUlCb2JJUlFnQUNnQ0tDSWZJQVVnRTNGQkEzUnFJZ3BCQkdvaEZpQUFLQUtJQVNJRVFmOGZJQVJCL3g5Skd5RVhJQTlCQkdvaERTQUZRUWxxSVFjZ0JTQUFLQUlNYXlFYklBQW9Bb0FCSVIwZ0lTRUpJQndoQkFOQUFrQUNmeUFFUVFOR0JFQWdBaWdDQUVGL2Fnd0JDeUFDSUFSQkFuUnFLQUlBQ3lJR1FYOXFJQnRQRFFBZ0QwRUVFQjhnRHlBR2EwRUVFQjlIRFFBZ0RTQU5JQVpySUJJUUhVRUVhaUlHSUFsTkRRQWdHQ0FMUVFOMGFpSUpJQVkyQWdRZ0NTQUVJQnhyTmdJQUlBdEJBV29oQ3lBR0lCZExEUUlnQmlJSklBOXFJQkpHRFFJTElBUkJBV29pQkNBVVNRMEFDeUFNSUFVMkFnQUNRQ0FJSUJCSkRRQWdCVUVDYWlFVVFYOGdIWFJCZjNNaERVRUFJUVZCQUNFTUEwQWdEeUFGSUF3Z0JTQU1TUnNpQkdvZ0NDQVZhaUlYSUFScUlCSVFIU0FFYWlJRUlBbExCRUFnR0NBTFFRTjBhaUlKSUFRMkFnUWdDU0FVSUFock5nSUFJQVFnQ0dvZ0J5QUVJQWNnQ0d0TEd5RUhJQXRCQVdvaEN5QUVRWUFnU3cwQ0lBUWlDU0FQYWlBU1JnMENDeUFmSUFnZ0UzRkJBM1JxSVFZQ1FBSkFJQVFnRjJvdEFBQWdCQ0FQYWkwQUFFa0VRQ0FLSUFnMkFnQWdDQ0FPU3cwQklCRkJRR3NoQ2d3RUN5QVdJQWcyQWdBZ0NDQU9Td1JBSUFZaEZpQUVJUXdNQWdzZ0VVRkFheUVXREFNTElBUWhCU0FHUVFScUlnb2hCZ3NnRFVVTkFTQU5RWDlxSVEwZ0JpZ0NBQ0lJSUJCUERRQUxDeUFXUVFBMkFnQWdDa0VBTmdJQUlBQWdCMEY0YWpZQ0dBc2dDMFVOQUNBWklBSW9BZ0EyQWhBZ0dTQUNLQUlFTmdJVUlBSW9BZ2doQkNBWklCbzJBZ3dnR1VFQU5nSUlJQmtnQkRZQ0dDQVpJQU1nR2lBaVFRSVFXQ0lKTmdJQUlCZ2dDMEYvYWtFRGRHb2lCQ2dDQkNJR0lDcExCRUFnQkNnQ0FDRU5EQU1MUVFFaEJFRUFJQ0pCQWhBdElRY0RRQ0FaSUFSQkhHeHFRWUNBZ0lBRU5nSUFJQVJCQVdvaUJDQW9SdzBBQ3lBSElBbHFJUTFCQUNFSElDZ2hCZ05BSUJnZ0IwRURkR29pQkNnQ0JDRUpJQkZCUUdzZ0FpQUVLQUlBSWdvZ0hCQS9JQVlnQ1UwRVFDQUtRUUZxRUNRaUJVRUlkRUdBSUdvaERBTkFJQVpCZldvaEJBSi9JQUFvQW1SQkFVWUVRQ0FFRUNzZ0RHb01BUXNnQUNnQ1lDQUFLQUk0SUFWQkFuUnFLQUlBRUN0cklBQW9BbHhxSUFRUVBFRUNkQ0lFUVpDa0FXb29BZ0FnQldwQkNIUnFJQUFvQWpRZ0JHb29BZ0FRSzJ0Qk0yb0xJUWdnR1NBR1FSeHNhaUlFSUJvMkFnd2dCQ0FLTmdJRUlBUWdCallDQ0NBRUlBZ2dEV28yQWdBZ0JDQVJLUU5BTndJUUlBUWdFU2dDU0RZQ0dDQUdRUUZxSWdZZ0NVME5BQXNMSUFkQkFXb2lCeUFMUncwQUMwRUJJUWtDUUNBR1FYOXFJZ1JGQkVCQkFDRUVEQUVMQTBCQkFTRUlJQmtnQ1VGL2FrRWNiR29pQmlnQ0NFVUVRQ0FHS0FJTVFRRnFJUWdMSUFrZ0Qyb2lEa0YvYWtFQklDSkJBaEJTSUFZb0FnQnFJQWdnSWtFQ0VDMXFJQWhCZjJvZ0lrRUNFQzFySWdjZ0dTQUpRUnhzYWlJVUtBSUFJaFpNQkVBZ0ZDQUlOZ0lNSUJSQ0FEY0NCQ0FVSUFjMkFnQWdGQ0FHS0FJWU5nSVlJQlFnQmlrQ0VEY0NFQ0FISVJZTEFrQWdEaUFwU3cwQUlBUWdDVVlFUUNBSklRUU1Bd3RCQUNFYUlCUW9BZ2dpQjBVRVFDQVVLQUlNSVJvTFFRQWdJa0VDRUMwaExTQUFLQUlFSWdZZ0FDZ0NHQ0lJYWlBT1N3MEFJQUFvQW9RQklRc2dDQ0FPSUFacklncEpCRUFEUUNBQUlBWWdDR29nRWlBTFFRQVFRU0FJYWlJSUlBcEpEUUFMQ3lBSFFRQkhJUndnRkVFUWFpRWZJQUFnQ2pZQ0dBSkFBa0FDUUFKQUFrQWdDMEY5YWc0RkFBRUNBd01CQzBFQUlSQkJBQ0FPSUFBb0FnUWlGMnNpQ2tGL0lBQW9BbmhCZjJwMFFYOXpJaDFySWdZZ0JpQUtTeHNoSXlBQUtBSWdJQTRnQUNnQ2ZFRURFQjVCQW5ScUlpQW9BZ0FoRENBQUtBSVFJQUFvQWhRZ0NpQUFLQUowRUNjaUJrRUJJQVliSVJ0QkJFRURJQWNiSVNRZ0FDZ0NLQ0lsSUFvZ0hYRkJBM1JxSWdaQkJHb2hFeUFBS0FLSUFTSUhRZjhmSUFkQi94OUpHeUVGSUE1QkEyb2hIaUFLUVFscUlSVWdDaUFBS0FJTWF5RW1JQUFvQW9BQklTY2dJU0VISUJ3aENBTkFBa0FDZnlBSVFRTkdCRUFnSHlnQ0FFRi9hZ3dCQ3lBVUlBaEJBblJxS0FJUUN5SU5RWDlxSUNaUERRQWdEa0VERUI4Z0RpQU5hMEVERUI5SERRQWdIaUFlSUExcklCSVFIVUVEYWlJTElBZE5EUUFnR0NBUVFRTjBhaUlISUFzMkFnUWdCeUFJSUJ4ck5nSUFJQkJCQVdvaEVDQUxJQVZMRFFVZ0N5SUhJQTVxSUJKR0RRVUxJQWhCQVdvaUNDQWtTUTBBQ3dKQUlBZEJBa3NOQUVFQ0lRY2dGeUFBS0FJY0lBQW9BaVFnRVVIY0FHb2dEaEJBSWdzZ0cwa05BQ0FLSUF0cklnaEIvLzhQU3cwQUlBNGdDeUFYYWlBU0VCMGlDMEVEU1EwQUlCZ2dDellDQkNBWUlBaEJBbW8yQWdBZ0N5QUZUUVJBUVFFaEVDQUxJZ2NnRG1vZ0VrY05BUXRCQVNFUUlBQWdDa0VCYWpZQ0dBd0VDeUFnSUFvMkFnQUNRQ0FNSUJ0SkRRQWdDa0VDYWlFZVFYOGdKM1JCZjNNaENFRUFJUXRCQUNFS0EwQWdEaUFMSUFvZ0N5QUtTUnNpQldvZ0RDQVhhaUlnSUFWcUlCSVFIU0FGYWlJRklBZExCRUFnR0NBUVFRTjBhaUlISUFVMkFnUWdCeUFlSUF4ck5nSUFJQVVnREdvZ0ZTQUZJQlVnREd0TEd5RVZJQkJCQVdvaEVDQUZRWUFnU3cwQ0lBVWlCeUFPYWlBU1JnMENDeUFsSUF3Z0hYRkJBM1JxSVEwQ1FBSkFJQVVnSUdvdEFBQWdCU0FPYWkwQUFFa0VRQ0FHSUF3MkFnQWdEQ0FqU3cwQklCRkJRR3NoQmd3RUN5QVRJQXcyQWdBZ0RDQWpTd1JBSUEwaEV5QUZJUW9NQWdzZ0VVRkFheUVUREFNTElBVWhDeUFOUVFScUlnWWhEUXNnQ0VVTkFTQUlRWDlxSVFnZ0RTZ0NBQ0lNSUJ0UERRQUxDeUFUUVFBMkFnQWdCa0VBTmdJQUlBQWdGVUY0YWpZQ0dBd0RDMEVBSVJCQkFDQU9JQUFvQWdRaUkyc2lDa0YvSUFBb0FuaEJmMnAwUVg5ekloZHJJZ1lnQmlBS1N4c2hHeUFBS0FJZ0lBNGdBQ2dDZkVFRUVCNUJBblJxSWg0b0FnQWhEQ0FBS0FJUUlBQW9BaFFnQ2lBQUtBSjBFQ2NpQmtFQklBWWJJUjFCQkVFRElBY2JJU0FnQUNnQ0tDSWtJQW9nRjNGQkEzUnFJaE5CQkdvaEJpQUFLQUtJQVNJSFFmOGZJQWRCL3g5Skd5RWxJQTVCQkdvaEJTQUtRUWxxSVJVZ0NpQUFLQUlNYXlFbUlBQW9Bb0FCSVNjZ0lTRUhJQndoQ0FOQUFrQUNmeUFJUVFOR0JFQWdIeWdDQUVGL2Fnd0JDeUFVSUFoQkFuUnFLQUlRQ3lJTlFYOXFJQ1pQRFFBZ0RrRUVFQjhnRGlBTmEwRUVFQjlIRFFBZ0JTQUZJQTFySUJJUUhVRUVhaUlMSUFkTkRRQWdHQ0FRUVFOMGFpSUhJQXMyQWdRZ0J5QUlJQnhyTmdJQUlCQkJBV29oRUNBTElDVkxEUVFnQ3lJSElBNXFJQkpHRFFRTElBaEJBV29pQ0NBZ1NRMEFDeUFlSUFvMkFnQUNRQ0FNSUIxSkRRQWdDa0VDYWlFZVFYOGdKM1JCZjNNaENFRUFJUXRCQUNFS0EwQWdEaUFMSUFvZ0N5QUtTUnNpQldvZ0RDQWphaUlnSUFWcUlCSVFIU0FGYWlJRklBZExCRUFnR0NBUVFRTjBhaUlISUFVMkFnUWdCeUFlSUF4ck5nSUFJQVVnREdvZ0ZTQUZJQlVnREd0TEd5RVZJQkJCQVdvaEVDQUZRWUFnU3cwQ0lBVWlCeUFPYWlBU1JnMENDeUFrSUF3Z0YzRkJBM1JxSVEwQ1FBSkFJQVVnSUdvdEFBQWdCU0FPYWkwQUFFa0VRQ0FUSUF3MkFnQWdEQ0FiU3cwQklCRkJRR3NoRXd3RUN5QUdJQXcyQWdBZ0RDQWJTd1JBSUEwaEJpQUZJUW9NQWdzZ0VVRkFheUVHREFNTElBVWhDeUFOUVFScUloTWhEUXNnQ0VVTkFTQUlRWDlxSVFnZ0RTZ0NBQ0lNSUIxUERRQUxDeUFHUVFBMkFnQWdFMEVBTmdJQUlBQWdGVUY0YWpZQ0dBd0NDMEVBSVJCQkFDQU9JQUFvQWdRaUkyc2lDa0YvSUFBb0FuaEJmMnAwUVg5ekloZHJJZ1lnQmlBS1N4c2hHeUFBS0FJZ0lBNGdBQ2dDZkVFRkVCNUJBblJxSWg0b0FnQWhEQ0FBS0FJUUlBQW9BaFFnQ2lBQUtBSjBFQ2NpQmtFQklBWWJJUjFCQkVFRElBY2JJU0FnQUNnQ0tDSWtJQW9nRjNGQkEzUnFJaE5CQkdvaEJpQUFLQUtJQVNJSFFmOGZJQWRCL3g5Skd5RWxJQTVCQkdvaEJTQUtRUWxxSVJVZ0NpQUFLQUlNYXlFbUlBQW9Bb0FCSVNjZ0lTRUhJQndoQ0FOQUFrQUNmeUFJUVFOR0JFQWdIeWdDQUVGL2Fnd0JDeUFVSUFoQkFuUnFLQUlRQ3lJTlFYOXFJQ1pQRFFBZ0RrRUVFQjhnRGlBTmEwRUVFQjlIRFFBZ0JTQUZJQTFySUJJUUhVRUVhaUlMSUFkTkRRQWdHQ0FRUVFOMGFpSUhJQXMyQWdRZ0J5QUlJQnhyTmdJQUlCQkJBV29oRUNBTElDVkxEUU1nQ3lJSElBNXFJQkpHRFFNTElBaEJBV29pQ0NBZ1NRMEFDeUFlSUFvMkFnQUNRQ0FNSUIxSkRRQWdDa0VDYWlFZVFYOGdKM1JCZjNNaENFRUFJUXRCQUNFS0EwQWdEaUFMSUFvZ0N5QUtTUnNpQldvZ0RDQWphaUlnSUFWcUlCSVFIU0FGYWlJRklBZExCRUFnR0NBUVFRTjBhaUlISUFVMkFnUWdCeUFlSUF4ck5nSUFJQVVnREdvZ0ZTQUZJQlVnREd0TEd5RVZJQkJCQVdvaEVDQUZRWUFnU3cwQ0lBVWlCeUFPYWlBU1JnMENDeUFrSUF3Z0YzRkJBM1JxSVEwQ1FBSkFJQVVnSUdvdEFBQWdCU0FPYWkwQUFFa0VRQ0FUSUF3MkFnQWdEQ0FiU3cwQklCRkJRR3NoRXd3RUN5QUdJQXcyQWdBZ0RDQWJTd1JBSUEwaEJpQUZJUW9NQWdzZ0VVRkFheUVHREFNTElBVWhDeUFOUVFScUloTWhEUXNnQ0VVTkFTQUlRWDlxSVFnZ0RTZ0NBQ0lNSUIxUERRQUxDeUFHUVFBMkFnQWdFMEVBTmdJQUlBQWdGVUY0YWpZQ0dBd0JDMEVBSVJCQkFDQU9JQUFvQWdRaUkyc2lDa0YvSUFBb0FuaEJmMnAwUVg5ekloZHJJZ1lnQmlBS1N4c2hHeUFBS0FJZ0lBNGdBQ2dDZkVFR0VCNUJBblJxSWg0b0FnQWhEQ0FBS0FJUUlBQW9BaFFnQ2lBQUtBSjBFQ2NpQmtFQklBWWJJUjFCQkVFRElBY2JJU0FnQUNnQ0tDSWtJQW9nRjNGQkEzUnFJaE5CQkdvaEJpQUFLQUtJQVNJSFFmOGZJQWRCL3g5Skd5RWxJQTVCQkdvaEJTQUtRUWxxSVJVZ0NpQUFLQUlNYXlFbUlBQW9Bb0FCSVNjZ0lTRUhJQndoQ0FOQUFrQUNmeUFJUVFOR0JFQWdIeWdDQUVGL2Fnd0JDeUFVSUFoQkFuUnFLQUlRQ3lJTlFYOXFJQ1pQRFFBZ0RrRUVFQjhnRGlBTmEwRUVFQjlIRFFBZ0JTQUZJQTFySUJJUUhVRUVhaUlMSUFkTkRRQWdHQ0FRUVFOMGFpSUhJQXMyQWdRZ0J5QUlJQnhyTmdJQUlCQkJBV29oRUNBTElDVkxEUUlnQ3lJSElBNXFJQkpHRFFJTElBaEJBV29pQ0NBZ1NRMEFDeUFlSUFvMkFnQUNRQ0FNSUIxSkRRQWdDa0VDYWlFZVFYOGdKM1JCZjNNaENFRUFJUXRCQUNFS0EwQWdEaUFMSUFvZ0N5QUtTUnNpQldvZ0RDQWphaUlnSUFWcUlCSVFIU0FGYWlJRklBZExCRUFnR0NBUVFRTjBhaUlISUFVMkFnUWdCeUFlSUF4ck5nSUFJQVVnREdvZ0ZTQUZJQlVnREd0TEd5RVZJQkJCQVdvaEVDQUZRWUFnU3cwQ0lBVWlCeUFPYWlBU1JnMENDeUFrSUF3Z0YzRkJBM1JxSVEwQ1FBSkFJQVVnSUdvdEFBQWdCU0FPYWkwQUFFa0VRQ0FUSUF3MkFnQWdEQ0FiU3cwQklCRkJRR3NoRXd3RUN5QUdJQXcyQWdBZ0RDQWJTd1JBSUEwaEJpQUZJUW9NQWdzZ0VVRkFheUVHREFNTElBVWhDeUFOUVFScUloTWhEUXNnQ0VVTkFTQUlRWDlxSVFnZ0RTZ0NBQ0lNSUIxUERRQUxDeUFHUVFBMkFnQWdFMEVBTmdJQUlBQWdGVUY0YWpZQ0dBc2dFRVVOQUNBWUlCQkJmMnBCQTNScUlnY29BZ1FpQmlBcVN5QUdJQWxxUVlBZ1QzSU5CQ0FXSUMxcUlReEJBQ0VXQTBBZ0VVRkFheUFmSUJnZ0ZrRURkR29pQnlnQ0FDSUdJQndRUHlBb0lRVUNmeUFXQkVBZ0IwRjhhaWdDQUVFQmFpRUZDeUFIS0FJRUlnZ2dCVThMQkVBZ0JrRUJhaEFrSWd0QkNIUkJnQ0JxSVJNRFFDQUlRWDFxSVFvZ0NDQUphaUVIQW44Z0FDZ0NaRUVCUmdSQUlBb1FLeUFUYWd3QkN5QUFLQUpnSUFBb0FqZ2dDMEVDZEdvb0FnQVFLMnNnQUNnQ1hHb2dDaEE4UVFKMElncEJrS1FCYWlnQ0FDQUxha0VJZEdvZ0FDZ0NOQ0FLYWlnQ0FCQXJhMEV6YWdzZ0RHb2hDZ0pBQWtBZ0J5QUVUUVJBSUFvZ0dTQUhRUnhzYWlnQ0FFZ05BUXdDQ3dOQUlCa2dCRUVCYWlJRVFSeHNha0dBZ0lDQUJEWUNBQ0FFSUFkSkRRQUxDeUFaSUFkQkhHeHFJZ2NnR2pZQ0RDQUhJQVkyQWdRZ0J5QUlOZ0lJSUFjZ0NqWUNBQ0FISUJFcEEwQTNBaEFnQnlBUktBSklOZ0lZQ3lBSVFYOXFJZ2dnQlU4TkFBc0xJQlpCQVdvaUZpQVFSdzBBQ3dzZ0NVRUJhaUlKSUFSTkRRQUxDeUFaSUFSQkhHeHFJZ2tvQWd3aEdpQUpLQUlFSVEwZ0NTZ0NBQ0VzSUFrb0FnZ2hCaUFSSUFrb0FoZzJBbGdnRVNBSktRSVFOd05RSUJFZ0NTa0NDRGNES0NBUklBa3BBaEEzQXpBZ0VTQUpLQUlZTmdJNElCRWdDU2tDQURjRElFRUFJQVFnRVVFZ2FoQStheUlKSUFrZ0JFc2JJUVFNQXdzZ0QwRUJhaUVQREFjTElBY29BZ0FoRFVFQUlRUWdDU0FVS0FJSUJIOGdCQVVnRkNnQ0RBdHJJZ1JCZ0NCTkRRRUxJQmtnR2pZQ0tDQVpJQVkyQWlRZ0dTQU5OZ0lnSUJrZ0xEWUNIQ0FaSUJFb0FsZzJBalFnR1NBUktRTlFOd0lzREFFTElCa2dCRUVCYWlJTFFSeHNhaUlKSUJvMkFnd2dDU0FHTmdJSUlBa2dEVFlDQkNBSklDdzJBZ0FnQ1NBUktRTlFOd0lRSUFrZ0VTZ0NXRFlDR0NBTElSb2dCQTBCQzBFQklScEJBU0VMREFFTEEwQWdFU0FaSUFSQkhHeHFJZ2tpQ2tFWWFpZ0NBRFlDR0NBUklBa3BBaEEzQXhBZ0VTQUpLUUlJTndNSUlCRWdDU2tDQURjREFDQVJFRDRoQmlBWklCcEJmMm9pR2tFY2JHb2lCeUFLS0FJWU5nSVlJQWNnQ1NrQ0VEY0NFQ0FISUFrcEFnZzNBZ2dnQnlBSktRSUFOd0lBSUFRZ0Jrc2hDVUVBSUFRZ0Jtc2lCeUFISUFSTEd5RUVJQWtOQUFzZ0dpQUxTdzBCQ3dOQUlCa2dHa0VjYkdvaUJDZ0NEQ0VIQW44Z0F5QUhhaUFFS0FJSUlnVkZEUUFhQWtBQ1FDQUVLQUlFSWdwQkEwOEVRQ0FDSUFJcEFnQTNBZ1FnQ2tGK2FpRUVEQUVMQWtBQ1FBSkFBa0FnQ2lBSFJXb2lDUTRFQlFFQkFBRUxJQUlvQWdCQmYyb2hCQXdCQ3lBQ0lBbEJBblJxS0FJQUlRUWdDVUVDU1EwQkN5QUNJQUlvQWdRMkFnZ0xJQUlnQWlnQ0FEWUNCQXNnQWlBRU5nSUFDeUFpSUFjZ0F5QUtJQVVRVnlBRlFYMXFJUWdnQVNnQ0RDRUVBa0FDUUNBRElBZHFJZ2tnSzAwRVFDQUVJQU1RSENBQktBSU1JUVFnQjBFUVRRUkFJQUVnQkNBSGFqWUNEQXdEQ3lBRVFSQnFJQU5CRUdvaUJoQWNJQVJCSUdvZ0EwRWdhaEFjSUFkQk1VZ05BU0FFSUFkcUlRMGdCRUV3YWlFRUEwQWdCQ0FHUVNCcUlna1FIQ0FFUVJCcUlBWkJNR29RSENBSklRWWdCRUVnYWlJRUlBMUpEUUFMREFFTElBUWdBeUFKSUNzUUlnc2dBU0FCS0FJTUlBZHFOZ0lNSUFkQmdJQUVTUTBBSUFGQkFUWUNKQ0FCSUFFb0FnUWdBU2dDQUd0QkEzVTJBaWdMSUFFb0FnUWlCQ0FLUVFGcU5nSUFJQVFnQnpzQkJDQUlRWUNBQkU4RVFDQUJRUUkyQWlRZ0FTQUVJQUVvQWdCclFRTjFOZ0lvQ3lBRUlBZzdBUVlnQVNBRVFRaHFOZ0lFSUFVZ0Iyb2dBMm9pQXdzaER5QWFRUUZxSWhvZ0MwME5BQXNMSUNKQkFoQlJDeUFQSUNsSkRRQUxDeUFSUWVBQWFpUUFJQklnQTJzTGNnRUNmeUFCS0FJNEJFQWdBZ1JBSUFBUUt3OExJQUFRTGc4TElBQVFnQUZCQW5RaUFFR3dwd0ZxS0FJQVFRaDBJUVFnQVNnQ0JDSUJLQUlBSVFNQ2Z5QUNCRUFnQXhBcklRSWdBQ0FCYWlnQ0FCQXJEQUVMSUFNUUxpRUNJQUFnQVdvb0FnQVFMZ3NoQVNBQ0lBUnFJQUZyQzJZQkFYOGpBRUV3YXlJR0pBQWdCa0VZYWlBQkVKWUJJQVpCQ0dvZ0FoQ1dBU0FHUVNocUlBWkJHR29nQmtFSWFpQURJQVFnQlNBQUVRd0FJQVpCS0dvUXlBRWhBQ0FHUVNocUVNVUJJQVpCQ0dvUWtnRWdCa0VZYWhDU0FTQUdRVEJxSkFBZ0FBdGZBUUYvSXdCQjBCRnJJZ2drQUNBSVFRQTJBbEFDUUNBSVFRaHFJQUFnQVNBQ0lBTWdCQ0FGSUFZUXZBSWdCeENtQWlJR1FRQklEUUFnQ0VFSWFpQUJFS1VDSWdaQkFFZ05BQ0FJUVFocUVMc0NJUVlMSUFoQjBCRnFKQUFnQmd1M1BnRXBmeU1BUWVBQWF5SVFKQUFnQUNnQ2hBRWhCaUFBS0FJRUlTSWdBQ2dDaUFFaEJTQUFLQUlNSVFnZ0VDQUFLQUlZTmdKY0lBQW9BandoRnlBQVFVQnJLQUlBSVJZZ0FFRXNhaUlrSUFNZ0JFRUFFRmtnQXlBSUlDSnFJQU5HYWlJUElBTWdCR29pRVVGNGFpSXBTUVJBSUFWQi94OGdCVUgvSDBrYklTb2dFVUZnYWlFclFRTkJCQ0FHUVFOR0d5SW9RWDlxSVNJRFFBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUFLQUlFSWdVZ0FDZ0NHQ0lFYWlBUFN3MEFJQThnQTJzaEhTQUFLQUtFQVNFR0lBUWdEeUFGYXlJSVNRUkFBMEFnQUNBRUlBVnFJQkVnQmtFQUVFRWdCR29pQkNBSVNRMEFDd3NnSFVVaEd5QUFJQWcyQWhnQ1FBSkFBa0FDUUFKQUlBWkJmV29PQlFBQkFnTURBUXRCQUNFTFFRQWdEeUFBS0FJRUloOXJJZ3BCZnlBQUtBSjRRWDlxZEVGL2N5SU5heUlFSUFRZ0Nrc2JJUlVnQUNnQ0lDQVBJQUFvQW54QkF4QWVRUUowYWlJU0tBSUFJUWNnQUNnQ0VDQUFLQUlVSUFvZ0FDZ0NkQkFuSWdSQkFTQUVHeUVPUVFOQkJDQWRHeUVZSUFBb0FpZ2lIQ0FLSUExeFFRTjBhaUlHUVFScUlSTWdBQ2dDaUFFaUJFSC9IeUFFUWY4ZlNSc2hDU0FQUVFOcUlRd2dDa0VKYWlFVUlBb2dBQ2dDREdzaEdTQUFLQUtBQVNFYUlDSWhCU0FiSVFRRFFBSkFBbjhnQkVFRFJnUkFJQUlvQWdCQmYyb01BUXNnQWlBRVFRSjBhaWdDQUFzaUNFRi9haUFaVHcwQUlBOUJBeEFmSUE4Z0NHdEJBeEFmUncwQUlBd2dEQ0FJYXlBUkVCMUJBMm9pQ0NBRlRRMEFJQmNnQzBFRGRHb2lCU0FJTmdJRUlBVWdCQ0FiYXpZQ0FDQUxRUUZxSVFzZ0NDQUpTdzBGSUFnaUJTQVBhaUFSUmcwRkN5QUVRUUZxSWdRZ0dFa05BQXNDUUNBRlFRSkxEUUJCQWlFRklCOGdBQ2dDSENBQUtBSWtJQkJCM0FCcUlBOFFRQ0lFSUE1SkRRQWdDaUFFYXlJSVFmLy9EMHNOQUNBUElBUWdIMm9nRVJBZElnUkJBMGtOQUNBWElBUTJBZ1FnRnlBSVFRSnFOZ0lBSUFRZ0NVMEVRRUVCSVFzZ0JDSUZJQTlxSUJGSERRRUxRUUVoQ3lBQUlBcEJBV28yQWhnTUJBc2dFaUFLTmdJQUFrQWdCeUFPU1EwQUlBcEJBbW9oRWtGL0lCcDBRWDl6SVF4QkFDRUtRUUFoQ1FOQUlBOGdDaUFKSUFvZ0NVa2JJZ1JxSUFjZ0gyb2lHQ0FFYWlBUkVCMGdCR29pQkNBRlN3UkFJQmNnQzBFRGRHb2lCU0FFTmdJRUlBVWdFaUFIYXpZQ0FDQUVJQWRxSUJRZ0JDQVVJQWRyU3hzaEZDQUxRUUZxSVFzZ0JFR0FJRXNOQWlBRUlnVWdEMm9nRVVZTkFnc2dIQ0FISUExeFFRTjBhaUVJQWtBQ1FDQUVJQmhxTFFBQUlBUWdEMm90QUFCSkJFQWdCaUFITmdJQUlBY2dGVXNOQVNBUVFVQnJJUVlNQkFzZ0V5QUhOZ0lBSUFjZ0ZVc0VRQ0FJSVJNZ0JDRUpEQUlMSUJCQlFHc2hFd3dEQ3lBRUlRb2dDRUVFYWlJR0lRZ0xJQXhGRFFFZ0RFRi9haUVNSUFnb0FnQWlCeUFPVHcwQUN3c2dFMEVBTmdJQUlBWkJBRFlDQUNBQUlCUkJlR28yQWhnTUF3dEJBQ0VMUVFBZ0R5QUFLQUlFSWhWcklncEJmeUFBS0FKNFFYOXFkRUYvY3lJVGF5SUVJQVFnQ2tzYklSOGdBQ2dDSUNBUElBQW9BbnhCQkJBZVFRSjBhaUlNS0FJQUlRY2dBQ2dDRUNBQUtBSVVJQW9nQUNnQ2RCQW5JZ1JCQVNBRUd5RU5RUU5CQkNBZEd5RVNJQUFvQWlnaUdDQUtJQk54UVFOMGFpSU9RUVJxSVFZZ0FDZ0NpQUVpQkVIL0h5QUVRZjhmU1JzaEhDQVBRUVJxSVFrZ0NrRUphaUVVSUFvZ0FDZ0NER3NoR1NBQUtBS0FBU0VhSUNJaEJTQWJJUVFEUUFKQUFuOGdCRUVEUmdSQUlBSW9BZ0JCZjJvTUFRc2dBaUFFUVFKMGFpZ0NBQXNpQ0VGL2FpQVpUdzBBSUE5QkJCQWZJQThnQ0d0QkJCQWZSdzBBSUFrZ0NTQUlheUFSRUIxQkJHb2lDQ0FGVFEwQUlCY2dDMEVEZEdvaUJTQUlOZ0lFSUFVZ0JDQWJhellDQUNBTFFRRnFJUXNnQ0NBY1N3MEVJQWdpQlNBUGFpQVJSZzBFQ3lBRVFRRnFJZ1FnRWtrTkFBc2dEQ0FLTmdJQUFrQWdCeUFOU1EwQUlBcEJBbW9oRWtGL0lCcDBRWDl6SVF4QkFDRUtRUUFoQ1FOQUlBOGdDaUFKSUFvZ0NVa2JJZ1JxSUFjZ0ZXb2lIQ0FFYWlBUkVCMGdCR29pQkNBRlN3UkFJQmNnQzBFRGRHb2lCU0FFTmdJRUlBVWdFaUFIYXpZQ0FDQUVJQWRxSUJRZ0JDQVVJQWRyU3hzaEZDQUxRUUZxSVFzZ0JFR0FJRXNOQWlBRUlnVWdEMm9nRVVZTkFnc2dHQ0FISUJOeFFRTjBhaUVJQWtBQ1FDQUVJQnhxTFFBQUlBUWdEMm90QUFCSkJFQWdEaUFITmdJQUlBY2dIMHNOQVNBUVFVQnJJUTRNQkFzZ0JpQUhOZ0lBSUFjZ0gwc0VRQ0FJSVFZZ0JDRUpEQUlMSUJCQlFHc2hCZ3dEQ3lBRUlRb2dDRUVFYWlJT0lRZ0xJQXhGRFFFZ0RFRi9haUVNSUFnb0FnQWlCeUFOVHcwQUN3c2dCa0VBTmdJQUlBNUJBRFlDQUNBQUlCUkJlR28yQWhnTUFndEJBQ0VMUVFBZ0R5QUFLQUlFSWhWcklncEJmeUFBS0FKNFFYOXFkRUYvY3lJVGF5SUVJQVFnQ2tzYklSOGdBQ2dDSUNBUElBQW9BbnhCQlJBZVFRSjBhaUlNS0FJQUlRY2dBQ2dDRUNBQUtBSVVJQW9nQUNnQ2RCQW5JZ1JCQVNBRUd5RU5RUU5CQkNBZEd5RVNJQUFvQWlnaUdDQUtJQk54UVFOMGFpSU9RUVJxSVFZZ0FDZ0NpQUVpQkVIL0h5QUVRZjhmU1JzaEhDQVBRUVJxSVFrZ0NrRUphaUVVSUFvZ0FDZ0NER3NoR1NBQUtBS0FBU0VhSUNJaEJTQWJJUVFEUUFKQUFuOGdCRUVEUmdSQUlBSW9BZ0JCZjJvTUFRc2dBaUFFUVFKMGFpZ0NBQXNpQ0VGL2FpQVpUdzBBSUE5QkJCQWZJQThnQ0d0QkJCQWZSdzBBSUFrZ0NTQUlheUFSRUIxQkJHb2lDQ0FGVFEwQUlCY2dDMEVEZEdvaUJTQUlOZ0lFSUFVZ0JDQWJhellDQUNBTFFRRnFJUXNnQ0NBY1N3MERJQWdpQlNBUGFpQVJSZzBEQ3lBRVFRRnFJZ1FnRWtrTkFBc2dEQ0FLTmdJQUFrQWdCeUFOU1EwQUlBcEJBbW9oRWtGL0lCcDBRWDl6SVF4QkFDRUtRUUFoQ1FOQUlBOGdDaUFKSUFvZ0NVa2JJZ1JxSUFjZ0ZXb2lIQ0FFYWlBUkVCMGdCR29pQkNBRlN3UkFJQmNnQzBFRGRHb2lCU0FFTmdJRUlBVWdFaUFIYXpZQ0FDQUVJQWRxSUJRZ0JDQVVJQWRyU3hzaEZDQUxRUUZxSVFzZ0JFR0FJRXNOQWlBRUlnVWdEMm9nRVVZTkFnc2dHQ0FISUJOeFFRTjBhaUVJQWtBQ1FDQUVJQnhxTFFBQUlBUWdEMm90QUFCSkJFQWdEaUFITmdJQUlBY2dIMHNOQVNBUVFVQnJJUTRNQkFzZ0JpQUhOZ0lBSUFjZ0gwc0VRQ0FJSVFZZ0JDRUpEQUlMSUJCQlFHc2hCZ3dEQ3lBRUlRb2dDRUVFYWlJT0lRZ0xJQXhGRFFFZ0RFRi9haUVNSUFnb0FnQWlCeUFOVHcwQUN3c2dCa0VBTmdJQUlBNUJBRFlDQUNBQUlCUkJlR28yQWhnTUFRdEJBQ0VMUVFBZ0R5QUFLQUlFSWhWcklncEJmeUFBS0FKNFFYOXFkRUYvY3lJVGF5SUVJQVFnQ2tzYklSOGdBQ2dDSUNBUElBQW9BbnhCQmhBZVFRSjBhaUlNS0FJQUlRY2dBQ2dDRUNBQUtBSVVJQW9nQUNnQ2RCQW5JZ1JCQVNBRUd5RU5RUU5CQkNBZEd5RVNJQUFvQWlnaUdDQUtJQk54UVFOMGFpSU9RUVJxSVFZZ0FDZ0NpQUVpQkVIL0h5QUVRZjhmU1JzaEhDQVBRUVJxSVFrZ0NrRUphaUVVSUFvZ0FDZ0NER3NoR1NBQUtBS0FBU0VhSUNJaEJTQWJJUVFEUUFKQUFuOGdCRUVEUmdSQUlBSW9BZ0JCZjJvTUFRc2dBaUFFUVFKMGFpZ0NBQXNpQ0VGL2FpQVpUdzBBSUE5QkJCQWZJQThnQ0d0QkJCQWZSdzBBSUFrZ0NTQUlheUFSRUIxQkJHb2lDQ0FGVFEwQUlCY2dDMEVEZEdvaUJTQUlOZ0lFSUFVZ0JDQWJhellDQUNBTFFRRnFJUXNnQ0NBY1N3MENJQWdpQlNBUGFpQVJSZzBDQ3lBRVFRRnFJZ1FnRWtrTkFBc2dEQ0FLTmdJQUFrQWdCeUFOU1EwQUlBcEJBbW9oRWtGL0lCcDBRWDl6SVF4QkFDRUtRUUFoQ1FOQUlBOGdDaUFKSUFvZ0NVa2JJZ1JxSUFjZ0ZXb2lIQ0FFYWlBUkVCMGdCR29pQkNBRlN3UkFJQmNnQzBFRGRHb2lCU0FFTmdJRUlBVWdFaUFIYXpZQ0FDQUVJQWRxSUJRZ0JDQVVJQWRyU3hzaEZDQUxRUUZxSVFzZ0JFR0FJRXNOQWlBRUlnVWdEMm9nRVVZTkFnc2dHQ0FISUJOeFFRTjBhaUVJQWtBQ1FDQUVJQnhxTFFBQUlBUWdEMm90QUFCSkJFQWdEaUFITmdJQUlBY2dIMHNOQVNBUVFVQnJJUTRNQkFzZ0JpQUhOZ0lBSUFjZ0gwc0VRQ0FJSVFZZ0JDRUpEQUlMSUJCQlFHc2hCZ3dEQ3lBRUlRb2dDRUVFYWlJT0lRZ0xJQXhGRFFFZ0RFRi9haUVNSUFnb0FnQWlCeUFOVHcwQUN3c2dCa0VBTmdJQUlBNUJBRFlDQUNBQUlCUkJlR28yQWhnTElBdEZEUUFnRmlBQ0tBSUFOZ0lRSUJZZ0FpZ0NCRFlDRkNBQ0tBSUlJUVFnRmlBZE5nSU1JQlpCQURZQ0NDQVdJQVEyQWhnZ0ZpQURJQjBnSkVFQUVGZ2lCVFlDQUNBWElBdEJmMnBCQTNScUlnUW9BZ1FpQ0NBcVN3UkFJQVFvQWdBaEJRd0RDMEVCSVFSQkFDQWtRUUFRTFNFR0EwQWdGaUFFUVJ4c2FrR0FnSUNBQkRZQ0FDQUVRUUZxSWdRZ0tFY05BQXNnQlNBR2FpRU1RUUFoQmlBb0lRZ0RRQ0FYSUFaQkEzUnFJZ1FvQWdRaENpQVFRVUJySUFJZ0JDZ0NBQ0lKSUJzUVB5QUlJQXBOQkVBZ0NVRUJhaEFrSWdWQkNYUkJzN1IvYWtFeklBVkJFMHNiSVJRZ0JVRUlkRUdBSUdvaEV3TkFJQWhCZldvaEJBSi9JQUFvQW1SQkFVWUVRQ0FFRUM0Z0Uyb01BUXNnQUNnQ1lDQVVhaUFBS0FJNElBVkJBblJxS0FJQUVDNXJJQUFvQWx4cUlBUVFQRUVDZENJRVFaQ2tBV29vQWdBZ0JXcEJDSFJxSUFBb0FqUWdCR29vQWdBUUxtc0xJUWNnRmlBSVFSeHNhaUlFSUIwMkFnd2dCQ0FKTmdJRUlBUWdDRFlDQ0NBRUlBY2dER28yQWdBZ0JDQVFLUU5BTndJUUlBUWdFQ2dDU0RZQ0dDQUlRUUZxSWdnZ0NrME5BQXNMSUFaQkFXb2lCaUFMUncwQUMwRUJJUW9DUUNBSVFYOXFJZ1JGQkVCQkFDRUVEQUVMQTBCQkFTRUhJQllnQ2tGL2FrRWNiR29pQmlnQ0NFVUVRQ0FHS0FJTVFRRnFJUWNMSUFvZ0Qyb2lEVUYvYWtFQklDUkJBQkJTSUFZb0FnQnFJQWNnSkVFQUVDMXFJQWRCZjJvZ0pFRUFFQzFySWdVZ0ZpQUtRUnhzYWlJWUtBSUFJaFJNQkVBZ0dDQUhOZ0lNSUJoQ0FEY0NCQ0FZSUFVMkFnQWdHQ0FHS0FJWU5nSVlJQmdnQmlrQ0VEY0NFQ0FGSVJRTElBMGdLVXNFZnlBS1FRRnFCU0FFSUFwR0JFQWdDaUVFREFNTEFrQWdGaUFLUVFGcUloOUJIR3hxS0FJQUlCUkJnQUZxVEEwQVFRQWhIU0FZS0FJSUlnVkZCRUFnR0NnQ0RDRWRDMEVBSUNSQkFCQXRJUzBnQUNnQ0JDSUdJQUFvQWhnaUIyb2dEVXNOQUNBQUtBS0VBU0VJSUFjZ0RTQUdheUlKU1FSQUEwQWdBQ0FHSUFkcUlCRWdDRUVBRUVFZ0Iyb2lCeUFKU1EwQUN3c2dCVUVBUnlFYklCaEJFR29oSENBQUlBazJBaGdDUUFKQUFrQUNRQUpBSUFoQmZXb09CUUFCQWdNREFRdEJBQ0VPUVFBZ0RTQUFLQUlFSWhscklnaEJmeUFBS0FKNFFYOXFkRUYvY3lJaGF5SUdJQVlnQ0VzYklTVWdBQ2dDSUNBTklBQW9BbnhCQXhBZVFRSjBhaUllS0FJQUlRa2dBQ2dDRUNBQUtBSVVJQWdnQUNnQ2RCQW5JZ1pCQVNBR0d5RWFRUVJCQXlBRkd5RWpJQUFvQWlnaUlDQUlJQ0Z4UVFOMGFpSU1RUVJxSVJNZ0FDZ0NpQUVpQlVIL0h5QUZRZjhmU1JzaEN5QU5RUU5xSVJJZ0NFRUphaUVWSUFnZ0FDZ0NER3NoSmlBQUtBS0FBU0VuSUNJaEJpQWJJUWNEUUFKQUFuOGdCMEVEUmdSQUlCd29BZ0JCZjJvTUFRc2dHQ0FIUVFKMGFpZ0NFQXNpQlVGL2FpQW1UdzBBSUExQkF4QWZJQTBnQld0QkF4QWZSdzBBSUJJZ0VpQUZheUFSRUIxQkEyb2lCU0FHVFEwQUlCY2dEa0VEZEdvaUJpQUZOZ0lFSUFZZ0J5QWJhellDQUNBT1FRRnFJUTRnQlNBTFN3MEZJQVVpQmlBTmFpQVJSZzBGQ3lBSFFRRnFJZ2NnSTBrTkFBc0NRQ0FHUVFKTERRQkJBaUVHSUJrZ0FDZ0NIQ0FBS0FJa0lCQkIzQUJxSUEwUVFDSUZJQnBKRFFBZ0NDQUZheUlIUWYvL0Qwc05BQ0FOSUFVZ0dXb2dFUkFkSWdWQkEwa05BQ0FYSUFVMkFnUWdGeUFIUVFKcU5nSUFJQVVnQzAwRVFFRUJJUTRnQlNJR0lBMXFJQkZIRFFFTFFRRWhEaUFBSUFoQkFXbzJBaGdNQkFzZ0hpQUlOZ0lBQWtBZ0NTQWFTUTBBSUFoQkFtb2hIa0YvSUNkMFFYOXpJUkpCQUNFTFFRQWhDQU5BSUEwZ0N5QUlJQXNnQ0VrYklnVnFJQWtnR1dvaUl5QUZhaUFSRUIwZ0JXb2lCeUFHU3dSQUlCY2dEa0VEZEdvaUJTQUhOZ0lFSUFVZ0hpQUphellDQUNBSElBbHFJQlVnQnlBVklBbHJTeHNoRlNBT1FRRnFJUTRnQjBHQUlFc05BaUFISWdZZ0RXb2dFVVlOQWdzZ0lDQUpJQ0Z4UVFOMGFpRUZBa0FDUUNBSElDTnFMUUFBSUFjZ0RXb3RBQUJKQkVBZ0RDQUpOZ0lBSUFrZ0pVc05BU0FRUVVCcklRd01CQXNnRXlBSk5nSUFJQWtnSlVzRVFDQUZJUk1nQnlFSURBSUxJQkJCUUdzaEV3d0RDeUFISVFzZ0JVRUVhaUlNSVFVTElCSkZEUUVnRWtGL2FpRVNJQVVvQWdBaUNTQWFUdzBBQ3dzZ0UwRUFOZ0lBSUF4QkFEWUNBQ0FBSUJWQmVHbzJBaGdNQXd0QkFDRU9RUUFnRFNBQUtBSUVJaVZySWdoQmZ5QUFLQUo0UVg5cWRFRi9jeUlaYXlJR0lBWWdDRXNiSVJvZ0FDZ0NJQ0FOSUFBb0FueEJCQkFlUVFKMGFpSVNLQUlBSVFrZ0FDZ0NFQ0FBS0FJVUlBZ2dBQ2dDZEJBbklnWkJBU0FHR3lFaFFRUkJBeUFGR3lFZUlBQW9BaWdpSXlBSUlCbHhRUU4wYWlJVFFRUnFJUXdnQUNnQ2lBRWlCVUgvSHlBRlFmOGZTUnNoSUNBTlFRUnFJUXNnQ0VFSmFpRVZJQWdnQUNnQ0RHc2hKaUFBS0FLQUFTRW5JQ0loQmlBYklRY0RRQUpBQW44Z0IwRURSZ1JBSUJ3b0FnQkJmMm9NQVFzZ0dDQUhRUUowYWlnQ0VBc2lCVUYvYWlBbVR3MEFJQTFCQkJBZklBMGdCV3RCQkJBZlJ3MEFJQXNnQ3lBRmF5QVJFQjFCQkdvaUJTQUdUUTBBSUJjZ0RrRURkR29pQmlBRk5nSUVJQVlnQnlBYmF6WUNBQ0FPUVFGcUlRNGdCU0FnU3cwRUlBVWlCaUFOYWlBUlJnMEVDeUFIUVFGcUlnY2dIa2tOQUFzZ0VpQUlOZ0lBQWtBZ0NTQWhTUTBBSUFoQkFtb2hIa0YvSUNkMFFYOXpJUkpCQUNFTFFRQWhDQU5BSUEwZ0N5QUlJQXNnQ0VrYklnVnFJQWtnSldvaUlDQUZhaUFSRUIwZ0JXb2lCeUFHU3dSQUlCY2dEa0VEZEdvaUJTQUhOZ0lFSUFVZ0hpQUphellDQUNBSElBbHFJQlVnQnlBVklBbHJTeHNoRlNBT1FRRnFJUTRnQjBHQUlFc05BaUFISWdZZ0RXb2dFVVlOQWdzZ0l5QUpJQmx4UVFOMGFpRUZBa0FDUUNBSElDQnFMUUFBSUFjZ0RXb3RBQUJKQkVBZ0V5QUpOZ0lBSUFrZ0drc05BU0FRUVVCcklSTU1CQXNnRENBSk5nSUFJQWtnR2tzRVFDQUZJUXdnQnlFSURBSUxJQkJCUUdzaERBd0RDeUFISVFzZ0JVRUVhaUlUSVFVTElCSkZEUUVnRWtGL2FpRVNJQVVvQWdBaUNTQWhUdzBBQ3dzZ0RFRUFOZ0lBSUJOQkFEWUNBQ0FBSUJWQmVHbzJBaGdNQWd0QkFDRU9RUUFnRFNBQUtBSUVJaVZySWdoQmZ5QUFLQUo0UVg5cWRFRi9jeUlaYXlJR0lBWWdDRXNiSVJvZ0FDZ0NJQ0FOSUFBb0FueEJCUkFlUVFKMGFpSVNLQUlBSVFrZ0FDZ0NFQ0FBS0FJVUlBZ2dBQ2dDZEJBbklnWkJBU0FHR3lFaFFRUkJBeUFGR3lFZUlBQW9BaWdpSXlBSUlCbHhRUU4wYWlJVFFRUnFJUXdnQUNnQ2lBRWlCVUgvSHlBRlFmOGZTUnNoSUNBTlFRUnFJUXNnQ0VFSmFpRVZJQWdnQUNnQ0RHc2hKaUFBS0FLQUFTRW5JQ0loQmlBYklRY0RRQUpBQW44Z0IwRURSZ1JBSUJ3b0FnQkJmMm9NQVFzZ0dDQUhRUUowYWlnQ0VBc2lCVUYvYWlBbVR3MEFJQTFCQkJBZklBMGdCV3RCQkJBZlJ3MEFJQXNnQ3lBRmF5QVJFQjFCQkdvaUJTQUdUUTBBSUJjZ0RrRURkR29pQmlBRk5nSUVJQVlnQnlBYmF6WUNBQ0FPUVFGcUlRNGdCU0FnU3cwRElBVWlCaUFOYWlBUlJnMERDeUFIUVFGcUlnY2dIa2tOQUFzZ0VpQUlOZ0lBQWtBZ0NTQWhTUTBBSUFoQkFtb2hIa0YvSUNkMFFYOXpJUkpCQUNFTFFRQWhDQU5BSUEwZ0N5QUlJQXNnQ0VrYklnVnFJQWtnSldvaUlDQUZhaUFSRUIwZ0JXb2lCeUFHU3dSQUlCY2dEa0VEZEdvaUJTQUhOZ0lFSUFVZ0hpQUphellDQUNBSElBbHFJQlVnQnlBVklBbHJTeHNoRlNBT1FRRnFJUTRnQjBHQUlFc05BaUFISWdZZ0RXb2dFVVlOQWdzZ0l5QUpJQmx4UVFOMGFpRUZBa0FDUUNBSElDQnFMUUFBSUFjZ0RXb3RBQUJKQkVBZ0V5QUpOZ0lBSUFrZ0drc05BU0FRUVVCcklSTU1CQXNnRENBSk5nSUFJQWtnR2tzRVFDQUZJUXdnQnlFSURBSUxJQkJCUUdzaERBd0RDeUFISVFzZ0JVRUVhaUlUSVFVTElCSkZEUUVnRWtGL2FpRVNJQVVvQWdBaUNTQWhUdzBBQ3dzZ0RFRUFOZ0lBSUJOQkFEWUNBQ0FBSUJWQmVHbzJBaGdNQVF0QkFDRU9RUUFnRFNBQUtBSUVJaVZySWdoQmZ5QUFLQUo0UVg5cWRFRi9jeUlaYXlJR0lBWWdDRXNiSVJvZ0FDZ0NJQ0FOSUFBb0FueEJCaEFlUVFKMGFpSVNLQUlBSVFrZ0FDZ0NFQ0FBS0FJVUlBZ2dBQ2dDZEJBbklnWkJBU0FHR3lFaFFRUkJBeUFGR3lFZUlBQW9BaWdpSXlBSUlCbHhRUU4wYWlJVFFRUnFJUXdnQUNnQ2lBRWlCVUgvSHlBRlFmOGZTUnNoSUNBTlFRUnFJUXNnQ0VFSmFpRVZJQWdnQUNnQ0RHc2hKaUFBS0FLQUFTRW5JQ0loQmlBYklRY0RRQUpBQW44Z0IwRURSZ1JBSUJ3b0FnQkJmMm9NQVFzZ0dDQUhRUUowYWlnQ0VBc2lCVUYvYWlBbVR3MEFJQTFCQkJBZklBMGdCV3RCQkJBZlJ3MEFJQXNnQ3lBRmF5QVJFQjFCQkdvaUJTQUdUUTBBSUJjZ0RrRURkR29pQmlBRk5nSUVJQVlnQnlBYmF6WUNBQ0FPUVFGcUlRNGdCU0FnU3cwQ0lBVWlCaUFOYWlBUlJnMENDeUFIUVFGcUlnY2dIa2tOQUFzZ0VpQUlOZ0lBQWtBZ0NTQWhTUTBBSUFoQkFtb2hIa0YvSUNkMFFYOXpJUkpCQUNFTFFRQWhDQU5BSUEwZ0N5QUlJQXNnQ0VrYklnVnFJQWtnSldvaUlDQUZhaUFSRUIwZ0JXb2lCeUFHU3dSQUlCY2dEa0VEZEdvaUJTQUhOZ0lFSUFVZ0hpQUphellDQUNBSElBbHFJQlVnQnlBVklBbHJTeHNoRlNBT1FRRnFJUTRnQjBHQUlFc05BaUFISWdZZ0RXb2dFVVlOQWdzZ0l5QUpJQmx4UVFOMGFpRUZBa0FDUUNBSElDQnFMUUFBSUFjZ0RXb3RBQUJKQkVBZ0V5QUpOZ0lBSUFrZ0drc05BU0FRUVVCcklSTU1CQXNnRENBSk5nSUFJQWtnR2tzRVFDQUZJUXdnQnlFSURBSUxJQkJCUUdzaERBd0RDeUFISVFzZ0JVRUVhaUlUSVFVTElCSkZEUUVnRWtGL2FpRVNJQVVvQWdBaUNTQWhUdzBBQ3dzZ0RFRUFOZ0lBSUJOQkFEWUNBQ0FBSUJWQmVHbzJBaGdMSUE1RkRRQWdGeUFPUVg5cVFRTjBhaUlGS0FJRUlnZ2dLa3NnQ0NBS2FrR0FJRTl5RFFVZ0ZDQXRhaUVVUVFBaENBTkFJQkJCUUdzZ0hDQVhJQWhCQTNScUlnWW9BZ0FpQ3lBYkVEOGdLQ0VGSUFnRVFDQUdRWHhxS0FJQVFRRnFJUVVMQWtBZ0JpZ0NCQ0lISUFWSkRRQWdDMEVCYWhBa0lnbEJDWFJCczdSL2FrRXpJQWxCRTBzYklSTWdDVUVJZEVHQUlHb2hEUU5BSUFkQmZXb2hEQ0FISUFwcUlRWUNmeUFBS0FKa1FRRkdCRUFnREJBdUlBMXFEQUVMSUFBb0FtQWdFMm9nQUNnQ09DQUpRUUowYWlnQ0FCQXVheUFBS0FKY2FpQU1FRHhCQW5RaURFR1FwQUZxS0FJQUlBbHFRUWgwYWlBQUtBSTBJQXhxS0FJQUVDNXJDeUFVYWlFTUFrQWdCaUFFVFFSQUlBd2dGaUFHUVJ4c2FpZ0NBRWdOQVF3REN3TkFJQllnQkVFQmFpSUVRUnhzYWtHQWdJQ0FCRFlDQUNBRUlBWkpEUUFMQ3lBV0lBWkJIR3hxSWdZZ0hUWUNEQ0FHSUFzMkFnUWdCaUFITmdJSUlBWWdERFlDQUNBR0lCQXBBMEEzQWhBZ0JpQVFLQUpJTmdJWUlBZEJmMm9pQnlBRlR3MEFDd3NnQ0VFQmFpSUlJQTVIRFFBTEN5QWZDeUlLSUFSTkRRQUxDeUFXSUFSQkhHeHFJZ1lvQWd3aEhTQUdLQUlFSVFVZ0JpZ0NBQ0VzSUFZb0FnZ2hDQ0FRSUFZb0FoZzJBbGdnRUNBR0tRSVFOd05RSUJBZ0Jpa0NDRGNES0NBUUlBWXBBaEEzQXpBZ0VDQUdLQUlZTmdJNElCQWdCaWtDQURjRElFRUFJQVFnRUVFZ2FoQStheUlHSUFZZ0JFc2JJUVFNQXdzZ0QwRUJhaUVQREFjTElBVW9BZ0FoQlVFQUlRUWdDaUFZS0FJSUJIOGdCQVVnR0NnQ0RBdHJJZ1JCZ0NCTkRRRUxJQllnSFRZQ0tDQVdJQWcyQWlRZ0ZpQUZOZ0lnSUJZZ0xEWUNIQ0FXSUJBb0FsZzJBalFnRmlBUUtRTlFOd0lzREFFTElCWWdCRUVCYWlJVVFSeHNhaUlHSUIwMkFnd2dCaUFJTmdJSUlBWWdCVFlDQkNBR0lDdzJBZ0FnQmlBUUtRTlFOd0lRSUFZZ0VDZ0NXRFlDR0NBVUlRd2dCQTBCQzBFQklReEJBU0VVREFFTEEwQWdFQ0FXSUFSQkhHeHFJZ1VpQ2tFWWFpZ0NBRFlDR0NBUUlBVXBBaEEzQXhBZ0VDQUZLUUlJTndNSUlCQWdCU2tDQURjREFDQVFFRDRoQ0NBV0lBeEJmMm9pREVFY2JHb2lCaUFLS0FJWU5nSVlJQVlnQlNrQ0VEY0NFQ0FHSUFVcEFnZzNBZ2dnQmlBRktRSUFOd0lBSUFRZ0NFc2hCVUVBSUFRZ0NHc2lCaUFHSUFSTEd5RUVJQVVOQUFzZ0RDQVVTdzBCQ3dOQUlCWWdERUVjYkdvaUJDZ0NEQ0VHQW44Z0F5QUdhaUFFS0FJSUlnZEZEUUFhQWtBQ1FDQUVLQUlFSWdwQkEwOEVRQ0FDSUFJcEFnQTNBZ1FnQ2tGK2FpRUVEQUVMQWtBQ1FBSkFBa0FnQ2lBR1JXb2lCUTRFQlFFQkFBRUxJQUlvQWdCQmYyb2hCQXdCQ3lBQ0lBVkJBblJxS0FJQUlRUWdCVUVDU1EwQkN5QUNJQUlvQWdRMkFnZ0xJQUlnQWlnQ0FEWUNCQXNnQWlBRU5nSUFDeUFrSUFZZ0F5QUtJQWNRVnlBSFFYMXFJUWtnQVNnQ0RDRUVBa0FDUUNBRElBWnFJZ1VnSzAwRVFDQUVJQU1RSENBQktBSU1JUVFnQmtFUVRRUkFJQUVnQkNBR2FqWUNEQXdEQ3lBRVFSQnFJQU5CRUdvaUNCQWNJQVJCSUdvZ0EwRWdhaEFjSUFaQk1VZ05BU0FFSUFacUlRc2dCRUV3YWlFRUEwQWdCQ0FJUVNCcUlnVVFIQ0FFUVJCcUlBaEJNR29RSENBRklRZ2dCRUVnYWlJRUlBdEpEUUFMREFFTElBUWdBeUFGSUNzUUlnc2dBU0FCS0FJTUlBWnFOZ0lNSUFaQmdJQUVTUTBBSUFGQkFUWUNKQ0FCSUFFb0FnUWdBU2dDQUd0QkEzVTJBaWdMSUFFb0FnUWlCQ0FLUVFGcU5nSUFJQVFnQmpzQkJDQUpRWUNBQkU4RVFDQUJRUUkyQWlRZ0FTQUVJQUVvQWdCclFRTjFOZ0lvQ3lBRUlBazdBUVlnQVNBRVFRaHFOZ0lFSUFZZ0Iyb2dBMm9pQXdzaER5QU1RUUZxSWd3Z0ZFME5BQXNMSUNSQkFCQlJDeUFQSUNsSkRRQUxDeUFRUWVBQWFpUUFJQkVnQTJzTGN3RURmeUFBSUFFb0FnQWdBU2dDQkNJRlFReHNhaUlFS1FJQU53SUFJQUFnQkNnQ0NDSUdOZ0lJSUFZZ0FDZ0NCQ0lFYWlBQ1RRUkFJQUVnQlVFQmFqWUNCQThMQWtBZ0JDQUNTUVJBSUFBZ0FpQUVheUlFTmdJSUlBUWdBMDhOQVFzZ0FFRUFOZ0lBQ3lBQklBSWdBeERxQVF0eUFRRi9Jd0JCSUdzaUJpUUFJQVlnQlNrQ0VEY0RHQ0FHSUFVcEFnZzNBeEFnQmlBRktRSUFOd01JSUFBZ0FpQUdRUWhxRU5ZQklBRWdBbW9pQUMwQUFFRURkR29nQTYwZ0JLMUNJSWFFTndJQUlBQWdBQzBBQUVFQmFrRi9JQVVvQWdoMFFYOXpjVG9BQUNBR1FTQnFKQUFMTndJQmZ3RitJQUVFUUFOQUlBQWdBbW94QUFBZ0EwTGp5Slc5eTV2dmpVOStmRUlLZkNFRElBSkJBV29pQWlBQlJ3MEFDd3NnQXd1UkFRSUVmd0YrSXdCQklHc2lCeVFBSUFKQkFXb2lDQ0FEU1FSQUlBWW9BZ3doQ1FOQUlBSWdDV290QUFBaENpQUFLUU1nSVFzZ0FpMEFBQ0VDSUFjZ0Jpa0NFRGNER0NBSElBWXBBZ2czQXhBZ0J5QUdLUUlBTndNSUlBQWdBU0FDSUFvZ0N4RFpBU0lCSUFVZ0NDQUVheUFIUVFocUVKa0JJQWdpQWtFQmFpSUlJQU5KRFFBTEN5QUhRU0JxSkFBZ0FRdm9CZ0lkZndKK0l3QkJnQUZySWdVa0FDQUZJQUFvQWhBMkFuZ2dCU0FBS1FJSU53TndJQVVnQUNrQ0FEY0RhQ0FDS0FJSUlRWWdBaWdDQkNFSElBSW9BaEFoR0NBQUtRTWdJU01nQWlnQ0RDRUtJQUFvQWd3aUVDRU5JQVZCNkFCcUVPZ0JJaEVFUUNBQUtBSUlJUklnQUNnQ0VDRU5Dd0ovQWtBZ0F5QUVhaUlPSUFwQkNDQUtRUWhMRzJzaUdTQURTUVJBSUFNaEJ3d0JDeUFISUFacklRdEJmeUFZZEVGL2N5RWJJQkFnRW1wQkFDQVJHeUVjSUEwZ0VtcEJBQ0FSR3lFZElBQW9BZ1FpRHlBUWFpRVRRUUFoQkVFQklBWjBRUU4wSVI0Z0JrRWZSaUVmSUFNaUJ5RUdBMEFDZndKK0lBTWdCa2NFUUNBaUlBUXRBQUFnQkNBS2FpMEFBQ0FqRU5rQkRBRUxJQU1nQ2hDb0F3c2lJaUFMSUJnUTJBRWdHMGNFUUNBR0lRUWdCa0VCYWd3QkN5QUdJQTlySVJRZ0FDZ0NGQ0VFSUFVZ0Fpa0NFRGNEWUNBRklBSXBBZ2czQTFnZ0JTQUNLUUlBTndOUUlBUWdJaUFMRU5jQklBVkIwQUJxRU5ZQklRUWdJaUFMRU5VQklTQUNRQ0FmUlFSQUlBUWdIbW9oSVVFQUlSVkJBQ0VXUVFBaERFRUFJUm9EUUFKQUlBUW9BZ1FnSUVjTkFDQUVLQUlBSWdnZ0RVME5BQUovSUJFRVFDQUdJQklnRHlBSUlCQkpJZ2tiSUFocUloY2dEaUFjSUE0Z0NSc2dFeEFnSWdnZ0Nra05BaUFHSUFjZ0Z5QWRJQk1nQ1JzUTFBRU1BUXNnQmlBSUlBOXFJZ2tnRGhBZElnZ2dDa2tOQVNBR0lBY2dDU0FURU5RQkN5RUpJQWdnQ1dvaUZ5QWFUUTBBSUJjaEdpQUVJUXdnQ1NFV0lBZ2hGUXNnQkVFSWFpSUVJQ0ZKRFFBTElBd05BUXNnQlNBQ0tRSVFOd01ZSUFVZ0Fpa0NDRGNERUNBRklBSXBBZ0EzQXdnZ0FDQWlJQXNnRkNBRlFRaHFFSmtCSUFZaEJDQUdRUUZxREFFTFFicC9JQUVvQWdnaUJDQUJLQUlNUmcwREdpQU1LQUlBSVFnZ0FTZ0NBQ0FFUVF4c2FpSU1JQlVnRm1vMkFnZ2dEQ0FHSUJacklBZHJOZ0lFSUF3Z0ZDQUlhellDQUNBQklBUkJBV28yQWdnZ0JTQUNLUUlRTndOSUlBVkJRR3NnQWlrQ0NEY0RBQ0FGSUFJcEFnQTNBemdnQUNBaUlBc2dGQ0FGUVRocUVKa0JBbjhnQmlBR0lCVnFJZ2NnR1VzTkFCb2dCU0FDS1FJUU53TXdJQVVnQWlrQ0NEY0RLQ0FGSUFJcEFnQTNBeUFnQUNBaUlBWWdCeUFQSUFzZ0JVRWdhaENwQXlFaUlBZEJmMm9MSVFRZ0J3c2lCaUFaVFEwQUN3c2dEaUFIYXdzaEFDQUZRWUFCYWlRQUlBQUxSQUVCZndKQUlBRWdBQ2dDQkdzaUF5QUNUUTBBSUFBb0FoQWlBU0FESUFKcklnSkpCRUFnQUNBQ05nSVFJQUloQVFzZ0FDZ0NEQ0FCVHcwQUlBQWdBVFlDREFzTE9RRURmeUFCQkVBRFFDQUFJQU5CQTNScUlnUkJBQ0FFS0FJQUlnUWdBbXNpQlNBRklBUkxHellDQUNBRFFRRnFJZ01nQVVjTkFBc0xDMFlCQVg4Z0FDZ0NCQ0VESUFBZ0FpQUJhellDQkNBQUlBSWdBMnNnQVdzaUFTQUFLQUlJYWpZQ0NDQUFJQUFvQWhBZ0FXczJBaEFnQUNBQUtBSU1JQUZyTmdJTUlBRUxYd0VDZnlNQVFSQnJJZ1lrQUVHSTdBRWdBUkRUQVVFUWFoQk1JZ2MyQWdBZ0JrRUlhaUFESUFRZ0FSRFRBU0lESUFFUWV5QUhJQU5CRUdvZ0FoQjdJQVVRcEFOQmlPd0JLQUlBRU5zQklBQWdCa0VJYWhEYUFTQUdRUkJxSkFBTGdBd0JGMzhqQUVFUWF5SVBKQUFnQWlnQ0JDRUpJQUlvQWdBaEJpQURJQUFvQWdRaUVDQUFLQUlNSWhGcUloUWdBMFpxSWdVZ0F5QUVhaUlPUVhocUloSkpCRUFnQUNnQ0NDSVRJQUFvQWhBaUZXb2hHaUFSSUJOcUlSWWdEa0ZnYWlFWElCRkJmMm9oR0FOQUFuOUJBQ0FGUVFGcUlnY2dCaUFRYW1zaUJDQVZUUTBBR2tFQUlCZ2dCR3RCQTBrTkFCcEJBQ0FIS0FBQUlBUWdFeUFRSUFRZ0VVa2lCQnRxSWdvb0FBQkhEUUFhSUFWQkJXb2dDa0VFYWlBT0lCWWdEaUFFR3lBVUVDQkJCR29MSVFRZ0QwSC9rK3ZjQXpZQ0RBSkFJQUFnQlNBT0lBOUJER29RbWdFaUNpQUVJQW9nQkVzaUNCc2lDa0VEVFFSQUlBVWdBMnRCQ0hVZ0JXcEJBV29oQlF3QkN5QVBLQUlNUVFBZ0NCc2hCQ0FGSUFjZ0NCc2hCd0pBQWtBZ0JTQVNUdzBBSUFVZ0VHc2hEQU5BSUF4QkFXb2hEU0FGUVFGcUlRZ0NRQ0FFUlFSQVFRQWhCQXdCQ3lBTklBWnJJZ3NnRlUwZ0dDQUxhMEVEU1hJTkFDQUlLQUFBSUFzZ0V5QVFJQXNnRVVraUN4dHFJaGtvQUFCSERRQWdCVUVGYWlBWlFRUnFJQTRnRmlBT0lBc2JJQlFRSUNJTFFYdExEUUFnQzBFRWFpSUxRUU5zSUFwQkEyd2dCRUVCYWhBa2EwRUJha3dOQUNBSUlRZEJBQ0VFSUFzaENnc2dEMEgvayt2Y0F6WUNDQUovQWtBZ0FDQUlJQTRnRDBFSWFoQ2FBU0lMUVFSSkRRQWdCRUVCYWhBa0lSa2dDMEVDZENBUEtBSUlJaHRCQVdvUUpHc2dDa0VDZENBWmEwRUVha3dOQUNBTklRd2dDQ0VGSUFzaENpQWJEQUVMSUFnZ0VrOE5BaUFNUVFKcUlRd2dCVUVDYWlFSUFrQWdCRVVFUUVFQUlRUU1BUXNnRENBR2F5SU5JQlZOSUJnZ0RXdEJBMGx5RFFBZ0NDZ0FBQ0FOSUJNZ0VDQU5JQkZKSWcwYmFpSUxLQUFBUncwQUlBVkJCbW9nQzBFRWFpQU9JQllnRGlBTkd5QVVFQ0FpQlVGN1N3MEFJQVZCQkdvaUJVRUNkQ0FLUVFKMFFRRnlJQVJCQVdvUUpHdE1EUUFnQ0NFSFFRQWhCQ0FGSVFvTElBOUIvNVByM0FNMkFnUWdBQ0FJSUE0Z0QwRUVhaENhQVNJTlFRUkpEUUlnQkVFQmFoQWtJUVVnRFVFQ2RDQVBLQUlFSWd0QkFXb1FKR3NnQ2tFQ2RDQUZhMEVIYWt3TkFpQUlJUVVnRFNFS0lBc0xJUVFnQlNFSElBVWdFa2tOQUFzTUFRc2dCeUVGQ3dKL0lBUkZCRUFnQmlFSUlBa01BUXNnQkVGK2FpRUlBa0FnQlNBRFRRMEFJQk1nRUNBRklCQnJJQWhySWdjZ0VVa2lDUnNnQjJvaUJ5QWFJQlFnQ1JzaURFME5BQU5BSUFWQmYyb2lDUzBBQUNBSFFYOXFJZ2N0QUFCSERRRWdDa0VCYWlFS0lBY2dERXNFUUNBSklnVWdBMHNOQVFzTElBa2hCUXNnQmdzaEJ5QUtRWDFxSVEwZ0JTQURheUVNSUFFb0Fnd2hCZ0pBQWtBZ0JTQVhUUVJBSUFZZ0F4QWNJQUVvQWd3aENTQU1RUkJOQkVBZ0FTQUpJQXhxTmdJTURBTUxJQWxCRUdvZ0EwRVFhaUlHRUJ3Z0NVRWdhaUFEUVNCcUVCd2dERUV4U0EwQklBa2dER29oQ3lBSlFUQnFJUU1EUUNBRElBWkJJR29pQ1JBY0lBTkJFR29nQmtFd2FoQWNJQWtoQmlBRFFTQnFJZ01nQzBrTkFBc01BUXNnQmlBRElBVWdGeEFpQ3lBQklBRW9BZ3dnREdvMkFnd2dERUdBZ0FSSkRRQWdBVUVCTmdJa0lBRWdBU2dDQkNBQktBSUFhMEVEZFRZQ0tBc2dBU2dDQkNJRElBUkJBV28yQWdBZ0F5QU1Pd0VFSUExQmdJQUVUd1JBSUFGQkFqWUNKQ0FCSUFNZ0FTZ0NBR3RCQTNVMkFpZ0xJQU1nRFRzQkJpQUJJQU5CQ0dvMkFnUWdCeUVKSUFnaEJpQUZJQXBxSWdNaEJTQURJQkpMRFFBRFFBSkFJQWNoQmlBSUlRY2dBeUFRYXlBR2F5SUVJQlZOSUJnZ0JHdEJBMGx5RFFBZ0F5Z0FBQ0FFSUJNZ0VDQUVJQkZKSWdRYmFpSUZLQUFBUncwQUlBTkJCR29nQlVFRWFpQU9JQllnRGlBRUd5QVVFQ0FpQ2tFQmFpRUZJQUVvQWd3aEJBSkFJQU1nRjAwRVFDQUVJQU1RSEF3QkN5QUVJQU1nQXlBWEVDSUxJQUVvQWdRaUJFRUJOZ0lBSUFSQkFEc0JCQ0FGUVlDQUJFOEVRQ0FCUVFJMkFpUWdBU0FFSUFFb0FnQnJRUU4xTmdJb0N5QUVJQVU3QVFZZ0FTQUVRUWhxTmdJRUlBWWhDQ0FISVFrZ0NrRUVhaUFEYWlJRElRVWdBeUFTVFEwQkRBSUxDeUFHSVFrZ0J5RUdJQU1oQlFzZ0JTQVNTUTBBQ3dzZ0FpQUpOZ0lFSUFJZ0JqWUNBQ0FQUVJCcUpBQWdEaUFEYXd1ZEpRRWpmeUFDS0FJRUlSMGdBaWdDQUNFVUlBTWdBQ2dDQkNJYklBQW9BZ3dpSG1vaUlTQURSbW9pQnlBRElBUnFJZ3hCZUdvaUgwa0VRQ0FBS0FJSUlpQWdBQ2dDRUNJamFpRW5JQjRnSUdvaEpDQU1RV0JxSVNVZ0hrRi9haUVtQTBBQ2YwRUFJQWRCQVdvaUhDQVVJQnRxYXlJRUlDTk5EUUFhUVFBZ0ppQUVhMEVEU1EwQUdrRUFJQndvQUFBZ0JDQWdJQnNnQkNBZVNTSUZHMm9pQkNnQUFFY05BQm9nQjBFRmFpQUVRUVJxSUF3Z0pDQU1JQVViSUNFUUlFRUVhZ3NoRlFKQUFrQUNRQUpBQWtBZ0FDZ0NoQUZCZTJvT0F3RUNBZ0FMSUFBb0FnUWhFQ0FBS0FKMElRVWdBQ2dDRUNFRUlBQW9BaFFoQ0NBQUtBS0FBU0VMSUFBb0FpZ2hEaUFBS0FJTUlRb2dBQ2dDQ0NFTklBQWdBQ2dDZUNJUElBQW9BbndnQjBFRUVDd2lCaUFFSUFjZ0VHc2lDVUVCSUFWMElnVnJJQVFnQ1NBRWF5QUZTeHNnQ0JzaUVVME5Ba0VBSUFsQkFTQVBkQ0lFYXlJRklBVWdDVXNiSVE4Z0NpQU5haUVXSUFvZ0VHb2hFaUFFUVg5cUlSTWdCMEVFYWlFWFFRRWdDM1FoQzBIL2srdmNBeUVJUVFNaEJRTkFBa0FDZnlBR0lBcFBCRUFnQmlBUWFpSUVJQVZxTFFBQUlBVWdCMm90QUFCSERRSWdCeUFFSUF3UUhRd0JDeUFHSUExcUlnUW9BQUFnQnlnQUFFY05BU0FYSUFSQkJHb2dEQ0FXSUJJUUlFRUVhZ3NpQkNBRlRRMEFJQWtnQm10QkFtb2hDQ0FISUFRaUJXb2dERVlOQlFzZ0JpQVBUUVJBSUFVaEJBd0ZDeUFPSUFZZ0UzRkJBblJxS0FJQUlnWWdFVTBFUUNBRklRUU1CUXNnQlNFRUlBdEJmMm9pQ3cwQUN3d0RDeUFBS0FJRUlSQWdBQ2dDZENFRklBQW9BaEFoQkNBQUtBSVVJUWdnQUNnQ2dBRWhDeUFBS0FJb0lRNGdBQ2dDRENFS0lBQW9BZ2doRFNBQUlBQW9BbmdpRHlBQUtBSjhJQWRCQlJBc0lnWWdCQ0FISUJCcklnbEJBU0FGZENJRmF5QUVJQWtnQkdzZ0JVc2JJQWdiSWhGTkRRRkJBQ0FKUVFFZ0QzUWlCR3NpQlNBRklBbExHeUVQSUFvZ0RXb2hGaUFLSUJCcUlSSWdCRUYvYWlFVElBZEJCR29oRjBFQklBdDBJUXRCLzVQcjNBTWhDRUVESVFVRFFBSkFBbjhnQmlBS1R3UkFJQVlnRUdvaUJDQUZhaTBBQUNBRklBZHFMUUFBUncwQ0lBY2dCQ0FNRUIwTUFRc2dCaUFOYWlJRUtBQUFJQWNvQUFCSERRRWdGeUFFUVFScUlBd2dGaUFTRUNCQkJHb0xJZ1FnQlUwTkFDQUpJQVpyUVFKcUlRZ2dCeUFFSWdWcUlBeEdEUVFMSUFZZ0QwMEVRQ0FGSVFRTUJBc2dEaUFHSUJOeFFRSjBhaWdDQUNJR0lCRk5CRUFnQlNFRURBUUxJQVVoQkNBTFFYOXFJZ3NOQUFzTUFnc2dBQ2dDQkNFUUlBQW9BblFoQlNBQUtBSVFJUVFnQUNnQ0ZDRUlJQUFvQW9BQklRc2dBQ2dDS0NFT0lBQW9BZ3doQ2lBQUtBSUlJUTBnQUNBQUtBSjRJZzhnQUNnQ2ZDQUhRUVlRTENJR0lBUWdCeUFRYXlJSlFRRWdCWFFpQldzZ0JDQUpJQVJySUFWTEd5QUlHeUlSVFEwQVFRQWdDVUVCSUE5MElnUnJJZ1VnQlNBSlN4c2hEeUFLSUExcUlSWWdDaUFRYWlFU0lBUkJmMm9oRXlBSFFRUnFJUmRCQVNBTGRDRUxRZitUNjl3RElRaEJBeUVGQTBBQ1FBSi9JQVlnQ2s4RVFDQUdJQkJxSWdRZ0JXb3RBQUFnQlNBSGFpMEFBRWNOQWlBSElBUWdEQkFkREFFTElBWWdEV29pQkNnQUFDQUhLQUFBUncwQklCY2dCRUVFYWlBTUlCWWdFaEFnUVFScUN5SUVJQVZORFFBZ0NTQUdhMEVDYWlFSUlBY2dCQ0lGYWlBTVJnMERDeUFHSUE5TkJFQWdCU0VFREFNTElBNGdCaUFUY1VFQ2RHb29BZ0FpQmlBUlRRUkFJQVVoQkF3REN5QUZJUVFnQzBGL2FpSUxEUUFMREFFTFFRTWhCRUgvayt2Y0F5RUlDd0pBSUFRZ0ZTQUVJQlZMSWdVYklnUkJBMDBFUUNBSElBTnJRUWgxSUFkcVFRRnFJUWNNQVFzZ0NFRUFJQVViSVFrZ0J5QWNJQVViSVJBQ1FBSkFJQWNnSDA4TkFDQUhJQnRySVJ3RFFDQWNRUUZxSVJVZ0IwRUJhaUVLQWtBZ0NVVUVRRUVBSVFrTUFRc2dGU0FVYXlJRklDTk5JQ1lnQld0QkEwbHlEUUFnQ2lnQUFDQUZJQ0FnR3lBRklCNUpJZ2diYWlJRktBQUFSdzBBSUFkQkJXb2dCVUVFYWlBTUlDUWdEQ0FJR3lBaEVDQWlCVUY3U3cwQUlBVkJCR29pQlVFRGJDQUVRUU5zSUFsQkFXb1FKR3RCQVdwTURRQWdDaUVRUVFBaENTQUZJUVFMQWtBQ1FBSkFBa0FDUUFKQUlBQW9Bb1FCUVh0cURnTUJBZ0lBQ3lBQUtBSUVJUThnQUNnQ2RDRUlJQUFvQWhBaEJTQUFLQUlVSVFzZ0FDZ0NnQUVoRFNBQUtBSW9JUklnQUNnQ0RDRVJJQUFvQWdnaEZpQUFJQUFvQW5naUV5QUFLQUo4SUFwQkJCQXNJZ1lnQlNBS0lBOXJJZzVCQVNBSWRDSUlheUFGSUE0Z0JXc2dDRXNiSUFzYkloZE5EUU5CQUNBT1FRRWdFM1FpQldzaUNDQUlJQTVMR3lFVElCRWdGbW9oR0NBUElCRnFJUmtnQlVGL2FpRWFJQWRCQldvaElrRUJJQTEwSVExQi81UHIzQU1oQzBFRElRZ0RRQUpBQW44Z0JpQVJUd1JBSUFZZ0Qyb2lCU0FJYWkwQUFDQUlJQXBxTFFBQVJ3MENJQW9nQlNBTUVCME1BUXNnQmlBV2FpSUZLQUFBSUFvb0FBQkhEUUVnSWlBRlFRUnFJQXdnR0NBWkVDQkJCR29MSWdVZ0NFME5BQ0FPSUFaclFRSnFJUXNnQlNFSUlBVWdDbW9nREVZTkJBc2dCaUFUVFFSQUlBZ2hCUXdFQ3lBU0lBWWdHbkZCQW5ScUtBSUFJZ1lnRjAwRVFDQUlJUVVNQkFzZ0NDRUZJQTFCZjJvaURRMEFDd3dDQ3lBQUtBSUVJUThnQUNnQ2RDRUlJQUFvQWhBaEJTQUFLQUlVSVFzZ0FDZ0NnQUVoRFNBQUtBSW9JUklnQUNnQ0RDRVJJQUFvQWdnaEZpQUFJQUFvQW5naUV5QUFLQUo4SUFwQkJSQXNJZ1lnQlNBS0lBOXJJZzVCQVNBSWRDSUlheUFGSUE0Z0JXc2dDRXNiSUFzYkloZE5EUUpCQUNBT1FRRWdFM1FpQldzaUNDQUlJQTVMR3lFVElCRWdGbW9oR0NBUElCRnFJUmtnQlVGL2FpRWFJQWRCQldvaElrRUJJQTEwSVExQi81UHIzQU1oQzBFRElRZ0RRQUpBQW44Z0JpQVJUd1JBSUFZZ0Qyb2lCU0FJYWkwQUFDQUlJQXBxTFFBQVJ3MENJQW9nQlNBTUVCME1BUXNnQmlBV2FpSUZLQUFBSUFvb0FBQkhEUUVnSWlBRlFRUnFJQXdnR0NBWkVDQkJCR29MSWdVZ0NFME5BQ0FPSUFaclFRSnFJUXNnQlNFSUlBVWdDbW9nREVZTkF3c2dCaUFUVFFSQUlBZ2hCUXdEQ3lBU0lBWWdHbkZCQW5ScUtBSUFJZ1lnRjAwRVFDQUlJUVVNQXdzZ0NDRUZJQTFCZjJvaURRMEFDd3dCQ3lBQUtBSUVJUThnQUNnQ2RDRUlJQUFvQWhBaEJTQUFLQUlVSVFzZ0FDZ0NnQUVoRFNBQUtBSW9JUklnQUNnQ0RDRVJJQUFvQWdnaEZpQUFJQUFvQW5naUV5QUFLQUo4SUFwQkJoQXNJZ1lnQlNBS0lBOXJJZzVCQVNBSWRDSUlheUFGSUE0Z0JXc2dDRXNiSUFzYkloZE5EUUZCQUNBT1FRRWdFM1FpQldzaUNDQUlJQTVMR3lFVElCRWdGbW9oR0NBUElCRnFJUmtnQlVGL2FpRWFJQWRCQldvaElrRUJJQTEwSVExQi81UHIzQU1oQzBFRElRZ0RRQUpBQW44Z0JpQVJUd1JBSUFZZ0Qyb2lCU0FJYWkwQUFDQUlJQXBxTFFBQVJ3MENJQW9nQlNBTUVCME1BUXNnQmlBV2FpSUZLQUFBSUFvb0FBQkhEUUVnSWlBRlFRUnFJQXdnR0NBWkVDQkJCR29MSWdVZ0NFME5BQ0FPSUFaclFRSnFJUXNnQlNFSUlBVWdDbW9nREVZTkFnc2dCaUFUVFFSQUlBZ2hCUXdDQ3lBU0lBWWdHbkZCQW5ScUtBSUFJZ1lnRjAwRVFDQUlJUVVNQWdzZ0NDRUZJQTFCZjJvaURRMEFDd3NnQlVFRVNRMEFJQWxCQVdvUUpDRUlJQVZCQW5RZ0MwRUJhaEFrYXlBRVFRSjBJQWhyUVFScVRBMEFJQlVoSENBS0lRY2dDeUVKSUFVaEJBd0JDeUFLSUI5UERRSWdIRUVDYWlFY0lBZEJBbW9oQlVFQUlRb0NmeUFFSUFsRkRRQWFBa0FnSENBVWF5SUlJQ05OSUNZZ0NHdEJBMGx5RFFBZ0JTZ0FBQ0FJSUNBZ0d5QUlJQjVKSWdZYmFpSUlLQUFBUncwQUlBZEJCbW9nQ0VFRWFpQU1JQ1FnRENBR0d5QWhFQ0FpQ0VGN1N3MEFJQVFnQ0VFRWFpSUlRUUowSUFSQkFuUkJBWElnQ1NJS1FRRnFFQ1JyVEEwQkdpQUZJUkJCQUNFS0lBZ01BUXNnQ1NFS0lBUUxJUWdDUUFKQUFrQUNRQ0FBS0FLRUFVRjdhZzREQVFJQ0FBc2dBQ2dDQkNFTklBQW9BblFoQ1NBQUtBSVFJUVFnQUNnQ0ZDRUxJQUFvQW9BQklSRWdBQ2dDS0NFV0lBQW9BZ3doRGlBQUtBSUlJUThnQUNBQUtBSjRJaElnQUNnQ2ZDQUZRUVFRTENJR0lBUWdCU0FOYXlJVlFRRWdDWFFpQ1dzZ0JDQVZJQVJySUFsTEd5QUxHeUlUVFEwR1FRQWdGVUVCSUJKMElnUnJJZ2tnQ1NBVlN4c2hFaUFPSUE5cUlSY2dEU0FPYWlFWUlBUkJmMm9oR1NBSFFRWnFJUnBCQVNBUmRDRUxRZitUNjl3RElRbEJBeUVIQTBBQ1FBSi9JQVlnRGs4RVFDQUdJQTFxSWdRZ0Iyb3RBQUFnQlNBSGFpMEFBRWNOQWlBRklBUWdEQkFkREFFTElBWWdEMm9pQkNnQUFDQUZLQUFBUncwQklCb2dCRUVFYWlBTUlCY2dHQkFnUVFScUN5SUVJQWRORFFBZ0ZTQUdhMEVDYWlFSklBVWdCQ0lIYWlBTVJnMEVDeUFHSUJKTkJFQWdCeUVFREFRTElCWWdCaUFaY1VFQ2RHb29BZ0FpQmlBVFRRUkFJQWNoQkF3RUN5QUhJUVFnQzBGL2FpSUxEUUFMREFJTElBQW9BZ1FoRFNBQUtBSjBJUWtnQUNnQ0VDRUVJQUFvQWhRaEN5QUFLQUtBQVNFUklBQW9BaWdoRmlBQUtBSU1JUTRnQUNnQ0NDRVBJQUFnQUNnQ2VDSVNJQUFvQW53Z0JVRUZFQ3dpQmlBRUlBVWdEV3NpRlVFQklBbDBJZ2xySUFRZ0ZTQUVheUFKU3hzZ0N4c2lFMDBOQlVFQUlCVkJBU0FTZENJRWF5SUpJQWtnRlVzYklSSWdEaUFQYWlFWElBMGdEbW9oR0NBRVFYOXFJUmtnQjBFR2FpRWFRUUVnRVhRaEMwSC9rK3ZjQXlFSlFRTWhCd05BQWtBQ2Z5QUdJQTVQQkVBZ0JpQU5haUlFSUFkcUxRQUFJQVVnQjJvdEFBQkhEUUlnQlNBRUlBd1FIUXdCQ3lBR0lBOXFJZ1FvQUFBZ0JTZ0FBRWNOQVNBYUlBUkJCR29nRENBWElCZ1FJRUVFYWdzaUJDQUhUUTBBSUJVZ0JtdEJBbW9oQ1NBRklBUWlCMm9nREVZTkF3c2dCaUFTVFFSQUlBY2hCQXdEQ3lBV0lBWWdHWEZCQW5ScUtBSUFJZ1lnRTAwRVFDQUhJUVFNQXdzZ0J5RUVJQXRCZjJvaUN3MEFDd3dCQ3lBQUtBSUVJUTBnQUNnQ2RDRUpJQUFvQWhBaEJDQUFLQUlVSVFzZ0FDZ0NnQUVoRVNBQUtBSW9JUllnQUNnQ0RDRU9JQUFvQWdnaER5QUFJQUFvQW5naUVpQUFLQUo4SUFWQkJoQXNJZ1lnQkNBRklBMXJJaFZCQVNBSmRDSUpheUFFSUJVZ0JHc2dDVXNiSUFzYkloTk5EUVJCQUNBVlFRRWdFblFpQkdzaUNTQUpJQlZMR3lFU0lBNGdEMm9oRnlBTklBNXFJUmdnQkVGL2FpRVpJQWRCQm1vaEdrRUJJQkYwSVF0Qi81UHIzQU1oQ1VFRElRY0RRQUpBQW44Z0JpQU9Ud1JBSUFZZ0RXb2lCQ0FIYWkwQUFDQUZJQWRxTFFBQVJ3MENJQVVnQkNBTUVCME1BUXNnQmlBUGFpSUVLQUFBSUFVb0FBQkhEUUVnR2lBRVFRUnFJQXdnRnlBWUVDQkJCR29MSWdRZ0IwME5BQ0FWSUFaclFRSnFJUWtnQlNBRUlnZHFJQXhHRFFJTElBWWdFazBFUUNBSElRUU1BZ3NnRmlBR0lCbHhRUUowYWlnQ0FDSUdJQk5OQkVBZ0J5RUVEQUlMSUFjaEJDQUxRWDlxSWdzTkFBc0xJQVJCQkVrTkF5QUtRUUZxRUNRaEJpQUZJUWNnQkVFQ2RDQUpRUUZxRUNScklBaEJBblFnQm10QkIycE1EUU1MSUFjaEVDQUpJUW9nQkNFSUlBY2dIMGtOQUFzTUFRc2dDU0VLSUFRaENBc0NmeUFLUlFSQUlCUWhCU0FkREFFTElBcEJmbW9oQlFKQUlCQWdBMDBOQUNBZ0lCc2dFQ0FiYXlBRmF5SUVJQjVKSWdjYklBUnFJZ1FnSnlBaElBY2JJZ1pORFFBRFFDQVFRWDlxSWdjdEFBQWdCRUYvYWlJRUxRQUFSdzBCSUFoQkFXb2hDQ0FFSUFaTEJFQWdCeUlRSUFOTERRRUxDeUFISVJBTElCUUxJUVlnQ0VGOWFpRUpJQkFnQTJzaEZDQUJLQUlNSVFRQ1FBSkFJQkFnSlUwRVFDQUVJQU1RSENBQktBSU1JUVFnRkVFUVRRUkFJQUVnQkNBVWFqWUNEQXdEQ3lBRVFSQnFJQU5CRUdvaUJ4QWNJQVJCSUdvZ0EwRWdhaEFjSUJSQk1VZ05BU0FFSUJScUlSMGdCRUV3YWlFRUEwQWdCQ0FIUVNCcUlnTVFIQ0FFUVJCcUlBZEJNR29RSENBRElRY2dCRUVnYWlJRUlCMUpEUUFMREFFTElBUWdBeUFRSUNVUUlnc2dBU0FCS0FJTUlCUnFOZ0lNSUJSQmdJQUVTUTBBSUFGQkFUWUNKQ0FCSUFFb0FnUWdBU2dDQUd0QkEzVTJBaWdMSUFFb0FnUWlBeUFLUVFGcU5nSUFJQU1nRkRzQkJDQUpRWUNBQkU4RVFDQUJRUUkyQWlRZ0FTQURJQUVvQWdCclFRTjFOZ0lvQ3lBRElBazdBUVlnQVNBRFFRaHFOZ0lFSUFZaEhTQUZJUlFnQ0NBUWFpSURJUWNnQXlBZlN3MEFBMEFDUUNBR0lSUWdCU0VHSUFNZ0cyc2dGR3NpQkNBalRTQW1JQVJyUVFOSmNnMEFJQU1vQUFBZ0JDQWdJQnNnQkNBZVNTSUZHMm9pQkNnQUFFY05BQ0FEUVFScUlBUkJCR29nRENBa0lBd2dCUnNnSVJBZ0lnZEJBV29oQlNBQktBSU1JUVFDUUNBRElDVk5CRUFnQkNBREVCd01BUXNnQkNBRElBTWdKUkFpQ3lBQktBSUVJZ1JCQVRZQ0FDQUVRUUE3QVFRZ0JVR0FnQVJQQkVBZ0FVRUNOZ0lrSUFFZ0JDQUJLQUlBYTBFRGRUWUNLQXNnQkNBRk93RUdJQUVnQkVFSWFqWUNCQ0FVSVFVZ0JpRWRJQWRCQkdvZ0Eyb2lBeUVISUFNZ0gwME5BUXdDQ3dzZ0ZDRWRJQVloRkNBRElRY0xJQWNnSDBrTkFBc0xJQUlnSFRZQ0JDQUNJQlEyQWdBZ0RDQURhd3ZYR2dFaWZ5QUNLQUlFSVJnZ0FpZ0NBQ0VRSUFNZ0FDZ0NCQ0laSUFBb0Fnd2lHbW9pSVNBRFJtb2lCeUFESUFScUlncEJlR29pSEVrRVFDQUFLQUlJSWgwZ0FDZ0NFQ0lqYWlFbUlCb2dIV29oSkNBS1FXQnFJU0lnR2tGL2FpRWxBMEFDZjBFQUlBZEJBV29pRVNBUUlCbHFheUlFSUNOTkRRQWFRUUFnSlNBRWEwRURTUTBBR2tFQUlCRW9BQUFnQkNBZElCa2dCQ0FhU1NJRkcyb2lCQ2dBQUVjTkFCb2dCMEVGYWlBRVFRUnFJQW9nSkNBS0lBVWJJQ0VRSUVFRWFnc2hHd0pBQWtBQ1FBSkFBa0FnQUNnQ2hBRkJlMm9PQXdFQ0FnQUxJQUFvQWdRaERTQUFLQUowSVFZZ0FDZ0NFQ0VFSUFBb0FoUWhDeUFBS0FLQUFTRUpJQUFvQWlnaEVpQUFLQUlNSVFnZ0FDZ0NDQ0VPSUFBZ0FDZ0NlQ0lQSUFBb0Fud2dCMEVFRUN3aUJTQUVJQWNnRFdzaURFRUJJQVowSWdacklBUWdEQ0FFYXlBR1N4c2dDeHNpRkUwTkFrRUFJQXhCQVNBUGRDSUVheUlHSUFZZ0RFc2JJUThnQ0NBT2FpRVZJQWdnRFdvaEV5QUVRWDlxSVJZZ0IwRUVhaUVYUVFFZ0NYUWhDVUgvayt2Y0F5RUxRUU1oQmdOQUFrQUNmeUFGSUFoUEJFQWdCU0FOYWlJRUlBWnFMUUFBSUFZZ0Iyb3RBQUJIRFFJZ0J5QUVJQW9RSFF3QkN5QUZJQTVxSWdRb0FBQWdCeWdBQUVjTkFTQVhJQVJCQkdvZ0NpQVZJQk1RSUVFRWFnc2lCQ0FHVFEwQUlBd2dCV3RCQW1vaEN5QUVJUVlnQkNBSGFpQUtSZzBGQ3lBRklBOU5CRUFnQmlFRURBVUxJQklnQlNBV2NVRUNkR29vQWdBaUJTQVVUUVJBSUFZaEJBd0ZDeUFHSVFRZ0NVRi9haUlKRFFBTERBTUxJQUFvQWdRaERTQUFLQUowSVFZZ0FDZ0NFQ0VFSUFBb0FoUWhDeUFBS0FLQUFTRUpJQUFvQWlnaEVpQUFLQUlNSVFnZ0FDZ0NDQ0VPSUFBZ0FDZ0NlQ0lQSUFBb0Fud2dCMEVGRUN3aUJTQUVJQWNnRFdzaURFRUJJQVowSWdacklBUWdEQ0FFYXlBR1N4c2dDeHNpRkUwTkFVRUFJQXhCQVNBUGRDSUVheUlHSUFZZ0RFc2JJUThnQ0NBT2FpRVZJQWdnRFdvaEV5QUVRWDlxSVJZZ0IwRUVhaUVYUVFFZ0NYUWhDVUgvayt2Y0F5RUxRUU1oQmdOQUFrQUNmeUFGSUFoUEJFQWdCU0FOYWlJRUlBWnFMUUFBSUFZZ0Iyb3RBQUJIRFFJZ0J5QUVJQW9RSFF3QkN5QUZJQTVxSWdRb0FBQWdCeWdBQUVjTkFTQVhJQVJCQkdvZ0NpQVZJQk1RSUVFRWFnc2lCQ0FHVFEwQUlBd2dCV3RCQW1vaEN5QUVJUVlnQkNBSGFpQUtSZzBFQ3lBRklBOU5CRUFnQmlFRURBUUxJQklnQlNBV2NVRUNkR29vQWdBaUJTQVVUUVJBSUFZaEJBd0VDeUFHSVFRZ0NVRi9haUlKRFFBTERBSUxJQUFvQWdRaERTQUFLQUowSVFZZ0FDZ0NFQ0VFSUFBb0FoUWhDeUFBS0FLQUFTRUpJQUFvQWlnaEVpQUFLQUlNSVFnZ0FDZ0NDQ0VPSUFBZ0FDZ0NlQ0lQSUFBb0Fud2dCMEVHRUN3aUJTQUVJQWNnRFdzaURFRUJJQVowSWdacklBUWdEQ0FFYXlBR1N4c2dDeHNpRkUwTkFFRUFJQXhCQVNBUGRDSUVheUlHSUFZZ0RFc2JJUThnQ0NBT2FpRVZJQWdnRFdvaEV5QUVRWDlxSVJZZ0IwRUVhaUVYUVFFZ0NYUWhDVUgvayt2Y0F5RUxRUU1oQmdOQUFrQUNmeUFGSUFoUEJFQWdCU0FOYWlJRUlBWnFMUUFBSUFZZ0Iyb3RBQUJIRFFJZ0J5QUVJQW9RSFF3QkN5QUZJQTVxSWdRb0FBQWdCeWdBQUVjTkFTQVhJQVJCQkdvZ0NpQVZJQk1RSUVFRWFnc2lCQ0FHVFEwQUlBd2dCV3RCQW1vaEN5QUVJUVlnQkNBSGFpQUtSZzBEQ3lBRklBOU5CRUFnQmlFRURBTUxJQklnQlNBV2NVRUNkR29vQWdBaUJTQVVUUVJBSUFZaEJBd0RDeUFHSVFRZ0NVRi9haUlKRFFBTERBRUxRUU1oQkVIL2srdmNBeUVMQ3dKQUlBUWdHeUFFSUJ0TElnUWJJZ3hCQTAwRVFDQUhJQU5yUVFoMUlBZHFRUUZxSVFjTUFRc2dDMEVBSUFRYklRMGdCeUFSSUFRYklRc0NRQ0FISUJ4UERRQWdCeUFaYXlFYkEwQWdHMEVCYWlFYklBZEJBV29oQmdKQUlBMUZCRUJCQUNFTkRBRUxJQnNnRUdzaUJDQWpUU0FsSUFSclFRTkpjZzBBSUFZb0FBQWdCQ0FkSUJrZ0JDQWFTU0lGRzJvaUJDZ0FBRWNOQUNBSFFRVnFJQVJCQkdvZ0NpQWtJQW9nQlJzZ0lSQWdJZ1JCZTBzTkFDQUVRUVJxSWdSQkEyd2dERUVEYkNBTlFRRnFFQ1JyUVFGcVRBMEFJQVloQzBFQUlRMGdCQ0VNQ3dKQUFrQUNRQUpBSUFBb0FvUUJRWHRxRGdNQkFnSUFDeUFBS0FJRUlRNGdBQ2dDZENFSUlBQW9BaEFoQlNBQUtBSVVJUWtnQUNnQ2dBRWhGQ0FBS0FJb0lSVWdBQ2dDRENFU0lBQW9BZ2doRHlBQUlBQW9BbmdpRXlBQUtBSjhJQVpCQkJBc0lnUWdCU0FHSUE1ckloRkJBU0FJZENJSWF5QUZJQkVnQldzZ0NFc2JJQWtiSWhaTkRRUkJBQ0FSUVFFZ0UzUWlCV3NpQ0NBSUlCRkxHeUVUSUE4Z0Vtb2hGeUFPSUJKcUlSNGdCVUYvYWlFZklBZEJCV29oSUVFQklCUjBJUWxCLzVQcjNBTWhDRUVESVFjRFFBSkFBbjhnQkNBU1R3UkFJQVFnRG1vaUJTQUhhaTBBQUNBR0lBZHFMUUFBUncwQ0lBWWdCU0FLRUIwTUFRc2dCQ0FQYWlJRktBQUFJQVlvQUFCSERRRWdJQ0FGUVFScUlBb2dGeUFlRUNCQkJHb0xJZ1VnQjAwTkFDQVJJQVJyUVFKcUlRZ2dCaUFGSWdkcUlBcEdEUVFMSUFRZ0UwMEVRQ0FISVFVTUJBc2dGU0FFSUI5eFFRSjBhaWdDQUNJRUlCWk5CRUFnQnlFRkRBUUxJQWNoQlNBSlFYOXFJZ2tOQUFzTUFnc2dBQ2dDQkNFT0lBQW9BblFoQ0NBQUtBSVFJUVVnQUNnQ0ZDRUpJQUFvQW9BQklSUWdBQ2dDS0NFVklBQW9BZ3doRWlBQUtBSUlJUThnQUNBQUtBSjRJaE1nQUNnQ2ZDQUdRUVVRTENJRUlBVWdCaUFPYXlJUlFRRWdDSFFpQ0dzZ0JTQVJJQVZySUFoTEd5QUpHeUlXVFEwRFFRQWdFVUVCSUJOMElnVnJJZ2dnQ0NBUlN4c2hFeUFQSUJKcUlSY2dEaUFTYWlFZUlBVkJmMm9oSHlBSFFRVnFJU0JCQVNBVWRDRUpRZitUNjl3RElRaEJBeUVIQTBBQ1FBSi9JQVFnRWs4RVFDQUVJQTVxSWdVZ0Iyb3RBQUFnQmlBSGFpMEFBRWNOQWlBR0lBVWdDaEFkREFFTElBUWdEMm9pQlNnQUFDQUdLQUFBUncwQklDQWdCVUVFYWlBS0lCY2dIaEFnUVFScUN5SUZJQWRORFFBZ0VTQUVhMEVDYWlFSUlBWWdCU0lIYWlBS1JnMERDeUFFSUJOTkJFQWdCeUVGREFNTElCVWdCQ0FmY1VFQ2RHb29BZ0FpQkNBV1RRUkFJQWNoQlF3REN5QUhJUVVnQ1VGL2FpSUpEUUFMREFFTElBQW9BZ1FoRGlBQUtBSjBJUWdnQUNnQ0VDRUZJQUFvQWhRaENTQUFLQUtBQVNFVUlBQW9BaWdoRlNBQUtBSU1JUklnQUNnQ0NDRVBJQUFnQUNnQ2VDSVRJQUFvQW53Z0JrRUdFQ3dpQkNBRklBWWdEbXNpRVVFQklBaDBJZ2hySUFVZ0VTQUZheUFJU3hzZ0NSc2lGazBOQWtFQUlCRkJBU0FUZENJRmF5SUlJQWdnRVVzYklSTWdEeUFTYWlFWElBNGdFbW9oSGlBRlFYOXFJUjhnQjBFRmFpRWdRUUVnRkhRaENVSC9rK3ZjQXlFSVFRTWhCd05BQWtBQ2Z5QUVJQkpQQkVBZ0JDQU9haUlGSUFkcUxRQUFJQVlnQjJvdEFBQkhEUUlnQmlBRklBb1FIUXdCQ3lBRUlBOXFJZ1VvQUFBZ0JpZ0FBRWNOQVNBZ0lBVkJCR29nQ2lBWElCNFFJRUVFYWdzaUJTQUhUUTBBSUJFZ0JHdEJBbW9oQ0NBR0lBVWlCMm9nQ2tZTkFnc2dCQ0FUVFFSQUlBY2hCUXdDQ3lBVklBUWdIM0ZCQW5ScUtBSUFJZ1FnRmswRVFDQUhJUVVNQWdzZ0J5RUZJQWxCZjJvaUNRMEFDd3NnQlVFRVNRMEJJQTFCQVdvUUpDRUVJQVZCQW5RZ0NFRUJhaEFrYXlBTVFRSjBJQVJyUVFScVRBMEJJQVVoRENBSUlRMGdCaUlISVFzZ0J5QWNTUTBBQ3dzQ2Z5QU5SUVJBSUJBaEJpQVlEQUVMSUExQmZtb2hCZ0pBSUFzZ0EwME5BQ0FkSUJrZ0N5QVpheUFHYXlJRUlCcEpJZ1ViSUFScUlnUWdKaUFoSUFVYklnZE5EUUFEUUNBTFFYOXFJZ1V0QUFBZ0JFRi9haUlFTFFBQVJ3MEJJQXhCQVdvaERDQUVJQWRMQkVBZ0JTSUxJQU5MRFFFTEN5QUZJUXNMSUJBTElRVWdERUY5YWlFWUlBc2dBMnNoRUNBQktBSU1JUVFDUUFKQUlBc2dJazBFUUNBRUlBTVFIQ0FCS0FJTUlRUWdFRUVRVFFSQUlBRWdCQ0FRYWpZQ0RBd0RDeUFFUVJCcUlBTkJFR29pQnhBY0lBUkJJR29nQTBFZ2FoQWNJQkJCTVVnTkFTQUVJQkJxSVFnZ0JFRXdhaUVFQTBBZ0JDQUhRU0JxSWdNUUhDQUVRUkJxSUFkQk1Hb1FIQ0FESVFjZ0JFRWdhaUlFSUFoSkRRQUxEQUVMSUFRZ0F5QUxJQ0lRSWdzZ0FTQUJLQUlNSUJCcU5nSU1JQkJCZ0lBRVNRMEFJQUZCQVRZQ0pDQUJJQUVvQWdRZ0FTZ0NBR3RCQTNVMkFpZ0xJQUVvQWdRaUF5QU5RUUZxTmdJQUlBTWdFRHNCQkNBWVFZQ0FCRThFUUNBQlFRSTJBaVFnQVNBRElBRW9BZ0JyUVFOMU5nSW9DeUFESUJnN0FRWWdBU0FEUVFocU5nSUVJQVVoR0NBR0lSQWdDeUFNYWlJRElRY2dBeUFjU3cwQUEwQUNRQ0FGSVJBZ0JpRUZJQU1nR1dzZ0VHc2lCQ0FqVFNBbElBUnJRUU5KY2cwQUlBTW9BQUFnQkNBZElCa2dCQ0FhU1NJR0cyb2lCQ2dBQUVjTkFDQURRUVJxSUFSQkJHb2dDaUFrSUFvZ0Joc2dJUkFnSWdkQkFXb2hCaUFCS0FJTUlRUUNRQ0FESUNKTkJFQWdCQ0FERUJ3TUFRc2dCQ0FESUFNZ0loQWlDeUFCS0FJRUlnUkJBVFlDQUNBRVFRQTdBUVFnQmtHQWdBUlBCRUFnQVVFQ05nSWtJQUVnQkNBQktBSUFhMEVEZFRZQ0tBc2dCQ0FHT3dFR0lBRWdCRUVJYWpZQ0JDQVFJUVlnQlNFWUlBZEJCR29nQTJvaUF5RUhJQU1nSEUwTkFRd0NDd3NnRUNFWUlBVWhFQ0FESVFjTElBY2dIRWtOQUFzTElBSWdHRFlDQkNBQ0lCQTJBZ0FnQ2lBRGF3dUFFQUVkZnlBQ0tBSUVJUW9nQWlnQ0FDRUlJQU1nQUNnQ0JDSVNJQUFvQWd3aUUyb2lIQ0FEUm1vaUJpQURJQVJxSWd4QmVHb2lIVWtFUUNBQUtBSUlJaG9nQUNnQ0VDSWVhaUVoSUJNZ0dtb2hIeUFNUVdCcUlSc2dFMEYvYWlFZ0EwQUNRQUovQWtBQ2Z3SkFJQVpCQVdvaUJTQUlJQkpxYXlJRUlCNU5JQ0FnQkd0QkEwbHlEUUFnQlNnQUFDQUVJQm9nRWlBRUlCTkpJZ1FiYWlJSEtBQUFSdzBBSUFaQkJXb2dCMEVFYWlBTUlCOGdEQ0FFR3lBY0VDQkJCR29oQkVFQURBRUxBa0FDUUFKQUFrQUNRQUpBSUFBb0FvUUJRWHRxRGdNQkFnSUFDeUFBS0FJRUlRNGdBQ2dDZENFRklBQW9BaEFoQkNBQUtBSVVJUWtnQUNnQ2dBRWhEU0FBS0FJb0lSUWdBQ2dDRENFUElBQW9BZ2doRVNBQUlBQW9BbmdpRUNBQUtBSjhJQVpCQkJBc0lnY2dCQ0FHSUE1cklndEJBU0FGZENJRmF5QUVJQXNnQkdzZ0JVc2JJQWtiSWhWTkRRTkJBQ0FMUVFFZ0VIUWlCR3NpQlNBRklBdExHeUVRSUE4Z0VXb2hGaUFPSUE5cUlSY2dCRUYvYWlFWUlBWkJCR29oR1VFQklBMTBJUWxCLzVQcjNBTWhEVUVESVFVRFFBSkFBbjhnQnlBUFR3UkFJQWNnRG1vaUJDQUZhaTBBQUNBRklBWnFMUUFBUncwQ0lBWWdCQ0FNRUIwTUFRc2dCeUFSYWlJRUtBQUFJQVlvQUFCSERRRWdHU0FFUVFScUlBd2dGaUFYRUNCQkJHb0xJZ1FnQlUwTkFDQUxJQWRyUVFKcUlRMGdCaUFFSWdWcUlBeEdEUVFMSUFjZ0VFMEVRQ0FGSVFRTUJBc2dGQ0FISUJoeFFRSjBhaWdDQUNJSElCVk5CRUFnQlNFRURBUUxJQVVoQkNBSlFYOXFJZ2tOQUFzTUFnc2dBQ2dDQkNFT0lBQW9BblFoQlNBQUtBSVFJUVFnQUNnQ0ZDRUpJQUFvQW9BQklRMGdBQ2dDS0NFVUlBQW9BZ3doRHlBQUtBSUlJUkVnQUNBQUtBSjRJaEFnQUNnQ2ZDQUdRUVVRTENJSElBUWdCaUFPYXlJTFFRRWdCWFFpQldzZ0JDQUxJQVJySUFWTEd5QUpHeUlWVFEwQ1FRQWdDMEVCSUJCMElnUnJJZ1VnQlNBTFN4c2hFQ0FQSUJGcUlSWWdEaUFQYWlFWElBUkJmMm9oR0NBR1FRUnFJUmxCQVNBTmRDRUpRZitUNjl3RElRMUJBeUVGQTBBQ1FBSi9JQWNnRDA4RVFDQUhJQTVxSWdRZ0JXb3RBQUFnQlNBR2FpMEFBRWNOQWlBR0lBUWdEQkFkREFFTElBY2dFV29pQkNnQUFDQUdLQUFBUncwQklCa2dCRUVFYWlBTUlCWWdGeEFnUVFScUN5SUVJQVZORFFBZ0N5QUhhMEVDYWlFTklBWWdCQ0lGYWlBTVJnMERDeUFISUJCTkJFQWdCU0VFREFNTElCUWdCeUFZY1VFQ2RHb29BZ0FpQnlBVlRRUkFJQVVoQkF3REN5QUZJUVFnQ1VGL2FpSUpEUUFMREFFTElBQW9BZ1FoRGlBQUtBSjBJUVVnQUNnQ0VDRUVJQUFvQWhRaENTQUFLQUtBQVNFTklBQW9BaWdoRkNBQUtBSU1JUThnQUNnQ0NDRVJJQUFnQUNnQ2VDSVFJQUFvQW53Z0JrRUdFQ3dpQnlBRUlBWWdEbXNpQzBFQklBVjBJZ1ZySUFRZ0N5QUVheUFGU3hzZ0NSc2lGVTBOQVVFQUlBdEJBU0FRZENJRWF5SUZJQVVnQzBzYklSQWdEeUFSYWlFV0lBNGdEMm9oRnlBRVFYOXFJUmdnQmtFRWFpRVpRUUVnRFhRaENVSC9rK3ZjQXlFTlFRTWhCUU5BQWtBQ2Z5QUhJQTlQQkVBZ0J5QU9haUlFSUFWcUxRQUFJQVVnQm1vdEFBQkhEUUlnQmlBRUlBd1FIUXdCQ3lBSElCRnFJZ1FvQUFBZ0JpZ0FBRWNOQVNBWklBUkJCR29nRENBV0lCY1FJRUVFYWdzaUJDQUZUUTBBSUFzZ0IydEJBbW9oRFNBR0lBUWlCV29nREVZTkFnc2dCeUFRVFFSQUlBVWhCQXdDQ3lBVUlBY2dHSEZCQW5ScUtBSUFJZ2NnRlUwRVFDQUZJUVFNQWdzZ0JTRUVJQWxCZjJvaUNRMEFDd3NnQkVFRFN3MEJDeUFHSUFOclFRaDFJQVpxUVFGcUlRWU1CQXNnRFEwQklBWWhCVUVBQ3lFTklBZ2hDU0FLREFFTElBMUJmbW9oQ1FKQUFrQWdCaUFEVFEwQUlCb2dFaUFHSUJKcklBbHJJZ1VnRTBraUNoc2dCV29pQnlBaElCd2dDaHNpQ2swTkFBTkFJQVpCZjJvaUJTMEFBQ0FIUVg5cUlnY3RBQUJIRFFFZ0JFRUJhaUVFSUFjZ0NrME5BaUFGSWdZZ0Ewc05BQXNNQVFzZ0JpRUZDeUFJQ3lFSElBUkJmV29oQ3lBRklBTnJJUW9nQVNnQ0RDRUlBa0FDUUNBRklCdE5CRUFnQ0NBREVCd2dBU2dDRENFSUlBcEJFRTBFUUNBQklBZ2dDbW8yQWd3TUF3c2dDRUVRYWlBRFFSQnFJZ1lRSENBSVFTQnFJQU5CSUdvUUhDQUtRVEZJRFFFZ0NDQUthaUVPSUFoQk1Hb2hBd05BSUFNZ0JrRWdhaUlJRUJ3Z0EwRVFhaUFHUVRCcUVCd2dDQ0VHSUFOQklHb2lBeUFPU1EwQUN3d0JDeUFJSUFNZ0JTQWJFQ0lMSUFFZ0FTZ0NEQ0FLYWpZQ0RDQUtRWUNBQkVrTkFDQUJRUUUyQWlRZ0FTQUJLQUlFSUFFb0FnQnJRUU4xTmdJb0N5QUJLQUlFSWdNZ0RVRUJhallDQUNBRElBbzdBUVFnQzBHQWdBUlBCRUFnQVVFQ05nSWtJQUVnQXlBQktBSUFhMEVEZFRZQ0tBc2dBeUFMT3dFR0lBRWdBMEVJYWpZQ0JDQUhJUW9nQ1NFSUlBUWdCV29pQXlFR0lBTWdIVXNOQUFOQUFrQWdCeUVJSUFraEJ5QURJQkpySUFocklnUWdIazBnSUNBRWEwRURTWElOQUNBREtBQUFJQVFnR2lBU0lBUWdFMGtpQkJ0cUlnVW9BQUJIRFFBZ0EwRUVhaUFGUVFScUlBd2dIeUFNSUFRYklCd1FJQ0lHUVFGcUlRVWdBU2dDRENFRUFrQWdBeUFiVFFSQUlBUWdBeEFjREFFTElBUWdBeUFESUJzUUlnc2dBU2dDQkNJRVFRRTJBZ0FnQkVFQU93RUVJQVZCZ0lBRVR3UkFJQUZCQWpZQ0pDQUJJQVFnQVNnQ0FHdEJBM1UyQWlnTElBUWdCVHNCQmlBQklBUkJDR28yQWdRZ0NDRUpJQWNoQ2lBR1FRUnFJQU5xSWdNaEJpQURJQjFORFFFTUFnc0xJQWdoQ2lBSElRZ2dBeUVHQ3lBR0lCMUpEUUFMQ3lBQ0lBbzJBZ1FnQWlBSU5nSUFJQXdnQTJzTCtRY0JGWDhqQUVFUWF5SU9KQUFnQWlnQ0JDRUlJQUlvQWdBaEJpQURJQUFvQW5BaUJTZ0NBQ0lSSUFNZ0FDZ0NCQ0lOSUFBb0Fnd2lER29pRW10cUlBVW9BZ1FpRXlBRktBSU1haUlYUm1vaUJTQURJQVJxSWdwQmVHb2lGRWtFUUNBVElBd2dFMm9nRVdzaUdHc2hGU0FLUVdCcUlROERRQUpBQW44Q1FBSi9Ba0FnRENBRlFRRnFJZ2NnQmlBTmFtc2lCRUYvYzJwQkEwa05BQ0FUSUFRZ0dHdHFJQWNnQm1zZ0JDQU1TU0lFR3lJSktBQUFJQWNvQUFCSERRQWdCVUVGYWlBSlFRUnFJQW9nRVNBS0lBUWJJQklRSUVFRWFpRUxRUUFNQVFzZ0RrSC9rK3ZjQXpZQ0RDQUFJQVVnQ2lBT1FReHFFR29pQzBFRFRRUkFJQVVnQTJ0QkNIVWdCV3BCQVdvaEJRd0VDeUFPS0FJTUloQU5BU0FGSVFkQkFBc2hFQ0FHSVFrZ0NBd0JDd0pBSUFVZ0EwMEVRQ0FGSVFjTUFRc2dCU0VISUJVZ0RTQUZJQTBnRUdwclFRSnFJZ1FnREVraUNSc2dCR29pQkNBWElCSWdDUnNpQ1UwTkFBTkFJQVZCZjJvaUJ5MEFBQ0FFUVg5cUlnUXRBQUJIQkVBZ0JTRUhEQUlMSUF0QkFXb2hDeUFFSUFsTkRRRWdCeUlGSUFOTERRQUxDeUFRUVg1cUlRa2dCZ3NoQkNBTFFYMXFJUllnQnlBRGF5RUlJQUVvQWd3aEJRSkFBa0FnQnlBUFRRUkFJQVVnQXhBY0lBRW9BZ3doQmlBSVFSQk5CRUFnQVNBR0lBaHFOZ0lNREFNTElBWkJFR29nQTBFUWFpSUZFQndnQmtFZ2FpQURRU0JxRUJ3Z0NFRXhTQTBCSUFZZ0NHb2hHU0FHUVRCcUlRTURRQ0FESUFWQklHb2lCaEFjSUFOQkVHb2dCVUV3YWhBY0lBWWhCU0FEUVNCcUlnTWdHVWtOQUFzTUFRc2dCU0FESUFjZ0R4QWlDeUFCSUFFb0Fnd2dDR28yQWd3Z0NFR0FnQVJKRFFBZ0FVRUJOZ0lrSUFFZ0FTZ0NCQ0FCS0FJQWEwRURkVFlDS0FzZ0FTZ0NCQ0lESUJCQkFXbzJBZ0FnQXlBSU93RUVJQlpCZ0lBRVR3UkFJQUZCQWpZQ0pDQUJJQU1nQVNnQ0FHdEJBM1UyQWlnTElBTWdGanNCQmlBQklBTkJDR28yQWdRZ0JDRUlJQWtoQmlBSElBdHFJZ01oQlNBRElCUkxEUUFEUUFKQUlBUWhCaUFKSVFRZ0RDQURJQTFySUFacklnVkJmM05xUVFOSkRRQWdCU0FWSUEwZ0JTQU1TU0lGRzJvaUJ5Z0FBQ0FES0FBQVJ3MEFJQU5CQkdvZ0IwRUVhaUFLSUJFZ0NpQUZHeUFTRUNBaUMwRUJhaUVISUFFb0Fnd2hCUUpBSUFNZ0QwMEVRQ0FGSUFNUUhBd0JDeUFGSUFNZ0F5QVBFQ0lMSUFFb0FnUWlCVUVCTmdJQUlBVkJBRHNCQkNBSFFZQ0FCRThFUUNBQlFRSTJBaVFnQVNBRklBRW9BZ0JyUVFOMU5nSW9DeUFGSUFjN0FRWWdBU0FGUVFocU5nSUVJQVloQ1NBRUlRZ2dDMEVFYWlBRGFpSURJUVVnQXlBVVRRMEJEQUlMQ3lBR0lRZ2dCQ0VHSUFNaEJRc2dCU0FVU1EwQUN3c2dBaUFJTmdJRUlBSWdCallDQUNBT1FSQnFKQUFnQ2lBRGF3dWFDZ0VWZnlNQVFSQnJJZzhrQUNBQ0tBSUVJUWtnQWlnQ0FDRUlJQU1nQUNnQ2NDSUZLQUlBSWhJZ0F5QUFLQUlFSWhBZ0FDZ0NEQ0lOYWlJVGEyb2dCU2dDQkNJVUlBVW9BZ3hxSWhoR2FpSUdJQU1nQkdvaURFRjRhaUlSU1FSQUlCUWdEU0FVYWlBU2F5SVdheUVYSUF4QllHb2hGUU5BQW45QkFDQU5JQVpCQVdvaUJDQUlJQkJxYXlJRlFYOXpha0VEU1EwQUdrRUFJQlFnQlNBV2Eyb2dCQ0FJYXlBRklBMUpJZ1ViSWdjb0FBQWdCQ2dBQUVjTkFCb2dCa0VGYWlBSFFRUnFJQXdnRWlBTUlBVWJJQk1RSUVFRWFnc2hCU0FQUWYrVDY5d0ROZ0lNQWtBZ0FDQUdJQXdnRDBFTWFoQnFJZ2NnQlNBSElBVkxJZ29iSWdkQkEwMEVRQ0FHSUFOclFRaDFJQVpxUVFGcUlRWU1BUXNnQmlBRUlBb2JJZ3NoQlNBUEtBSU1RUUFnQ2hzaURpRUtJQWNoQkFKQUlBWWdFVThOQUFOQUFrQWdEU0FHUVFGcUlnVWdFR3NnQ0dzaUJFRi9jMnBCQTBrTkFDQVVJQVFnRm10cUlBVWdDR3NnQkNBTlNTSUVHeUlLS0FBQUlBVW9BQUJIRFFBZ0JrRUZhaUFLUVFScUlBd2dFaUFNSUFRYklCTVFJQ0lFUVh0TERRQWdCRUVFYWlJRVFRTnNJQWRCQTJ3Z0RrRUJhaEFrYTBFQmFrd05BRUVBSVE0Z0JTRUxJQVFoQndzZ0QwSC9rK3ZjQXpZQ0NBSkFJQUFnQlNBTUlBOUJDR29RYWlJRVFRUkpEUUFnRGtFQmFoQWtJUVlnQkVFQ2RDQVBLQUlJSWdwQkFXb1FKR3NnQjBFQ2RDQUdhMEVFYWt3TkFDQUZJUVlnQkNFSElBb2hEaUFGSVFzZ0JTQVJTUTBCREFJTEN5QUxJUVVnRGlFS0lBY2hCQXNDZnlBS1JRUkFJQVVoQmlBSklRY2dDQXdCQ3dKQUlBVWdBMDBFUUNBRklRWU1BUXNnQlNFR0lCY2dFQ0FGSUFvZ0VHcHJRUUpxSWdjZ0RVa2lDUnNnQjJvaUJ5QVlJQk1nQ1JzaUNVME5BQU5BSUFWQmYyb2lCaTBBQUNBSFFYOXFJZ2N0QUFCSEJFQWdCU0VHREFJTElBUkJBV29oQkNBSElBbE5EUUVnQmlJRklBTkxEUUFMQ3lBSUlRY2dDa0YrYWdzaEJTQUVRWDFxSVE0Z0JpQURheUVMSUFFb0Fnd2hDQUpBQWtBZ0JpQVZUUVJBSUFnZ0F4QWNJQUVvQWd3aENTQUxRUkJOQkVBZ0FTQUpJQXRxTmdJTURBTUxJQWxCRUdvZ0EwRVFhaUlJRUJ3Z0NVRWdhaUFEUVNCcUVCd2dDMEV4U0EwQklBa2dDMm9oR1NBSlFUQnFJUU1EUUNBRElBaEJJR29pQ1JBY0lBTkJFR29nQ0VFd2FoQWNJQWtoQ0NBRFFTQnFJZ01nR1VrTkFBc01BUXNnQ0NBRElBWWdGUkFpQ3lBQklBRW9BZ3dnQzJvMkFnd2dDMEdBZ0FSSkRRQWdBVUVCTmdJa0lBRWdBU2dDQkNBQktBSUFhMEVEZFRZQ0tBc2dBU2dDQkNJRElBcEJBV28yQWdBZ0F5QUxPd0VFSUE1QmdJQUVUd1JBSUFGQkFqWUNKQ0FCSUFNZ0FTZ0NBR3RCQTNVMkFpZ0xJQU1nRGpzQkJpQUJJQU5CQ0dvMkFnUWdCeUVKSUFVaENDQUVJQVpxSWdNaEJpQURJQkZMRFFBRFFBSkFJQWNoQ0NBRklRY2dEU0FESUJCcklBaHJJZ1JCZjNOcVFRTkpEUUFnQkNBWElCQWdCQ0FOU1NJRkcyb2lCQ2dBQUNBREtBQUFSdzBBSUFOQkJHb2dCRUVFYWlBTUlCSWdEQ0FGR3lBVEVDQWlCa0VCYWlFRklBRW9BZ3doQkFKQUlBTWdGVTBFUUNBRUlBTVFIQXdCQ3lBRUlBTWdBeUFWRUNJTElBRW9BZ1FpQkVFQk5nSUFJQVJCQURzQkJDQUZRWUNBQkU4RVFDQUJRUUkyQWlRZ0FTQUVJQUVvQWdCclFRTjFOZ0lvQ3lBRUlBVTdBUVlnQVNBRVFRaHFOZ0lFSUFnaEJTQUhJUWtnQmtFRWFpQURhaUlESVFZZ0F5QVJUUTBCREFJTEN5QUlJUWtnQnlFSUlBTWhCZ3NnQmlBUlNRMEFDd3NnQWlBSk5nSUVJQUlnQ0RZQ0FDQVBRUkJxSkFBZ0RDQURhd3ZtQ3dFVmZ5TUFRUkJySWcwa0FDQUNLQUlFSVFvZ0FpZ0NBQ0VJSUFNZ0FDZ0NjQ0lHS0FJQUloSWdBeUFBS0FJRUloQWdBQ2dDRENJT2FpSVRhMm9nQmlnQ0JDSVVJQVlvQWd4cUlobEdhaUlGSUFNZ0JHb2lDMEY0YWlJUlNRUkFJQlFnRGlBVWFpQVNheUlXYXlFWUlBdEJZR29oRlFOQUFuOUJBQ0FPSUFWQkFXb2lCQ0FJSUJCcWF5SUdRWDl6YWtFRFNRMEFHa0VBSUJRZ0JpQVdhMm9nQkNBSWF5QUdJQTVKSWdZYklna29BQUFnQkNnQUFFY05BQm9nQlVFRmFpQUpRUVJxSUFzZ0VpQUxJQVliSUJNUUlFRUVhZ3NoQmlBTlFmK1Q2OXdETmdJTUFrQWdBQ0FGSUFzZ0RVRU1haEJxSWdrZ0JpQUpJQVpMSWdZYklnbEJBMDBFUUNBRklBTnJRUWgxSUFWcVFRRnFJUVVNQVFzZ0RTZ0NERUVBSUFZYklRd2dCU0FFSUFZYklRUUNRQ0FGSUJGUERRQURRQUpBSUE0Z0JVRUJhaUlHSUJCcklBaHJJZ2RCZjNOcVFRTkpEUUFnRkNBSElCWnJhaUFHSUFocklBY2dEa2tpQnhzaUR5Z0FBQ0FHS0FBQVJ3MEFJQVZCQldvZ0QwRUVhaUFMSUJJZ0N5QUhHeUFURUNBaUIwRjdTdzBBSUFkQkJHb2lCMEVEYkNBSlFRTnNJQXhCQVdvUUpHdEJBV3BNRFFCQkFDRU1JQVloQkNBSElRa0xJQTFCLzVQcjNBTTJBZ2dDZndKQUlBQWdCaUFMSUExQkNHb1FhaUlIUVFSSkRRQWdERUVCYWhBa0lSY2dCMEVDZENBTktBSUlJZzlCQVdvUUpHc2dDVUVDZENBWGEwRUVha3dOQUNBUElRd2dCeUVKSUFZTUFRc2dCaUFSVHcwQ0FrQWdEaUFGUVFKcUlnWWdFR3NnQ0dzaUIwRi9jMnBCQTBrTkFDQVVJQWNnRm10cUlBWWdDR3NnQnlBT1NTSUhHeUlQS0FBQUlBWW9BQUJIRFFBZ0JVRUdhaUFQUVFScUlBc2dFaUFMSUFjYklCTVFJQ0lGUVh0TERRQWdCVUVFYWlJRlFRSjBJQWxCQW5SQkFYSWdERUVCYWhBa2Ewd05BRUVBSVF3Z0JpRUVJQVVoQ1FzZ0RVSC9rK3ZjQXpZQ0JDQUFJQVlnQ3lBTlFRUnFFR29pQlVFRVNRMENJQXhCQVdvUUpDRVBJQVZCQW5RZ0RTZ0NCQ0lIUVFGcUVDUnJJQWxCQW5RZ0QydEJCMnBNRFFJZ0J5RU1JQVVoQ1NBR0N5SUZJUVFnQlNBUlNRMEFDd3NDZnlBTVJRUkFJQVFoQlNBS0lRWWdDQXdCQ3dKQUlBUWdBMDBFUUNBRUlRVU1BUXNnR0NBUUlBUWlCU0FNSUJCcWEwRUNhaUlHSUE1Sklnb2JJQVpxSWdZZ0dTQVRJQW9iSWdwTkRRQURRQ0FFUVg5cUlnVXRBQUFnQmtGL2FpSUdMUUFBUndSQUlBUWhCUXdDQ3lBSlFRRnFJUWtnQmlBS1RRMEJJQVVoQkNBRklBTkxEUUFMQ3lBSUlRWWdERUYrYWdzaEJDQUpRWDFxSVE4Z0JTQURheUVISUFFb0Fnd2hDQUpBQWtBZ0JTQVZUUVJBSUFnZ0F4QWNJQUVvQWd3aENpQUhRUkJOQkVBZ0FTQUhJQXBxTmdJTURBTUxJQXBCRUdvZ0EwRVFhaUlJRUJ3Z0NrRWdhaUFEUVNCcUVCd2dCMEV4U0EwQklBY2dDbW9oRnlBS1FUQnFJUU1EUUNBRElBaEJJR29pQ2hBY0lBTkJFR29nQ0VFd2FoQWNJQW9oQ0NBRFFTQnFJZ01nRjBrTkFBc01BUXNnQ0NBRElBVWdGUkFpQ3lBQklBRW9BZ3dnQjJvMkFnd2dCMEdBZ0FSSkRRQWdBVUVCTmdJa0lBRWdBU2dDQkNBQktBSUFhMEVEZFRZQ0tBc2dBU2dDQkNJRElBeEJBV28yQWdBZ0F5QUhPd0VFSUE5QmdJQUVUd1JBSUFGQkFqWUNKQ0FCSUFNZ0FTZ0NBR3RCQTNVMkFpZ0xJQU1nRHpzQkJpQUJJQU5CQ0dvMkFnUWdCaUVLSUFRaENDQUZJQWxxSWdNaEJTQURJQkZMRFFBRFFBSkFJQVloQ0NBRUlRWWdEaUFESUJCcklBaHJJZ1JCZjNOcVFRTkpEUUFnQkNBWUlCQWdCQ0FPU1NJRkcyb2lCQ2dBQUNBREtBQUFSdzBBSUFOQkJHb2dCRUVFYWlBTElCSWdDeUFGR3lBVEVDQWlDVUVCYWlFRklBRW9BZ3doQkFKQUlBTWdGVTBFUUNBRUlBTVFIQXdCQ3lBRUlBTWdBeUFWRUNJTElBRW9BZ1FpQkVFQk5nSUFJQVJCQURzQkJDQUZRWUNBQkU4RVFDQUJRUUkyQWlRZ0FTQUVJQUVvQWdCclFRTjFOZ0lvQ3lBRUlBVTdBUVlnQVNBRVFRaHFOZ0lFSUFnaEJDQUdJUW9nQ1VFRWFpQURhaUlESVFVZ0F5QVJUUTBCREFJTEN5QUlJUW9nQmlFSUlBTWhCUXNnQlNBUlNRMEFDd3NnQWlBS05nSUVJQUlnQ0RZQ0FDQU5RUkJxSkFBZ0N5QURhd3ZwQ3dFVmZ5TUFRUkJySWcwa0FDQUNLQUlFSVFvZ0FpZ0NBQ0VJSUFNZ0FDZ0NjQ0lHS0FJQUloSWdBeUFBS0FJRUloQWdBQ2dDRENJT2FpSVRhMm9nQmlnQ0JDSVVJQVlvQWd4cUlobEdhaUlGSUFNZ0JHb2lDMEY0YWlJUlNRUkFJQlFnRGlBVWFpQVNheUlXYXlFWUlBdEJZR29oRlFOQUFuOUJBQ0FPSUFWQkFXb2lCQ0FJSUJCcWF5SUdRWDl6YWtFRFNRMEFHa0VBSUJRZ0JpQVdhMm9nQkNBSWF5QUdJQTVKSWdZYklna29BQUFnQkNnQUFFY05BQm9nQlVFRmFpQUpRUVJxSUFzZ0VpQUxJQVliSUJNUUlFRUVhZ3NoQmlBTlFmK1Q2OXdETmdJTUFrQWdBQ0FGSUFzZ0RVRU1haENiQVNJSklBWWdDU0FHU3lJR0d5SUpRUU5OQkVBZ0JTQURhMEVJZFNBRmFrRUJhaUVGREFFTElBMG9BZ3hCQUNBR0d5RU1JQVVnQkNBR0d5RUVBa0FnQlNBUlR3MEFBMEFDUUNBT0lBVkJBV29pQmlBUWF5QUlheUlIUVg5emFrRURTUTBBSUJRZ0J5QVdhMm9nQmlBSWF5QUhJQTVKSWdjYklnOG9BQUFnQmlnQUFFY05BQ0FGUVFWcUlBOUJCR29nQ3lBU0lBc2dCeHNnRXhBZ0lnZEJlMHNOQUNBSFFRUnFJZ2RCQTJ3Z0NVRURiQ0FNUVFGcUVDUnJRUUZxVEEwQVFRQWhEQ0FHSVFRZ0J5RUpDeUFOUWYrVDY5d0ROZ0lJQW44Q1FDQUFJQVlnQ3lBTlFRaHFFSnNCSWdkQkJFa05BQ0FNUVFGcUVDUWhGeUFIUVFKMElBMG9BZ2dpRDBFQmFoQWtheUFKUVFKMElCZHJRUVJxVEEwQUlBOGhEQ0FISVFrZ0Jnd0JDeUFHSUJGUERRSUNRQ0FPSUFWQkFtb2lCaUFRYXlBSWF5SUhRWDl6YWtFRFNRMEFJQlFnQnlBV2Eyb2dCaUFJYXlBSElBNUpJZ2NiSWc4b0FBQWdCaWdBQUVjTkFDQUZRUVpxSUE5QkJHb2dDeUFTSUFzZ0J4c2dFeEFnSWdWQmUwc05BQ0FGUVFScUlnVkJBblFnQ1VFQ2RFRUJjaUFNUVFGcUVDUnJUQTBBUVFBaERDQUdJUVFnQlNFSkN5QU5RZitUNjl3RE5nSUVJQUFnQmlBTElBMUJCR29RbXdFaUJVRUVTUTBDSUF4QkFXb1FKQ0VQSUFWQkFuUWdEU2dDQkNJSFFRRnFFQ1JySUFsQkFuUWdEMnRCQjJwTURRSWdCeUVNSUFVaENTQUdDeUlGSVFRZ0JTQVJTUTBBQ3dzQ2Z5QU1SUVJBSUFRaEJTQUtJUVlnQ0F3QkN3SkFJQVFnQTAwRVFDQUVJUVVNQVFzZ0dDQVFJQVFpQlNBTUlCQnFhMEVDYWlJR0lBNUpJZ29iSUFacUlnWWdHU0FUSUFvYklncE5EUUFEUUNBRVFYOXFJZ1V0QUFBZ0JrRi9haUlHTFFBQVJ3UkFJQVFoQlF3Q0N5QUpRUUZxSVFrZ0JpQUtUUTBCSUFVaEJDQUZJQU5MRFFBTEN5QUlJUVlnREVGK2Fnc2hCQ0FKUVgxcUlROGdCU0FEYXlFSElBRW9BZ3doQ0FKQUFrQWdCU0FWVFFSQUlBZ2dBeEFjSUFFb0Fnd2hDaUFIUVJCTkJFQWdBU0FISUFwcU5nSU1EQU1MSUFwQkVHb2dBMEVRYWlJSUVCd2dDa0VnYWlBRFFTQnFFQndnQjBFeFNBMEJJQWNnQ21vaEZ5QUtRVEJxSVFNRFFDQURJQWhCSUdvaUNoQWNJQU5CRUdvZ0NFRXdhaEFjSUFvaENDQURRU0JxSWdNZ0Ywa05BQXNNQVFzZ0NDQURJQVVnRlJBaUN5QUJJQUVvQWd3Z0IybzJBZ3dnQjBHQWdBUkpEUUFnQVVFQk5nSWtJQUVnQVNnQ0JDQUJLQUlBYTBFRGRUWUNLQXNnQVNnQ0JDSURJQXhCQVdvMkFnQWdBeUFIT3dFRUlBOUJnSUFFVHdSQUlBRkJBallDSkNBQklBTWdBU2dDQUd0QkEzVTJBaWdMSUFNZ0R6c0JCaUFCSUFOQkNHbzJBZ1FnQmlFS0lBUWhDQ0FGSUFscUlnTWhCU0FESUJGTERRQURRQUpBSUFZaENDQUVJUVlnRGlBRElCQnJJQWhySWdSQmYzTnFRUU5KRFFBZ0JDQVlJQkFnQkNBT1NTSUZHMm9pQkNnQUFDQURLQUFBUncwQUlBTkJCR29nQkVFRWFpQUxJQklnQ3lBRkd5QVRFQ0FpQ1VFQmFpRUZJQUVvQWd3aEJBSkFJQU1nRlUwRVFDQUVJQU1RSEF3QkN5QUVJQU1nQXlBVkVDSUxJQUVvQWdRaUJFRUJOZ0lBSUFSQkFEc0JCQ0FGUVlDQUJFOEVRQ0FCUVFJMkFpUWdBU0FFSUFFb0FnQnJRUU4xTmdJb0N5QUVJQVU3QVFZZ0FTQUVRUWhxTmdJRUlBZ2hCQ0FHSVFvZ0NVRUVhaUFEYWlJRElRVWdBeUFSVFEwQkRBSUxDeUFJSVFvZ0JpRUlJQU1oQlFzZ0JTQVJTUTBBQ3dzZ0FpQUtOZ0lFSUFJZ0NEWUNBQ0FOUVJCcUpBQWdDeUFEYXd2Y0RRRVNmeUFDS0FJQUlnVWdBaWdDQkNJSFFRQWdCeUFESUFBb0FnUWdBQ2dDREdvaUZDQURSbW9pQmlBVWF5SUpTeUlLR3lBRklBbExJZ2tiSVJaQkFDQUZJQWtiSVFsQkFDQUhJQW9iSVFvZ0JpQURJQVJxSWc1QmVHb2lGVWtFUUNBT1FXQnFJUk1EUUFKQUFuOENRQUovSUFsRklBWkJBV29pQ0NBSmF5Z0FBQ0FJS0FBQVIzSkZCRUFnQmtFRmFpSUVJQVFnQ1dzZ0RoQWRRUVJxSVFWQkFBd0JDd0pBQWtBQ1FBSkFBa0FDUUNBQUtBS0VBVUY3YWc0REFRSUNBQXNnQUNnQ0JDRVBJQUFvQW5RaEJTQUFLQUlRSVFRZ0FDZ0NGQ0VJSUFBb0FvQUJJUXdnQUNnQ0tDRVFJQUFnQUNnQ2VDSU5JQUFvQW53Z0JrRUVFQ3dpQnlBRUlBWWdEMnNpQzBFQklBVjBJZ1ZySUFRZ0N5QUVheUFGU3hzZ0NCc2lFVTBOQTBFQUlBdEJBU0FOZENJRWF5SUZJQVVnQzBzYklRMGdCRUYvYWlFU1FRRWdESFFoQ0VIL2srdmNBeUVNUVFNaEJBTkFBa0FnQnlBUGFpSUZJQVJxTFFBQUlBUWdCbW90QUFCSERRQWdCaUFGSUE0UUhTSUZJQVJORFFBZ0N5QUhhMEVDYWlFTUlBVWlCQ0FHYWlBT1JnMEVDeUFISUExTkJFQWdCQ0VGREFRTElCQWdCeUFTY1VFQ2RHb29BZ0FpQnlBUlRRUkFJQVFoQlF3RUN5QUVJUVVnQ0VGL2FpSUlEUUFMREFJTElBQW9BZ1FoRHlBQUtBSjBJUVVnQUNnQ0VDRUVJQUFvQWhRaENDQUFLQUtBQVNFTUlBQW9BaWdoRUNBQUlBQW9BbmdpRFNBQUtBSjhJQVpCQlJBc0lnY2dCQ0FHSUE5cklndEJBU0FGZENJRmF5QUVJQXNnQkdzZ0JVc2JJQWdiSWhGTkRRSkJBQ0FMUVFFZ0RYUWlCR3NpQlNBRklBdExHeUVOSUFSQmYyb2hFa0VCSUF4MElRaEIvNVByM0FNaERFRURJUVFEUUFKQUlBY2dEMm9pQlNBRWFpMEFBQ0FFSUFacUxRQUFSdzBBSUFZZ0JTQU9FQjBpQlNBRVRRMEFJQXNnQjJ0QkFtb2hEQ0FGSWdRZ0Jtb2dEa1lOQXdzZ0J5QU5UUVJBSUFRaEJRd0RDeUFRSUFjZ0VuRkJBblJxS0FJQUlnY2dFVTBFUUNBRUlRVU1Bd3NnQkNFRklBaEJmMm9pQ0EwQUN3d0JDeUFBS0FJRUlROGdBQ2dDZENFRklBQW9BaEFoQkNBQUtBSVVJUWdnQUNnQ2dBRWhEQ0FBS0FJb0lSQWdBQ0FBS0FKNElnMGdBQ2dDZkNBR1FRWVFMQ0lISUFRZ0JpQVBheUlMUVFFZ0JYUWlCV3NnQkNBTElBUnJJQVZMR3lBSUd5SVJUUTBCUVFBZ0MwRUJJQTEwSWdScklnVWdCU0FMU3hzaERTQUVRWDlxSVJKQkFTQU1kQ0VJUWYrVDY5d0RJUXhCQXlFRUEwQUNRQ0FISUE5cUlnVWdCR290QUFBZ0JDQUdhaTBBQUVjTkFDQUdJQVVnRGhBZElnVWdCRTBOQUNBTElBZHJRUUpxSVF3Z0JTSUVJQVpxSUE1R0RRSUxJQWNnRFUwRVFDQUVJUVVNQWdzZ0VDQUhJQkp4UVFKMGFpZ0NBQ0lISUJGTkJFQWdCQ0VGREFJTElBUWhCU0FJUVg5cUlnZ05BQXNMSUFWQkEwc05BUXNnQmlBRGEwRUlkU0FHYWtFQmFpRUdEQVFMSUF3TkFTQUdJUWhCQUFzaERDQUtJUWNnQ1F3QkN3SkFJQVlnQTAwRVFDQUdJUWdNQVFzZ0JpRUlJQVpCQWlBTWF5SUVhaUFVVFEwQUEwQWdCa0YvYWlJSUxRQUFJQVFnQm1wQmYyb3RBQUJIQkVBZ0JpRUlEQUlMSUFWQkFXb2hCU0FJSUFOTkRRRWdCQ0FJSWdacUlCUkxEUUFMQ3lBSklRY2dERUYrYWdzaEJDQUZRWDFxSVFzZ0NDQURheUVLSUFFb0Fnd2hCZ0pBQWtBZ0NDQVRUUVJBSUFZZ0F4QWNJQUVvQWd3aEJpQUtRUkJOQkVBZ0FTQUdJQXBxTmdJTURBTUxJQVpCRUdvZ0EwRVFhaUlKRUJ3Z0JrRWdhaUFEUVNCcUVCd2dDa0V4U0EwQklBWWdDbW9oRHlBR1FUQnFJUU1EUUNBRElBbEJJR29pQmhBY0lBTkJFR29nQ1VFd2FoQWNJQVloQ1NBRFFTQnFJZ01nRDBrTkFBc01BUXNnQmlBRElBZ2dFeEFpQ3lBQklBRW9BZ3dnQ21vMkFnd2dDa0dBZ0FSSkRRQWdBVUVCTmdJa0lBRWdBU2dDQkNBQktBSUFhMEVEZFRZQ0tBc2dBU2dDQkNJRElBeEJBV28yQWdBZ0F5QUtPd0VFSUF0QmdJQUVUd1JBSUFGQkFqWUNKQ0FCSUFNZ0FTZ0NBR3RCQTNVMkFpZ0xJQU1nQ3pzQkJpQUJJQU5CQ0dvMkFnUWdCU0FJYWlFRElBZEZCRUFnQnlFS0lBUWhDU0FESVFZTUFRc2dCeUVLSUFRaENTQURJZ1lnRlVzTkFBTkFJQWNoQ1NBRUlRY2dBeWdBQUNBRElBbHJLQUFBUndSQUlBa2hDaUFISVFrZ0F5RUdEQUlMSUFOQkJHb2lCQ0FFSUFscklBNFFIU0lHUVFGcUlRVWdBU2dDRENFRUFrQWdBeUFUVFFSQUlBUWdBeEFjREFFTElBUWdBeUFESUJNUUlnc2dBU2dDQkNJRVFRRTJBZ0FnQkVFQU93RUVJQVZCZ0lBRVR3UkFJQUZCQWpZQ0pDQUJJQVFnQVNnQ0FHdEJBM1UyQWlnTElBUWdCVHNCQmlBQklBUkJDR28yQWdRZ0JrRUVhaUFEYWlFRElBZEZCRUFnQnlFS0lBTWhCZ3dDQ3lBSklRUWdCeUVLSUFNaUJpQVZUUTBBQ3dzZ0JpQVZTUTBBQ3dzZ0FpQUtJQllnQ2hzMkFnUWdBaUFKSUJZZ0NSczJBZ0FnRGlBRGF3dEpBUUYvSXdCQklHc2lBaVFBSUFKQkNHb2dBUkNXQVNBQ1FSaHFJQUpCQ0dvZ0FCRUVBQ0FDUVJocUVNZ0JJUUFnQWtFWWFoREZBU0FDUVFocUVKSUJJQUpCSUdva0FDQUFDNGdXQVJaL0lBSW9BZ0FpQlNBQ0tBSUVJZ1pCQUNBR0lBTWdBQ2dDQkNBQUtBSU1haUlZSUFOR2FpSUhJQmhySWdwTElna2JJQVVnQ2tzaUNoc2hHa0VBSUFVZ0Noc2hDa0VBSUFZZ0NSc2hGQ0FISUFNZ0JHb2lEa0Y0YWlJVlNRUkFJQTVCWUdvaEZ3TkFRUUFoRFVFQUlBcHJJUmtnQ2tVZ0IwRUJhaUlQSUFwcktBQUFJQThvQUFCSGNrVUVRQ0FIUVFWcUlnUWdCQ0FaYWlBT0VCMUJCR29oRFFzQ1FBSkFBa0FDUUFKQUlBQW9Bb1FCUVh0cURnTUJBZ0lBQ3lBQUtBSUVJUXdnQUNnQ2RDRUZJQUFvQWhBaEJDQUFLQUlVSVFrZ0FDZ0NnQUVoQ0NBQUtBSW9JUklnQUNBQUtBSjRJaEFnQUNnQ2ZDQUhRUVFRTENJR0lBUWdCeUFNYXlJTFFRRWdCWFFpQldzZ0JDQUxJQVJySUFWTEd5QUpHeUlSVFEwQ1FRQWdDMEVCSUJCMElnUnJJZ1VnQlNBTFN4c2hFQ0FFUVg5cUlSTkJBU0FJZENFSVFmK1Q2OXdESVFsQkF5RUVBMEFDUUNBR0lBeHFJZ1VnQkdvdEFBQWdCQ0FIYWkwQUFFY05BQ0FISUFVZ0RoQWRJZ1VnQkUwTkFDQUxJQVpyUVFKcUlRa2dCeUFGSWdScUlBNUdEUVVMSUFZZ0VFMEVRQ0FFSVFVTUJRc2dFaUFHSUJOeFFRSjBhaWdDQUNJR0lCRk5CRUFnQkNFRkRBVUxJQVFoQlNBSVFYOXFJZ2dOQUFzTUF3c2dBQ2dDQkNFTUlBQW9BblFoQlNBQUtBSVFJUVFnQUNnQ0ZDRUpJQUFvQW9BQklRZ2dBQ2dDS0NFU0lBQWdBQ2dDZUNJUUlBQW9BbndnQjBFRkVDd2lCaUFFSUFjZ0RHc2lDMEVCSUFWMElnVnJJQVFnQ3lBRWF5QUZTeHNnQ1JzaUVVME5BVUVBSUF0QkFTQVFkQ0lFYXlJRklBVWdDMHNiSVJBZ0JFRi9haUVUUVFFZ0NIUWhDRUgvayt2Y0F5RUpRUU1oQkFOQUFrQWdCaUFNYWlJRklBUnFMUUFBSUFRZ0Iyb3RBQUJIRFFBZ0J5QUZJQTRRSFNJRklBUk5EUUFnQ3lBR2EwRUNhaUVKSUFjZ0JTSUVhaUFPUmcwRUN5QUdJQkJOQkVBZ0JDRUZEQVFMSUJJZ0JpQVRjVUVDZEdvb0FnQWlCaUFSVFFSQUlBUWhCUXdFQ3lBRUlRVWdDRUYvYWlJSURRQUxEQUlMSUFBb0FnUWhEQ0FBS0FKMElRVWdBQ2dDRUNFRUlBQW9BaFFoQ1NBQUtBS0FBU0VJSUFBb0FpZ2hFaUFBSUFBb0FuZ2lFQ0FBS0FKOElBZEJCaEFzSWdZZ0JDQUhJQXhySWd0QkFTQUZkQ0lGYXlBRUlBc2dCR3NnQlVzYklBa2JJaEZORFFCQkFDQUxRUUVnRUhRaUJHc2lCU0FGSUF0TEd5RVFJQVJCZjJvaEUwRUJJQWgwSVFoQi81UHIzQU1oQ1VFRElRUURRQUpBSUFZZ0RHb2lCU0FFYWkwQUFDQUVJQWRxTFFBQVJ3MEFJQWNnQlNBT0VCMGlCU0FFVFEwQUlBc2dCbXRCQW1vaENTQUhJQVVpQkdvZ0RrWU5Bd3NnQmlBUVRRUkFJQVFoQlF3REN5QVNJQVlnRTNGQkFuUnFLQUlBSWdZZ0VVMEVRQ0FFSVFVTUF3c2dCQ0VGSUFoQmYyb2lDQTBBQ3d3QkMwRURJUVZCLzVQcjNBTWhDUXNDUUNBRklBMGdCU0FOU3lJRUd5SUxRUU5OQkVBZ0J5QURhMEVJZFNBSGFrRUJhaUVIREFFTElBbEJBQ0FFR3lFTUlBY2dEeUFFR3lFSkFrQWdCeUFWVHcwQUEwQWdCMEVCYWlFRkFrQWdERVVFUUVFQUlRd01BUXNnQ2tVZ0JTZ0FBQ0FGSUJscUtBQUFSM0lOQUNBSFFRVnFJZ1FnQkNBWmFpQU9FQjBpQkVGN1N3MEFJQVJCQkdvaUJFRURiQ0FMUVFOc0lBeEJBV29RSkd0QkFXcE1EUUFnQlNFSlFRQWhEQ0FFSVFzTEFrQUNRQUpBQWtBZ0FDZ0NoQUZCZTJvT0F3RUNBZ0FMSUFBb0FnUWhFaUFBS0FKMElRWWdBQ2dDRUNFRUlBQW9BaFFoQ0NBQUtBS0FBU0VOSUFBb0FpZ2hFQ0FBSUFBb0FuZ2lFU0FBS0FKOElBVkJCQkFzSWdjZ0JDQUZJQkpySWc5QkFTQUdkQ0lHYXlBRUlBOGdCR3NnQmtzYklBZ2JJaE5ORFFSQkFDQVBRUUVnRVhRaUJHc2lCaUFHSUE5TEd5RVJJQVJCZjJvaEZrRUJJQTEwSVFoQi81UHIzQU1oRFVFRElRUURRQUpBSUFjZ0Vtb2lCaUFFYWkwQUFDQUVJQVZxTFFBQVJ3MEFJQVVnQmlBT0VCMGlCaUFFVFEwQUlBOGdCMnRCQW1vaERTQUZJQVlpQkdvZ0RrWU5CQXNnQnlBUlRRUkFJQVFoQmd3RUN5QVFJQWNnRm5GQkFuUnFLQUlBSWdjZ0UwMEVRQ0FFSVFZTUJBc2dCQ0VHSUFoQmYyb2lDQTBBQ3d3Q0N5QUFLQUlFSVJJZ0FDZ0NkQ0VHSUFBb0FoQWhCQ0FBS0FJVUlRZ2dBQ2dDZ0FFaERTQUFLQUlvSVJBZ0FDQUFLQUo0SWhFZ0FDZ0NmQ0FGUVFVUUxDSUhJQVFnQlNBU2F5SVBRUUVnQm5RaUJtc2dCQ0FQSUFScklBWkxHeUFJR3lJVFRRMERRUUFnRDBFQklCRjBJZ1JySWdZZ0JpQVBTeHNoRVNBRVFYOXFJUlpCQVNBTmRDRUlRZitUNjl3RElRMUJBeUVFQTBBQ1FDQUhJQkpxSWdZZ0JHb3RBQUFnQkNBRmFpMEFBRWNOQUNBRklBWWdEaEFkSWdZZ0JFME5BQ0FQSUFkclFRSnFJUTBnQlNBR0lnUnFJQTVHRFFNTElBY2dFVTBFUUNBRUlRWU1Bd3NnRUNBSElCWnhRUUowYWlnQ0FDSUhJQk5OQkVBZ0JDRUdEQU1MSUFRaEJpQUlRWDlxSWdnTkFBc01BUXNnQUNnQ0JDRVNJQUFvQW5RaEJpQUFLQUlRSVFRZ0FDZ0NGQ0VJSUFBb0FvQUJJUTBnQUNnQ0tDRVFJQUFnQUNnQ2VDSVJJQUFvQW53Z0JVRUdFQ3dpQnlBRUlBVWdFbXNpRDBFQklBWjBJZ1pySUFRZ0R5QUVheUFHU3hzZ0NCc2lFMDBOQWtFQUlBOUJBU0FSZENJRWF5SUdJQVlnRDBzYklSRWdCRUYvYWlFV1FRRWdEWFFoQ0VIL2srdmNBeUVOUVFNaEJBTkFBa0FnQnlBU2FpSUdJQVJxTFFBQUlBUWdCV290QUFCSERRQWdCU0FHSUE0UUhTSUdJQVJORFFBZ0R5QUhhMEVDYWlFTklBVWdCaUlFYWlBT1JnMENDeUFISUJGTkJFQWdCQ0VHREFJTElCQWdCeUFXY1VFQ2RHb29BZ0FpQnlBVFRRUkFJQVFoQmd3Q0N5QUVJUVlnQ0VGL2FpSUlEUUFMQ3lBR1FRUkpEUUVnREVFQmFoQWtJUVFnQmtFQ2RDQU5RUUZxRUNScklBdEJBblFnQkd0QkJHcE1EUUVnQmlFTElBMGhEQ0FGSWdjaENTQUZJQlZKRFFBTEN3Si9JQXhGQkVBZ0NTRUhJQW9oQmlBVURBRUxBa0FnQ1NBRFRRUkFJQWtoQnd3QkMwRUNJQXhySWdRZ0NTSUhhaUFZVFEwQUEwQWdDVUYvYWlJSExRQUFJQVFnQ1dwQmYyb3RBQUJIQkVBZ0NTRUhEQUlMSUF0QkFXb2hDeUFISUFOTkRRRWdCeUVKSUFRZ0Iyb2dHRXNOQUFzTElBeEJmbW9oQmlBS0N5RUZJQXRCZldvaENTQUhJQU5ySVFvZ0FTZ0NEQ0VFQWtBQ1FDQUhJQmROQkVBZ0JDQURFQndnQVNnQ0RDRUVJQXBCRUUwRVFDQUJJQVFnQ21vMkFnd01Bd3NnQkVFUWFpQURRUkJxSWdnUUhDQUVRU0JxSUFOQklHb1FIQ0FLUVRGSURRRWdCQ0FLYWlFVUlBUkJNR29oQkFOQUlBUWdDRUVnYWlJREVCd2dCRUVRYWlBSVFUQnFFQndnQXlFSUlBUkJJR29pQkNBVVNRMEFDd3dCQ3lBRUlBTWdCeUFYRUNJTElBRWdBU2dDRENBS2FqWUNEQ0FLUVlDQUJFa05BQ0FCUVFFMkFpUWdBU0FCS0FJRUlBRW9BZ0JyUVFOMU5nSW9DeUFCS0FJRUlnTWdERUVCYWpZQ0FDQURJQW83QVFRZ0NVR0FnQVJQQkVBZ0FVRUNOZ0lrSUFFZ0F5QUJLQUlBYTBFRGRUWUNLQXNnQXlBSk93RUdJQUVnQTBFSWFqWUNCQ0FISUF0cUlRTWdCVVVFUUNBRklSUWdCaUVLSUFNaEJ3d0JDeUFGSVJRZ0JpRUtJQU1pQnlBVlN3MEFBMEFnQlNFS0lBWWhCU0FES0FBQUlBTWdDbXNvQUFCSEJFQWdDaUVVSUFVaENpQURJUWNNQWdzZ0EwRUVhaUlFSUFRZ0Ntc2dEaEFkSWdkQkFXb2hCaUFCS0FJTUlRUUNRQ0FESUJkTkJFQWdCQ0FERUJ3TUFRc2dCQ0FESUFNZ0Z4QWlDeUFCS0FJRUlnUkJBVFlDQUNBRVFRQTdBUVFnQmtHQWdBUlBCRUFnQVVFQ05nSWtJQUVnQkNBQktBSUFhMEVEZFRZQ0tBc2dCQ0FHT3dFR0lBRWdCRUVJYWpZQ0JDQUhRUVJxSUFOcUlRTWdCVVVFUUNBRklSUWdBeUVIREFJTElBb2hCaUFGSVJRZ0F5SUhJQlZORFFBTEN5QUhJQlZKRFFBTEN5QUNJQlFnR2lBVUd6WUNCQ0FDSUFvZ0dpQUtHellDQUNBT0lBTnJDNmtlQVJkL0lBSW9BZ0FpQlNBQ0tBSUVJZ1pCQUNBR0lBTWdBQ2dDQkNBQUtBSU1haUlhSUFOR2FpSUlJQnBySWdkTElnc2JJQVVnQjBzaUJ4c2hHMEVBSUFVZ0J4c2hFMEVBSUFZZ0N4c2hGU0FJSUFNZ0JHb2lFRUY0YWlJV1NRUkFJQkJCWUdvaEdRTkFRUUFoREVFQUlCTnJJUmNnRTBVZ0NFRUJhaUlPSUJOcktBQUFJQTRvQUFCSGNrVUVRQ0FJUVFWcUlnUWdCQ0FYYWlBUUVCMUJCR29oREFzQ1FBSkFBa0FDUUFKQUlBQW9Bb1FCUVh0cURnTUJBZ0lBQ3lBQUtBSUVJUW9nQUNnQ2RDRUZJQUFvQWhBaEJDQUFLQUlVSVFjZ0FDZ0NnQUVoQ1NBQUtBSW9JUTBnQUNBQUtBSjRJZzhnQUNnQ2ZDQUlRUVFRTENJR0lBUWdDQ0FLYXlJTFFRRWdCWFFpQldzZ0JDQUxJQVJySUFWTEd5QUhHeUlSVFEwQ1FRQWdDMEVCSUE5MElnUnJJZ1VnQlNBTFN4c2hEeUFFUVg5cUlSSkJBU0FKZENFSFFmK1Q2OXdESVFsQkF5RUVBMEFDUUNBR0lBcHFJZ1VnQkdvdEFBQWdCQ0FJYWkwQUFFY05BQ0FJSUFVZ0VCQWRJZ1VnQkUwTkFDQUxJQVpyUVFKcUlRa2dDQ0FGSWdScUlCQkdEUVVMSUFZZ0QwMEVRQ0FFSVFVTUJRc2dEU0FHSUJKeFFRSjBhaWdDQUNJR0lCRk5CRUFnQkNFRkRBVUxJQVFoQlNBSFFYOXFJZ2NOQUFzTUF3c2dBQ2dDQkNFS0lBQW9BblFoQlNBQUtBSVFJUVFnQUNnQ0ZDRUhJQUFvQW9BQklRa2dBQ2dDS0NFTklBQWdBQ2dDZUNJUElBQW9BbndnQ0VFRkVDd2lCaUFFSUFnZ0Ntc2lDMEVCSUFWMElnVnJJQVFnQ3lBRWF5QUZTeHNnQnhzaUVVME5BVUVBSUF0QkFTQVBkQ0lFYXlJRklBVWdDMHNiSVE4Z0JFRi9haUVTUVFFZ0NYUWhCMEgvayt2Y0F5RUpRUU1oQkFOQUFrQWdCaUFLYWlJRklBUnFMUUFBSUFRZ0NHb3RBQUJIRFFBZ0NDQUZJQkFRSFNJRklBUk5EUUFnQ3lBR2EwRUNhaUVKSUFnZ0JTSUVhaUFRUmcwRUN5QUdJQTlOQkVBZ0JDRUZEQVFMSUEwZ0JpQVNjVUVDZEdvb0FnQWlCaUFSVFFSQUlBUWhCUXdFQ3lBRUlRVWdCMEYvYWlJSERRQUxEQUlMSUFBb0FnUWhDaUFBS0FKMElRVWdBQ2dDRUNFRUlBQW9BaFFoQnlBQUtBS0FBU0VKSUFBb0FpZ2hEU0FBSUFBb0FuZ2lEeUFBS0FKOElBaEJCaEFzSWdZZ0JDQUlJQXBySWd0QkFTQUZkQ0lGYXlBRUlBc2dCR3NnQlVzYklBY2JJaEZORFFCQkFDQUxRUUVnRDNRaUJHc2lCU0FGSUF0TEd5RVBJQVJCZjJvaEVrRUJJQWwwSVFkQi81UHIzQU1oQ1VFRElRUURRQUpBSUFZZ0Ntb2lCU0FFYWkwQUFDQUVJQWhxTFFBQVJ3MEFJQWdnQlNBUUVCMGlCU0FFVFEwQUlBc2dCbXRCQW1vaENTQUlJQVVpQkdvZ0VFWU5Bd3NnQmlBUFRRUkFJQVFoQlF3REN5QU5JQVlnRW5GQkFuUnFLQUlBSWdZZ0VVMEVRQ0FFSVFVTUF3c2dCQ0VGSUFkQmYyb2lCdzBBQ3d3QkMwRURJUVZCLzVQcjNBTWhDUXNDUUNBRklBd2dCU0FNU3lJRUd5SUZRUU5OQkVBZ0NDQURhMEVJZFNBSWFrRUJhaUVJREFFTElBZ2dEaUFFR3lFTElBbEJBQ0FFR3lJTUlRNGdCU0VKQWtBZ0NDQVdUdzBBQTBBZ0NFRUJhaUVKQWtBZ0RFVUVRRUVBSVF3TUFRc2dFMFVnQ1NnQUFDQUpJQmRxS0FBQVIzSU5BQ0FJUVFWcUlnUWdCQ0FYYWlBUUVCMGlCRUY3U3cwQUlBUkJCR29pQkVFRGJDQUZRUU5zSUF4QkFXb1FKR3RCQVdwTURRQWdDU0VMUVFBaERDQUVJUVVMQWtBQ1FBSkFBa0FDUUFKQUlBQW9Bb1FCUVh0cURnTUJBZ0lBQ3lBQUtBSUVJUThnQUNnQ2RDRUhJQUFvQWhBaEJpQUFLQUlVSVE0Z0FDZ0NnQUVoQ2lBQUtBSW9JUkVnQUNBQUtBSjRJaElnQUNnQ2ZDQUpRUVFRTENJRUlBWWdDU0FQYXlJTlFRRWdCM1FpQjJzZ0JpQU5JQVpySUFkTEd5QU9HeUlVVFEwRFFRQWdEVUVCSUJKMElnWnJJZ2NnQnlBTlN4c2hFaUFHUVg5cUlSaEJBU0FLZENFS1FmK1Q2OXdESVE1QkF5RUdBMEFDUUNBRUlBOXFJZ2NnQm1vdEFBQWdCaUFKYWkwQUFFY05BQ0FKSUFjZ0VCQWRJZ2NnQmswTkFDQU5JQVJyUVFKcUlRNGdDU0FISWdacUlCQkdEUVFMSUFRZ0VrMEVRQ0FHSVFjTUJBc2dFU0FFSUJoeFFRSjBhaWdDQUNJRUlCUk5CRUFnQmlFSERBUUxJQVloQnlBS1FYOXFJZ29OQUFzTUFnc2dBQ2dDQkNFUElBQW9BblFoQnlBQUtBSVFJUVlnQUNnQ0ZDRU9JQUFvQW9BQklRb2dBQ2dDS0NFUklBQWdBQ2dDZUNJU0lBQW9BbndnQ1VFRkVDd2lCQ0FHSUFrZ0Qyc2lEVUVCSUFkMElnZHJJQVlnRFNBR2F5QUhTeHNnRGhzaUZFME5Ba0VBSUExQkFTQVNkQ0lHYXlJSElBY2dEVXNiSVJJZ0JrRi9haUVZUVFFZ0NuUWhDa0gvayt2Y0F5RU9RUU1oQmdOQUFrQWdCQ0FQYWlJSElBWnFMUUFBSUFZZ0NXb3RBQUJIRFFBZ0NTQUhJQkFRSFNJSElBWk5EUUFnRFNBRWEwRUNhaUVPSUFrZ0J5SUdhaUFRUmcwREN5QUVJQkpOQkVBZ0JpRUhEQU1MSUJFZ0JDQVljVUVDZEdvb0FnQWlCQ0FVVFFSQUlBWWhCd3dEQ3lBR0lRY2dDa0YvYWlJS0RRQUxEQUVMSUFBb0FnUWhEeUFBS0FKMElRY2dBQ2dDRUNFR0lBQW9BaFFoRGlBQUtBS0FBU0VLSUFBb0FpZ2hFU0FBSUFBb0FuZ2lFaUFBS0FKOElBbEJCaEFzSWdRZ0JpQUpJQTlySWcxQkFTQUhkQ0lIYXlBR0lBMGdCbXNnQjBzYklBNGJJaFJORFFGQkFDQU5RUUVnRW5RaUJtc2lCeUFISUExTEd5RVNJQVpCZjJvaEdFRUJJQXAwSVFwQi81UHIzQU1oRGtFRElRWURRQUpBSUFRZ0Qyb2lCeUFHYWkwQUFDQUdJQWxxTFFBQVJ3MEFJQWtnQnlBUUVCMGlCeUFHVFEwQUlBMGdCR3RCQW1vaERpQUpJQWNpQm1vZ0VFWU5BZ3NnQkNBU1RRUkFJQVloQnd3Q0N5QVJJQVFnR0hGQkFuUnFLQUlBSWdRZ0ZFMEVRQ0FHSVFjTUFnc2dCaUVISUFwQmYyb2lDZzBBQ3dzZ0IwRUVTUTBBSUF4QkFXb1FKQ0VFSUFkQkFuUWdEa0VCYWhBa2F5QUZRUUowSUFSclFRUnFUQTBBSUFraENDQU9JUXdnQnlFRkRBRUxJQWtnRms4RVFDQU1JUTRnQlNFSkRBTUxJQWhCQW1vaEJrRUFJUTRDZnlBRklBeEZEUUFhQWtBZ0UwVWdCaWdBQUNBR0lCZHFLQUFBUjNJTkFDQUlRUVpxSWdRZ0JDQVhhaUFRRUIwaUJFRjdTdzBBSUF3aERpQUZJQVJCQkdvaUJFRUNkQ0FGUVFKMFFRRnlJQXhCQVdvUUpHdE1EUUVhSUFZaEMwRUFJUTRnQkF3QkN5QU1JUTRnQlFzaENRSkFBa0FDUUFKQUlBQW9Bb1FCUVh0cURnTUJBZ0lBQ3lBQUtBSUVJUTBnQUNnQ2RDRUZJQUFvQWhBaEJDQUFLQUlVSVFjZ0FDZ0NnQUVoRENBQUtBSW9JUThnQUNBQUtBSjRJaEVnQUNnQ2ZDQUdRUVFRTENJSUlBUWdCaUFOYXlJS1FRRWdCWFFpQldzZ0JDQUtJQVJySUFWTEd5QUhHeUlTVFEwRlFRQWdDa0VCSUJGMElnUnJJZ1VnQlNBS1N4c2hFU0FFUVg5cUlSUkJBU0FNZENFSFFmK1Q2OXdESVF4QkF5RUVBMEFDUUNBSUlBMXFJZ1VnQkdvdEFBQWdCQ0FHYWkwQUFFY05BQ0FHSUFVZ0VCQWRJZ1VnQkUwTkFDQUtJQWhyUVFKcUlRd2dCaUFGSWdScUlCQkdEUVFMSUFnZ0VVMEVRQ0FFSVFVTUJBc2dEeUFJSUJSeFFRSjBhaWdDQUNJSUlCSk5CRUFnQkNFRkRBUUxJQVFoQlNBSFFYOXFJZ2NOQUFzTUFnc2dBQ2dDQkNFTklBQW9BblFoQlNBQUtBSVFJUVFnQUNnQ0ZDRUhJQUFvQW9BQklRd2dBQ2dDS0NFUElBQWdBQ2dDZUNJUklBQW9BbndnQmtFRkVDd2lDQ0FFSUFZZ0RXc2lDa0VCSUFWMElnVnJJQVFnQ2lBRWF5QUZTeHNnQnhzaUVrME5CRUVBSUFwQkFTQVJkQ0lFYXlJRklBVWdDa3NiSVJFZ0JFRi9haUVVUVFFZ0RIUWhCMEgvayt2Y0F5RU1RUU1oQkFOQUFrQWdDQ0FOYWlJRklBUnFMUUFBSUFRZ0Jtb3RBQUJIRFFBZ0JpQUZJQkFRSFNJRklBUk5EUUFnQ2lBSWEwRUNhaUVNSUFZZ0JTSUVhaUFRUmcwREN5QUlJQkZOQkVBZ0JDRUZEQU1MSUE4Z0NDQVVjVUVDZEdvb0FnQWlDQ0FTVFFSQUlBUWhCUXdEQ3lBRUlRVWdCMEYvYWlJSERRQUxEQUVMSUFBb0FnUWhEU0FBS0FKMElRVWdBQ2dDRUNFRUlBQW9BaFFoQnlBQUtBS0FBU0VNSUFBb0FpZ2hEeUFBSUFBb0FuZ2lFU0FBS0FKOElBWkJCaEFzSWdnZ0JDQUdJQTFySWdwQkFTQUZkQ0lGYXlBRUlBb2dCR3NnQlVzYklBY2JJaEpORFFOQkFDQUtRUUVnRVhRaUJHc2lCU0FGSUFwTEd5RVJJQVJCZjJvaEZFRUJJQXgwSVFkQi81UHIzQU1oREVFRElRUURRQUpBSUFnZ0RXb2lCU0FFYWkwQUFDQUVJQVpxTFFBQVJ3MEFJQVlnQlNBUUVCMGlCU0FFVFEwQUlBb2dDR3RCQW1vaERDQUdJQVVpQkdvZ0VFWU5BZ3NnQ0NBUlRRUkFJQVFoQlF3Q0N5QVBJQWdnRkhGQkFuUnFLQUlBSWdnZ0VrMEVRQ0FFSVFVTUFnc2dCQ0VGSUFkQmYyb2lCdzBBQ3dzZ0JVRUVTUTBDSUE1QkFXb1FKQ0VFSUFZaENDQUZRUUowSUF4QkFXb1FKR3NnQ1VFQ2RDQUVhMEVIYWt3TkFnc2dDQ0VMSUF3aERpQUZJUWtnQ0NBV1NRMEFDd3NDZnlBT1JRUkFJQXNoQlNBVklRWWdFd3dCQ3dKQUlBc2dBMDBFUUNBTElRVU1BUXRCQWlBT2F5SUVJQXNpQldvZ0drME5BQU5BSUF0QmYyb2lCUzBBQUNBRUlBdHFRWDlxTFFBQVJ3UkFJQXNoQlF3Q0N5QUpRUUZxSVFrZ0JTQURUUTBCSUFVaEN5QUVJQVZxSUJwTERRQUxDeUFUSVFZZ0RrRithZ3NoQkNBSlFYMXFJUk1nQlNBRGF5RUxJQUVvQWd3aEJ3SkFBa0FnQlNBWlRRUkFJQWNnQXhBY0lBRW9BZ3doQ0NBTFFSQk5CRUFnQVNBSUlBdHFOZ0lNREFNTElBaEJFR29nQTBFUWFpSUhFQndnQ0VFZ2FpQURRU0JxRUJ3Z0MwRXhTQTBCSUFnZ0Myb2hGU0FJUVRCcUlRZ0RRQ0FJSUFkQklHb2lBeEFjSUFoQkVHb2dCMEV3YWhBY0lBTWhCeUFJUVNCcUlnZ2dGVWtOQUFzTUFRc2dCeUFESUFVZ0dSQWlDeUFCSUFFb0Fnd2dDMm8yQWd3Z0MwR0FnQVJKRFFBZ0FVRUJOZ0lrSUFFZ0FTZ0NCQ0FCS0FJQWEwRURkVFlDS0FzZ0FTZ0NCQ0lESUE1QkFXbzJBZ0FnQXlBTE93RUVJQk5CZ0lBRVR3UkFJQUZCQWpZQ0pDQUJJQU1nQVNnQ0FHdEJBM1UyQWlnTElBTWdFenNCQmlBQklBTkJDR28yQWdRZ0JTQUphaUVESUFaRkJFQWdCaUVWSUFRaEV5QURJUWdNQVFzZ0JpRVZJQVFoRXlBRElnZ2dGa3NOQUFOQUlBWWhFeUFFSVFZZ0F5Z0FBQ0FESUJOcktBQUFSd1JBSUJNaEZTQUdJUk1nQXlFSURBSUxJQU5CQkdvaUJDQUVJQk5ySUJBUUhTSUhRUUZxSVFVZ0FTZ0NEQ0VFQWtBZ0F5QVpUUVJBSUFRZ0F4QWNEQUVMSUFRZ0F5QURJQmtRSWdzZ0FTZ0NCQ0lFUVFFMkFnQWdCRUVBT3dFRUlBVkJnSUFFVHdSQUlBRkJBallDSkNBQklBUWdBU2dDQUd0QkEzVTJBaWdMSUFRZ0JUc0JCaUFCSUFSQkNHbzJBZ1FnQjBFRWFpQURhaUVESUFaRkJFQWdCaUVWSUFNaENBd0NDeUFUSVFRZ0JpRVZJQU1pQ0NBV1RRMEFDd3NnQ0NBV1NRMEFDd3NnQWlBVklCc2dGUnMyQWdRZ0FpQVRJQnNnRXhzMkFnQWdFQ0FEYXd2eUFnRVBmd0pBSUFBb0FuQWlCeWdDSUNBQklBY29BbndnQmhCYVFRSjBhaWdDQUNJR0lBY29BaEFpQ2swTkFDQUhLQUlBSWc4Z0J5Z0NCQ0lNYXlJTFFYOGdCeWdDZUVGL2FuUkJmM01pRFdzZ0NpQUxJQXBySUExTEd5RU9JQUFvQWdRaUNTQUFLQUlNYWlFUUlBRWdDV3NpQ0VFQ2FpRVJJQWhCQVdvaEVpQUpJQUFvQWhBZ0Myc2lFMm9oRkNBSEtBSW9JUlZCQUNFQVFRQWhDUU5BSUFFZ0NTQUFJQWtnQUVrYklnZHFJQVlnREdvZ0Iyb2dBaUFQSUJBUUlDQUhhaUlISUFSTEJFQWdCeUFFYTBFQ2RDQVNJQVlnRTJvaUNHc1FKQ0FES0FJQVFRRnFFQ1JyU2dSQUlBTWdFU0FJYXpZQ0FDQUhJUVFMSUFFZ0Iyb2dBa1lOQWdzZ0ZTQUdJQTF4UVFOMGFpRUlBa0FnRENBVUlBWWdCMm9nQzBrYklBWnFJQWRxTFFBQUlBRWdCMm90QUFCSkJFQWdCaUFPVFEwRElBaEJCR29oQ0NBSElRa2dBQ0VIREFFTElBWWdEazBOQWdzZ0NDZ0NBQ0lHSUFwTkRRRWdCeUVBSUFWQmYyb2lCUTBBQ3dzZ0JBdkRBd0VUZnlNQVFSQnJJZ3drQUNBQUtBSW9JaEpCZnlBQUtBSjRRWDlxZEVGL2N5SVRJQUZ4UVFOMGFpSUlRUVJxSVFvQ1FDQURSU0FJS0FJQUlnWWdBVUVCSUFBb0FuUjBJZ2xySUFBb0FoQWlCeUFCSUFkcklBbExHeUlVVFhJTkFDQUFLQUlJSWcwZ0FDZ0NEQ0lIYWlJVklBSWdCeUFCU3lJUUd5RU9JQUFvQWdRaUN5QUhhaUVXSUEwZ0N5QVFHeUFCYWlFUFFRQWhBaUFGUVFGR0lSZEJBQ0VKQTBBQ1FDQVFJQVZCQVVkeVJVRUFJQUlnQ1NBQ0lBbEpHeUlBSUFacUlnRWdCMGtiUlFSQUlBQWdEMm9nRFNBTElBRWdCMGtiSUFzZ0Z4c2dCbW9pRVNBQWFpQU9FQjBnQUdvaEFBd0JDeUFHSUExcUlnRWdCaUFMYWlBQUlBOXFJQUFnQVdvZ0RpQVZJQllRSUNBQWFpSUFJQVpxSUFkSkd5RVJDeUFBSUE5cUloZ2dEa1lOQVNBU0lBWWdFM0ZCQTNScUlRRUNRQUpBSUFBZ0VXb3RBQUFnR0MwQUFFa0VRQ0FJSUFZMkFnQWdCaUFFU3cwQklBeEJER29oQ0F3RUN5QUtJQVkyQWdBZ0JpQUVTd1JBSUFFaENpQUFJUWtNQWdzZ0RFRU1haUVLREFNTElBRkJCR29pQVNFSUlBQWhBZ3NnQVNnQ0FDSUdJQlJORFFFZ0EwRi9haUlERFFBTEN5QUtRUUEyQWdBZ0NFRUFOZ0lBSUF4QkVHb2tBQXY3Q2dFUWZ5TUFRUkJySWd3a0FDQUNLQUlBSWdZZ0FpZ0NCQ0lJUVFBZ0NDQURJQUFvQWdRZ0FDZ0NER29pRWlBRFJtb2lCU0FTYXlJSFN5SUpHeUFHSUFkTElnY2JJUk5CQUNBR0lBY2JJUWRCQUNBSUlBa2JJUWdnQlNBRElBUnFJZzFCZUdvaUQwa0VRQ0FOUVdCcUlSRURRRUVBSVFaQkFDQUhheUVPSUFkRklBVkJBV29pQ1NBSGF5Z0FBQ0FKS0FBQVIzSkZCRUFnQlVFRmFpSUVJQVFnRG1vZ0RSQWRRUVJxSVFZTElBeEIvNVByM0FNMkFnd0NRQ0FBSUFVZ0RTQU1RUXhxRUp3QklnUWdCaUFFSUFaTElnWWJJZ3RCQTAwRVFDQUZJQU5yUVFoMUlBVnFRUUZxSVFVTUFRc2dEQ2dDREVFQUlBWWJJUVFnQlNBSklBWWJJUVlDUUNBRklBOVBEUUFEUUNBRlFRRnFJUWtDUUNBRVJRUkFRUUFoQkF3QkN5QUhSU0FKS0FBQUlBa2dEbW9vQUFCSGNnMEFJQVZCQldvaUNpQUtJQTVxSUEwUUhTSUtRWHRMRFFBZ0NrRUVhaUlLUVFOc0lBdEJBMndnQkVFQmFoQWthMEVCYWt3TkFDQUpJUVpCQUNFRUlBb2hDd3NnREVIL2srdmNBellDQ0FKL0FrQWdBQ0FKSUEwZ0RFRUlhaENjQVNJS1FRUkpEUUFnQkVFQmFoQWtJUkFnQ2tFQ2RDQU1LQUlJSWhSQkFXb1FKR3NnQzBFQ2RDQVFhMEVFYWt3TkFDQUpJUVVnQ2lFTElCUU1BUXNnQ1NBUFR3MENJQVZCQW1vaENRSkFJQVJGQkVCQkFDRUVEQUVMSUFkRklBa29BQUFnQ1NBT2FpZ0FBRWR5RFFBZ0JVRUdhaUlGSUFVZ0Rtb2dEUkFkSWdWQmUwc05BQ0FGUVFScUlnVkJBblFnQzBFQ2RFRUJjaUFFUVFGcUVDUnJUQTBBSUFraEJrRUFJUVFnQlNFTEN5QU1RZitUNjl3RE5nSUVJQUFnQ1NBTklBeEJCR29RbkFFaUNrRUVTUTBDSUFSQkFXb1FKQ0VGSUFwQkFuUWdEQ2dDQkNJUVFRRnFFQ1JySUF0QkFuUWdCV3RCQjJwTURRSWdDU0VGSUFvaEN5QVFDeUVFSUFVaEJpQUZJQTlKRFFBTEN3Si9JQVJGQkVBZ0JpRUZJQWNoQ1NBSURBRUxBa0FnQmlBRFRRUkFJQVloQlF3QkMwRUNJQVJySWdnZ0JpSUZhaUFTVFEwQUEwQWdCa0YvYWlJRkxRQUFJQVlnQ0dwQmYyb3RBQUJIQkVBZ0JpRUZEQUlMSUF0QkFXb2hDeUFGSUFOTkRRRWdCU0VHSUFVZ0NHb2dFa3NOQUFzTElBUkJmbW9oQ1NBSEN5RUdJQXRCZldvaERpQUZJQU5ySVFvZ0FTZ0NEQ0VIQWtBQ1FDQUZJQkZOQkVBZ0J5QURFQndnQVNnQ0RDRUlJQXBCRUUwRVFDQUJJQWdnQ21vMkFnd01Bd3NnQ0VFUWFpQURRUkJxSWdjUUhDQUlRU0JxSUFOQklHb1FIQ0FLUVRGSURRRWdDQ0FLYWlFUUlBaEJNR29oQXdOQUlBTWdCMEVnYWlJSUVCd2dBMEVRYWlBSFFUQnFFQndnQ0NFSElBTkJJR29pQXlBUVNRMEFDd3dCQ3lBSElBTWdCU0FSRUNJTElBRWdBU2dDRENBS2FqWUNEQ0FLUVlDQUJFa05BQ0FCUVFFMkFpUWdBU0FCS0FJRUlBRW9BZ0JyUVFOMU5nSW9DeUFCS0FJRUlnTWdCRUVCYWpZQ0FDQURJQW83QVFRZ0RrR0FnQVJQQkVBZ0FVRUNOZ0lrSUFFZ0F5QUJLQUlBYTBFRGRUWUNLQXNnQXlBT093RUdJQUVnQTBFSWFqWUNCQ0FGSUF0cUlRTWdCa1VFUUNBR0lRZ2dDU0VISUFNaEJRd0JDeUFHSVFnZ0NTRUhJQU1oQlNBRElBOUxEUUFEUUNBR0lRY2dDU0VHSUFNb0FBQWdBeUFIYXlnQUFFY0VRQ0FISVFnZ0JpRUhJQU1oQlF3Q0N5QURRUVJxSWdRZ0JDQUhheUFORUIwaUNFRUJhaUVGSUFFb0Fnd2hCQUpBSUFNZ0VVMEVRQ0FFSUFNUUhBd0JDeUFFSUFNZ0F5QVJFQ0lMSUFFb0FnUWlCRUVCTmdJQUlBUkJBRHNCQkNBRlFZQ0FCRThFUUNBQlFRSTJBaVFnQVNBRUlBRW9BZ0JyUVFOMU5nSW9DeUFFSUFVN0FRWWdBU0FFUVFocU5nSUVJQWhCQkdvZ0Eyb2hBeUFHUlFSQUlBWWhDQ0FESVFVTUFnc2dCeUVKSUFZaENDQURJUVVnQXlBUFRRMEFDd3NnQlNBUFNRMEFDd3NnQWlBSUlCTWdDQnMyQWdRZ0FpQUhJQk1nQnhzMkFnQWdERUVRYWlRQUlBMGdBMnNMcGhRQkYzOGdBQ2dDZkNFUklBQW9BaUFoRWlBQUtBSUlJUTBnQUNnQ2lBRWlDU0FKUldvaEZ5QURJQVJxSWc1QmVHb2hFeUFDS0FJRUlRWWdBaWdDQUNFSkFrQWdBQ2dDRUNBQUtBSVVJQU1nQUNnQ0JDSU1heUFFYWlJRUlBQW9BblFpQnhBbklnOGdBQ2dDRENJQVNRUkFJQk1nQTBzRVFDQU5JQThnQUNBQUlBOUpHeUlVYWlFVklBd2dGR29oRmlBTklBOXFJUndnRGtGZ2FpRVFJQlJCZjJvaEdDQURJUUFEUUNBU0lBTWdFU0FGRUI1QkFuUnFJZ1FvQWdBaENpQUVJQU1nREdzaUdUWUNBQUpBQWtBQ1FBSkFJQU1nQ1NBTWFtdEJBV29pQkNBUFRTQVlJQVJyUVFOSmNrVUVRQ0FFSUEwZ0RDQUVJQlJKSWdjYmFpSUVLQUFBSUFOQkFXb2lDeWdBQUVZTkFRc2dDaUFQVHdSQUlBMGdEQ0FLSUJSSklnUWJJQXBxSWdjb0FBQWdBeWdBQUVZTkFnc2dBeUFYSUFNZ0FHdEJDSFZxYWlFRERBTUxJQU5CQldvZ0JFRUVhaUFPSUJVZ0RpQUhHeUFXRUNBaUdrRUJhaUVLSUFzZ0FHc2hDQ0FCS0FJTUlRUUNRQUpBSUFzZ0VFMEVRQ0FFSUFBUUhDQUJLQUlNSVFjZ0NFRVFUUVJBSUFFZ0J5QUlhallDREF3REN5QUhRUkJxSUFCQkVHb2lCQkFjSUFkQklHb2dBRUVnYWhBY0lBaEJNVWdOQVNBSElBaHFJUnNnQjBFd2FpRUFBMEFnQUNBRVFTQnFJZ2NRSENBQVFSQnFJQVJCTUdvUUhDQUhJUVFnQUVFZ2FpSUFJQnRKRFFBTERBRUxJQVFnQUNBTElCQVFJZ3NnQVNBQktBSU1JQWhxTmdJTUlBaEJnSUFFU1EwQUlBRkJBVFlDSkNBQklBRW9BZ1FnQVNnQ0FHdEJBM1UyQWlnTElBRW9BZ1FpQUVFQk5nSUFJQUFnQ0RzQkJDQUtRWUNBQkU4RVFDQUJRUUkyQWlRZ0FTQUFJQUVvQWdCclFRTjFOZ0lvQ3lBQUlBbzdBUVlnQVNBQVFRaHFOZ0lFSUJwQkJHb2dDMm9oQUF3QkN5QURRUVJxSUFkQkJHb2dEaUFWSUE0Z0JCc2dGaEFnUVFScUlRWUNRQ0FISUJ3Z0ZpQUVHeUlMVFFSQUlBTWhCQXdCQ3lBRElRZ2dBeUVFSUFNZ0FFME5BQU5BSUFoQmYyb2lCQzBBQUNBSFFYOXFJZ2N0QUFCSEJFQWdDQ0VFREFJTElBWkJBV29oQmlBSElBdE5EUUVnQkNFSUlBUWdBRXNOQUFzTElCa2dDbXNoQ0NBR1FYMXFJUm9nQkNBQWF5RUxJQUVvQWd3aEJ3SkFBa0FnQkNBUVRRUkFJQWNnQUJBY0lBRW9BZ3doQ2lBTFFSQk5CRUFnQVNBS0lBdHFOZ0lNREFNTElBcEJFR29nQUVFUWFpSUhFQndnQ2tFZ2FpQUFRU0JxRUJ3Z0MwRXhTQTBCSUFvZ0Myb2hHeUFLUVRCcUlRQURRQ0FBSUFkQklHb2lDaEFjSUFCQkVHb2dCMEV3YWhBY0lBb2hCeUFBUVNCcUlnQWdHMGtOQUFzTUFRc2dCeUFBSUFRZ0VCQWlDeUFCSUFFb0Fnd2dDMm8yQWd3Z0MwR0FnQVJKRFFBZ0FVRUJOZ0lrSUFFZ0FTZ0NCQ0FCS0FJQWEwRURkVFlDS0FzZ0FTZ0NCQ0lBSUFoQkEybzJBZ0FnQUNBTE93RUVJQnBCZ0lBRVR3UkFJQUZCQWpZQ0pDQUJJQUFnQVNnQ0FHdEJBM1UyQWlnTElBQWdHanNCQmlBQklBQkJDR28yQWdRZ0JDQUdhaUVBSUFraEJpQUlJUWtMSUFBZ0Uwc0VRQ0FBSVFNTUFRc2dFaUFEUVFKcUlCRWdCUkFlUVFKMGFpQVpRUUpxTmdJQUlCSWdBRUYrYWlJRElCRWdCUkFlUVFKMGFpQURJQXhyTmdJQUlBa2hCeUFHSVFRRFFBSkFJQVFoQ1NBSElRUWdBQ0FNYXlJR0lBbHJJZ01nRDAwZ0dDQURhMEVEU1hJTkFDQURJQTBnRENBRElCUkpJZ2NiYWlJREtBQUFJQUFvQUFCSERRQWdBRUVFYWlBRFFRUnFJQTRnRlNBT0lBY2JJQllRSUNJSVFRRnFJUWNnQVNnQ0RDRURBa0FnQUNBUVRRUkFJQU1nQUJBY0RBRUxJQU1nQUNBQUlCQVFJZ3NnQVNnQ0JDSURRUUUyQWdBZ0EwRUFPd0VFSUFkQmdJQUVUd1JBSUFGQkFqWUNKQ0FCSUFNZ0FTZ0NBR3RCQTNVMkFpZ0xJQU1nQnpzQkJpQUJJQU5CQ0dvMkFnUWdFaUFBSUJFZ0JSQWVRUUowYWlBR05nSUFJQWtoQnlBRUlRWWdDRUVFYWlBQWFpSUFJUU1nQUNBVFRRMEJEQUlMQ3lBSklRWWdCQ0VKSUFBaEF3c2dBeUFUU1EwQUN5QUFJUU1MSUFJZ0NUWUNBQXdCQ3lBSklBWkJBQ0FHSUFNZ0RDQUVRUUVnQjNRaUIyc2dBQ0FFSUFCcklBZExHeUlVYWlJUUlBTkdhaUlBSUJCcklnUkxJZ2diSUFrZ0JFc2lCQnNoRmtFQUlBa2dCQnNoQjBFQUlBWWdDQnNoQ1NBQVFRRnFJZ1FnRTBrRVFDQVhRUUZxSVJjZ0RrRmdhaUVQQTBBZ0FDQVJJQVVRSGlFR0lBQW9BQUFoQ3lBRUlCRWdCUkFlSVFnZ0JDZ0FBQ0VWSUJJZ0NFRUNkR29pQ2lnQ0FDRUlJQklnQmtFQ2RHb2lEU2dDQUNFR0lBMGdBQ0FNYXlJWU5nSUFJQW9nQkNBTWF6WUNBQUovQWtBZ0IwVWdBRUVDYWlJTklBZHJJZ29vQUFBZ0RTZ0FBRWR5UlFSQUlBb2dBQzBBQVNBS1FYOXFMUUFBUmlJRWF5RUdJQTBnQkdzaEFFRUFJUlVNQVFzQ1FBSkFBa0FnQmlBVVN3UkFJQXNnQmlBTWFpSUdLQUFBUmcwQkN5QUlJQlJORFFFZ0ZTQUlJQXhxSWdZb0FBQkhEUUVnQkNFQUN5QUFJQVpySWdwQkFtb2hGVUVBSVFRZ0JpQVFUU0FBSUFOTmNnMEJBMEFnQUVGL2FpSUlMUUFBSUFaQmYyb2lDeTBBQUVjTkFpQUVRUUZxSVFRZ0NDQURTd1JBSUFnaEFDQUxJZ1lnRUVzTkFRc0xJQWNoQ1NBTElRWWdDaUVISUFnaEFBd0NDeUFFSUJjZ0FDQURhMEVIZG1vaUJtb2hCQ0FBSUFacURBSUxJQWNoQ1NBS0lRY0xJQUFnQkdwQkJHb2dCQ0FHYWtFRWFpQU9FQjBnQkdvaUMwRUJhaUVLSUFBZ0Eyc2hDQ0FCS0FJTUlRUUNRQUpBSUFBZ0QwMEVRQ0FFSUFNUUhDQUJLQUlNSVFZZ0NFRVFUUVJBSUFFZ0JpQUlhaUlHTmdJTURBTUxJQVpCRUdvZ0EwRVFhaUlFRUJ3Z0JrRWdhaUFEUVNCcUVCd2dDRUV4U0EwQklBWWdDR29oR1NBR1FUQnFJUU1EUUNBRElBUkJJR29pQmhBY0lBTkJFR29nQkVFd2FoQWNJQVloQkNBRFFTQnFJZ01nR1VrTkFBc01BUXNnQkNBRElBQWdEeEFpQ3lBQklBRW9BZ3dnQ0dvaUJqWUNEQ0FJUVlDQUJFa05BQ0FCUVFFMkFpUWdBU0FCS0FJRUlBRW9BZ0JyUVFOMU5nSW9DeUFCS0FJRUlnTWdGVUVCYWpZQ0FDQURJQWc3QVFRZ0NrR0FnQVJQQkVBZ0FVRUNOZ0lrSUFFZ0F5QUJLQUlBYTBFRGRUWUNLQXNnQXlBS093RUdJQUVnQTBFSWFqWUNCQ0FMUVFScUlBQnFJZ05CQVdvaEJBSkFJQU1nRTBzTkFDQVNJQTBnRVNBRkVCNUJBblJxSUJoQkFtbzJBZ0FnRWlBRFFYNXFJZ0FnRVNBRkVCNUJBblJxSUFBZ0RHczJBZ0FnQ1VVRVFFRUFJUWtNQVFzZ0F5Z0FBQ0FESUFscktBQUFSdzBBUVFBZ0NXc2hCQU5BSUFraEFDQUhJUWtnQUNFSElBTkJCR29pQUNBQUlBUnFJQTRRSFNFRUlCSWdBeUFSSUFVUUhrRUNkR29nQXlBTWF6WUNBQ0FFUVFGcUlRZ0NRQ0FESUE5TkJFQWdCaUFERUJ3TUFRc2dCaUFESUFNZ0R4QWlDeUFCS0FJRUlnQkJBVFlDQUNBQVFRQTdBUVFnQ0VHQWdBUlBCRUFnQVVFQ05nSWtJQUVnQUNBQktBSUFhMEVEZFRZQ0tBc2dBQ0FJT3dFR0lBRWdBRUVJYWpZQ0JBSkFJQWxGSUFNZ0JHcEJCR29pQXlBVFMzSU5BQ0FES0FBQUlBTWdDV3NvQUFCSERRQkJBQ0FKYXlFRUlBRW9BZ3doQmd3QkN3c2dBMEVCYWlFRUN5QURDeUVBSUFRZ0Uwa05BQXNMSUFJZ0J5QVdJQWNiTmdJQUlBa2dGaUFKR3lFR0N5QUNJQVkyQWdRZ0RpQURhd3NpQUNBQUlBRWdBaUFESUFRZ0FDZ0NoQUVpQUVFRUlBQkJlMnBCQTBrYkVMNERDNDg2QVJ0L0FrQUNRQUpBQWtBQ1FDQUFLQUtFQVVGN2FnNERBd0lCQUFzZ0FpZ0NCQ0VGSUFJb0FnQWhDaUFESUFBb0FuQWlCaWdDQUNJUklBTWdBQ2dDQkNJT0lBQW9BZ3dpRDJvaUVtdHFJQVlvQWdRaUV5QUdLQUlNSWhkcUloeEdhaUlISUFNZ0JHb2lEVUY0YWlJV1NRUkFJQUFvQW9nQklnUWdCRVZxSVJnZ0FDZ0NmQ0VVSUFZb0Fud2hIU0FBS0FJZ0lSVWdCaWdDSUNFZUlCTWdFeUFSYXlBUGFpSVpheUVmSUExQllHb2hEQ0FQUVg5cUlSb0RRQ0FWSUFjZ0ZFRUVFQjVCQW5ScUlnQW9BZ0FoQ3lBQUlBY2dEbXNpR3pZQ0FBSkFBa0FDUUNBYUlBZEJBV29pQUNBS0lBNXFheUlFYTBFRFNRMEFJQk1nQkNBWmEyb2dBQ0FLYXlBRUlBOUpJZ1FiSWdZb0FBQWdBQ2dBQUVjTkFDQUhRUVZxSUFaQkJHb2dEU0FSSUEwZ0JCc2dFaEFnSWdsQkFXb2hDeUFBSUFOcklRZ2dBU2dDRENFRUFrQUNRQ0FBSUF4TkJFQWdCQ0FERUJ3Z0FTZ0NEQ0VHSUFoQkVFMEVRQ0FCSUFZZ0NHbzJBZ3dNQXdzZ0JrRVFhaUFEUVJCcUlnUVFIQ0FHUVNCcUlBTkJJR29RSENBSVFURklEUUVnQmlBSWFpRVFJQVpCTUdvaEF3TkFJQU1nQkVFZ2FpSUdFQndnQTBFUWFpQUVRVEJxRUJ3Z0JpRUVJQU5CSUdvaUF5QVFTUTBBQ3d3QkN5QUVJQU1nQUNBTUVDSUxJQUVnQVNnQ0RDQUlhallDRENBSVFZQ0FCRWtOQUNBQlFRRTJBaVFnQVNBQktBSUVJQUVvQWdCclFRTjFOZ0lvQ3lBSlFRUnFJUVFnQVNnQ0JDSURRUUUyQWdBZ0F5QUlPd0VFSUF0QmdJQUVTUTBCSUFGQkFqWUNKQ0FCSUFNZ0FTZ0NBR3RCQTNVMkFpZ01BUXNDUUNBTElBOU5CRUFDUUNBZUlBY2dIVUVFRUI1QkFuUnFLQUlBSWdnZ0YwME5BQ0FJSUJOcUlnWW9BQUFnQnlnQUFFY05BQ0FIUVFScUlBWkJCR29nRFNBUklCSVFJRUVFYWlFRUlCc2dDR3NoQ3dKQUlBY2dBMDBFUUNBSElRQU1BUXNnQnlFRklBY2hBQ0FJSUJkTURRQURRQ0FGUVg5cUlnQXRBQUFnQmtGL2FpSUdMUUFBUndSQUlBVWhBQXdDQ3lBRVFRRnFJUVFnQUNBRFRRMEJJQUFoQlNBR0lCeExEUUFMQ3lBTElCbHJJUVlnQkVGOWFpRUxJQUFnQTJzaENTQUJLQUlNSVFVQ1FBSkFJQUFnREUwRVFDQUZJQU1RSENBQktBSU1JUWdnQ1VFUVRRUkFJQUVnQ0NBSmFqWUNEQXdEQ3lBSVFSQnFJQU5CRUdvaUJSQWNJQWhCSUdvZ0EwRWdhaEFjSUFsQk1VZ05BU0FJSUFscUlSQWdDRUV3YWlFREEwQWdBeUFGUVNCcUlnZ1FIQ0FEUVJCcUlBVkJNR29RSENBSUlRVWdBMEVnYWlJRElCQkpEUUFMREFFTElBVWdBeUFBSUF3UUlnc2dBU0FCS0FJTUlBbHFOZ0lNSUFsQmdJQUVTUTBBSUFGQkFUWUNKQ0FCSUFFb0FnUWdBU2dDQUd0QkEzVTJBaWdMSUFFb0FnUWlBeUFHUVFOcU5nSUFJQU1nQ1RzQkJDQUxRWUNBQkVrTkFpQUJRUUkyQWlRZ0FTQURJQUVvQWdCclFRTjFOZ0lvREFJTElBY2dCeUFEYTBFSWRTQVlhbW9oQnd3REN5QUxJQTVxSWdnb0FBQWdCeWdBQUVjRVFDQUhJQWNnQTJ0QkNIVWdHR3BxSVFjTUF3c2dCMEVFYWlBSVFRUnFJQTBRSFVFRWFpRUVBa0FnQnlBRFRRUkFJQWNoQUF3QkN5QUhJUVlnQ0NFRklBY2hBQ0FMSUE5TURRQURRQ0FHUVg5cUlnQXRBQUFnQlVGL2FpSUZMUUFBUndSQUlBWWhBQXdDQ3lBRVFRRnFJUVFnQUNBRFRRMEJJQUFoQmlBRklCSkxEUUFMQ3lBSElBaHJJUVlnQkVGOWFpRUxJQUFnQTJzaENTQUJLQUlNSVFVQ1FBSkFJQUFnREUwRVFDQUZJQU1RSENBQktBSU1JUWdnQ1VFUVRRUkFJQUVnQ0NBSmFqWUNEQXdEQ3lBSVFSQnFJQU5CRUdvaUJSQWNJQWhCSUdvZ0EwRWdhaEFjSUFsQk1VZ05BU0FJSUFscUlSQWdDRUV3YWlFREEwQWdBeUFGUVNCcUlnZ1FIQ0FEUVJCcUlBVkJNR29RSENBSUlRVWdBMEVnYWlJRElCQkpEUUFMREFFTElBVWdBeUFBSUF3UUlnc2dBU0FCS0FJTUlBbHFOZ0lNSUFsQmdJQUVTUTBBSUFGQkFUWUNKQ0FCSUFFb0FnUWdBU2dDQUd0QkEzVTJBaWdMSUFFb0FnUWlBeUFHUVFOcU5nSUFJQU1nQ1RzQkJDQUxRWUNBQkU4RVFDQUJRUUkyQWlRZ0FTQURJQUVvQWdCclFRTjFOZ0lvQ3lBS0lRVWdCaUVLREFFTElBb2hCU0FHSVFvTElBTWdDenNCQmlBQklBTkJDR28yQWdRZ0FDQUVhaUlESUJaTEJFQWdBeUVIREFFTElCVWdCMEVDYWlBVVFRUVFIa0VDZEdvZ0cwRUNhallDQUNBVklBTkJmbW9pQUNBVVFRUVFIa0VDZEdvZ0FDQU9hellDQUNBS0lRUWdCU0VBQTBBQ1FDQUFJUW9nQkNFQUlCb2dBeUFPYXlJSElBcHJJZ1JyUVFOSkRRQWdCQ0FmSUE0Z0JDQVBTU0lGRzJvaUJDZ0FBQ0FES0FBQVJ3MEFJQU5CQkdvZ0JFRUVhaUFOSUJFZ0RTQUZHeUFTRUNBaUJrRUJhaUVGSUFFb0Fnd2hCQUpBSUFNZ0RFMEVRQ0FFSUFNUUhBd0JDeUFFSUFNZ0F5QU1FQ0lMSUFFb0FnUWlCRUVCTmdJQUlBUkJBRHNCQkNBRlFZQ0FCRThFUUNBQlFRSTJBaVFnQVNBRUlBRW9BZ0JyUVFOMU5nSW9DeUFFSUFVN0FRWWdBU0FFUVFocU5nSUVJQlVnQXlBVVFRUVFIa0VDZEdvZ0J6WUNBQ0FLSVFRZ0FDRUZJQVpCQkdvZ0Eyb2lBeUVISUFNZ0ZrME5BUXdDQ3dzZ0NpRUZJQUFoQ2lBRElRY0xJQWNnRmtrTkFBc0xEQU1MSUFJb0FnUWhCU0FDS0FJQUlRb2dBeUFBS0FKd0lnWW9BZ0FpRVNBRElBQW9BZ1FpRGlBQUtBSU1JZzlxSWhKcmFpQUdLQUlFSWhNZ0JpZ0NEQ0lYYWlJY1Jtb2lCeUFESUFScUlnMUJlR29pRmtrRVFDQUFLQUtJQVNJRUlBUkZhaUVZSUFBb0Fud2hGQ0FHS0FKOElSMGdBQ2dDSUNFVklBWW9BaUFoSGlBVElCTWdFV3NnRDJvaUdXc2hIeUFOUVdCcUlRd2dEMEYvYWlFYUEwQWdGU0FISUJSQkJ4QWVRUUowYWlJQUtBSUFJUXNnQUNBSElBNXJJaHMyQWdBQ1FBSkFBa0FnR2lBSFFRRnFJZ0FnQ2lBT2Ftc2lCR3RCQTBrTkFDQVRJQVFnR1d0cUlBQWdDbXNnQkNBUFNTSUVHeUlHS0FBQUlBQW9BQUJIRFFBZ0IwRUZhaUFHUVFScUlBMGdFU0FOSUFRYklCSVFJQ0lKUVFGcUlRc2dBQ0FEYXlFSUlBRW9BZ3doQkFKQUFrQWdBQ0FNVFFSQUlBUWdBeEFjSUFFb0Fnd2hCaUFJUVJCTkJFQWdBU0FHSUFocU5nSU1EQU1MSUFaQkVHb2dBMEVRYWlJRUVCd2dCa0VnYWlBRFFTQnFFQndnQ0VFeFNBMEJJQVlnQ0dvaEVDQUdRVEJxSVFNRFFDQURJQVJCSUdvaUJoQWNJQU5CRUdvZ0JFRXdhaEFjSUFZaEJDQURRU0JxSWdNZ0VFa05BQXNNQVFzZ0JDQURJQUFnREJBaUN5QUJJQUVvQWd3Z0NHbzJBZ3dnQ0VHQWdBUkpEUUFnQVVFQk5nSWtJQUVnQVNnQ0JDQUJLQUlBYTBFRGRUWUNLQXNnQ1VFRWFpRUVJQUVvQWdRaUEwRUJOZ0lBSUFNZ0NEc0JCQ0FMUVlDQUJFa05BU0FCUVFJMkFpUWdBU0FESUFFb0FnQnJRUU4xTmdJb0RBRUxBa0FnQ3lBUFRRUkFBa0FnSGlBSElCMUJCeEFlUVFKMGFpZ0NBQ0lJSUJkTkRRQWdDQ0FUYWlJR0tBQUFJQWNvQUFCSERRQWdCMEVFYWlBR1FRUnFJQTBnRVNBU0VDQkJCR29oQkNBYklBaHJJUXNDUUNBSElBTk5CRUFnQnlFQURBRUxJQWNoQlNBSElRQWdDQ0FYVEEwQUEwQWdCVUYvYWlJQUxRQUFJQVpCZjJvaUJpMEFBRWNFUUNBRklRQU1BZ3NnQkVFQmFpRUVJQUFnQTAwTkFTQUFJUVVnQmlBY1N3MEFDd3NnQ3lBWmF5RUdJQVJCZldvaEN5QUFJQU5ySVFrZ0FTZ0NEQ0VGQWtBQ1FDQUFJQXhOQkVBZ0JTQURFQndnQVNnQ0RDRUlJQWxCRUUwRVFDQUJJQWdnQ1dvMkFnd01Bd3NnQ0VFUWFpQURRUkJxSWdVUUhDQUlRU0JxSUFOQklHb1FIQ0FKUVRGSURRRWdDQ0FKYWlFUUlBaEJNR29oQXdOQUlBTWdCVUVnYWlJSUVCd2dBMEVRYWlBRlFUQnFFQndnQ0NFRklBTkJJR29pQXlBUVNRMEFDd3dCQ3lBRklBTWdBQ0FNRUNJTElBRWdBU2dDRENBSmFqWUNEQ0FKUVlDQUJFa05BQ0FCUVFFMkFpUWdBU0FCS0FJRUlBRW9BZ0JyUVFOMU5nSW9DeUFCS0FJRUlnTWdCa0VEYWpZQ0FDQURJQWs3QVFRZ0MwR0FnQVJKRFFJZ0FVRUNOZ0lrSUFFZ0F5QUJLQUlBYTBFRGRUWUNLQXdDQ3lBSElBY2dBMnRCQ0hVZ0dHcHFJUWNNQXdzZ0N5QU9haUlJS0FBQUlBY29BQUJIQkVBZ0J5QUhJQU5yUVFoMUlCaHFhaUVIREFNTElBZEJCR29nQ0VFRWFpQU5FQjFCQkdvaEJBSkFJQWNnQTAwRVFDQUhJUUFNQVFzZ0J5RUdJQWdoQlNBSElRQWdDeUFQVEEwQUEwQWdCa0YvYWlJQUxRQUFJQVZCZjJvaUJTMEFBRWNFUUNBR0lRQU1BZ3NnQkVFQmFpRUVJQUFnQTAwTkFTQUFJUVlnQlNBU1N3MEFDd3NnQnlBSWF5RUdJQVJCZldvaEN5QUFJQU5ySVFrZ0FTZ0NEQ0VGQWtBQ1FDQUFJQXhOQkVBZ0JTQURFQndnQVNnQ0RDRUlJQWxCRUUwRVFDQUJJQWdnQ1dvMkFnd01Bd3NnQ0VFUWFpQURRUkJxSWdVUUhDQUlRU0JxSUFOQklHb1FIQ0FKUVRGSURRRWdDQ0FKYWlFUUlBaEJNR29oQXdOQUlBTWdCVUVnYWlJSUVCd2dBMEVRYWlBRlFUQnFFQndnQ0NFRklBTkJJR29pQXlBUVNRMEFDd3dCQ3lBRklBTWdBQ0FNRUNJTElBRWdBU2dDRENBSmFqWUNEQ0FKUVlDQUJFa05BQ0FCUVFFMkFpUWdBU0FCS0FJRUlBRW9BZ0JyUVFOMU5nSW9DeUFCS0FJRUlnTWdCa0VEYWpZQ0FDQURJQWs3QVFRZ0MwR0FnQVJQQkVBZ0FVRUNOZ0lrSUFFZ0F5QUJLQUlBYTBFRGRUWUNLQXNnQ2lFRklBWWhDZ3dCQ3lBS0lRVWdCaUVLQ3lBRElBczdBUVlnQVNBRFFRaHFOZ0lFSUFBZ0JHb2lBeUFXU3dSQUlBTWhCd3dCQ3lBVklBZEJBbW9nRkVFSEVCNUJBblJxSUJ0QkFtbzJBZ0FnRlNBRFFYNXFJZ0FnRkVFSEVCNUJBblJxSUFBZ0RtczJBZ0FnQ2lFRUlBVWhBQU5BQWtBZ0FDRUtJQVFoQUNBYUlBTWdEbXNpQnlBS2F5SUVhMEVEU1EwQUlBUWdIeUFPSUFRZ0Qwa2lCUnRxSWdRb0FBQWdBeWdBQUVjTkFDQURRUVJxSUFSQkJHb2dEU0FSSUEwZ0JSc2dFaEFnSWdaQkFXb2hCU0FCS0FJTUlRUUNRQ0FESUF4TkJFQWdCQ0FERUJ3TUFRc2dCQ0FESUFNZ0RCQWlDeUFCS0FJRUlnUkJBVFlDQUNBRVFRQTdBUVFnQlVHQWdBUlBCRUFnQVVFQ05nSWtJQUVnQkNBQktBSUFhMEVEZFRZQ0tBc2dCQ0FGT3dFR0lBRWdCRUVJYWpZQ0JDQVZJQU1nRkVFSEVCNUJBblJxSUFjMkFnQWdDaUVFSUFBaEJTQUdRUVJxSUFOcUlnTWhCeUFESUJaTkRRRU1BZ3NMSUFvaEJTQUFJUW9nQXlFSEN5QUhJQlpKRFFBTEN3d0NDeUFDS0FJRUlRVWdBaWdDQUNFS0lBTWdBQ2dDY0NJR0tBSUFJaEVnQXlBQUtBSUVJZzRnQUNnQ0RDSVBhaUlTYTJvZ0JpZ0NCQ0lUSUFZb0Fnd2lGMm9pSEVacUlnY2dBeUFFYWlJTlFYaHFJaFpKQkVBZ0FDZ0NpQUVpQkNBRVJXb2hHQ0FBS0FKOElSUWdCaWdDZkNFZElBQW9BaUFoRlNBR0tBSWdJUjRnRXlBVElCRnJJQTlxSWhscklSOGdEVUZnYWlFTUlBOUJmMm9oR2dOQUlCVWdCeUFVUVFZUUhrRUNkR29pQUNnQ0FDRUxJQUFnQnlBT2F5SWJOZ0lBQWtBQ1FBSkFJQm9nQjBFQmFpSUFJQW9nRG1wcklnUnJRUU5KRFFBZ0V5QUVJQmxyYWlBQUlBcHJJQVFnRDBraUJCc2lCaWdBQUNBQUtBQUFSdzBBSUFkQkJXb2dCa0VFYWlBTklCRWdEU0FFR3lBU0VDQWlDVUVCYWlFTElBQWdBMnNoQ0NBQktBSU1JUVFDUUFKQUlBQWdERTBFUUNBRUlBTVFIQ0FCS0FJTUlRWWdDRUVRVFFSQUlBRWdCaUFJYWpZQ0RBd0RDeUFHUVJCcUlBTkJFR29pQkJBY0lBWkJJR29nQTBFZ2FoQWNJQWhCTVVnTkFTQUdJQWhxSVJBZ0JrRXdhaUVEQTBBZ0F5QUVRU0JxSWdZUUhDQURRUkJxSUFSQk1Hb1FIQ0FHSVFRZ0EwRWdhaUlESUJCSkRRQUxEQUVMSUFRZ0F5QUFJQXdRSWdzZ0FTQUJLQUlNSUFocU5nSU1JQWhCZ0lBRVNRMEFJQUZCQVRZQ0pDQUJJQUVvQWdRZ0FTZ0NBR3RCQTNVMkFpZ0xJQWxCQkdvaEJDQUJLQUlFSWdOQkFUWUNBQ0FESUFnN0FRUWdDMEdBZ0FSSkRRRWdBVUVDTmdJa0lBRWdBeUFCS0FJQWEwRURkVFlDS0F3QkN3SkFJQXNnRDAwRVFBSkFJQjRnQnlBZFFRWVFIa0VDZEdvb0FnQWlDQ0FYVFEwQUlBZ2dFMm9pQmlnQUFDQUhLQUFBUncwQUlBZEJCR29nQmtFRWFpQU5JQkVnRWhBZ1FRUnFJUVFnR3lBSWF5RUxBa0FnQnlBRFRRUkFJQWNoQUF3QkN5QUhJUVVnQnlFQUlBZ2dGMHdOQUFOQUlBVkJmMm9pQUMwQUFDQUdRWDlxSWdZdEFBQkhCRUFnQlNFQURBSUxJQVJCQVdvaEJDQUFJQU5ORFFFZ0FDRUZJQVlnSEVzTkFBc0xJQXNnR1dzaEJpQUVRWDFxSVFzZ0FDQURheUVKSUFFb0Fnd2hCUUpBQWtBZ0FDQU1UUVJBSUFVZ0F4QWNJQUVvQWd3aENDQUpRUkJOQkVBZ0FTQUlJQWxxTmdJTURBTUxJQWhCRUdvZ0EwRVFhaUlGRUJ3Z0NFRWdhaUFEUVNCcUVCd2dDVUV4U0EwQklBZ2dDV29oRUNBSVFUQnFJUU1EUUNBRElBVkJJR29pQ0JBY0lBTkJFR29nQlVFd2FoQWNJQWdoQlNBRFFTQnFJZ01nRUVrTkFBc01BUXNnQlNBRElBQWdEQkFpQ3lBQklBRW9BZ3dnQ1dvMkFnd2dDVUdBZ0FSSkRRQWdBVUVCTmdJa0lBRWdBU2dDQkNBQktBSUFhMEVEZFRZQ0tBc2dBU2dDQkNJRElBWkJBMm8yQWdBZ0F5QUpPd0VFSUF0QmdJQUVTUTBDSUFGQkFqWUNKQ0FCSUFNZ0FTZ0NBR3RCQTNVMkFpZ01BZ3NnQnlBSElBTnJRUWgxSUJocWFpRUhEQU1MSUFzZ0Rtb2lDQ2dBQUNBSEtBQUFSd1JBSUFjZ0J5QURhMEVJZFNBWWFtb2hCd3dEQ3lBSFFRUnFJQWhCQkdvZ0RSQWRRUVJxSVFRQ1FDQUhJQU5OQkVBZ0J5RUFEQUVMSUFjaEJpQUlJUVVnQnlFQUlBc2dEMHdOQUFOQUlBWkJmMm9pQUMwQUFDQUZRWDlxSWdVdEFBQkhCRUFnQmlFQURBSUxJQVJCQVdvaEJDQUFJQU5ORFFFZ0FDRUdJQVVnRWtzTkFBc0xJQWNnQ0dzaEJpQUVRWDFxSVFzZ0FDQURheUVKSUFFb0Fnd2hCUUpBQWtBZ0FDQU1UUVJBSUFVZ0F4QWNJQUVvQWd3aENDQUpRUkJOQkVBZ0FTQUlJQWxxTmdJTURBTUxJQWhCRUdvZ0EwRVFhaUlGRUJ3Z0NFRWdhaUFEUVNCcUVCd2dDVUV4U0EwQklBZ2dDV29oRUNBSVFUQnFJUU1EUUNBRElBVkJJR29pQ0JBY0lBTkJFR29nQlVFd2FoQWNJQWdoQlNBRFFTQnFJZ01nRUVrTkFBc01BUXNnQlNBRElBQWdEQkFpQ3lBQklBRW9BZ3dnQ1dvMkFnd2dDVUdBZ0FSSkRRQWdBVUVCTmdJa0lBRWdBU2dDQkNBQktBSUFhMEVEZFRZQ0tBc2dBU2dDQkNJRElBWkJBMm8yQWdBZ0F5QUpPd0VFSUF0QmdJQUVUd1JBSUFGQkFqWUNKQ0FCSUFNZ0FTZ0NBR3RCQTNVMkFpZ0xJQW9oQlNBR0lRb01BUXNnQ2lFRklBWWhDZ3NnQXlBTE93RUdJQUVnQTBFSWFqWUNCQ0FBSUFScUlnTWdGa3NFUUNBRElRY01BUXNnRlNBSFFRSnFJQlJCQmhBZVFRSjBhaUFiUVFKcU5nSUFJQlVnQTBGK2FpSUFJQlJCQmhBZVFRSjBhaUFBSUE1ck5nSUFJQW9oQkNBRklRQURRQUpBSUFBaENpQUVJUUFnR2lBRElBNXJJZ2NnQ21zaUJHdEJBMGtOQUNBRUlCOGdEaUFFSUE5SklnVWJhaUlFS0FBQUlBTW9BQUJIRFFBZ0EwRUVhaUFFUVFScUlBMGdFU0FOSUFVYklCSVFJQ0lHUVFGcUlRVWdBU2dDRENFRUFrQWdBeUFNVFFSQUlBUWdBeEFjREFFTElBUWdBeUFESUF3UUlnc2dBU2dDQkNJRVFRRTJBZ0FnQkVFQU93RUVJQVZCZ0lBRVR3UkFJQUZCQWpZQ0pDQUJJQVFnQVNnQ0FHdEJBM1UyQWlnTElBUWdCVHNCQmlBQklBUkJDR28yQWdRZ0ZTQURJQlJCQmhBZVFRSjBhaUFITmdJQUlBb2hCQ0FBSVFVZ0JrRUVhaUFEYWlJRElRY2dBeUFXVFEwQkRBSUxDeUFLSVFVZ0FDRUtJQU1oQndzZ0J5QVdTUTBBQ3dzTUFRc2dBaWdDQkNFRklBSW9BZ0FoQ2lBRElBQW9BbkFpQmlnQ0FDSVJJQU1nQUNnQ0JDSU9JQUFvQWd3aUQyb2lFbXRxSUFZb0FnUWlFeUFHS0FJTUloZHFJaHhHYWlJSElBTWdCR29pRFVGNGFpSVdTUVJBSUFBb0FvZ0JJZ1FnQkVWcUlSZ2dBQ2dDZkNFVUlBWW9BbndoSFNBQUtBSWdJUlVnQmlnQ0lDRWVJQk1nRXlBUmF5QVBhaUlaYXlFZklBMUJZR29oRENBUFFYOXFJUm9EUUNBVklBY2dGRUVGRUI1QkFuUnFJZ0FvQWdBaEN5QUFJQWNnRG1zaUd6WUNBQUpBQWtBQ1FDQWFJQWRCQVdvaUFDQUtJQTVxYXlJRWEwRURTUTBBSUJNZ0JDQVphMm9nQUNBS2F5QUVJQTlKSWdRYklnWW9BQUFnQUNnQUFFY05BQ0FIUVFWcUlBWkJCR29nRFNBUklBMGdCQnNnRWhBZ0lnbEJBV29oQ3lBQUlBTnJJUWdnQVNnQ0RDRUVBa0FDUUNBQUlBeE5CRUFnQkNBREVCd2dBU2dDRENFR0lBaEJFRTBFUUNBQklBWWdDR28yQWd3TUF3c2dCa0VRYWlBRFFSQnFJZ1FRSENBR1FTQnFJQU5CSUdvUUhDQUlRVEZJRFFFZ0JpQUlhaUVRSUFaQk1Hb2hBd05BSUFNZ0JFRWdhaUlHRUJ3Z0EwRVFhaUFFUVRCcUVCd2dCaUVFSUFOQklHb2lBeUFRU1EwQUN3d0JDeUFFSUFNZ0FDQU1FQ0lMSUFFZ0FTZ0NEQ0FJYWpZQ0RDQUlRWUNBQkVrTkFDQUJRUUUyQWlRZ0FTQUJLQUlFSUFFb0FnQnJRUU4xTmdJb0N5QUpRUVJxSVFRZ0FTZ0NCQ0lEUVFFMkFnQWdBeUFJT3dFRUlBdEJnSUFFU1EwQklBRkJBallDSkNBQklBTWdBU2dDQUd0QkEzVTJBaWdNQVFzQ1FDQUxJQTlOQkVBQ1FDQWVJQWNnSFVFRkVCNUJBblJxS0FJQUlnZ2dGMDBOQUNBSUlCTnFJZ1lvQUFBZ0J5Z0FBRWNOQUNBSFFRUnFJQVpCQkdvZ0RTQVJJQklRSUVFRWFpRUVJQnNnQ0dzaEN3SkFJQWNnQTAwRVFDQUhJUUFNQVFzZ0J5RUZJQWNoQUNBSUlCZE1EUUFEUUNBRlFYOXFJZ0F0QUFBZ0JrRi9haUlHTFFBQVJ3UkFJQVVoQUF3Q0N5QUVRUUZxSVFRZ0FDQURUUTBCSUFBaEJTQUdJQnhMRFFBTEN5QUxJQmxySVFZZ0JFRjlhaUVMSUFBZ0Eyc2hDU0FCS0FJTUlRVUNRQUpBSUFBZ0RFMEVRQ0FGSUFNUUhDQUJLQUlNSVFnZ0NVRVFUUVJBSUFFZ0NDQUphallDREF3REN5QUlRUkJxSUFOQkVHb2lCUkFjSUFoQklHb2dBMEVnYWhBY0lBbEJNVWdOQVNBSUlBbHFJUkFnQ0VFd2FpRURBMEFnQXlBRlFTQnFJZ2dRSENBRFFSQnFJQVZCTUdvUUhDQUlJUVVnQTBFZ2FpSURJQkJKRFFBTERBRUxJQVVnQXlBQUlBd1FJZ3NnQVNBQktBSU1JQWxxTmdJTUlBbEJnSUFFU1EwQUlBRkJBVFlDSkNBQklBRW9BZ1FnQVNnQ0FHdEJBM1UyQWlnTElBRW9BZ1FpQXlBR1FRTnFOZ0lBSUFNZ0NUc0JCQ0FMUVlDQUJFa05BaUFCUVFJMkFpUWdBU0FESUFFb0FnQnJRUU4xTmdJb0RBSUxJQWNnQnlBRGEwRUlkU0FZYW1vaEJ3d0RDeUFMSUE1cUlnZ29BQUFnQnlnQUFFY0VRQ0FISUFjZ0EydEJDSFVnR0dwcUlRY01Bd3NnQjBFRWFpQUlRUVJxSUEwUUhVRUVhaUVFQWtBZ0J5QURUUVJBSUFjaEFBd0JDeUFISVFZZ0NDRUZJQWNoQUNBTElBOU1EUUFEUUNBR1FYOXFJZ0F0QUFBZ0JVRi9haUlGTFFBQVJ3UkFJQVloQUF3Q0N5QUVRUUZxSVFRZ0FDQURUUTBCSUFBaEJpQUZJQkpMRFFBTEN5QUhJQWhySVFZZ0JFRjlhaUVMSUFBZ0Eyc2hDU0FCS0FJTUlRVUNRQUpBSUFBZ0RFMEVRQ0FGSUFNUUhDQUJLQUlNSVFnZ0NVRVFUUVJBSUFFZ0NDQUphallDREF3REN5QUlRUkJxSUFOQkVHb2lCUkFjSUFoQklHb2dBMEVnYWhBY0lBbEJNVWdOQVNBSUlBbHFJUkFnQ0VFd2FpRURBMEFnQXlBRlFTQnFJZ2dRSENBRFFSQnFJQVZCTUdvUUhDQUlJUVVnQTBFZ2FpSURJQkJKRFFBTERBRUxJQVVnQXlBQUlBd1FJZ3NnQVNBQktBSU1JQWxxTmdJTUlBbEJnSUFFU1EwQUlBRkJBVFlDSkNBQklBRW9BZ1FnQVNnQ0FHdEJBM1UyQWlnTElBRW9BZ1FpQXlBR1FRTnFOZ0lBSUFNZ0NUc0JCQ0FMUVlDQUJFOEVRQ0FCUVFJMkFpUWdBU0FESUFFb0FnQnJRUU4xTmdJb0N5QUtJUVVnQmlFS0RBRUxJQW9oQlNBR0lRb0xJQU1nQ3pzQkJpQUJJQU5CQ0dvMkFnUWdBQ0FFYWlJRElCWkxCRUFnQXlFSERBRUxJQlVnQjBFQ2FpQVVRUVVRSGtFQ2RHb2dHMEVDYWpZQ0FDQVZJQU5CZm1vaUFDQVVRUVVRSGtFQ2RHb2dBQ0FPYXpZQ0FDQUtJUVFnQlNFQUEwQUNRQ0FBSVFvZ0JDRUFJQm9nQXlBT2F5SUhJQXBySWdSclFRTkpEUUFnQkNBZklBNGdCQ0FQU1NJRkcyb2lCQ2dBQUNBREtBQUFSdzBBSUFOQkJHb2dCRUVFYWlBTklCRWdEU0FGR3lBU0VDQWlCa0VCYWlFRklBRW9BZ3doQkFKQUlBTWdERTBFUUNBRUlBTVFIQXdCQ3lBRUlBTWdBeUFNRUNJTElBRW9BZ1FpQkVFQk5nSUFJQVJCQURzQkJDQUZRWUNBQkU4RVFDQUJRUUkyQWlRZ0FTQUVJQUVvQWdCclFRTjFOZ0lvQ3lBRUlBVTdBUVlnQVNBRVFRaHFOZ0lFSUJVZ0F5QVVRUVVRSGtFQ2RHb2dCellDQUNBS0lRUWdBQ0VGSUFaQkJHb2dBMm9pQXlFSElBTWdGazBOQVF3Q0N3c2dDaUVGSUFBaENpQURJUWNMSUFjZ0Zra05BQXNMSUFJZ0JUWUNCQ0FDSUFvMkFnQWdEU0FEYXc4TElBSWdCVFlDQkNBQ0lBbzJBZ0FnRFNBRGF3dUtKZ0VVZndKL0FrQUNRQUpBQWtBZ0FDZ0NoQUZCZTJvT0F3TUNBUUFMSUFJb0FnQWlDU0FDS0FJRUlnaEJBQ0FJSUFNZ0FDZ0NCQ0lMSUFNZ0Myc2dCR29pQlVFQklBQW9BblIwSWdacklBQW9BZ3dpQnlBRklBZHJJQVpMR3lJVWFpSVNJQU5HYWlJRklCSnJJZ1pMSWdjYklBa2dCa3NpQmhzaEZVRUFJQWtnQmhzaENVRUFJQWdnQnhzaENDQUZRUUZxSWdZZ0F5QUVhaUlFUVhocUloTkpCRUFnQUNnQ2ZDRU5JQUFvQWlBaERpQUVRV0JxSVJBZ0FDZ0NpQUVpQUNBQVJXcEJBV29oRmdOQUlBVWdEVUVFRUI0aEFDQUZLQUFBSVF3Z0JpQU5RUVFRSGlFSElBWW9BQUFoRVNBT0lBZEJBblJxSWdvb0FnQWhCeUFPSUFCQkFuUnFJZzhvQWdBaEFDQVBJQVVnQzJzaUZ6WUNBQ0FLSUFZZ0MyczJBZ0FDZndKQUlBbEZJQVZCQW1vaUR5QUpheUlLS0FBQUlBOG9BQUJIY2tVRVFDQUtJQVV0QUFFZ0NrRi9haTBBQUVZaUJtc2hBQ0FQSUFacklRVkJBQ0VSREFFTEFrQUNRQUpBSUFBZ0ZFc0VRQ0FNSUFBZ0Myb2lBQ2dBQUVZTkFRc2dCeUFVVFEwQklCRWdCeUFMYWlJQUtBQUFSdzBCSUFZaEJRc2dCU0FBYXlJS1FRSnFJUkZCQUNFR0lBQWdFazBnQlNBRFRYSU5BUU5BSUFWQmYyb2lCeTBBQUNBQVFYOXFJZ3d0QUFCSERRSWdCa0VCYWlFR0lBY2dBMHNFUUNBSElRVWdEQ0lBSUJKTERRRUxDeUFKSVFnZ0RDRUFJQW9oQ1NBSElRVU1BZ3NnQmlBV0lBVWdBMnRCQjNacUlnQnFJUVlnQUNBRmFnd0NDeUFKSVFnZ0NpRUpDeUFGSUFacVFRUnFJQUFnQm1wQkJHb2dCQkFkSUFacUlneEJBV29oQ2lBRklBTnJJUWNnQVNnQ0RDRUFBa0FDUUNBRklCQk5CRUFnQUNBREVCd2dBU2dDRENFQUlBZEJFRTBFUUNBQklBQWdCMm9pQURZQ0RBd0RDeUFBUVJCcUlBTkJFR29pQmhBY0lBQkJJR29nQTBFZ2FoQWNJQWRCTVVnTkFTQUFJQWRxSVJnZ0FFRXdhaUVEQTBBZ0F5QUdRU0JxSWdBUUhDQURRUkJxSUFaQk1Hb1FIQ0FBSVFZZ0EwRWdhaUlESUJoSkRRQUxEQUVMSUFBZ0F5QUZJQkFRSWdzZ0FTQUJLQUlNSUFkcUlnQTJBZ3dnQjBHQWdBUkpEUUFnQVVFQk5nSWtJQUVnQVNnQ0JDQUJLQUlBYTBFRGRUWUNLQXNnQVNnQ0JDSURJQkZCQVdvMkFnQWdBeUFIT3dFRUlBcEJnSUFFVHdSQUlBRkJBallDSkNBQklBTWdBU2dDQUd0QkEzVTJBaWdMSUFNZ0Nqc0JCaUFCSUFOQkNHbzJBZ1FnREVFRWFpQUZhaUlEUVFGcUlRWUNRQ0FESUJOTERRQWdEaUFQSUExQkJCQWVRUUowYWlBWFFRSnFOZ0lBSUE0Z0EwRithaUlGSUExQkJCQWVRUUowYWlBRklBdHJOZ0lBSUFoRkJFQkJBQ0VJREFFTElBTW9BQUFnQXlBSWF5Z0FBRWNOQUVFQUlBaHJJUVlEUUNBSUlRVWdDU0VJSUFVaENTQURRUVJxSWdVZ0JTQUdhaUFFRUIwaEJTQU9JQU1nRFVFRUVCNUJBblJxSUFNZ0MyczJBZ0FnQlVFQmFpRUdBa0FnQXlBUVRRUkFJQUFnQXhBY0RBRUxJQUFnQXlBRElCQVFJZ3NnQVNnQ0JDSUFRUUUyQWdBZ0FFRUFPd0VFSUFaQmdJQUVUd1JBSUFGQkFqWUNKQ0FCSUFBZ0FTZ0NBR3RCQTNVMkFpZ0xJQUFnQmpzQkJpQUJJQUJCQ0dvMkFnUUNRQ0FJUlNBRElBVnFRUVJxSWdNZ0UwdHlEUUFnQXlnQUFDQURJQWhyS0FBQVJ3MEFRUUFnQ0dzaEJpQUJLQUlNSVFBTUFRc0xJQU5CQVdvaEJnc2dBd3NoQlNBR0lCTkpEUUFMQ3lBQ0lBa2dGU0FKR3pZQ0FDQUlJQlVnQ0JzaEJTQUNRUVJxREFNTElBSW9BZ0FpQ1NBQ0tBSUVJZ2hCQUNBSUlBTWdBQ2dDQkNJTElBTWdDMnNnQkdvaUJVRUJJQUFvQW5SMElnWnJJQUFvQWd3aUJ5QUZJQWRySUFaTEd5SVVhaUlTSUFOR2FpSUZJQkpySWdaTElnY2JJQWtnQmtzaUJoc2hGVUVBSUFrZ0Joc2hDVUVBSUFnZ0J4c2hDQ0FGUVFGcUlnWWdBeUFFYWlJRVFYaHFJaE5KQkVBZ0FDZ0NmQ0VOSUFBb0FpQWhEaUFFUVdCcUlSQWdBQ2dDaUFFaUFDQUFSV3BCQVdvaEZnTkFJQVVnRFVFSEVCNGhBQ0FGS0FBQUlRd2dCaUFOUVFjUUhpRUhJQVlvQUFBaEVTQU9JQWRCQW5ScUlnb29BZ0FoQnlBT0lBQkJBblJxSWc4b0FnQWhBQ0FQSUFVZ0Myc2lGellDQUNBS0lBWWdDMnMyQWdBQ2Z3SkFJQWxGSUFWQkFtb2lEeUFKYXlJS0tBQUFJQThvQUFCSGNrVUVRQ0FLSUFVdEFBRWdDa0YvYWkwQUFFWWlCbXNoQUNBUElBWnJJUVZCQUNFUkRBRUxBa0FDUUFKQUlBQWdGRXNFUUNBTUlBQWdDMm9pQUNnQUFFWU5BUXNnQnlBVVRRMEJJQkVnQnlBTGFpSUFLQUFBUncwQklBWWhCUXNnQlNBQWF5SUtRUUpxSVJGQkFDRUdJQUFnRWswZ0JTQURUWElOQVFOQUlBVkJmMm9pQnkwQUFDQUFRWDlxSWd3dEFBQkhEUUlnQmtFQmFpRUdJQWNnQTBzRVFDQUhJUVVnRENJQUlCSkxEUUVMQ3lBSklRZ2dEQ0VBSUFvaENTQUhJUVVNQWdzZ0JpQVdJQVVnQTJ0QkIzWnFJZ0JxSVFZZ0FDQUZhZ3dDQ3lBSklRZ2dDaUVKQ3lBRklBWnFRUVJxSUFBZ0JtcEJCR29nQkJBZElBWnFJZ3hCQVdvaENpQUZJQU5ySVFjZ0FTZ0NEQ0VBQWtBQ1FDQUZJQkJOQkVBZ0FDQURFQndnQVNnQ0RDRUFJQWRCRUUwRVFDQUJJQUFnQjJvaUFEWUNEQXdEQ3lBQVFSQnFJQU5CRUdvaUJoQWNJQUJCSUdvZ0EwRWdhaEFjSUFkQk1VZ05BU0FBSUFkcUlSZ2dBRUV3YWlFREEwQWdBeUFHUVNCcUlnQVFIQ0FEUVJCcUlBWkJNR29RSENBQUlRWWdBMEVnYWlJRElCaEpEUUFMREFFTElBQWdBeUFGSUJBUUlnc2dBU0FCS0FJTUlBZHFJZ0EyQWd3Z0IwR0FnQVJKRFFBZ0FVRUJOZ0lrSUFFZ0FTZ0NCQ0FCS0FJQWEwRURkVFlDS0FzZ0FTZ0NCQ0lESUJGQkFXbzJBZ0FnQXlBSE93RUVJQXBCZ0lBRVR3UkFJQUZCQWpZQ0pDQUJJQU1nQVNnQ0FHdEJBM1UyQWlnTElBTWdDanNCQmlBQklBTkJDR28yQWdRZ0RFRUVhaUFGYWlJRFFRRnFJUVlDUUNBRElCTkxEUUFnRGlBUElBMUJCeEFlUVFKMGFpQVhRUUpxTmdJQUlBNGdBMEYrYWlJRklBMUJCeEFlUVFKMGFpQUZJQXRyTmdJQUlBaEZCRUJCQUNFSURBRUxJQU1vQUFBZ0F5QUlheWdBQUVjTkFFRUFJQWhySVFZRFFDQUlJUVVnQ1NFSUlBVWhDU0FEUVFScUlnVWdCU0FHYWlBRUVCMGhCU0FPSUFNZ0RVRUhFQjVCQW5ScUlBTWdDMnMyQWdBZ0JVRUJhaUVHQWtBZ0F5QVFUUVJBSUFBZ0F4QWNEQUVMSUFBZ0F5QURJQkFRSWdzZ0FTZ0NCQ0lBUVFFMkFnQWdBRUVBT3dFRUlBWkJnSUFFVHdSQUlBRkJBallDSkNBQklBQWdBU2dDQUd0QkEzVTJBaWdMSUFBZ0Jqc0JCaUFCSUFCQkNHbzJBZ1FDUUNBSVJTQURJQVZxUVFScUlnTWdFMHR5RFFBZ0F5Z0FBQ0FESUFocktBQUFSdzBBUVFBZ0NHc2hCaUFCS0FJTUlRQU1BUXNMSUFOQkFXb2hCZ3NnQXdzaEJTQUdJQk5KRFFBTEN5QUNJQWtnRlNBSkd6WUNBQ0FJSUJVZ0NCc2hCU0FDUVFScURBSUxJQUlvQWdBaUNTQUNLQUlFSWdoQkFDQUlJQU1nQUNnQ0JDSUxJQU1nQzJzZ0JHb2lCVUVCSUFBb0FuUjBJZ1pySUFBb0Fnd2lCeUFGSUFkcklBWkxHeUlVYWlJU0lBTkdhaUlGSUJKcklnWkxJZ2NiSUFrZ0Jrc2lCaHNoRlVFQUlBa2dCaHNoQ1VFQUlBZ2dCeHNoQ0NBRlFRRnFJZ1lnQXlBRWFpSUVRWGhxSWhOSkJFQWdBQ2dDZkNFTklBQW9BaUFoRGlBRVFXQnFJUkFnQUNnQ2lBRWlBQ0FBUldwQkFXb2hGZ05BSUFVZ0RVRUdFQjRoQUNBRktBQUFJUXdnQmlBTlFRWVFIaUVISUFZb0FBQWhFU0FPSUFkQkFuUnFJZ29vQWdBaEJ5QU9JQUJCQW5ScUlnOG9BZ0FoQUNBUElBVWdDMnNpRnpZQ0FDQUtJQVlnQzJzMkFnQUNmd0pBSUFsRklBVkJBbW9pRHlBSmF5SUtLQUFBSUE4b0FBQkhja1VFUUNBS0lBVXRBQUVnQ2tGL2FpMEFBRVlpQm1zaEFDQVBJQVpySVFWQkFDRVJEQUVMQWtBQ1FBSkFJQUFnRkVzRVFDQU1JQUFnQzJvaUFDZ0FBRVlOQVFzZ0J5QVVUUTBCSUJFZ0J5QUxhaUlBS0FBQVJ3MEJJQVloQlFzZ0JTQUFheUlLUVFKcUlSRkJBQ0VHSUFBZ0VrMGdCU0FEVFhJTkFRTkFJQVZCZjJvaUJ5MEFBQ0FBUVg5cUlnd3RBQUJIRFFJZ0JrRUJhaUVHSUFjZ0Ewc0VRQ0FISVFVZ0RDSUFJQkpMRFFFTEN5QUpJUWdnRENFQUlBb2hDU0FISVFVTUFnc2dCaUFXSUFVZ0EydEJCM1pxSWdCcUlRWWdBQ0FGYWd3Q0N5QUpJUWdnQ2lFSkN5QUZJQVpxUVFScUlBQWdCbXBCQkdvZ0JCQWRJQVpxSWd4QkFXb2hDaUFGSUFOcklRY2dBU2dDRENFQUFrQUNRQ0FGSUJCTkJFQWdBQ0FERUJ3Z0FTZ0NEQ0VBSUFkQkVFMEVRQ0FCSUFBZ0Iyb2lBRFlDREF3REN5QUFRUkJxSUFOQkVHb2lCaEFjSUFCQklHb2dBMEVnYWhBY0lBZEJNVWdOQVNBQUlBZHFJUmdnQUVFd2FpRURBMEFnQXlBR1FTQnFJZ0FRSENBRFFSQnFJQVpCTUdvUUhDQUFJUVlnQTBFZ2FpSURJQmhKRFFBTERBRUxJQUFnQXlBRklCQVFJZ3NnQVNBQktBSU1JQWRxSWdBMkFnd2dCMEdBZ0FSSkRRQWdBVUVCTmdJa0lBRWdBU2dDQkNBQktBSUFhMEVEZFRZQ0tBc2dBU2dDQkNJRElCRkJBV28yQWdBZ0F5QUhPd0VFSUFwQmdJQUVUd1JBSUFGQkFqWUNKQ0FCSUFNZ0FTZ0NBR3RCQTNVMkFpZ0xJQU1nQ2pzQkJpQUJJQU5CQ0dvMkFnUWdERUVFYWlBRmFpSURRUUZxSVFZQ1FDQURJQk5MRFFBZ0RpQVBJQTFCQmhBZVFRSjBhaUFYUVFKcU5nSUFJQTRnQTBGK2FpSUZJQTFCQmhBZVFRSjBhaUFGSUF0ck5nSUFJQWhGQkVCQkFDRUlEQUVMSUFNb0FBQWdBeUFJYXlnQUFFY05BRUVBSUFocklRWURRQ0FJSVFVZ0NTRUlJQVVoQ1NBRFFRUnFJZ1VnQlNBR2FpQUVFQjBoQlNBT0lBTWdEVUVHRUI1QkFuUnFJQU1nQzJzMkFnQWdCVUVCYWlFR0FrQWdBeUFRVFFSQUlBQWdBeEFjREFFTElBQWdBeUFESUJBUUlnc2dBU2dDQkNJQVFRRTJBZ0FnQUVFQU93RUVJQVpCZ0lBRVR3UkFJQUZCQWpZQ0pDQUJJQUFnQVNnQ0FHdEJBM1UyQWlnTElBQWdCanNCQmlBQklBQkJDR28yQWdRQ1FDQUlSU0FESUFWcVFRUnFJZ01nRTB0eURRQWdBeWdBQUNBRElBaHJLQUFBUncwQVFRQWdDR3NoQmlBQktBSU1JUUFNQVFzTElBTkJBV29oQmdzZ0F3c2hCU0FHSUJOSkRRQUxDeUFDSUFrZ0ZTQUpHellDQUNBSUlCVWdDQnNoQlNBQ1FRUnFEQUVMSUFJb0FnQWlDU0FDS0FJRUlnaEJBQ0FJSUFNZ0FDZ0NCQ0lMSUFNZ0Myc2dCR29pQlVFQklBQW9BblIwSWdacklBQW9BZ3dpQnlBRklBZHJJQVpMR3lJVWFpSVNJQU5HYWlJRklCSnJJZ1pMSWdjYklBa2dCa3NpQmhzaEZVRUFJQWtnQmhzaENVRUFJQWdnQnhzaENDQUZRUUZxSWdZZ0F5QUVhaUlFUVhocUloTkpCRUFnQUNnQ2ZDRU5JQUFvQWlBaERpQUVRV0JxSVJBZ0FDZ0NpQUVpQUNBQVJXcEJBV29oRmdOQUlBVWdEVUVGRUI0aEFDQUZLQUFBSVF3Z0JpQU5RUVVRSGlFSElBWW9BQUFoRVNBT0lBZEJBblJxSWdvb0FnQWhCeUFPSUFCQkFuUnFJZzhvQWdBaEFDQVBJQVVnQzJzaUZ6WUNBQ0FLSUFZZ0MyczJBZ0FDZndKQUlBbEZJQVZCQW1vaUR5QUpheUlLS0FBQUlBOG9BQUJIY2tVRVFDQUtJQVV0QUFFZ0NrRi9haTBBQUVZaUJtc2hBQ0FQSUFacklRVkJBQ0VSREFFTEFrQUNRQUpBSUFBZ0ZFc0VRQ0FNSUFBZ0Myb2lBQ2dBQUVZTkFRc2dCeUFVVFEwQklCRWdCeUFMYWlJQUtBQUFSdzBCSUFZaEJRc2dCU0FBYXlJS1FRSnFJUkZCQUNFR0lBQWdFazBnQlNBRFRYSU5BUU5BSUFWQmYyb2lCeTBBQUNBQVFYOXFJZ3d0QUFCSERRSWdCa0VCYWlFR0lBY2dBMHNFUUNBSElRVWdEQ0lBSUJKTERRRUxDeUFKSVFnZ0RDRUFJQW9oQ1NBSElRVU1BZ3NnQmlBV0lBVWdBMnRCQjNacUlnQnFJUVlnQUNBRmFnd0NDeUFKSVFnZ0NpRUpDeUFGSUFacVFRUnFJQUFnQm1wQkJHb2dCQkFkSUFacUlneEJBV29oQ2lBRklBTnJJUWNnQVNnQ0RDRUFBa0FDUUNBRklCQk5CRUFnQUNBREVCd2dBU2dDRENFQUlBZEJFRTBFUUNBQklBQWdCMm9pQURZQ0RBd0RDeUFBUVJCcUlBTkJFR29pQmhBY0lBQkJJR29nQTBFZ2FoQWNJQWRCTVVnTkFTQUFJQWRxSVJnZ0FFRXdhaUVEQTBBZ0F5QUdRU0JxSWdBUUhDQURRUkJxSUFaQk1Hb1FIQ0FBSVFZZ0EwRWdhaUlESUJoSkRRQUxEQUVMSUFBZ0F5QUZJQkFRSWdzZ0FTQUJLQUlNSUFkcUlnQTJBZ3dnQjBHQWdBUkpEUUFnQVVFQk5nSWtJQUVnQVNnQ0JDQUJLQUlBYTBFRGRUWUNLQXNnQVNnQ0JDSURJQkZCQVdvMkFnQWdBeUFIT3dFRUlBcEJnSUFFVHdSQUlBRkJBallDSkNBQklBTWdBU2dDQUd0QkEzVTJBaWdMSUFNZ0Nqc0JCaUFCSUFOQkNHbzJBZ1FnREVFRWFpQUZhaUlEUVFGcUlRWUNRQ0FESUJOTERRQWdEaUFQSUExQkJSQWVRUUowYWlBWFFRSnFOZ0lBSUE0Z0EwRithaUlGSUExQkJSQWVRUUowYWlBRklBdHJOZ0lBSUFoRkJFQkJBQ0VJREFFTElBTW9BQUFnQXlBSWF5Z0FBRWNOQUVFQUlBaHJJUVlEUUNBSUlRVWdDU0VJSUFVaENTQURRUVJxSWdVZ0JTQUdhaUFFRUIwaEJTQU9JQU1nRFVFRkVCNUJBblJxSUFNZ0MyczJBZ0FnQlVFQmFpRUdBa0FnQXlBUVRRUkFJQUFnQXhBY0RBRUxJQUFnQXlBRElCQVFJZ3NnQVNnQ0JDSUFRUUUyQWdBZ0FFRUFPd0VFSUFaQmdJQUVUd1JBSUFGQkFqWUNKQ0FCSUFBZ0FTZ0NBR3RCQTNVMkFpZ0xJQUFnQmpzQkJpQUJJQUJCQ0dvMkFnUUNRQ0FJUlNBRElBVnFRUVJxSWdNZ0UwdHlEUUFnQXlnQUFDQURJQWhyS0FBQVJ3MEFRUUFnQ0dzaEJpQUJLQUlNSVFBTUFRc0xJQU5CQVdvaEJnc2dBd3NoQlNBR0lCTkpEUUFMQ3lBQ0lBa2dGU0FKR3pZQ0FDQUlJQlVnQ0JzaEJTQUNRUVJxQ3lBRk5nSUFJQVFnQTJzTFlBRUZmeUFBS0FJRUlnUWdBQ2dDR0dvaUFrRURhaUlESUFGQmVtb2lCVWtFUUNBQUtBS0VBU0VHSUFBb0Fud2hBU0FBS0FJZ0lRQURRQ0FBSUFJZ0FTQUdFQjVCQW5ScUlBSWdCR3MyQWdBZ0F5SUNRUU5xSWdNZ0JVa05BQXNMQy80ZEFSbC9JQUFvQW5naEZTQUFLQUo4SVJNZ0FDZ0NLQ0VXSUFBb0FpQWhGQ0FESUFScUlnMUJlR29oRnlBQ0tBSUVJUWNnQWlnQ0FDRUlBa0FnQUNnQ0RDSUdJQUFvQWhBZ0FDZ0NGQ0FESUFBb0FnUWlDMnNnQkdvaUJDQUFLQUowSWdvUUp5SVFTd1JBSUJjZ0Ewc0VRQ0FBS0FJSUlnNGdCaUFRSUFZZ0VFc2JJZzlxSVJnZ0N5QVBhaUVSSUE0Z0VHb2hHeUFOUVdCcUlSSWdEMEYvYWlFY0lBTWhBQU5BSUJZZ0F5QVZJQVVRSGtFQ2RHb2lCQ2dDQUNFS0lCUWdBeUFUUVFnUUhrRUNkR29pQmlnQ0FDRU1JQVlnQXlBTGF5SWFOZ0lBSUFRZ0dqWUNBQUpBQWtBQ1FBSkFBa0FDUUFKQUlCcEJBV29pR1NBSWF5SUVJQkJOSUJ3Z0JHdEJBMGx5UlFSQUlBNGdDeUFFSUE5SklnWWJJQVJxSWdrb0FBQWdBMEVCYWlJRUtBQUFSZzBCQ3lBTUlCQk5EUU1nRGlBTElBd2dEMGtpQkJzZ0RHb2lDU2tBQUNBREtRQUFVZzBESUFOQkNHb2dDVUVJYWlBTklCZ2dEU0FFR3lBUkVDQkJDR29oQmlBSklCc2dFU0FFR3lJSFN3MEJJQU1oQkF3Q0N5QURRUVZxSUFsQkJHb2dEU0FZSUEwZ0Joc2dFUkFnSWdsQkFXb2hEQ0FFSUFCcklRb2dBU2dDRENFREFrQUNRQ0FFSUJKTkJFQWdBeUFBRUJ3Z0FTZ0NEQ0VESUFwQkVFMEVRQ0FCSUFNZ0NtbzJBZ3dNQXdzZ0EwRVFhaUFBUVJCcUlnWVFIQ0FEUVNCcUlBQkJJR29RSENBS1FURklEUUVnQXlBS2FpRVpJQU5CTUdvaEF3TkFJQU1nQmtFZ2FpSUFFQndnQTBFUWFpQUdRVEJxRUJ3Z0FDRUdJQU5CSUdvaUF5QVpTUTBBQ3d3QkN5QURJQUFnQkNBU0VDSUxJQUVnQVNnQ0RDQUthallDRENBS1FZQ0FCRWtOQUNBQlFRRTJBaVFnQVNBQktBSUVJQUVvQWdCclFRTjFOZ0lvQ3lBSlFRUnFJUVlnQVNnQ0JDSURRUUUyQWdBZ0F5QUtPd0VFSUF4QmdJQUVTUTBFSUFGQkFqWUNKQ0FCSUFNZ0FTZ0NBR3RCQTNVMkFpZ01CQXNnQXlFRUlBTWdBRTBOQUFOQUlBTkJmMm9pQkMwQUFDQUpRWDlxSWdrdEFBQkhCRUFnQXlFRURBSUxJQVpCQVdvaEJpQUpJQWRORFFFZ0JDSURJQUJMRFFBTEN5QWFJQXhySVFvZ0JrRjlhaUVNSUFRZ0FHc2hCeUFCS0FJTUlRTUNRQUpBSUFRZ0VrMEVRQ0FESUFBUUhDQUJLQUlNSVFNZ0IwRVFUUVJBSUFFZ0F5QUhhallDREF3REN5QURRUkJxSUFCQkVHb2lDUkFjSUFOQklHb2dBRUVnYWhBY0lBZEJNVWdOQVNBRElBZHFJUmtnQTBFd2FpRURBMEFnQXlBSlFTQnFJZ0FRSENBRFFSQnFJQWxCTUdvUUhDQUFJUWtnQTBFZ2FpSURJQmxKRFFBTERBRUxJQU1nQUNBRUlCSVFJZ3NnQVNBQktBSU1JQWRxTmdJTUlBZEJnSUFFU1EwQUlBRkJBVFlDSkNBQklBRW9BZ1FnQVNnQ0FHdEJBM1UyQWlnTElBRW9BZ1FpQXlBS1FRTnFOZ0lBSUFNZ0J6c0JCQ0FNUVlDQUJFa05BU0FCUVFJMkFpUWdBU0FESUFFb0FnQnJRUU4xTmdJb0RBRUxBa0FDUUNBS0lCQk5EUUFnRGlBTElBb2dEMGtpSFJzZ0Ntb2lDU2dBQUNBREtBQUFSdzBBSUJRZ0EwRUJhaUlFSUJOQkNCQWVRUUowYWlJR0tBSUFJUXdnQmlBWk5nSUFBa0FDUUNBTUlCQk5EUUFnRGlBTElBd2dEMGtpSGhzZ0RHb2lCeWtBQUNBRUtRQUFVZzBBSUFOQkNXb2dCMEVJYWlBTklCZ2dEU0FlR3lBUkVDQkJDR29oQmlBWklBeHJJUW9nQnlBYklCRWdIaHNpQ1UwZ0JDQUFUWElOQVFOQUlBUkJmMm9pQXkwQUFDQUhRWDlxSWdjdEFBQkhEUUlnQmtFQmFpRUdJQWNnQ1UwRVFDQURJUVFNQXdzZ0F5SUVJQUJMRFFBTERBRUxJQU5CQkdvZ0NVRUVhaUFOSUJnZ0RTQWRHeUFSRUNCQkJHb2hCaUFhSUFwcklRb2dDU0FiSUJFZ0hSc2lCMDBFUUNBRElRUU1BUXNnQXlBQVRRUkFJQU1oQkF3QkN3TkFJQU5CZjJvaUJDMEFBQ0FKUVg5cUlna3RBQUJIQkVBZ0F5RUVEQUlMSUFaQkFXb2hCaUFKSUFkTkRRRWdCQ0lESUFCTERRQUxDeUFHUVgxcUlRd2dCQ0FBYXlFSElBRW9BZ3doQXdKQUFrQWdCQ0FTVFFSQUlBTWdBQkFjSUFFb0Fnd2hBeUFIUVJCTkJFQWdBU0FESUFkcU5nSU1EQU1MSUFOQkVHb2dBRUVRYWlJSkVCd2dBMEVnYWlBQVFTQnFFQndnQjBFeFNBMEJJQU1nQjJvaEdTQURRVEJxSVFNRFFDQURJQWxCSUdvaUFCQWNJQU5CRUdvZ0NVRXdhaEFjSUFBaENTQURRU0JxSWdNZ0dVa05BQXNNQVFzZ0F5QUFJQVFnRWhBaUN5QUJJQUVvQWd3Z0IybzJBZ3dnQjBHQWdBUkpEUUFnQVVFQk5nSWtJQUVnQVNnQ0JDQUJLQUlBYTBFRGRUWUNLQXNnQVNnQ0JDSURJQXBCQTJvMkFnQWdBeUFIT3dFRUlBeEJnSUFFU1EwQklBRkJBallDSkNBQklBTWdBU2dDQUd0QkEzVTJBaWdNQVFzZ0F5QUFhMEVJZFNBRGFrRUJhaUVEREFNTElBZ2hCeUFLSVFnTUFRc2dDQ0VISUFvaENBc2dBeUFNT3dFR0lBRWdBMEVJYWpZQ0JDQUVJQVpxSWdBZ0Ywc0VRQ0FBSVFNTUFRc2dGQ0FMSUJwQkFtb2lBMm9pQkNBVFFRZ1FIa0VDZEdvZ0F6WUNBQ0FVSUFCQmZtb2lCaUFUUVFnUUhrRUNkR29nQmlBTGF6WUNBQ0FXSUFRZ0ZTQUZFQjVCQW5ScUlBTTJBZ0FnRmlBQVFYOXFJZ01nRlNBRkVCNUJBblJxSUFNZ0MyczJBZ0FnQ0NFR0lBY2hCQU5BQWtBZ0JDRUlJQVloQkNBQUlBdHJJZ1lnQ0dzaUF5QVFUU0FjSUFOclFRTkpjZzBBSUFNZ0RpQUxJQU1nRDBraUJ4dHFJZ01vQUFBZ0FDZ0FBRWNOQUNBQVFRUnFJQU5CQkdvZ0RTQVlJQTBnQnhzZ0VSQWdJZ3BCQVdvaEJ5QUJLQUlNSVFNQ1FDQUFJQkpOQkVBZ0F5QUFFQndNQVFzZ0F5QUFJQUFnRWhBaUN5QUJLQUlFSWdOQkFUWUNBQ0FEUVFBN0FRUWdCMEdBZ0FSUEJFQWdBVUVDTmdJa0lBRWdBeUFCS0FJQWEwRURkVFlDS0FzZ0F5QUhPd0VHSUFFZ0EwRUlhallDQkNBV0lBQWdGU0FGRUI1QkFuUnFJQVkyQWdBZ0ZDQUFJQk5CQ0JBZVFRSjBhaUFHTmdJQUlBZ2hCaUFFSVFjZ0NrRUVhaUFBYWlJQUlRTWdBQ0FYVFEwQkRBSUxDeUFJSVFjZ0JDRUlJQUFoQXdzZ0F5QVhTUTBBQ3lBQUlRTUxJQUlnQ0RZQ0FBd0JDeUFJSUFkQkFDQUhJQU1nQ3lBRVFRRWdDblFpQUdzZ0JpQUVJQVpySUFCTEd5SVFhaUlTSUFOR2FpSUVJQkpySWdCTElnWWJJQWdnQUVzaUFCc2hHRUVBSUFnZ0FCc2hBRUVBSUFjZ0Joc2hDaUFFSUJkSkJFQWdEVUZnYWlFUkEwQWdCQ0FUUVFnUUhpRUlJQllnQkNBVklBVVFIa0VDZEdvaUJpZ0NBQ0VQSUJRZ0NFRUNkR29pQ0NnQ0FDRU9JQVlnQkNBTGF5SU1OZ0lBSUFnZ0REWUNBQUpBQWtBZ0FFVWdCRUVCYWlJSUlBQnJLQUFBSUFnb0FBQkhja1VFUUNBRVFRVnFJZ1FnQkNBQWF5QU5FQjBpQ1VFQmFpRVBJQWdnQTJzaEJ5QUJLQUlNSVFRQ1FBSkFJQWdnRVUwRVFDQUVJQU1RSENBQktBSU1JUVlnQjBFUVRRUkFJQUVnQmlBSGFqWUNEQXdEQ3lBR1FSQnFJQU5CRUdvaUJCQWNJQVpCSUdvZ0EwRWdhaEFjSUFkQk1VZ05BU0FHSUFkcUlRNGdCa0V3YWlFREEwQWdBeUFFUVNCcUlnWVFIQ0FEUVJCcUlBUkJNR29RSENBR0lRUWdBMEVnYWlJRElBNUpEUUFMREFFTElBUWdBeUFJSUJFUUlnc2dBU0FCS0FJTUlBZHFOZ0lNSUFkQmdJQUVTUTBBSUFGQkFUWUNKQ0FCSUFFb0FnUWdBU2dDQUd0QkEzVTJBaWdMSUFsQkJHb2hCaUFCS0FJRUlnTkJBVFlDQUNBRElBYzdBUVFnRDBHQWdBUkpEUUVnQVVFQ05nSWtJQUVnQXlBQktBSUFhMEVEZFRZQ0tBd0JDd0pBQWtBQ1FBSkFBa0FnRGlBUVN3UkFJQXNnRG1vaUNTa0FBQ0FFS1FBQVVnMEJJQVJCQ0dvZ0NVRUlhaUFORUIxQkNHb2hCaUFFSUFscklRY2dCQ0FEVFFSQUlBUWhDQXdHQ3lBT0lCQk1CRUFnQkNFSURBWUxBMEFnQkVGL2FpSUlMUUFBSUFsQmYyb2lDUzBBQUVjRVFDQUVJUWdNQndzZ0JrRUJhaUVHSUFnZ0EwME5CaUFJSVFRZ0NTQVNTdzBBQ3d3RkN5QVBJQkJMRFFFTUFnc2dEeUFRVFEwQkN5QUxJQTlxSWdrb0FBQWdCQ2dBQUVZTkFRc2dCQ0FEYTBFSWRTQUVha0VCYWlFRURBTUxJQlFnQ0NBVFFRZ1FIa0VDZEdvaUJpZ0NBQ0VPSUFZZ0RFRUJhallDQUFKQUlBNGdFRTBOQUNBTElBNXFJZ29wQUFBZ0NDa0FBRklOQUNBRVFRbHFJQXBCQ0dvZ0RSQWRRUWhxSVFZZ0NDQUtheUVISUE0Z0VFd2dDQ0FEVFhJTkFRTkFJQWhCZjJvaUJDMEFBQ0FLUVg5cUlnb3RBQUJIRFFJZ0JrRUJhaUVHSUFRZ0EwMEVRQ0FFSVFnTUF3c2dCQ0VJSUFvZ0Vrc05BQXNNQVFzZ0JFRUVhaUFKUVFScUlBMFFIVUVFYWlFR0lBUWdDV3NoQnlBRUlBTk5CRUFnQkNFSURBRUxJQThnRUV3RVFDQUVJUWdNQVFzRFFDQUVRWDlxSWdndEFBQWdDVUYvYWlJSkxRQUFSd1JBSUFRaENBd0NDeUFHUVFGcUlRWWdDQ0FEVFEwQklBZ2hCQ0FKSUJKTERRQUxDeUFHUVgxcUlROGdDQ0FEYXlFSklBRW9BZ3doQkFKQUFrQWdDQ0FSVFFSQUlBUWdBeEFjSUFFb0Fnd2hDaUFKUVJCTkJFQWdBU0FKSUFwcU5nSU1EQU1MSUFwQkVHb2dBMEVRYWlJRUVCd2dDa0VnYWlBRFFTQnFFQndnQ1VFeFNBMEJJQWtnQ21vaERpQUtRVEJxSVFNRFFDQURJQVJCSUdvaUNoQWNJQU5CRUdvZ0JFRXdhaEFjSUFvaEJDQURRU0JxSWdNZ0Rra05BQXNNQVFzZ0JDQURJQWdnRVJBaUN5QUJJQUVvQWd3Z0NXbzJBZ3dnQ1VHQWdBUkpEUUFnQVVFQk5nSWtJQUVnQVNnQ0JDQUJLQUlBYTBFRGRUWUNLQXNnQVNnQ0JDSURJQWRCQTJvMkFnQWdBeUFKT3dFRUlBOUJnSUFFVHdSQUlBRkJBallDSkNBQklBTWdBU2dDQUd0QkEzVTJBaWdMSUFBaENpQUhJUUFMSUFNZ0R6c0JCaUFCSUFOQkNHbzJBZ1FnQmlBSWFpSURJQmRMQkVBZ0F5RUVEQUVMSUJRZ0N5QU1RUUpxSWdScUlnZ2dFMEVJRUI1QkFuUnFJQVEyQWdBZ0ZDQURRWDVxSWdZZ0UwRUlFQjVCQW5ScUlBWWdDMnMyQWdBZ0ZpQUlJQlVnQlJBZVFRSjBhaUFFTmdJQUlCWWdBMEYvYWlJRUlCVWdCUkFlUVFKMGFpQUVJQXRyTmdJQUlBQWhCaUFLSVFnRFFBSkFJQWdoQUNBR0lRZ2dBRVVnQXlnQUFDQURJQUJyS0FBQVIzSU5BQ0FEUVFScUlnUWdCQ0FBYXlBTkVCMGhCeUFXSUFNZ0ZTQUZFQjVCQW5ScUlBTWdDMnNpQkRZQ0FDQVVJQU1nRTBFSUVCNUJBblJxSUFRMkFnQWdCMEVCYWlFR0lBRW9BZ3doQkFKQUlBTWdFVTBFUUNBRUlBTVFIQXdCQ3lBRUlBTWdBeUFSRUNJTElBRW9BZ1FpQkVFQk5nSUFJQVJCQURzQkJDQUdRWUNBQkU4RVFDQUJRUUkyQWlRZ0FTQUVJQUVvQWdCclFRTjFOZ0lvQ3lBRUlBWTdBUVlnQVNBRVFRaHFOZ0lFSUFBaEJpQUlJUW9nQjBFRWFpQURhaUlESVFRZ0F5QVhUUTBCREFJTEN5QUFJUW9nQ0NFQUlBTWhCQXNnQkNBWFNRMEFDd3NnQWlBQUlCZ2dBQnMyQWdBZ0NpQVlJQW9iSVFjTElBSWdCellDQkNBTklBTnJDeUlBSUFBZ0FTQUNJQU1nQkNBQUtBS0VBU0lBUVFRZ0FFRjdha0VEU1JzUXd3TUxtMGtCSG44Q1FBSkFBa0FDUUFKQUlBQW9Bb1FCUVh0cURnTURBZ0VBQ3lBQ0tBSUVJUWdnQWlnQ0FDRU5JQU1nQUNnQ2NDSUdLQUlBSWc4Z0F5QUFLQUlFSWd3Z0F5QU1heUFFYWlJRlFRRWdBQ2dDZEhRaUIyc2dBQ2dDRENJS0lBVWdDbXNnQjBzYklndHFJZzVyYWlBR0tBSUVJaEFnQmlnQ0RDSWFhaUlXUm1vaUJTQURJQVJxSWdwQmVHb2lHMGtFUUNBQUtBSjRJUmNnQUNnQ2ZDRVRJQVlvQW5naEhpQUdLQUo4SVJ3Z0FDZ0NLQ0VZSUFBb0FpQWhGQ0FHS0FJb0lSOGdCaWdDSUNFZElCQWdDeUFRYWlBUGF5SVpheUVnSUFwQllHb2hFUU5BSUFVZ0UwRUlFQjRoQUNBRklCZEJCQkFlSVFRZ0JTQWNRUWdRSGlFSElBVWdIa0VFRUI0aElTQVVJQUJCQW5ScUlnQW9BZ0FoQ1NBWUlBUkJBblJxSWdRb0FnQWhCaUFFSUFVZ0RHc2lGVFlDQUNBQUlCVTJBZ0FDUUFKQUFrQWdDeUFWUVFGcUloSWdEV3NpQUVGL2MycEJBMGtOQUNBUUlBQWdHV3RxSUFBZ0RHb2dBQ0FMU1NJRUd5SWlLQUFBSUFWQkFXb2lBQ2dBQUVjTkFDQUZRUVZxSUNKQkJHb2dDaUFQSUFvZ0JCc2dEaEFnSWdsQkFXb2hCeUFBSUFOcklRWWdBU2dDRENFRUFrQUNRQ0FBSUJGTkJFQWdCQ0FERUJ3Z0FTZ0NEQ0VFSUFaQkVFMEVRQ0FCSUFRZ0JtbzJBZ3dNQXdzZ0JFRVFhaUFEUVJCcUlnVVFIQ0FFUVNCcUlBTkJJR29RSENBR1FURklEUUVnQkNBR2FpRVNJQVJCTUdvaEF3TkFJQU1nQlVFZ2FpSUVFQndnQTBFUWFpQUZRVEJxRUJ3Z0JDRUZJQU5CSUdvaUF5QVNTUTBBQ3d3QkN5QUVJQU1nQUNBUkVDSUxJQUVnQVNnQ0RDQUdhallDRENBR1FZQ0FCRWtOQUNBQlFRRTJBaVFnQVNBQktBSUVJQUVvQWdCclFRTjFOZ0lvQ3lBSlFRUnFJUVFnQVNnQ0JDSURRUUUyQWdBZ0F5QUdPd0VFSUFkQmdJQUVTUTBCSUFGQkFqWUNKQ0FCSUFNZ0FTZ0NBR3RCQTNVMkFpZ01BUXNDUUFKQUFrQUNRQUpBQWtBZ0NTQUxTd1JBSUFrZ0RHb2lCeWtBQUNBRktRQUFVZzBCSUFWQkNHb2dCMEVJYWlBS0VCMUJDR29oQkNBRklBZHJJUVlnQlNBRFRRUkFJQVVoQUF3SEN5QUpJQXRNQkVBZ0JTRUFEQWNMQTBBZ0JVRi9haUlBTFFBQUlBZEJmMm9pQnkwQUFFY0VRQ0FGSVFBTUNBc2dCRUVCYWlFRUlBQWdBMDBOQnlBQUlRVWdCeUFPU3cwQUN3d0dDd0pBSUIwZ0IwRUNkR29vQWdBaUFDQWFUQTBBSUFBZ0VHb2lCeWtBQUNBRktRQUFVZzBBSUFWQkNHb2dCMEVJYWlBS0lBOGdEaEFnUVFocUlRUWdGU0FBYXlBWmF5RUdJQVVnQTAwRVFDQUZJUUFNQndzRFFDQUZRWDlxSWdBdEFBQWdCMEYvYWlJSExRQUFSd1JBSUFVaEFBd0lDeUFFUVFGcUlRUWdBQ0FEVFEwSElBQWhCU0FISUJaTERRQUxEQVlMSUFZZ0MwME5BUXdDQ3lBR0lBdExEUUVMSUI4Z0lVRUNkR29vQWdBaUFDQWFUQTBCSUFBZ0VHb2lCeWdBQUNBRktBQUFSdzBCSUFBZ0dXb2hCZ3dDQ3lBR0lBeHFJZ2NvQUFBZ0JTZ0FBRVlOQVFzZ0JTQURhMEVJZFNBRmFrRUJhaUVGREFNTElBVkJBV29pQUNBVFFRZ1FIaUVFSUFBZ0hFRUlFQjRoQ0NBVUlBUkJBblJxSWdRb0FnQWhDU0FFSUJJMkFnQUNRQ0FKSUF0TEJFQWdDU0FNYWlJSUtRQUFJQUFwQUFCU0RRRWdCVUVKYWlBSVFRaHFJQW9RSFVFSWFpRUVJQUFnQ0dzaEJpQUpJQXRNSUFBZ0EwMXlEUUlEUUNBQVFYOXFJZ1V0QUFBZ0NFRi9haUlJTFFBQVJ3MERJQVJCQVdvaEJDQUZJQU5OQkVBZ0JTRUFEQVFMSUFVaEFDQUlJQTVMRFFBTERBSUxJQjBnQ0VFQ2RHb29BZ0FpQ1NBYVRBMEFJQWtnRUdvaUNDa0FBQ0FBS1FBQVVnMEFJQVZCQ1dvZ0NFRUlhaUFLSUE4Z0RoQWdRUWhxSVFRZ0VpQUpheUFaYXlFR0lBQWdBMDBOQVFOQUlBQkJmMm9pQlMwQUFDQUlRWDlxSWdndEFBQkhEUUlnQkVFQmFpRUVJQVVnQTAwRVFDQUZJUUFNQXdzZ0JTRUFJQWdnRmtzTkFBc01BUXNnQjBFRWFpRUFJQVZCQkdvaEJDQUdJQXRKQkVBZ0JDQUFJQW9nRHlBT0VDQkJCR29oQkNBVklBWnJJUVlnQlNBRFRRUkFJQVVoQUF3Q0N5QUhJQlpOQkVBZ0JTRUFEQUlMQTBBZ0JVRi9haUlBTFFBQUlBZEJmMm9pQnkwQUFFY0VRQ0FGSVFBTUF3c2dCRUVCYWlFRUlBQWdBMDBOQWlBQUlRVWdCeUFXU3cwQUN3d0JDeUFFSUFBZ0NoQWRRUVJxSVFRZ0JTQUhheUVHSUFVZ0EwMEVRQ0FGSVFBTUFRc2dCeUFPVFFSQUlBVWhBQXdCQ3dOQUlBVkJmMm9pQUMwQUFDQUhRWDlxSWdjdEFBQkhCRUFnQlNFQURBSUxJQVJCQVdvaEJDQUFJQU5ORFFFZ0FDRUZJQWNnRGtzTkFBc0xJQVJCZldvaEJ5QUFJQU5ySVFrZ0FTZ0NEQ0VGQWtBQ1FDQUFJQkZOQkVBZ0JTQURFQndnQVNnQ0RDRUlJQWxCRUUwRVFDQUJJQWdnQ1dvMkFnd01Bd3NnQ0VFUWFpQURRUkJxSWdVUUhDQUlRU0JxSUFOQklHb1FIQ0FKUVRGSURRRWdDQ0FKYWlFU0lBaEJNR29oQXdOQUlBTWdCVUVnYWlJSUVCd2dBMEVRYWlBRlFUQnFFQndnQ0NFRklBTkJJR29pQXlBU1NRMEFDd3dCQ3lBRklBTWdBQ0FSRUNJTElBRWdBU2dDRENBSmFqWUNEQ0FKUVlDQUJFa05BQ0FCUVFFMkFpUWdBU0FCS0FJRUlBRW9BZ0JyUVFOMU5nSW9DeUFCS0FJRUlnTWdCa0VEYWpZQ0FDQURJQWs3QVFRZ0IwR0FnQVJQQkVBZ0FVRUNOZ0lrSUFFZ0F5QUJLQUlBYTBFRGRUWUNLQXNnRFNFSUlBWWhEUXNnQXlBSE93RUdJQUVnQTBFSWFqWUNCQ0FBSUFScUlnTWdHMHNFUUNBRElRVU1BUXNnRkNBTUlCVkJBbW9pQUdvaUJDQVRRUWdRSGtFQ2RHb2dBRFlDQUNBVUlBTkJmbW9pQlNBVFFRZ1FIa0VDZEdvZ0JTQU1hellDQUNBWUlBUWdGMEVFRUI1QkFuUnFJQUEyQWdBZ0dDQURRWDlxSWdBZ0YwRUVFQjVCQW5ScUlBQWdER3MyQWdBZ0RTRUVJQWdoQUFOQUFrQWdBQ0VOSUFRaEFDQUxJQU1nREdzaUJTQU5heUlFUVg5emFrRURTUTBBSUFRZ0lDQU1JQVFnQzBraUNCdHFJZ1FvQUFBZ0F5Z0FBRWNOQUNBRFFRUnFJQVJCQkdvZ0NpQVBJQW9nQ0JzZ0RoQWdJZ1pCQVdvaENDQUJLQUlNSVFRQ1FDQURJQkZOQkVBZ0JDQURFQndNQVFzZ0JDQURJQU1nRVJBaUN5QUJLQUlFSWdSQkFUWUNBQ0FFUVFBN0FRUWdDRUdBZ0FSUEJFQWdBVUVDTmdJa0lBRWdCQ0FCS0FJQWEwRURkVFlDS0FzZ0JDQUlPd0VHSUFFZ0JFRUlhallDQkNBWUlBTWdGMEVFRUI1QkFuUnFJQVUyQWdBZ0ZDQURJQk5CQ0JBZVFRSjBhaUFGTmdJQUlBMGhCQ0FBSVFnZ0JrRUVhaUFEYWlJRElRVWdBeUFiVFEwQkRBSUxDeUFOSVFnZ0FDRU5JQU1oQlFzZ0JTQWJTUTBBQ3dzTUF3c2dBaWdDQkNFSUlBSW9BZ0FoRFNBRElBQW9BbkFpQmlnQ0FDSVBJQU1nQUNnQ0JDSU1JQU1nREdzZ0JHb2lCVUVCSUFBb0FuUjBJZ2RySUFBb0Fnd2lDaUFGSUFwcklBZExHeUlMYWlJT2Eyb2dCaWdDQkNJUUlBWW9BZ3dpR21vaUZrWnFJZ1VnQXlBRWFpSUtRWGhxSWh0SkJFQWdBQ2dDZUNFWElBQW9BbndoRXlBR0tBSjRJUjRnQmlnQ2ZDRWNJQUFvQWlnaEdDQUFLQUlnSVJRZ0JpZ0NLQ0VmSUFZb0FpQWhIU0FRSUFzZ0VHb2dEMnNpR1dzaElDQUtRV0JxSVJFRFFDQUZJQk5CQ0JBZUlRQWdCU0FYUVFjUUhpRUVJQVVnSEVFSUVCNGhCeUFGSUI1QkJ4QWVJU0VnRkNBQVFRSjBhaUlBS0FJQUlRa2dHQ0FFUVFKMGFpSUVLQUlBSVFZZ0JDQUZJQXhySWhVMkFnQWdBQ0FWTmdJQUFrQUNRQUpBSUFzZ0ZVRUJhaUlTSUExcklnQkJmM05xUVFOSkRRQWdFQ0FBSUJscmFpQUFJQXhxSUFBZ0Mwa2lCQnNpSWlnQUFDQUZRUUZxSWdBb0FBQkhEUUFnQlVFRmFpQWlRUVJxSUFvZ0R5QUtJQVFiSUE0UUlDSUpRUUZxSVFjZ0FDQURheUVHSUFFb0Fnd2hCQUpBQWtBZ0FDQVJUUVJBSUFRZ0F4QWNJQUVvQWd3aEJDQUdRUkJOQkVBZ0FTQUVJQVpxTmdJTURBTUxJQVJCRUdvZ0EwRVFhaUlGRUJ3Z0JFRWdhaUFEUVNCcUVCd2dCa0V4U0EwQklBUWdCbW9oRWlBRVFUQnFJUU1EUUNBRElBVkJJR29pQkJBY0lBTkJFR29nQlVFd2FoQWNJQVFoQlNBRFFTQnFJZ01nRWtrTkFBc01BUXNnQkNBRElBQWdFUkFpQ3lBQklBRW9BZ3dnQm1vMkFnd2dCa0dBZ0FSSkRRQWdBVUVCTmdJa0lBRWdBU2dDQkNBQktBSUFhMEVEZFRZQ0tBc2dDVUVFYWlFRUlBRW9BZ1FpQTBFQk5nSUFJQU1nQmpzQkJDQUhRWUNBQkVrTkFTQUJRUUkyQWlRZ0FTQURJQUVvQWdCclFRTjFOZ0lvREFFTEFrQUNRQUpBQWtBQ1FBSkFJQWtnQzBzRVFDQUpJQXhxSWdjcEFBQWdCU2tBQUZJTkFTQUZRUWhxSUFkQkNHb2dDaEFkUVFocUlRUWdCU0FIYXlFR0lBVWdBMDBFUUNBRklRQU1Cd3NnQ1NBTFRBUkFJQVVoQUF3SEN3TkFJQVZCZjJvaUFDMEFBQ0FIUVg5cUlnY3RBQUJIQkVBZ0JTRUFEQWdMSUFSQkFXb2hCQ0FBSUFOTkRRY2dBQ0VGSUFjZ0Rrc05BQXNNQmdzQ1FDQWRJQWRCQW5ScUtBSUFJZ0FnR2t3TkFDQUFJQkJxSWdjcEFBQWdCU2tBQUZJTkFDQUZRUWhxSUFkQkNHb2dDaUFQSUE0UUlFRUlhaUVFSUJVZ0FHc2dHV3NoQmlBRklBTk5CRUFnQlNFQURBY0xBMEFnQlVGL2FpSUFMUUFBSUFkQmYyb2lCeTBBQUVjRVFDQUZJUUFNQ0FzZ0JFRUJhaUVFSUFBZ0EwME5CeUFBSVFVZ0J5QVdTdzBBQ3d3R0N5QUdJQXRORFFFTUFnc2dCaUFMU3cwQkN5QWZJQ0ZCQW5ScUtBSUFJZ0FnR2t3TkFTQUFJQkJxSWdjb0FBQWdCU2dBQUVjTkFTQUFJQmxxSVFZTUFnc2dCaUFNYWlJSEtBQUFJQVVvQUFCR0RRRUxJQVVnQTJ0QkNIVWdCV3BCQVdvaEJRd0RDeUFGUVFGcUlnQWdFMEVJRUI0aEJDQUFJQnhCQ0JBZUlRZ2dGQ0FFUVFKMGFpSUVLQUlBSVFrZ0JDQVNOZ0lBQWtBZ0NTQUxTd1JBSUFrZ0RHb2lDQ2tBQUNBQUtRQUFVZzBCSUFWQkNXb2dDRUVJYWlBS0VCMUJDR29oQkNBQUlBaHJJUVlnQ1NBTFRDQUFJQU5OY2cwQ0EwQWdBRUYvYWlJRkxRQUFJQWhCZjJvaUNDMEFBRWNOQXlBRVFRRnFJUVFnQlNBRFRRUkFJQVVoQUF3RUN5QUZJUUFnQ0NBT1N3MEFDd3dDQ3lBZElBaEJBblJxS0FJQUlna2dHa3dOQUNBSklCQnFJZ2dwQUFBZ0FDa0FBRklOQUNBRlFRbHFJQWhCQ0dvZ0NpQVBJQTRRSUVFSWFpRUVJQklnQ1dzZ0dXc2hCaUFBSUFOTkRRRURRQ0FBUVg5cUlnVXRBQUFnQ0VGL2FpSUlMUUFBUncwQ0lBUkJBV29oQkNBRklBTk5CRUFnQlNFQURBTUxJQVVoQUNBSUlCWkxEUUFMREFFTElBZEJCR29oQUNBRlFRUnFJUVFnQmlBTFNRUkFJQVFnQUNBS0lBOGdEaEFnUVFScUlRUWdGU0FHYXlFR0lBVWdBMDBFUUNBRklRQU1BZ3NnQnlBV1RRUkFJQVVoQUF3Q0N3TkFJQVZCZjJvaUFDMEFBQ0FIUVg5cUlnY3RBQUJIQkVBZ0JTRUFEQU1MSUFSQkFXb2hCQ0FBSUFOTkRRSWdBQ0VGSUFjZ0Zrc05BQXNNQVFzZ0JDQUFJQW9RSFVFRWFpRUVJQVVnQjJzaEJpQUZJQU5OQkVBZ0JTRUFEQUVMSUFjZ0RrMEVRQ0FGSVFBTUFRc0RRQ0FGUVg5cUlnQXRBQUFnQjBGL2FpSUhMUUFBUndSQUlBVWhBQXdDQ3lBRVFRRnFJUVFnQUNBRFRRMEJJQUFoQlNBSElBNUxEUUFMQ3lBRVFYMXFJUWNnQUNBRGF5RUpJQUVvQWd3aEJRSkFBa0FnQUNBUlRRUkFJQVVnQXhBY0lBRW9BZ3doQ0NBSlFSQk5CRUFnQVNBSUlBbHFOZ0lNREFNTElBaEJFR29nQTBFUWFpSUZFQndnQ0VFZ2FpQURRU0JxRUJ3Z0NVRXhTQTBCSUFnZ0NXb2hFaUFJUVRCcUlRTURRQ0FESUFWQklHb2lDQkFjSUFOQkVHb2dCVUV3YWhBY0lBZ2hCU0FEUVNCcUlnTWdFa2tOQUFzTUFRc2dCU0FESUFBZ0VSQWlDeUFCSUFFb0Fnd2dDV28yQWd3Z0NVR0FnQVJKRFFBZ0FVRUJOZ0lrSUFFZ0FTZ0NCQ0FCS0FJQWEwRURkVFlDS0FzZ0FTZ0NCQ0lESUFaQkEybzJBZ0FnQXlBSk93RUVJQWRCZ0lBRVR3UkFJQUZCQWpZQ0pDQUJJQU1nQVNnQ0FHdEJBM1UyQWlnTElBMGhDQ0FHSVEwTElBTWdCenNCQmlBQklBTkJDR28yQWdRZ0FDQUVhaUlESUJ0TEJFQWdBeUVGREFFTElCUWdEQ0FWUVFKcUlnQnFJZ1FnRTBFSUVCNUJBblJxSUFBMkFnQWdGQ0FEUVg1cUlnVWdFMEVJRUI1QkFuUnFJQVVnREdzMkFnQWdHQ0FFSUJkQkJ4QWVRUUowYWlBQU5nSUFJQmdnQTBGL2FpSUFJQmRCQnhBZVFRSjBhaUFBSUF4ck5nSUFJQTBoQkNBSUlRQURRQUpBSUFBaERTQUVJUUFnQ3lBRElBeHJJZ1VnRFdzaUJFRi9jMnBCQTBrTkFDQUVJQ0FnRENBRUlBdEpJZ2diYWlJRUtBQUFJQU1vQUFCSERRQWdBMEVFYWlBRVFRUnFJQW9nRHlBS0lBZ2JJQTRRSUNJR1FRRnFJUWdnQVNnQ0RDRUVBa0FnQXlBUlRRUkFJQVFnQXhBY0RBRUxJQVFnQXlBRElCRVFJZ3NnQVNnQ0JDSUVRUUUyQWdBZ0JFRUFPd0VFSUFoQmdJQUVUd1JBSUFGQkFqWUNKQ0FCSUFRZ0FTZ0NBR3RCQTNVMkFpZ0xJQVFnQ0RzQkJpQUJJQVJCQ0dvMkFnUWdHQ0FESUJkQkJ4QWVRUUowYWlBRk5nSUFJQlFnQXlBVFFRZ1FIa0VDZEdvZ0JUWUNBQ0FOSVFRZ0FDRUlJQVpCQkdvZ0Eyb2lBeUVGSUFNZ0cwME5BUXdDQ3dzZ0RTRUlJQUFoRFNBRElRVUxJQVVnRzBrTkFBc0xEQUlMSUFJb0FnUWhDQ0FDS0FJQUlRMGdBeUFBS0FKd0lnWW9BZ0FpRHlBRElBQW9BZ1FpRENBRElBeHJJQVJxSWdWQkFTQUFLQUowZENJSGF5QUFLQUlNSWdvZ0JTQUtheUFIU3hzaUMyb2lEbXRxSUFZb0FnUWlFQ0FHS0FJTUlocHFJaFpHYWlJRklBTWdCR29pQ2tGNGFpSWJTUVJBSUFBb0FuZ2hGeUFBS0FKOElSTWdCaWdDZUNFZUlBWW9BbndoSENBQUtBSW9JUmdnQUNnQ0lDRVVJQVlvQWlnaEh5QUdLQUlnSVIwZ0VDQUxJQkJxSUE5cklobHJJU0FnQ2tGZ2FpRVJBMEFnQlNBVFFRZ1FIaUVBSUFVZ0YwRUdFQjRoQkNBRklCeEJDQkFlSVFjZ0JTQWVRUVlRSGlFaElCUWdBRUVDZEdvaUFDZ0NBQ0VKSUJnZ0JFRUNkR29pQkNnQ0FDRUdJQVFnQlNBTWF5SVZOZ0lBSUFBZ0ZUWUNBQUpBQWtBQ1FDQUxJQlZCQVdvaUVpQU5heUlBUVg5emFrRURTUTBBSUJBZ0FDQVphMm9nQUNBTWFpQUFJQXRKSWdRYklpSW9BQUFnQlVFQmFpSUFLQUFBUncwQUlBVkJCV29nSWtFRWFpQUtJQThnQ2lBRUd5QU9FQ0FpQ1VFQmFpRUhJQUFnQTJzaEJpQUJLQUlNSVFRQ1FBSkFJQUFnRVUwRVFDQUVJQU1RSENBQktBSU1JUVFnQmtFUVRRUkFJQUVnQkNBR2FqWUNEQXdEQ3lBRVFSQnFJQU5CRUdvaUJSQWNJQVJCSUdvZ0EwRWdhaEFjSUFaQk1VZ05BU0FFSUFacUlSSWdCRUV3YWlFREEwQWdBeUFGUVNCcUlnUVFIQ0FEUVJCcUlBVkJNR29RSENBRUlRVWdBMEVnYWlJRElCSkpEUUFMREFFTElBUWdBeUFBSUJFUUlnc2dBU0FCS0FJTUlBWnFOZ0lNSUFaQmdJQUVTUTBBSUFGQkFUWUNKQ0FCSUFFb0FnUWdBU2dDQUd0QkEzVTJBaWdMSUFsQkJHb2hCQ0FCS0FJRUlnTkJBVFlDQUNBRElBWTdBUVFnQjBHQWdBUkpEUUVnQVVFQ05nSWtJQUVnQXlBQktBSUFhMEVEZFRZQ0tBd0JDd0pBQWtBQ1FBSkFBa0FDUUNBSklBdExCRUFnQ1NBTWFpSUhLUUFBSUFVcEFBQlNEUUVnQlVFSWFpQUhRUWhxSUFvUUhVRUlhaUVFSUFVZ0Iyc2hCaUFGSUFOTkJFQWdCU0VBREFjTElBa2dDMHdFUUNBRklRQU1Cd3NEUUNBRlFYOXFJZ0F0QUFBZ0IwRi9haUlITFFBQVJ3UkFJQVVoQUF3SUN5QUVRUUZxSVFRZ0FDQURUUTBISUFBaEJTQUhJQTVMRFFBTERBWUxBa0FnSFNBSFFRSjBhaWdDQUNJQUlCcE1EUUFnQUNBUWFpSUhLUUFBSUFVcEFBQlNEUUFnQlVFSWFpQUhRUWhxSUFvZ0R5QU9FQ0JCQ0dvaEJDQVZJQUJySUJscklRWWdCU0FEVFFSQUlBVWhBQXdIQ3dOQUlBVkJmMm9pQUMwQUFDQUhRWDlxSWdjdEFBQkhCRUFnQlNFQURBZ0xJQVJCQVdvaEJDQUFJQU5ORFFjZ0FDRUZJQWNnRmtzTkFBc01CZ3NnQmlBTFRRMEJEQUlMSUFZZ0Mwc05BUXNnSHlBaFFRSjBhaWdDQUNJQUlCcE1EUUVnQUNBUWFpSUhLQUFBSUFVb0FBQkhEUUVnQUNBWmFpRUdEQUlMSUFZZ0RHb2lCeWdBQUNBRktBQUFSZzBCQ3lBRklBTnJRUWgxSUFWcVFRRnFJUVVNQXdzZ0JVRUJhaUlBSUJOQkNCQWVJUVFnQUNBY1FRZ1FIaUVJSUJRZ0JFRUNkR29pQkNnQ0FDRUpJQVFnRWpZQ0FBSkFJQWtnQzBzRVFDQUpJQXhxSWdncEFBQWdBQ2tBQUZJTkFTQUZRUWxxSUFoQkNHb2dDaEFkUVFocUlRUWdBQ0FJYXlFR0lBa2dDMHdnQUNBRFRYSU5BZ05BSUFCQmYyb2lCUzBBQUNBSVFYOXFJZ2d0QUFCSERRTWdCRUVCYWlFRUlBVWdBMDBFUUNBRklRQU1CQXNnQlNFQUlBZ2dEa3NOQUFzTUFnc2dIU0FJUVFKMGFpZ0NBQ0lKSUJwTURRQWdDU0FRYWlJSUtRQUFJQUFwQUFCU0RRQWdCVUVKYWlBSVFRaHFJQW9nRHlBT0VDQkJDR29oQkNBU0lBbHJJQmxySVFZZ0FDQURUUTBCQTBBZ0FFRi9haUlGTFFBQUlBaEJmMm9pQ0MwQUFFY05BaUFFUVFGcUlRUWdCU0FEVFFSQUlBVWhBQXdEQ3lBRklRQWdDQ0FXU3cwQUN3d0JDeUFIUVFScUlRQWdCVUVFYWlFRUlBWWdDMGtFUUNBRUlBQWdDaUFQSUE0UUlFRUVhaUVFSUJVZ0Jtc2hCaUFGSUFOTkJFQWdCU0VBREFJTElBY2dGazBFUUNBRklRQU1BZ3NEUUNBRlFYOXFJZ0F0QUFBZ0IwRi9haUlITFFBQVJ3UkFJQVVoQUF3REN5QUVRUUZxSVFRZ0FDQURUUTBDSUFBaEJTQUhJQlpMRFFBTERBRUxJQVFnQUNBS0VCMUJCR29oQkNBRklBZHJJUVlnQlNBRFRRUkFJQVVoQUF3QkN5QUhJQTVOQkVBZ0JTRUFEQUVMQTBBZ0JVRi9haUlBTFFBQUlBZEJmMm9pQnkwQUFFY0VRQ0FGSVFBTUFnc2dCRUVCYWlFRUlBQWdBMDBOQVNBQUlRVWdCeUFPU3cwQUN3c2dCRUY5YWlFSElBQWdBMnNoQ1NBQktBSU1JUVVDUUFKQUlBQWdFVTBFUUNBRklBTVFIQ0FCS0FJTUlRZ2dDVUVRVFFSQUlBRWdDQ0FKYWpZQ0RBd0RDeUFJUVJCcUlBTkJFR29pQlJBY0lBaEJJR29nQTBFZ2FoQWNJQWxCTVVnTkFTQUlJQWxxSVJJZ0NFRXdhaUVEQTBBZ0F5QUZRU0JxSWdnUUhDQURRUkJxSUFWQk1Hb1FIQ0FJSVFVZ0EwRWdhaUlESUJKSkRRQUxEQUVMSUFVZ0F5QUFJQkVRSWdzZ0FTQUJLQUlNSUFscU5nSU1JQWxCZ0lBRVNRMEFJQUZCQVRZQ0pDQUJJQUVvQWdRZ0FTZ0NBR3RCQTNVMkFpZ0xJQUVvQWdRaUF5QUdRUU5xTmdJQUlBTWdDVHNCQkNBSFFZQ0FCRThFUUNBQlFRSTJBaVFnQVNBRElBRW9BZ0JyUVFOMU5nSW9DeUFOSVFnZ0JpRU5DeUFESUFjN0FRWWdBU0FEUVFocU5nSUVJQUFnQkdvaUF5QWJTd1JBSUFNaEJRd0JDeUFVSUF3Z0ZVRUNhaUlBYWlJRUlCTkJDQkFlUVFKMGFpQUFOZ0lBSUJRZ0EwRithaUlGSUJOQkNCQWVRUUowYWlBRklBeHJOZ0lBSUJnZ0JDQVhRUVlRSGtFQ2RHb2dBRFlDQUNBWUlBTkJmMm9pQUNBWFFRWVFIa0VDZEdvZ0FDQU1hellDQUNBTklRUWdDQ0VBQTBBQ1FDQUFJUTBnQkNFQUlBc2dBeUFNYXlJRklBMXJJZ1JCZjNOcVFRTkpEUUFnQkNBZ0lBd2dCQ0FMU1NJSUcyb2lCQ2dBQUNBREtBQUFSdzBBSUFOQkJHb2dCRUVFYWlBS0lBOGdDaUFJR3lBT0VDQWlCa0VCYWlFSUlBRW9BZ3doQkFKQUlBTWdFVTBFUUNBRUlBTVFIQXdCQ3lBRUlBTWdBeUFSRUNJTElBRW9BZ1FpQkVFQk5nSUFJQVJCQURzQkJDQUlRWUNBQkU4RVFDQUJRUUkyQWlRZ0FTQUVJQUVvQWdCclFRTjFOZ0lvQ3lBRUlBZzdBUVlnQVNBRVFRaHFOZ0lFSUJnZ0F5QVhRUVlRSGtFQ2RHb2dCVFlDQUNBVUlBTWdFMEVJRUI1QkFuUnFJQVUyQWdBZ0RTRUVJQUFoQ0NBR1FRUnFJQU5xSWdNaEJTQURJQnRORFFFTUFnc0xJQTBoQ0NBQUlRMGdBeUVGQ3lBRklCdEpEUUFMQ3d3QkN5QUNLQUlFSVFnZ0FpZ0NBQ0VOSUFNZ0FDZ0NjQ0lHS0FJQUlnOGdBeUFBS0FJRUlnd2dBeUFNYXlBRWFpSUZRUUVnQUNnQ2RIUWlCMnNnQUNnQ0RDSUtJQVVnQ21zZ0Iwc2JJZ3BxSWc1cmFpQUdLQUlFSWhBZ0JpZ0NEQ0lhYWlJV1Jtb2lCU0FESUFScUlndEJlR29pRzBrRVFDQUFLQUo0SVJjZ0FDZ0NmQ0VUSUFZb0FuZ2hIaUFHS0FKOElSd2dBQ2dDS0NFWUlBQW9BaUFoRkNBR0tBSW9JUjhnQmlnQ0lDRWRJQkFnQ2lBUWFpQVBheUlaYXlFZ0lBdEJZR29oRVFOQUlBVWdFMEVJRUI0aEFDQUZJQmRCQlJBZUlRUWdCU0FjUVFnUUhpRUhJQVVnSGtFRkVCNGhJU0FVSUFCQkFuUnFJZ0FvQWdBaENTQVlJQVJCQW5ScUlnUW9BZ0FoQmlBRUlBVWdER3NpRlRZQ0FDQUFJQlUyQWdBQ1FBSkFBa0FnQ2lBVlFRRnFJaElnRFdzaUFFRi9jMnBCQTBrTkFDQVFJQUFnR1d0cUlBQWdER29nQUNBS1NTSUVHeUlpS0FBQUlBVkJBV29pQUNnQUFFY05BQ0FGUVFWcUlDSkJCR29nQ3lBUElBc2dCQnNnRGhBZ0lnbEJBV29oQnlBQUlBTnJJUVlnQVNnQ0RDRUVBa0FDUUNBQUlCRk5CRUFnQkNBREVCd2dBU2dDRENFRUlBWkJFRTBFUUNBQklBUWdCbW8yQWd3TUF3c2dCRUVRYWlBRFFSQnFJZ1VRSENBRVFTQnFJQU5CSUdvUUhDQUdRVEZJRFFFZ0JDQUdhaUVTSUFSQk1Hb2hBd05BSUFNZ0JVRWdhaUlFRUJ3Z0EwRVFhaUFGUVRCcUVCd2dCQ0VGSUFOQklHb2lBeUFTU1EwQUN3d0JDeUFFSUFNZ0FDQVJFQ0lMSUFFZ0FTZ0NEQ0FHYWpZQ0RDQUdRWUNBQkVrTkFDQUJRUUUyQWlRZ0FTQUJLQUlFSUFFb0FnQnJRUU4xTmdJb0N5QUpRUVJxSVFRZ0FTZ0NCQ0lEUVFFMkFnQWdBeUFHT3dFRUlBZEJnSUFFU1EwQklBRkJBallDSkNBQklBTWdBU2dDQUd0QkEzVTJBaWdNQVFzQ1FBSkFBa0FDUUFKQUFrQWdDU0FLU3dSQUlBa2dER29pQnlrQUFDQUZLUUFBVWcwQklBVkJDR29nQjBFSWFpQUxFQjFCQ0dvaEJDQUZJQWRySVFZZ0JTQURUUVJBSUFVaEFBd0hDeUFKSUFwTUJFQWdCU0VBREFjTEEwQWdCVUYvYWlJQUxRQUFJQWRCZjJvaUJ5MEFBRWNFUUNBRklRQU1DQXNnQkVFQmFpRUVJQUFnQTAwTkJ5QUFJUVVnQnlBT1N3MEFDd3dHQ3dKQUlCMGdCMEVDZEdvb0FnQWlBQ0FhVEEwQUlBQWdFR29pQnlrQUFDQUZLUUFBVWcwQUlBVkJDR29nQjBFSWFpQUxJQThnRGhBZ1FRaHFJUVFnRlNBQWF5QVpheUVHSUFVZ0EwMEVRQ0FGSVFBTUJ3c0RRQ0FGUVg5cUlnQXRBQUFnQjBGL2FpSUhMUUFBUndSQUlBVWhBQXdJQ3lBRVFRRnFJUVFnQUNBRFRRMEhJQUFoQlNBSElCWkxEUUFMREFZTElBWWdDazBOQVF3Q0N5QUdJQXBMRFFFTElCOGdJVUVDZEdvb0FnQWlBQ0FhVEEwQklBQWdFR29pQnlnQUFDQUZLQUFBUncwQklBQWdHV29oQmd3Q0N5QUdJQXhxSWdjb0FBQWdCU2dBQUVZTkFRc2dCU0FEYTBFSWRTQUZha0VCYWlFRkRBTUxJQVZCQVdvaUFDQVRRUWdRSGlFRUlBQWdIRUVJRUI0aENDQVVJQVJCQW5ScUlnUW9BZ0FoQ1NBRUlCSTJBZ0FDUUNBSklBcExCRUFnQ1NBTWFpSUlLUUFBSUFBcEFBQlNEUUVnQlVFSmFpQUlRUWhxSUFzUUhVRUlhaUVFSUFBZ0NHc2hCaUFKSUFwTUlBQWdBMDF5RFFJRFFDQUFRWDlxSWdVdEFBQWdDRUYvYWlJSUxRQUFSdzBESUFSQkFXb2hCQ0FGSUFOTkJFQWdCU0VBREFRTElBVWhBQ0FJSUE1TERRQUxEQUlMSUIwZ0NFRUNkR29vQWdBaUNTQWFUQTBBSUFrZ0VHb2lDQ2tBQUNBQUtRQUFVZzBBSUFWQkNXb2dDRUVJYWlBTElBOGdEaEFnUVFocUlRUWdFaUFKYXlBWmF5RUdJQUFnQTAwTkFRTkFJQUJCZjJvaUJTMEFBQ0FJUVg5cUlnZ3RBQUJIRFFJZ0JFRUJhaUVFSUFVZ0EwMEVRQ0FGSVFBTUF3c2dCU0VBSUFnZ0Zrc05BQXNNQVFzZ0IwRUVhaUVBSUFWQkJHb2hCQ0FHSUFwSkJFQWdCQ0FBSUFzZ0R5QU9FQ0JCQkdvaEJDQVZJQVpySVFZZ0JTQURUUVJBSUFVaEFBd0NDeUFISUJaTkJFQWdCU0VBREFJTEEwQWdCVUYvYWlJQUxRQUFJQWRCZjJvaUJ5MEFBRWNFUUNBRklRQU1Bd3NnQkVFQmFpRUVJQUFnQTAwTkFpQUFJUVVnQnlBV1N3MEFDd3dCQ3lBRUlBQWdDeEFkUVFScUlRUWdCU0FIYXlFR0lBVWdBMDBFUUNBRklRQU1BUXNnQnlBT1RRUkFJQVVoQUF3QkN3TkFJQVZCZjJvaUFDMEFBQ0FIUVg5cUlnY3RBQUJIQkVBZ0JTRUFEQUlMSUFSQkFXb2hCQ0FBSUFOTkRRRWdBQ0VGSUFjZ0Rrc05BQXNMSUFSQmZXb2hCeUFBSUFOcklRa2dBU2dDRENFRkFrQUNRQ0FBSUJGTkJFQWdCU0FERUJ3Z0FTZ0NEQ0VJSUFsQkVFMEVRQ0FCSUFnZ0NXbzJBZ3dNQXdzZ0NFRVFhaUFEUVJCcUlnVVFIQ0FJUVNCcUlBTkJJR29RSENBSlFURklEUUVnQ0NBSmFpRVNJQWhCTUdvaEF3TkFJQU1nQlVFZ2FpSUlFQndnQTBFUWFpQUZRVEJxRUJ3Z0NDRUZJQU5CSUdvaUF5QVNTUTBBQ3d3QkN5QUZJQU1nQUNBUkVDSUxJQUVnQVNnQ0RDQUphallDRENBSlFZQ0FCRWtOQUNBQlFRRTJBaVFnQVNBQktBSUVJQUVvQWdCclFRTjFOZ0lvQ3lBQktBSUVJZ01nQmtFRGFqWUNBQ0FESUFrN0FRUWdCMEdBZ0FSUEJFQWdBVUVDTmdJa0lBRWdBeUFCS0FJQWEwRURkVFlDS0FzZ0RTRUlJQVloRFFzZ0F5QUhPd0VHSUFFZ0EwRUlhallDQkNBQUlBUnFJZ01nRzBzRVFDQURJUVVNQVFzZ0ZDQU1JQlZCQW1vaUFHb2lCQ0FUUVFnUUhrRUNkR29nQURZQ0FDQVVJQU5CZm1vaUJTQVRRUWdRSGtFQ2RHb2dCU0FNYXpZQ0FDQVlJQVFnRjBFRkVCNUJBblJxSUFBMkFnQWdHQ0FEUVg5cUlnQWdGMEVGRUI1QkFuUnFJQUFnREdzMkFnQWdEU0VFSUFnaEFBTkFBa0FnQUNFTklBUWhBQ0FLSUFNZ0RHc2lCU0FOYXlJRVFYOXpha0VEU1EwQUlBUWdJQ0FNSUFRZ0Nra2lDQnRxSWdRb0FBQWdBeWdBQUVjTkFDQURRUVJxSUFSQkJHb2dDeUFQSUFzZ0NCc2dEaEFnSWdaQkFXb2hDQ0FCS0FJTUlRUUNRQ0FESUJGTkJFQWdCQ0FERUJ3TUFRc2dCQ0FESUFNZ0VSQWlDeUFCS0FJRUlnUkJBVFlDQUNBRVFRQTdBUVFnQ0VHQWdBUlBCRUFnQVVFQ05nSWtJQUVnQkNBQktBSUFhMEVEZFRZQ0tBc2dCQ0FJT3dFR0lBRWdCRUVJYWpZQ0JDQVlJQU1nRjBFRkVCNUJBblJxSUFVMkFnQWdGQ0FESUJOQkNCQWVRUUowYWlBRk5nSUFJQTBoQkNBQUlRZ2dCa0VFYWlBRGFpSURJUVVnQXlBYlRRMEJEQUlMQ3lBTklRZ2dBQ0VOSUFNaEJRc2dCU0FiU1EwQUN3c2dBaUFJTmdJRUlBSWdEVFlDQUNBTElBTnJEd3NnQWlBSU5nSUVJQUlnRFRZQ0FDQUtJQU5yQys0MkFSTi9BbjhDUUFKQUFrQUNRQ0FBS0FLRUFVRjdhZzREQXdJQkFBc2dBaWdDQUNJSUlBSW9BZ1FpQjBFQUlBY2dBeUFBS0FJRUlnMGdBeUFOYXlBRWFpSUZRUUVnQUNnQ2RIUWlCbXNnQUNnQ0RDSUpJQVVnQ1dzZ0Jrc2JJZzVxSWhJZ0EwWnFJZ1VnRW1zaUJrc2lDUnNnQ0NBR1N5SUdHeUVYUVFBZ0NDQUdHeUVJUVFBZ0J5QUpHeUVISUFVZ0F5QUVhaUlFUVhocUloVkpCRUFnQUNnQ2VDRVRJQUFvQW53aEVDQUFLQUlvSVJRZ0FDZ0NJQ0VSSUFSQllHb2hEd05BSUFVZ0VFRUlFQjRoQUNBVUlBVWdFMEVFRUI1QkFuUnFJZ1lvQWdBaEN5QVJJQUJCQW5ScUlnQW9BZ0FoRENBR0lBVWdEV3NpRmpZQ0FDQUFJQlkyQWdBQ1FBSkFJQWhGSUFWQkFXb2lBQ0FJYXlnQUFDQUFLQUFBUjNKRkJFQWdCVUVGYWlJRklBVWdDR3NnQkJBZElndEJBV29oQ2lBQUlBTnJJUWtnQVNnQ0RDRUZBa0FDUUNBQUlBOU5CRUFnQlNBREVCd2dBU2dDRENFR0lBbEJFRTBFUUNBQklBWWdDV28yQWd3TUF3c2dCa0VRYWlBRFFSQnFJZ1VRSENBR1FTQnFJQU5CSUdvUUhDQUpRVEZJRFFFZ0JpQUphaUVNSUFaQk1Hb2hBd05BSUFNZ0JVRWdhaUlHRUJ3Z0EwRVFhaUFGUVRCcUVCd2dCaUVGSUFOQklHb2lBeUFNU1EwQUN3d0JDeUFGSUFNZ0FDQVBFQ0lMSUFFZ0FTZ0NEQ0FKYWpZQ0RDQUpRWUNBQkVrTkFDQUJRUUUyQWlRZ0FTQUJLQUlFSUFFb0FnQnJRUU4xTmdJb0N5QUxRUVJxSVFZZ0FTZ0NCQ0lEUVFFMkFnQWdBeUFKT3dFRUlBcEJnSUFFU1EwQklBRkJBallDSkNBQklBTWdBU2dDQUd0QkEzVTJBaWdNQVFzQ1FBSkFBa0FDUUFKQUlBd2dEa3NFUUNBTUlBMXFJZ29wQUFBZ0JTa0FBRklOQVNBRlFRaHFJQXBCQ0dvZ0JCQWRRUWhxSVFZZ0JTQUtheUVKSUFVZ0EwMEVRQ0FGSVFBTUJnc2dEQ0FPVEFSQUlBVWhBQXdHQ3dOQUlBVkJmMm9pQUMwQUFDQUtRWDlxSWdvdEFBQkhCRUFnQlNFQURBY0xJQVpCQVdvaEJpQUFJQU5ORFFZZ0FDRUZJQW9nRWtzTkFBc01CUXNnQ3lBT1N3MEJEQUlMSUFzZ0RrME5BUXNnQ3lBTmFpSUtLQUFBSUFVb0FBQkdEUUVMSUFVZ0EydEJDSFVnQldwQkFXb2hCUXdEQ3lBUklBQWdFRUVJRUI1QkFuUnFJZ2NvQWdBaERDQUhJQlpCQVdvMkFnQUNRQ0FNSUE1TkRRQWdEQ0FOYWlJSEtRQUFJQUFwQUFCU0RRQWdCVUVKYWlBSFFRaHFJQVFRSFVFSWFpRUdJQUFnQjJzaENTQU1JQTVNSUFBZ0EwMXlEUUVEUUNBQVFYOXFJZ1V0QUFBZ0IwRi9haUlITFFBQVJ3MENJQVpCQVdvaEJpQUZJQU5OQkVBZ0JTRUFEQU1MSUFVaEFDQUhJQkpMRFFBTERBRUxJQVZCQkdvZ0NrRUVhaUFFRUIxQkJHb2hCaUFGSUFwcklRa2dCU0FEVFFSQUlBVWhBQXdCQ3lBTElBNU1CRUFnQlNFQURBRUxBMEFnQlVGL2FpSUFMUUFBSUFwQmYyb2lDaTBBQUVjRVFDQUZJUUFNQWdzZ0JrRUJhaUVHSUFBZ0EwME5BU0FBSVFVZ0NpQVNTdzBBQ3dzZ0JrRjlhaUVLSUFBZ0Eyc2hDeUFCS0FJTUlRVUNRQUpBSUFBZ0QwMEVRQ0FGSUFNUUhDQUJLQUlNSVFjZ0MwRVFUUVJBSUFFZ0J5QUxhallDREF3REN5QUhRUkJxSUFOQkVHb2lCUkFjSUFkQklHb2dBMEVnYWhBY0lBdEJNVWdOQVNBSElBdHFJUXdnQjBFd2FpRURBMEFnQXlBRlFTQnFJZ2NRSENBRFFSQnFJQVZCTUdvUUhDQUhJUVVnQTBFZ2FpSURJQXhKRFFBTERBRUxJQVVnQXlBQUlBOFFJZ3NnQVNBQktBSU1JQXRxTmdJTUlBdEJnSUFFU1EwQUlBRkJBVFlDSkNBQklBRW9BZ1FnQVNnQ0FHdEJBM1UyQWlnTElBRW9BZ1FpQXlBSlFRTnFOZ0lBSUFNZ0N6c0JCQ0FLUVlDQUJFOEVRQ0FCUVFJMkFpUWdBU0FESUFFb0FnQnJRUU4xTmdJb0N5QUlJUWNnQ1NFSUN5QURJQW83QVFZZ0FTQURRUWhxTmdJRUlBQWdCbW9pQXlBVlN3UkFJQU1oQlF3QkN5QVJJQTBnRmtFQ2FpSUFhaUlGSUJCQkNCQWVRUUowYWlBQU5nSUFJQkVnQTBGK2FpSUdJQkJCQ0JBZVFRSjBhaUFHSUExck5nSUFJQlFnQlNBVFFRUVFIa0VDZEdvZ0FEWUNBQ0FVSUFOQmYyb2lBQ0FUUVFRUUhrRUNkR29nQUNBTmF6WUNBQ0FJSVFZZ0J5RUFBMEFDUUNBQUlRZ2dCaUVBSUFoRklBTW9BQUFnQXlBSWF5Z0FBRWR5RFFBZ0EwRUVhaUlGSUFVZ0NHc2dCQkFkSVFrZ0ZDQURJQk5CQkJBZVFRSjBhaUFESUExcklnVTJBZ0FnRVNBRElCQkJDQkFlUVFKMGFpQUZOZ0lBSUFsQkFXb2hCeUFCS0FJTUlRVUNRQ0FESUE5TkJFQWdCU0FERUJ3TUFRc2dCU0FESUFNZ0R4QWlDeUFCS0FJRUlnVkJBVFlDQUNBRlFRQTdBUVFnQjBHQWdBUlBCRUFnQVVFQ05nSWtJQUVnQlNBQktBSUFhMEVEZFRZQ0tBc2dCU0FIT3dFR0lBRWdCVUVJYWpZQ0JDQUlJUVlnQUNFSElBbEJCR29nQTJvaUF5RUZJQU1nRlUwTkFRd0NDd3NnQ0NFSElBQWhDQ0FESVFVTElBVWdGVWtOQUFzTElBSWdDQ0FYSUFnYk5nSUFJQWNnRnlBSEd5RUlJQUpCQkdvTUF3c2dBaWdDQUNJSUlBSW9BZ1FpQjBFQUlBY2dBeUFBS0FJRUlnMGdBeUFOYXlBRWFpSUZRUUVnQUNnQ2RIUWlCbXNnQUNnQ0RDSUpJQVVnQ1dzZ0Jrc2JJZzVxSWhJZ0EwWnFJZ1VnRW1zaUJrc2lDUnNnQ0NBR1N5SUdHeUVYUVFBZ0NDQUdHeUVJUVFBZ0J5QUpHeUVISUFVZ0F5QUVhaUlFUVhocUloVkpCRUFnQUNnQ2VDRVRJQUFvQW53aEVDQUFLQUlvSVJRZ0FDZ0NJQ0VSSUFSQllHb2hEd05BSUFVZ0VFRUlFQjRoQUNBVUlBVWdFMEVIRUI1QkFuUnFJZ1lvQWdBaEN5QVJJQUJCQW5ScUlnQW9BZ0FoRENBR0lBVWdEV3NpRmpZQ0FDQUFJQlkyQWdBQ1FBSkFJQWhGSUFWQkFXb2lBQ0FJYXlnQUFDQUFLQUFBUjNKRkJFQWdCVUVGYWlJRklBVWdDR3NnQkJBZElndEJBV29oQ2lBQUlBTnJJUWtnQVNnQ0RDRUZBa0FDUUNBQUlBOU5CRUFnQlNBREVCd2dBU2dDRENFR0lBbEJFRTBFUUNBQklBWWdDV28yQWd3TUF3c2dCa0VRYWlBRFFSQnFJZ1VRSENBR1FTQnFJQU5CSUdvUUhDQUpRVEZJRFFFZ0JpQUphaUVNSUFaQk1Hb2hBd05BSUFNZ0JVRWdhaUlHRUJ3Z0EwRVFhaUFGUVRCcUVCd2dCaUVGSUFOQklHb2lBeUFNU1EwQUN3d0JDeUFGSUFNZ0FDQVBFQ0lMSUFFZ0FTZ0NEQ0FKYWpZQ0RDQUpRWUNBQkVrTkFDQUJRUUUyQWlRZ0FTQUJLQUlFSUFFb0FnQnJRUU4xTmdJb0N5QUxRUVJxSVFZZ0FTZ0NCQ0lEUVFFMkFnQWdBeUFKT3dFRUlBcEJnSUFFU1EwQklBRkJBallDSkNBQklBTWdBU2dDQUd0QkEzVTJBaWdNQVFzQ1FBSkFBa0FDUUFKQUlBd2dEa3NFUUNBTUlBMXFJZ29wQUFBZ0JTa0FBRklOQVNBRlFRaHFJQXBCQ0dvZ0JCQWRRUWhxSVFZZ0JTQUtheUVKSUFVZ0EwMEVRQ0FGSVFBTUJnc2dEQ0FPVEFSQUlBVWhBQXdHQ3dOQUlBVkJmMm9pQUMwQUFDQUtRWDlxSWdvdEFBQkhCRUFnQlNFQURBY0xJQVpCQVdvaEJpQUFJQU5ORFFZZ0FDRUZJQW9nRWtzTkFBc01CUXNnQ3lBT1N3MEJEQUlMSUFzZ0RrME5BUXNnQ3lBTmFpSUtLQUFBSUFVb0FBQkdEUUVMSUFVZ0EydEJDSFVnQldwQkFXb2hCUXdEQ3lBUklBQWdFRUVJRUI1QkFuUnFJZ2NvQWdBaERDQUhJQlpCQVdvMkFnQUNRQ0FNSUE1TkRRQWdEQ0FOYWlJSEtRQUFJQUFwQUFCU0RRQWdCVUVKYWlBSFFRaHFJQVFRSFVFSWFpRUdJQUFnQjJzaENTQU1JQTVNSUFBZ0EwMXlEUUVEUUNBQVFYOXFJZ1V0QUFBZ0IwRi9haUlITFFBQVJ3MENJQVpCQVdvaEJpQUZJQU5OQkVBZ0JTRUFEQU1MSUFVaEFDQUhJQkpMRFFBTERBRUxJQVZCQkdvZ0NrRUVhaUFFRUIxQkJHb2hCaUFGSUFwcklRa2dCU0FEVFFSQUlBVWhBQXdCQ3lBTElBNU1CRUFnQlNFQURBRUxBMEFnQlVGL2FpSUFMUUFBSUFwQmYyb2lDaTBBQUVjRVFDQUZJUUFNQWdzZ0JrRUJhaUVHSUFBZ0EwME5BU0FBSVFVZ0NpQVNTdzBBQ3dzZ0JrRjlhaUVLSUFBZ0Eyc2hDeUFCS0FJTUlRVUNRQUpBSUFBZ0QwMEVRQ0FGSUFNUUhDQUJLQUlNSVFjZ0MwRVFUUVJBSUFFZ0J5QUxhallDREF3REN5QUhRUkJxSUFOQkVHb2lCUkFjSUFkQklHb2dBMEVnYWhBY0lBdEJNVWdOQVNBSElBdHFJUXdnQjBFd2FpRURBMEFnQXlBRlFTQnFJZ2NRSENBRFFSQnFJQVZCTUdvUUhDQUhJUVVnQTBFZ2FpSURJQXhKRFFBTERBRUxJQVVnQXlBQUlBOFFJZ3NnQVNBQktBSU1JQXRxTmdJTUlBdEJnSUFFU1EwQUlBRkJBVFlDSkNBQklBRW9BZ1FnQVNnQ0FHdEJBM1UyQWlnTElBRW9BZ1FpQXlBSlFRTnFOZ0lBSUFNZ0N6c0JCQ0FLUVlDQUJFOEVRQ0FCUVFJMkFpUWdBU0FESUFFb0FnQnJRUU4xTmdJb0N5QUlJUWNnQ1NFSUN5QURJQW83QVFZZ0FTQURRUWhxTmdJRUlBQWdCbW9pQXlBVlN3UkFJQU1oQlF3QkN5QVJJQTBnRmtFQ2FpSUFhaUlGSUJCQkNCQWVRUUowYWlBQU5nSUFJQkVnQTBGK2FpSUdJQkJCQ0JBZVFRSjBhaUFHSUExck5nSUFJQlFnQlNBVFFRY1FIa0VDZEdvZ0FEWUNBQ0FVSUFOQmYyb2lBQ0FUUVFjUUhrRUNkR29nQUNBTmF6WUNBQ0FJSVFZZ0J5RUFBMEFDUUNBQUlRZ2dCaUVBSUFoRklBTW9BQUFnQXlBSWF5Z0FBRWR5RFFBZ0EwRUVhaUlGSUFVZ0NHc2dCQkFkSVFrZ0ZDQURJQk5CQnhBZVFRSjBhaUFESUExcklnVTJBZ0FnRVNBRElCQkJDQkFlUVFKMGFpQUZOZ0lBSUFsQkFXb2hCeUFCS0FJTUlRVUNRQ0FESUE5TkJFQWdCU0FERUJ3TUFRc2dCU0FESUFNZ0R4QWlDeUFCS0FJRUlnVkJBVFlDQUNBRlFRQTdBUVFnQjBHQWdBUlBCRUFnQVVFQ05nSWtJQUVnQlNBQktBSUFhMEVEZFRZQ0tBc2dCU0FIT3dFR0lBRWdCVUVJYWpZQ0JDQUlJUVlnQUNFSElBbEJCR29nQTJvaUF5RUZJQU1nRlUwTkFRd0NDd3NnQ0NFSElBQWhDQ0FESVFVTElBVWdGVWtOQUFzTElBSWdDQ0FYSUFnYk5nSUFJQWNnRnlBSEd5RUlJQUpCQkdvTUFnc2dBaWdDQUNJSUlBSW9BZ1FpQjBFQUlBY2dBeUFBS0FJRUlnMGdBeUFOYXlBRWFpSUZRUUVnQUNnQ2RIUWlCbXNnQUNnQ0RDSUpJQVVnQ1dzZ0Jrc2JJZzVxSWhJZ0EwWnFJZ1VnRW1zaUJrc2lDUnNnQ0NBR1N5SUdHeUVYUVFBZ0NDQUdHeUVJUVFBZ0J5QUpHeUVISUFVZ0F5QUVhaUlFUVhocUloVkpCRUFnQUNnQ2VDRVRJQUFvQW53aEVDQUFLQUlvSVJRZ0FDZ0NJQ0VSSUFSQllHb2hEd05BSUFVZ0VFRUlFQjRoQUNBVUlBVWdFMEVHRUI1QkFuUnFJZ1lvQWdBaEN5QVJJQUJCQW5ScUlnQW9BZ0FoRENBR0lBVWdEV3NpRmpZQ0FDQUFJQlkyQWdBQ1FBSkFJQWhGSUFWQkFXb2lBQ0FJYXlnQUFDQUFLQUFBUjNKRkJFQWdCVUVGYWlJRklBVWdDR3NnQkJBZElndEJBV29oQ2lBQUlBTnJJUWtnQVNnQ0RDRUZBa0FDUUNBQUlBOU5CRUFnQlNBREVCd2dBU2dDRENFR0lBbEJFRTBFUUNBQklBWWdDV28yQWd3TUF3c2dCa0VRYWlBRFFSQnFJZ1VRSENBR1FTQnFJQU5CSUdvUUhDQUpRVEZJRFFFZ0JpQUphaUVNSUFaQk1Hb2hBd05BSUFNZ0JVRWdhaUlHRUJ3Z0EwRVFhaUFGUVRCcUVCd2dCaUVGSUFOQklHb2lBeUFNU1EwQUN3d0JDeUFGSUFNZ0FDQVBFQ0lMSUFFZ0FTZ0NEQ0FKYWpZQ0RDQUpRWUNBQkVrTkFDQUJRUUUyQWlRZ0FTQUJLQUlFSUFFb0FnQnJRUU4xTmdJb0N5QUxRUVJxSVFZZ0FTZ0NCQ0lEUVFFMkFnQWdBeUFKT3dFRUlBcEJnSUFFU1EwQklBRkJBallDSkNBQklBTWdBU2dDQUd0QkEzVTJBaWdNQVFzQ1FBSkFBa0FDUUFKQUlBd2dEa3NFUUNBTUlBMXFJZ29wQUFBZ0JTa0FBRklOQVNBRlFRaHFJQXBCQ0dvZ0JCQWRRUWhxSVFZZ0JTQUtheUVKSUFVZ0EwMEVRQ0FGSVFBTUJnc2dEQ0FPVEFSQUlBVWhBQXdHQ3dOQUlBVkJmMm9pQUMwQUFDQUtRWDlxSWdvdEFBQkhCRUFnQlNFQURBY0xJQVpCQVdvaEJpQUFJQU5ORFFZZ0FDRUZJQW9nRWtzTkFBc01CUXNnQ3lBT1N3MEJEQUlMSUFzZ0RrME5BUXNnQ3lBTmFpSUtLQUFBSUFVb0FBQkdEUUVMSUFVZ0EydEJDSFVnQldwQkFXb2hCUXdEQ3lBUklBQWdFRUVJRUI1QkFuUnFJZ2NvQWdBaERDQUhJQlpCQVdvMkFnQUNRQ0FNSUE1TkRRQWdEQ0FOYWlJSEtRQUFJQUFwQUFCU0RRQWdCVUVKYWlBSFFRaHFJQVFRSFVFSWFpRUdJQUFnQjJzaENTQU1JQTVNSUFBZ0EwMXlEUUVEUUNBQVFYOXFJZ1V0QUFBZ0IwRi9haUlITFFBQVJ3MENJQVpCQVdvaEJpQUZJQU5OQkVBZ0JTRUFEQU1MSUFVaEFDQUhJQkpMRFFBTERBRUxJQVZCQkdvZ0NrRUVhaUFFRUIxQkJHb2hCaUFGSUFwcklRa2dCU0FEVFFSQUlBVWhBQXdCQ3lBTElBNU1CRUFnQlNFQURBRUxBMEFnQlVGL2FpSUFMUUFBSUFwQmYyb2lDaTBBQUVjRVFDQUZJUUFNQWdzZ0JrRUJhaUVHSUFBZ0EwME5BU0FBSVFVZ0NpQVNTdzBBQ3dzZ0JrRjlhaUVLSUFBZ0Eyc2hDeUFCS0FJTUlRVUNRQUpBSUFBZ0QwMEVRQ0FGSUFNUUhDQUJLQUlNSVFjZ0MwRVFUUVJBSUFFZ0J5QUxhallDREF3REN5QUhRUkJxSUFOQkVHb2lCUkFjSUFkQklHb2dBMEVnYWhBY0lBdEJNVWdOQVNBSElBdHFJUXdnQjBFd2FpRURBMEFnQXlBRlFTQnFJZ2NRSENBRFFSQnFJQVZCTUdvUUhDQUhJUVVnQTBFZ2FpSURJQXhKRFFBTERBRUxJQVVnQXlBQUlBOFFJZ3NnQVNBQktBSU1JQXRxTmdJTUlBdEJnSUFFU1EwQUlBRkJBVFlDSkNBQklBRW9BZ1FnQVNnQ0FHdEJBM1UyQWlnTElBRW9BZ1FpQXlBSlFRTnFOZ0lBSUFNZ0N6c0JCQ0FLUVlDQUJFOEVRQ0FCUVFJMkFpUWdBU0FESUFFb0FnQnJRUU4xTmdJb0N5QUlJUWNnQ1NFSUN5QURJQW83QVFZZ0FTQURRUWhxTmdJRUlBQWdCbW9pQXlBVlN3UkFJQU1oQlF3QkN5QVJJQTBnRmtFQ2FpSUFhaUlGSUJCQkNCQWVRUUowYWlBQU5nSUFJQkVnQTBGK2FpSUdJQkJCQ0JBZVFRSjBhaUFHSUExck5nSUFJQlFnQlNBVFFRWVFIa0VDZEdvZ0FEWUNBQ0FVSUFOQmYyb2lBQ0FUUVFZUUhrRUNkR29nQUNBTmF6WUNBQ0FJSVFZZ0J5RUFBMEFDUUNBQUlRZ2dCaUVBSUFoRklBTW9BQUFnQXlBSWF5Z0FBRWR5RFFBZ0EwRUVhaUlGSUFVZ0NHc2dCQkFkSVFrZ0ZDQURJQk5CQmhBZVFRSjBhaUFESUExcklnVTJBZ0FnRVNBRElCQkJDQkFlUVFKMGFpQUZOZ0lBSUFsQkFXb2hCeUFCS0FJTUlRVUNRQ0FESUE5TkJFQWdCU0FERUJ3TUFRc2dCU0FESUFNZ0R4QWlDeUFCS0FJRUlnVkJBVFlDQUNBRlFRQTdBUVFnQjBHQWdBUlBCRUFnQVVFQ05nSWtJQUVnQlNBQktBSUFhMEVEZFRZQ0tBc2dCU0FIT3dFR0lBRWdCVUVJYWpZQ0JDQUlJUVlnQUNFSElBbEJCR29nQTJvaUF5RUZJQU1nRlUwTkFRd0NDd3NnQ0NFSElBQWhDQ0FESVFVTElBVWdGVWtOQUFzTElBSWdDQ0FYSUFnYk5nSUFJQWNnRnlBSEd5RUlJQUpCQkdvTUFRc2dBaWdDQUNJSUlBSW9BZ1FpQjBFQUlBY2dBeUFBS0FJRUlnMGdBeUFOYXlBRWFpSUZRUUVnQUNnQ2RIUWlCbXNnQUNnQ0RDSUpJQVVnQ1dzZ0Jrc2JJZzVxSWhJZ0EwWnFJZ1VnRW1zaUJrc2lDUnNnQ0NBR1N5SUdHeUVYUVFBZ0NDQUdHeUVJUVFBZ0J5QUpHeUVISUFVZ0F5QUVhaUlFUVhocUloVkpCRUFnQUNnQ2VDRVRJQUFvQW53aEVDQUFLQUlvSVJRZ0FDZ0NJQ0VSSUFSQllHb2hEd05BSUFVZ0VFRUlFQjRoQUNBVUlBVWdFMEVGRUI1QkFuUnFJZ1lvQWdBaEN5QVJJQUJCQW5ScUlnQW9BZ0FoRENBR0lBVWdEV3NpRmpZQ0FDQUFJQlkyQWdBQ1FBSkFJQWhGSUFWQkFXb2lBQ0FJYXlnQUFDQUFLQUFBUjNKRkJFQWdCVUVGYWlJRklBVWdDR3NnQkJBZElndEJBV29oQ2lBQUlBTnJJUWtnQVNnQ0RDRUZBa0FDUUNBQUlBOU5CRUFnQlNBREVCd2dBU2dDRENFR0lBbEJFRTBFUUNBQklBWWdDV28yQWd3TUF3c2dCa0VRYWlBRFFSQnFJZ1VRSENBR1FTQnFJQU5CSUdvUUhDQUpRVEZJRFFFZ0JpQUphaUVNSUFaQk1Hb2hBd05BSUFNZ0JVRWdhaUlHRUJ3Z0EwRVFhaUFGUVRCcUVCd2dCaUVGSUFOQklHb2lBeUFNU1EwQUN3d0JDeUFGSUFNZ0FDQVBFQ0lMSUFFZ0FTZ0NEQ0FKYWpZQ0RDQUpRWUNBQkVrTkFDQUJRUUUyQWlRZ0FTQUJLQUlFSUFFb0FnQnJRUU4xTmdJb0N5QUxRUVJxSVFZZ0FTZ0NCQ0lEUVFFMkFnQWdBeUFKT3dFRUlBcEJnSUFFU1EwQklBRkJBallDSkNBQklBTWdBU2dDQUd0QkEzVTJBaWdNQVFzQ1FBSkFBa0FDUUFKQUlBd2dEa3NFUUNBTUlBMXFJZ29wQUFBZ0JTa0FBRklOQVNBRlFRaHFJQXBCQ0dvZ0JCQWRRUWhxSVFZZ0JTQUtheUVKSUFVZ0EwMEVRQ0FGSVFBTUJnc2dEQ0FPVEFSQUlBVWhBQXdHQ3dOQUlBVkJmMm9pQUMwQUFDQUtRWDlxSWdvdEFBQkhCRUFnQlNFQURBY0xJQVpCQVdvaEJpQUFJQU5ORFFZZ0FDRUZJQW9nRWtzTkFBc01CUXNnQ3lBT1N3MEJEQUlMSUFzZ0RrME5BUXNnQ3lBTmFpSUtLQUFBSUFVb0FBQkdEUUVMSUFVZ0EydEJDSFVnQldwQkFXb2hCUXdEQ3lBUklBQWdFRUVJRUI1QkFuUnFJZ2NvQWdBaERDQUhJQlpCQVdvMkFnQUNRQ0FNSUE1TkRRQWdEQ0FOYWlJSEtRQUFJQUFwQUFCU0RRQWdCVUVKYWlBSFFRaHFJQVFRSFVFSWFpRUdJQUFnQjJzaENTQU1JQTVNSUFBZ0EwMXlEUUVEUUNBQVFYOXFJZ1V0QUFBZ0IwRi9haUlITFFBQVJ3MENJQVpCQVdvaEJpQUZJQU5OQkVBZ0JTRUFEQU1MSUFVaEFDQUhJQkpMRFFBTERBRUxJQVZCQkdvZ0NrRUVhaUFFRUIxQkJHb2hCaUFGSUFwcklRa2dCU0FEVFFSQUlBVWhBQXdCQ3lBTElBNU1CRUFnQlNFQURBRUxBMEFnQlVGL2FpSUFMUUFBSUFwQmYyb2lDaTBBQUVjRVFDQUZJUUFNQWdzZ0JrRUJhaUVHSUFBZ0EwME5BU0FBSVFVZ0NpQVNTdzBBQ3dzZ0JrRjlhaUVLSUFBZ0Eyc2hDeUFCS0FJTUlRVUNRQUpBSUFBZ0QwMEVRQ0FGSUFNUUhDQUJLQUlNSVFjZ0MwRVFUUVJBSUFFZ0J5QUxhallDREF3REN5QUhRUkJxSUFOQkVHb2lCUkFjSUFkQklHb2dBMEVnYWhBY0lBdEJNVWdOQVNBSElBdHFJUXdnQjBFd2FpRURBMEFnQXlBRlFTQnFJZ2NRSENBRFFSQnFJQVZCTUdvUUhDQUhJUVVnQTBFZ2FpSURJQXhKRFFBTERBRUxJQVVnQXlBQUlBOFFJZ3NnQVNBQktBSU1JQXRxTmdJTUlBdEJnSUFFU1EwQUlBRkJBVFlDSkNBQklBRW9BZ1FnQVNnQ0FHdEJBM1UyQWlnTElBRW9BZ1FpQXlBSlFRTnFOZ0lBSUFNZ0N6c0JCQ0FLUVlDQUJFOEVRQ0FCUVFJMkFpUWdBU0FESUFFb0FnQnJRUU4xTmdJb0N5QUlJUWNnQ1NFSUN5QURJQW83QVFZZ0FTQURRUWhxTmdJRUlBQWdCbW9pQXlBVlN3UkFJQU1oQlF3QkN5QVJJQTBnRmtFQ2FpSUFhaUlGSUJCQkNCQWVRUUowYWlBQU5nSUFJQkVnQTBGK2FpSUdJQkJCQ0JBZVFRSjBhaUFHSUExck5nSUFJQlFnQlNBVFFRVVFIa0VDZEdvZ0FEWUNBQ0FVSUFOQmYyb2lBQ0FUUVFVUUhrRUNkR29nQUNBTmF6WUNBQ0FJSVFZZ0J5RUFBMEFDUUNBQUlRZ2dCaUVBSUFoRklBTW9BQUFnQXlBSWF5Z0FBRWR5RFFBZ0EwRUVhaUlGSUFVZ0NHc2dCQkFkSVFrZ0ZDQURJQk5CQlJBZVFRSjBhaUFESUExcklnVTJBZ0FnRVNBRElCQkJDQkFlUVFKMGFpQUZOZ0lBSUFsQkFXb2hCeUFCS0FJTUlRVUNRQ0FESUE5TkJFQWdCU0FERUJ3TUFRc2dCU0FESUFNZ0R4QWlDeUFCS0FJRUlnVkJBVFlDQUNBRlFRQTdBUVFnQjBHQWdBUlBCRUFnQVVFQ05nSWtJQUVnQlNBQktBSUFhMEVEZFRZQ0tBc2dCU0FIT3dFR0lBRWdCVUVJYWpZQ0JDQUlJUVlnQUNFSElBbEJCR29nQTJvaUF5RUZJQU1nRlUwTkFRd0NDd3NnQ0NFSElBQWhDQ0FESVFVTElBVWdGVWtOQUFzTElBSWdDQ0FYSUFnYk5nSUFJQWNnRnlBSEd5RUlJQUpCQkdvTElBZzJBZ0FnQkNBRGF3dU1BUUVJZnlBQUtBSUVJZ1FnQUNnQ0dHb2lBa0VDYWlBQlFYaHFJZ0ZOQkVBZ0FDZ0NlQ0VGSUFBb0FvUUJJUVlnQUNnQ2ZDRUhJQUFvQWlnaENDQUFLQUlnSVFBRFFDQUNJQWRCQ0JBZUlRTWdDQ0FDSUFVZ0JoQWVRUUowYWlBQ0lBUnJJZ2syQWdBZ0FDQURRUUowYWlBSk5nSUFJQUpCQldvaEF5QUNRUU5xSVFJZ0F5QUJUUTBBQ3dzTGd3VUJBbjhqQUVIUUFHc2lDeVFBUWJwL0lRd2dDMEU0YWlBQUlBRVEvd0VRSVVVRVFDQUxRU2hxSUFJZ0F5QUpRWDlxSWdCcUlnSXRBQUFRWXlBTFFSaHFJQVFnQUNBRmFpSUJMUUFBRUdNZ0MwRUlhaUFHSUFBZ0Iyb2lCQzBBQUJCaklBdEJPR29nQ0NBQVFRTjBhaUlBTHdFRUlBUXRBQUJCQW5SQnNLY0JhaWdDQUJCSElBdEJPR29RT1NBTFFUaHFJQUF2QVFZZ0FpMEFBRUVDZEVHUXBBRnFLQUlBRUVjZ0MwRTRhaEE1QWtBZ0NnUkFJQUV0QUFBaUFTQUJRUmdnQVVFWVNSc2lBbXNpQVFSQUlBdEJPR29nQUNnQ0FDQUJFRWNnQzBFNGFoQTVDeUFMUVRocUlBQW9BZ0FnQVhZZ0FoQkhEQUVMSUF0Qk9Hb2dBQ2dDQUNBQkxRQUFFRWNMSUF0Qk9Hb1FPU0FKUVFKUEJFQWdDVUYrYWlFTUEwQWdCeUFNYWkwQUFDRUNJQU1nREdvdEFBQWhCQ0FMUVRocUlBdEJHR29nQlNBTWFpMEFBQ0lBRUd3Z0MwRTRhaUFMUVNocUlBUVFiQ0FMUVRocUVEa2dDMEU0YWlBTFFRaHFJQUlRYkNBTFFUaHFFRGtnQzBFNGFpQUlJQXhCQTNScUlnRXZBUVFnQWtFQ2RFR3dwd0ZxS0FJQUlnSVFSeUFDSUFSQkFuUkJrS1FCYWlnQ0FDSUNha0VaVHdSQUlBdEJPR29RT1FzZ0MwRTRhaUFCTHdFR0lBSVFSeUFMUVRocUVEa0NRQ0FLQkVBZ0FDQUFRUmdnQUVFWVNSc2lBbXNpQUFSQUlBdEJPR29nQVNnQ0FDQUFFRWNnQzBFNGFoQTVDeUFMUVRocUlBRW9BZ0FnQUhZZ0FoQkhEQUVMSUF0Qk9Hb2dBU2dDQUNBQUVFY0xJQXRCT0dvUU9TQU1RWDlxSWd3Z0NVa05BQXNMSUF0Qk9Hb2dDeWdDS0NBTEtBSTBFSFFnQzBFNGFpQUxLQUlZSUFzb0FpUVFkQ0FMUVRocUlBc29BZ2dnQ3lnQ0ZCQjBJQXRCT0dvUS9RRWlBRUc2ZnlBQUd5RU1DeUFMUWRBQWFpUUFJQXdMTHdBZ0FDQUNRUU4wYWlnQ0JDSUFRUkIyUVFGcUlnSkJDSFJCZnlBQmRDQUFheUFDUVJCMGFrRUlkQ0FCZG1zTFR3RUVmd05BSUFOQkFTQUFJQVJCQW5ScUtBSUFJZ05CQ0hRaUJTQUNiaUlHSUFVZ0Fra2JJQVlnQXh0QkFuUkJrSndCYWlnQ0FDQURiR29oQXlBRVFRRnFJZ1FnQVUwTkFBc2dBMEVJZGd0S0FRRi9Jd0JCOEFScklnUWtBQ0FFSUFNZ0FpQUJFS2NCSWdNZ0FDQUNJQUVRcGdFaUFoQWhSUVJBSUFSQjhBQnFRWUFFSUFRZ0FTQURFS2dCSVFJTElBUkI4QVJxSkFBZ0FndUtBUUVJZnlNQVFSQnJJZ01rQUNBRElBQVFjMEYvSVFVQ1FDQUFMd0FDSUFKSkRRQWdBeWdDRENJSFFRaDBRWUFDYWlFSUlBTW9BZ2doQ1VFQUlRQURRQ0FKSUFjZ0FCREpBeUVHSUFFZ0FFRUNkR29vQWdBaUNnUkFJQVlnQ0U4TkFpQUdJQXBzSUFScUlRUUxJQUJCQVdvaUFDQUNUUTBBQ3lBRVFRaDJJUVVMSUFOQkVHb2tBQ0FGQzE4QkFuOUJDQ0FCYXlFRlFRQWhBUU5BSUFSQkFTQUFJQUZCQVhScUx3RUFJZ1FnQkVILy93TkdHMEVRZEVFUWRTQUZkRUVDZEVHUW5BRnFLQUlBSUFJZ0FVRUNkR29vQWdCc2FpRUVJQUZCQVdvaUFTQURUUTBBQ3lBRVFRaDJDMndCQVg4Q1FBSkFBa0FDUUNBQ1FmOGZTMEVDUVFFZ0FrRWZTeHRxSWdOQmYyb09Bd0FCQWdNTElBQWdBa0VEZEVFQmNqb0FBQXdDQ3lBQUlBSkJCSFJCQlhKQjlmOERjUkF2REFFTElBQWdBa0VFZEVFTmNoQk5DeUFBSUFOcUlBRXRBQUE2QUFBZ0EwRUJhZ3RCQUNBQUxRQUFRUUpIQkVBZ0FrRUFOZ0lBSUFOQkFEWUNBQ0FCUVFBMkFnQVBDeUFCSUFBb0FBUTJBZ0FnQXlBQUtBQUlOZ0lBSUFJZ0FDZ0FERFlDQUF1TEFRRUJmeU1BUVNCcklnRWtBQ0FBUVFCQm1BWVFLQ0lBUVFBMkFxQURJQUJCQURZQ25BTWdBRUVBTmdLWUF5QUJRUkJxRU9BQklBRWdBU2tER0RjRENDQUJJQUVwQXhBM0F3QWdBQ0FCRU44Qk5nSUlJQUFvQXVnRlJRUkFJQUFROWdFZ0FFRU1haUlBQkVBZ0FFRUFRZmdBRUNnaUFFRUJOZ0lnSUFCQkF6WUNMQXNMSUFGQklHb2tBQXRPQUNBQUlBRkIrQUFRS2lJQUlBSW9BaGcyQWh3Z0FDQUNLUUlRTndJVUlBQWdBaWtDQ0RjQ0RDQUFJQUlwQWdBM0FnUWdBQ0FDS1FJY053SWdJQUFnQWlnQ0pEWUNLQ0FBUVFNMkFpd0xxUUVCQW44akFFSFFBV3NpQmlRQUlBWkJxQUZxSWdjZ0JTQUVSU0FFYXEwUTlRTWdCMEVCTmdJY0lBZENBRGNDSUNBR0lBWXBBN0FCTndNUUlBWWdCaWtEdUFFM0F4Z2dCaUFHS1FQQUFUY0RJQ0FHSUFZcEE4Z0JOd01vSUFZZ0Jpa0RxQUUzQXdnZ0JrRXdhaUFBUVF4cUlBWkJDR29RMFFNZ0FDQUdRVEJxSUFTdEVONERJZ1VRSVFSL0lBVUZJQUFnQVNBQ0lBTWdCQkR4QXdzaEFDQUdRZEFCYWlRQUlBQUxKd0VDZnlBQUtBSVFJZ0VnQUNnQ0RDSUNTUVJBSUFGQkFDQUNJQUZyRUNnYUN5QUFFTzBCQ3lZQUlBQVE1UUVnQUVFQU5nSndJQUJCQURZQ1NDQUFRUUEyQWhRZ0FDQUFLQUlNTmdJWUMySUJBMzhqQUVFZ2F5SUNKQUFnQVJCN0lBSkJGR29nQWtFY2FpQUNRUmhxRU04RFFZanNBU0FDS0FJVUlnTVFUQ0lFTmdJQUlBRVFleUFFSUFNUW93SWdBa0VJYWlBRFFZanNBU2dDQUJEYkFTQUFJQUpCQ0dvUTJnRWdBa0VnYWlRQUN6UUFJQUJCQURZQ0lDQUFJQUUyQWhBZ0FDQUJOZ0lJSUFBZ0FUWUNBQ0FBSUFFZ0FtbzJBZ1FnQUJEbUFTQUFRUUEyQWh3TFF3RUNma0lCSVFJZ0FGQkZCRUJDNDhpVnZjdWI3NDFQSVFFRFFFSUJJQUVnQUVJQmcxQWJJQUorSVFJZ0FTQUJmaUVCSUFCQ0FZZ2lBRUlBVWcwQUN3c2dBZ3ZFQWdFRGZ5QUNLQUlZUVFGSEJFQkJCQ0FDS0FJRWRDRUZDeUFDS0FJSUlRWWdBaWdDRUVFRFJnUkFJQUlvQWdBaUJFRVJJQVJCRVVrYklRUUxJQU5CQVVZRVFDQUFRb0dBZ0lBUU53SU1JQUJDQURjQ0JDQUFRUUUyQWdBZ0FSRHVBUXNnQUNBRU5nSWNJQUFRMUFNZ0FTQUJLQUlJTmdJTUlBQWdBVUVFSUFaMEVKNEJOZ0lnSUFBZ0FTQUZFSjRCTmdJb0lBQWdBVUVFSUFSMFFRQWdCQnNRbmdFMkFpUWdBU2dDR0VVRVFDQUJFTk1ESUFJb0FoaEJCMDhFUUNBQUlBRkJnQWdRVlRZQ0xDQUFJQUZCa0FFUVZUWUNNQ0FBSUFGQjFBRVFWVFlDTkNBQUlBRkJnQUVRVlRZQ09DQUFJQUZCaUlBQ0VGVTJBandnQUVGQWF5QUJRWnlBQnhCVk5nSUFDeUFBSUFJcEFnQTNBblFnQUNBQ0tBSVlOZ0tNQVNBQUlBSXBBaEEzQW9RQklBQWdBaWtDQ0RjQ2ZFRkFRUUFnQVNnQ0dCc1BDMEZBQ3pRQUlBQkJBRFlDZ0FnZ0FFSG9JMnBDaElDQWdJQUJOd0lBSUFCQjRDTnFRb0NBZ0lBUU53SUFJQUJCMkNOcVFnQTNBZ0FMTEFFQ2YwRUJRUUFnQUNnQ0JDSUJJQUFvQWdocklnSWdBaUFCU3h0MFFRZ2dBWFJxUVFBZ0FDZ0NBQnNMaFFFQkEzOGdBQ2dDR0NJQlFRRkhCRUJCQkNBQUtBSUVkQ0VEQ3lBQUtBSUlJUUlDZndKQUlBQW9BaEJCQTBZRVFFR0lqQWxCQUNBQlFRWkxHeUVCUVFRZ0FuUWhBa0dBZ0NBZ0FDZ0NBQ0lBUVJGUERRSWFJQUJGRFFGQkJDQUFkQXdDQzBHSWpBbEJBQ0FCUVFaTEd5RUJRUVFnQW5RaEFndEJBQXNnQVNBRGFpQUNhbW9MbFFFQkFuOGdBQ0FCTmdJVUlBQW9BZ2doQlNBQUtBSU1JZ1JGQkVBZ0FFSEFBRFlDREVIQUFDRUVDeUFEUVFkUEJFQWdBQ0FDSUFRZ0JDQUNTUnMyQWd3TElBQW9BZ1FpQkVVRVFDQUFJQUZCZVdvaUFrRUdJQUpCQmtzYklnUTJBZ1FMSUFBb0FoQkZCRUFnQUVFQUlBRWdCR3NpQWlBQ0lBRkxHellDRUFzZ0FDQUZRUU1nQlJzaUFDQUVJQUFnQkVrYk5nSUlDL0FJQWhCL0FYNGpBRUhRQUdzaUJTUUFJQUJCQVRZQ3VBTWdBVUhVQUdvaEJpQUJLQUpVQkVBZ0JpQUJLQUlFSUFFb0FoZ2dBU2dDSEJEY0F5QUFJQUVvQW1CQmYycXRFTmNETndPSUJBc2dBU2dDRkNFSUlBRTFBZ1FoRXlBQlFRUnFJZ2tRMndNaERpQUZJQVlwQWhBM0EwZ2dCVUZBYXlBR0tRSUlOd01BSUFVZ0Jpa0NBRGNET0FKL1FnRWdFNFlpRXlBQ0lCTWdBbFFicHlJRVFRRWdCQnNpQkVHQWdBZ2dCRUdBZ0FoSkd5SUxJUVJCQUNBRktBSTRSUTBBR2lBRUlBVW9Ba1J1Q3lFTUlBVWdBQ2dDd0FRMkFqQWdCU0FBS1FLNEJEY0RLQ0FGSUFCQnNBUnFJZzhwQWdBM0F5QWdCU2dDSUNBRktBSWthMEdBZ0lENGVVc2hCeUFBUVlBQ2FpSUVJZ01nQXlnQ0RDQURLQUlVUVFBUTVBRUVmeUFES0FJY1FRRnFCVUVBQ3pZQ0hDQUFLQUtrQXlFTklBVWdCaWtDRURjREdDQUZJQVlwQWdnM0F4QWdCU0FHS1FJQU53TUlJQVZCQ0dvUTJnTWhBeUFFS0FJQUlBQW9Bb1FDRU9jQklSQUNRQUovUVFBZ0JDSUtLQUlNSUFRb0FoUWdBeUFNUVF4c0loRWdEaUFMUVNCcUloSWdDMEVEUVFRZ0NFRURSaHR1SWdoQkMyeHFhbXBxUWZqOUFFSGc5d0FnRFJ0cUlnTVE1QUZGRFFBYUlBb29BaHhCZ0FGS0N5QVFJQU5KY2dSQUlBMEVRRUZBSVFNTUFnc2dCQ0FBS0FLWUF5QUFLQUtjQXlBQUtBS2dBeENrQVFKL0lBUWhCeUFBS0FLY0F4cEJRQ0FESUFBb0FwZ0RJQUFvQXFBREVJY0NJZ3BGRFFBYUlBY2dDaUFERU5ZRFFRQUxJZ01RSVEwQklBQWdCRUh3SXhDZkFTSUROZ0tvQkNBRFJRUkFRVUFoQXd3Q0N5QUFJQVJCOENNUW53RWlBellDckFRZ0EwVUVRRUZBSVFNTUFnc2dBQ0FFUVlBd0VKOEJOZ0xBQlVFQklRZEJRQ0VESUFBb0Fxd0VSUTBCQ3lBRUVPWUJJQUJCaEFGcUlBRkIrQUFRS2hvZ0FDQUpLQUlZTmdLOEJTQUFJQWtwQWhBM0FyUUZJQUFnQ1NrQ0NEY0NyQVVnQUNBSktRSUFOd0trQlNBQVFnQTNBN0FDSUFBZ0FrSUJmRGNEcUFJZ0FFSUFOd080QWlBQ1FuOVJCRUFnQUVFQU5nS2tBUXNnQUNBTE5nS2tBaUFBUWNBQ2FoQ0dBaUFBUVFBMkF2d0JJQUJCQVRZQ0FDQUFLQUtvQkJEWkF5QUVJQklRWUNFRElBQkJBRFlDeUFVZ0FDQUxOZ0xjQXlBQUlBTTJBc1FESUFSQkFCQmdJUU1nQUVFQU5nTGNCU0FBSUFNMkFzUUZJQUFnQkVFQUVHQTJBdGdGSUFZb0FnQWlDZ1JBSUFBZ0JFRUJJQUVvQWxnZ0FTZ0NYR3QwSWdNUVlDSUdOZ0tBQkNBR1FRQWdBeEFvR2dzQ1FDQUFJZ01vQWdCQkFVY05BQ0FES0FMWUFRMEFJQU5DQURjRG1BUWdBMElBTndPZ0JBc2dBQ0FJTmdMWUF5QUFJQVFnQ0JCZ05nTE1BeUFBSUFRZ0NCQmdOZ0xRQXlBQUlBUWdDQkJnTmdMVUF5QUFJQVFnQ0VFRGRCQlZOZ0s4QXlBUElBUWdDU0FIRU5nRElnTkJBQ0FERUNFaUJ4c2hBeUFISUFwRmNnMEFJQUFnQkVFSUlBRW9BbGgwSWdFUVZTSUhOZ0w4QTBFQUlRTWdCMEVBSUFFUUtCb2dCQ0FSRUZVaEFTQUFJQXcyQXBRRUlBQWdBVFlDa0FRZ0FFSUFOd1BvQXlBQVFnQTNBL0FESUFCQkFEWUMrQU1nQUVIb0Eyb1E1UUVMSUFWQjBBQnFKQUFnQXd0TUFRRi9Jd0JCZ0FGcklnTWtBQ0FEUVFocUlBRkIrQUFRS2hvQ1FDQUFJQU5CQ0dvZ0FoRGRBeUlCRUNFTkFFRUFJUUZCQUJBaERRQWdBRUVBTmdMOEFRc2dBMEdBQVdva0FDQUJDN01GQVFaL0lBRkJFRzBoQ0NBQlFSQk9CRUFEUUNBQUlBWkJBblFpQldvaUFVRUFJQUpCQUNBQktBSUFJZ0ZCQVVZYklBRnFJZ0VnQW1zaUF5QURJQUZMR3pZQ0FDQUFJQVZCQkhKcUlnRkJBQ0FDUVFBZ0FTZ0NBQ0lEUVFGR0d5QURhaUlESUFKcklnUWdCQ0FEU3hzMkFnQWdBVUVBSUFKQkFDQUJLQUlFSWdGQkFVWWJJQUZxSWdFZ0Ftc2lBeUFESUFGTEd6WUNCQ0FBSUFWQkRISnFJZ0ZCQUNBQ1FRQWdBU2dDQUNJRFFRRkdHeUFEYWlJRElBSnJJZ1FnQkNBRFN4czJBZ0FnQVVFQUlBSkJBQ0FCS0FJRUlnTkJBVVliSUFOcUlnTWdBbXNpQkNBRUlBTkxHellDQkNBQlFRQWdBa0VBSUFFb0FnZ2lBMEVCUmhzZ0Eyb2lBeUFDYXlJRUlBUWdBMHNiTmdJSUlBRkJBQ0FDUVFBZ0FTZ0NEQ0lCUVFGR0d5QUJhaUlCSUFKcklnTWdBeUFCU3hzMkFnd2dBQ0FGUVJ4eWFpSUJRUUFnQWtFQUlBRW9BZ0FpQTBFQlJoc2dBMm9pQXlBQ2F5SUVJQVFnQTBzYk5nSUFJQUZCQUNBQ1FRQWdBU2dDQkNJRFFRRkdHeUFEYWlJRElBSnJJZ1FnQkNBRFN4czJBZ1FnQVVFQUlBSkJBQ0FCS0FJSUlnTkJBVVliSUFOcUlnTWdBbXNpQkNBRUlBTkxHellDQ0NBQlFRQWdBa0VBSUFFb0Fnd2lBMEVCUmhzZ0Eyb2lBeUFDYXlJRUlBUWdBMHNiTmdJTUlBRkJBQ0FDUVFBZ0FTZ0NFQ0lEUVFGR0d5QURhaUlESUFKcklnUWdCQ0FEU3hzMkFoQWdBVUVBSUFKQkFDQUJLQUlVSWdOQkFVWWJJQU5xSWdNZ0Ftc2lCQ0FFSUFOTEd6WUNGQ0FCUVFBZ0FrRUFJQUVvQWhnaUEwRUJSaHNnQTJvaUF5QUNheUlFSUFRZ0Ewc2JOZ0lZSUFGQkFDQUNRUUFnQVNnQ0hDSUJRUUZHR3lBQmFpSUJJQUpySWdNZ0F5QUJTeHMyQWh3Z0FDQUZRVHh5YWlJQlFRQWdBa0VBSUFFb0FnQWlBVUVCUmhzZ0FXb2lBU0FDYXlJRklBVWdBVXNiTmdJQUlBWkJFR29oQmlBSFFRRnFJZ2NnQ0VjTkFBc0xDOHNEQVFWL0l3QkJFR3NpQ1NRQUlBY2dBaERwQVNFTklBRWdBRUdFQ0JBcUlRb0NmeUFEQkVBZ0JDQUZJQVlnQnhDZEFRd0JDMEVHUVQ4Z0FDZ0NnQWdpQVVFQ1Joc2dCMDhFUUNBRUlBVWdCaUFIRUowQkRBRUxRYnAvSUFkQi8vOEFTMEVFUVFNZ0IwSC9CMHNiYWlJTElBVlBEUUFhSUFKQkJFa2dCMEdCQ0VseElRd2dDU0FCTmdJTUlBVWdDMnNoQXlBRUlBdHFJUUlDZnlBTFFRTkdJQUZCQWtaeElBZEJnQUpKY2lJQkJFQWdBaUFESUFZZ0IwRUFJQWdnQ2lBSlFReHFJQXdRK0FFTUFRc2dBaUFESUFZZ0IwRUJJQWdnQ2lBSlFReHFJQXdRK0FFTElRTWdDU2dDRENFQ0lBTVFJU0FEUlNBRElBY2dEV3RQY25JRVFDQUtJQUJCaEFnUUtob2dCQ0FGSUFZZ0J4Q2RBUXdCQ3lBRFFRRkdCRUFnQ2lBQVFZUUlFQ29hSUFRZ0JpQUhFTTREREFFTElBSkZCRUFnQ2tFQk5nS0FDQXRCQTBFQ0lBSWJJUUFDUUFKQUFrQUNRQ0FMUVgxcURnTUFBUUlEQ3lBRUlBZEJCSFJCQkVFQUlBRWJjaUFBY2tFRWN5QURRUTUwYWhDakFRd0NDeUFFSUFkQkJIUWdBSEpCQ0hJZ0EwRVNkR29RVFF3QkN5QUVJQWRCQkhRZ0FISkJESElnQTBFV2RHb1FUU0FFSUFOQkNuWTZBQVFMSUFNZ0Myb0xJUUFnQ1VFUWFpUUFJQUFMTXdFQmZ3SkFBa0FDUUNBQUtBSkFRWDlxRGdJQ0FBRUxRUUVQQ3lBQUtBSWNRUUZIRFFBZ0FDZ0NHRUVBUnlFQkN5QUJDLzhHQVJKL0l3QkI4QUZySWdna0FDQURLQUlFSVJVZ0FDZ0NGQ0VOSUFBb0FoQWhEaUFBS0FJWUlROGdBQ2dDQkNFSklBQW9BZ0FoRXdKQUlBRWdBaUFES0FJY0loQWdBeERoQXlBRUlBVWdBQ2dDQ0NJRElBQW9BZ3dnQTJzZ0JoRGdBeUlERUNFaUJ3MEFJQU1nQkdvaENrRzZmeUVESUFRZ0JXb2lDeUFFSUFvZ0J4c2lCMnRCQkVnTkFBSi9JQWtnRTJzaUEwRURkU0lGUWY4QVRRUkFJQWNnQlRvQUFDQUhRUUZxREFFTElBVkIvLzBCVFFSQUlBY2dCVG9BQVNBSElBVkJDSFpCZ0FGek9nQUFJQWRCQW1vTUFRc2dCMEgvQVRvQUFDQUhRUUZxSUFWQmdJSitha0gvL3dOeEVDOGdCMEVEYWdzaENpQUNRWVFJYWlFUklBTkZCRUFnRVNBQlFZUUlha0hnR3hBcUdpQUtJQVJySVFNTUFRc2dBQkR6QXlBSVFTTTJBZ3dnQ0VFUWFpQUlRUXhxSUE0Z0JTQUdFSU1CSVFNZ0FrSGdJMm9pQnlBQlFlQWphaWdDQURZQ0FDQUtRUUZxSWdBZ0N5QUFheUFDUWJRWmFpSVdRUWtnQnlBSVFSQnFJQWdvQWd3aUJ5QURJQVZCQ1NBQlFiUVphaUlEUVpDYUFVRUdRUUVnRUJDaUFTSVVJQWhCRUdvZ0J5QU9JQVZCa0pvQlFRWkJJeUFEUWFRS0lBWVFvUUVpQXhBaElnY05BQ0FJUVI4MkFnd2dDRUVRYWlBSVFReHFJQThnQlNBR0VJTUJJUXdnQ0NnQ0RDRUpJQUpCMkNOcUloSWdBVUhZSTJvb0FnQTJBZ0FnQUNBQUlBTnFJQWNiSWdjZ0N5QUhheUFSUVFnZ0VpQUlRUkJxSUFrZ0RDQUZRUWdnQVVHRUNHb2lBMEhnbWdGQkJTQUpRUjFKSUJBUW9nRWlEQ0FJUVJCcUlBa2dEeUFGUWVDYUFVRUZRUndnQTBHRUJpQUdFS0VCSWdNUUlTSUpEUUFnQ0VFME5nSU1JQWhCRUdvZ0NFRU1haUFOSUFVZ0JoQ0RBU0VTSUFKQjNDTnFJaGNnQVVIY0kyb29BZ0EyQWdBZ0J5QURJQWRxSUFrYklna2dDeUFKYXlBQ1FZZ09haUlZUVFrZ0Z5QUlRUkJxSUFnb0Fnd2lBaUFTSUFWQkNTQUJRWWdPYWlJRFFhQ2JBVUVHUVFFZ0VCQ2lBU0lCSUFoQkVHb2dBaUFOSUFWQm9Kc0JRUVpCTkNBRFFhd0xJQVlRb1FFaUF4QWhJZ0lOQUNBS0lBeEJCSFFnRkVFR2RHb2dBVUVDZEdvNkFBQWdDU0FESUFscUlBSWJJZ1lnQ3lBR2F5QVlJQTBnRVNBUElCWWdEaUFUSUFVZ0ZVRVpTeERJQXlJREVDRU5BQ0FESUFacUlRVWdCeUFBUVFBZ0ZFRUNSaHNnREVFQ1Joc2lBQ0FKSUFJYklBQWdBVUVDUmhzaUFBUkFRUUFoQXlBRklBQnJRUVJJRFFFTElBVWdCR3NoQXdzZ0NFSHdBV29rQUNBREM2a0NBUXgvSXdCQklHc2lCaVFBQWtBZ0JFRVVkaUFFUWYvL1AzRkJBRWRxSWc1RkRRQWdBeUFFYWlFTFFRRWdBaWdDRkhRaERDQUJLQUlJSVFVRFFDQUZJQUVvQWd4UERRRWdCaUFBS0FJUU5nSVlJQVlnQUNrQ0NEY0RFQ0FHSUFBcEFnQTNBd2dnQ3lBRElBbEJGSFJxSWdSQmdJQkFheUFMSUFSclFZQ0F3QUJKR3lJSElBUnJJUTBnQmtFSWFpQUhFTzhCQkVBZ0FpZ0NCQ0VQSUFBZ0RDQUVFSzBESVJBZ0FDZ0NGRUVCSUE5MElCQVFyQU1MSUFBZ0J5QU1FS3NESUFBZ0FTQUNJQVFnRFJDcUF5SUVFQ0VFUUNBRUlRZ01BZ3NDZnlBRklBRW9BZ2dpQjBrRVFDQUJLQUlBSUFWQkRHeHFJZ1VnQlNnQ0JDQUthallDQkNBRURBRUxJQW9nRFdvTElRb2dCeUVGSUFsQkFXb2lDU0FPUncwQUN3c2dCa0VnYWlRQUlBZ0xOQUVDZjBHNmZ5RUZJQU5CQTJvaUJpQUJUUVIvSUFBZ0EwRURkQ0FFYWhDakFTQUFRUU5xSUFJZ0F4QXFHaUFHQlNBRkN3c2hBQ0FCSUFCcklBTW9BZ0FnQW1wTEJFQWdBMEVBTmdJQUlBUkJBRFlDQUFzTFBnRUNmMEVCSVFJZ0FVRUNUd1IvSUFBdEFBQWhBd0pBQTBBZ0F5QUFJQUpxTFFBQVJ3MEJJQUpCQVdvaUFpQUJSdzBBQzBFQkR3dEJBQVVnQWdzTFR3RUJmd0pBSUFBZ0FTQUNJQU1nQkNBRklBY1E0Z01pQUVVZ0JpQUZUVUVBSUFCQnVuOUdHM0lFZnlBSUJTQUFFQ0ZGRFFFZ0FBc1BDeUFBUVFBZ0FDQUdJQVlnQXlnQ0hCRHBBV3RKR3d1RUF3RVBmeUFBS0FLd0F5RUpJQUJCdkFOcUlnY29BZ1FpQVNBSEtBSUFJZ3BySWdRRVFDQUFLQUtzQXlBSlFSUnNhaUVMSUFvZ0FXc2lBU0FFSUFFZ0JFb2JRUU4ySUFSQmZ5QUVRWDlLR3lJQlFRRWdBVUVCU0J0c0lnRkJBU0FCUVFGTEd5RU1JQWNvQWlnaERRTkFJQXNnQTBFVWJHb2lBU0FLSUFOQkEzUnFJZ1VvQWdBaUFqWUNCQ0FCSUFVdkFRUWlCallDQ0NBQklBVXZBUVlpQ0VFRGFpSUZOZ0lNQWtBZ0F5QU5SdzBBQWtBQ1FDQUhLQUlrUVg5cURnSUFBUUlMSUFFZ0JrR0FnQVJ5SWdZMkFnZ01BUXNnQVNBSVFZT0FCR29pQlRZQ0RBc0NRQ0FCQW44Z0FrRURUUVJBSUFFZ0FpQUdSV29pQ0RZQ0VDQUJJQXNnQXlBQ2F5SU9JQU1nRGlBQ1FRTkdHMEYvYWlBR0d5SUNRUlJzYWtFRWFpQUNRWDl6UVFKMFFkQ3dBV29nQWtGL1Noc29BZ0FpQWpZQ0JDQUlRUVJIRFFJZ0FrRi9hZ3dCQ3lBQ1FYMXFDellDQkFzZ0FTQUdJQTlxSWdFMkFnQWdBU0FGYWlFUElBTkJBV29pQXlBTVJ3MEFDd3NnQUNBRVFRTjFJQWxxTmdLd0F3dXJBd0VIZnlNQVFSQnJJZ1VrQUNBQ1FRWkxCRUFnQUVHOEEyb2lCeER5QVNBQUlBQW9BcWdFSWdZMkFwZ0ZJQUFnQUNnQ3hBRTJBcHdGSUFFZ0FDZ0N0QVJySWdRZ0FDZ0N5QVFpQTBHQUEycExCRUFnQUNBRUlBUWdBMnRCZ0gxcUlnUkJ3QUVnQkVIQUFVa2JhellDeUFRTElBQkJzQVJxSWdRUTdBRWhDQ0FBS0FLc0JDSURJQVlvQXVRak5nTGtJeUFEUWVnamFpQUdRZWdqYWlnQ0FEWUNBQ0FEUWV3amFpQUdRZXdqYWlnQ0FEWUNBQ0FEUWVRamFpRURJQWNoQmdKQUlBRWdBbW9DZnlBQUtBS2NCQ0FBS0FLZ0JFa0VRQ0FBUVpnRWFpQUVJQWNnQXlBQklBSVE2d0VNQVFzZ0FFSFlBV29pQ1NnQ0FBUkFJQVZDQURjQ0JDQUZJQUFvQXBBRU5nSUFJQVVnQUNnQ2xBUTJBZ3dnQUVIb0Eyb2dCU0FKSUFFZ0FoRGpBeUlERUNFTkFpQUZJQVFnQnlBQUtBS3NCRUhrSTJvZ0FTQUNFT3NCREFFTElBUWdCeUFESUFFZ0FpQUFLQUtnQVNBSUVQTUJFUUlBQ3lJQWF5RUJJQVlvQWd3Z0FTQUFFQ29hSUFZZ0JpZ0NEQ0FBYWpZQ0RFRUFJUU1MSUFWQkVHb2tBQ0FERHdzZ0FFR1lCR29nQWlBQUtBS1lBUkRxQVNBRlFSQnFKQUJCQVF2ckFRRUNmd0pBQWtBQ1FFRUJJQUFnQXlBRUVPa0RJZ1ZCQVVaQkFuUWdCUkFoR3c0RkFBSUNBZ0VDQ3lBQUtBS29Bd1JBSUFBUTZBTkJBQThMSUFCQnZBTnFJQUFvQXFnRUlBQW9BcXdFSUFCQmhBRnFJQUVnQWlBRUlBQW9Bc0FGRU9jRElnWkJHRXNOQUNBQUtBSzRBdzBBSUFNZ0JCRG1BMFVOQUNBQklBTXRBQUE2QUFCQkFTRUdDeUFHRUNFaEFpQUFLQUtvQkNFQkFrQWdCa0VDU1FSQUlBRWhCUXdCQ3lBQ0JFQWdBU0VGREFFTElBQW9BcXdFSVFVZ0FDQUJOZ0tzQkNBQUlBVTJBcWdFQ3lBRlFkZ2phaWdDQUVFQ1JnUkFJQVZCQVRZQzJDTUxJQVloQlFzZ0JRdHJBUUovSUFBb0FpQkJBU0FCS0FJTWRDQUNFS0FCQWtBZ0FTZ0NIQ0lFUVFGR0RRQkJBU0FCS0FJSWRDRUJJQUFvQWlnaEF5QUVRUVpHQkVBZ0F5QUJJQUlRM3dNTUFRc2dBeUFCSUFJUW9BRUxJQUFvQWh3aUFRUkFJQUFvQWlSQkFTQUJkQ0FDRUtBQkN3dFNBUUYvSUFBZ0FDZ0NCQ0lFSUFNZ0JHc2lBeUFDYXlBRFFYOGdBWFJCZjNOeGF5SUJhallDQkNBQUlBQW9BZ2dnQVdvMkFnZ2dBQ0FBS0FJUUlBRnJOZ0lRSUFBZ0FDZ0NEQ0FCYXpZQ0RDQUJDNWNCQVFGL0l3QkJJR3NpQlNRQUlBVWdBQ2dDRURZQ0dDQUZJQUFwQWdnM0F4QWdCU0FBS1FJQU53TUlJQVZCQ0dvZ0JCRHZBUVJBSUFBZ0FpZ0NDQ0FDS0FJY0VQUUJRUUVnQWlnQ0JIUWdBeERzQXlFRElBRVE3Z0VnQUNBQ0lBTVE2d01nQVJEdEFTQUFRUUEyQW5BZ0FFRUFOZ0lVSUFCQkFDQUFLQUlZSWdBZ0Eyc2lBU0FCSUFCTEd6WUNHQXNnQlVFZ2FpUUFDL0VDQVExL0lBQW9Bb2dCSVFVZ0FDZ0NwQUloQnlBQUtBS29BUVJBSUFCQndBSnFJQU1nQkJDRkFnc2dBRUdFQVdvaERFRUJJQVYwSVEwZ0FFR2dCV29oRGlBQVFjUUVhaUVQSUFCQmdBSnFJUkFnQUVHd0JHb2hFU0FCSVFVQ1FBTkFJQUpCQmtrRVFFRzZmdzhMSUJFZ0VDQU1JQU1nQXlBRUlBY2dCQ0FIU1JzaUNHb2lDaER0QXlBQUtBSzBCQ0FLSUEwZ0R5QU9FT1VESUFBb0FzZ0VJQUFvQXNBRUlnbEpCRUFnQUNBSk5nTElCQXNnQUNBRlFRTnFJQUpCZldvZ0F5QUlFT29ESWdZUUlRMEJJQWNnQkU4aEJ3SkFBbjhDUUFKQUFrQWdCZzRDQUFFQ0N5QUZJQUlnQXlBSUlBY1E1QU1pQmhBaFJRMEREQVVMUVFJaEN5QUhJUWtnQ0VFRGRBd0JDeUFHUVFOMElRbEJCQ0VMSUFjTElRTWdCU0FESUFseUlBdHlFS01CSUFaQkEyb2hCZ3NnQUVFQU5nSzRBeUFDSUFacklRSWdCU0FHYWlFRklBb2hBeUFFSUFnaUIyc2lCQTBBQ3lBRklBRkxCRUFnQUVFRE5nSUFDeUFGSUFGcklRWUxJQVlMcmdFQkEzOUJSQ0VESUFFaEJTQUJJUVFDUUFKQUFrQUNRQ0FBS0FJQURnUURBQUVDQVFzZ0FTQUNJQUJCaEFGcVFnQkJBQkR4QVNJREVDRU5BaUFBUVFJMkFnQWdBU0FEYWlFRklBSWdBMnNoQWd0QnVuOGhBeUFDUVFSSkRRRWdCVUVCRUUwZ0FrRjlhaUVDSUFWQkEyb2hCQXNnQUNnQ3FBRUVRRUc2ZnlFRElBSkJCRWtOQVNBRUlBQkJ3QUpxRUlRQ3B4Qk5JQVJCQkdvaEJBc2dBRUVBTmdJQUlBUWdBV3NoQXdzZ0F3dnRBUUlDZndGK1FVUWhCZ0pBQWtBQ1FBSkFJQUFvQWdBT0FnTUFBUXNnQVNBQ0lBQkJoQUZxSUFBcEE2Z0NRbjk4SUFBb0F2d0JFUEVCSWdVUUlRMEJJQUJCQWpZQ0FDQUJJQVZxSVFFZ0FpQUZheUVDQ3lBRVJRMEFJQUJCc0FScUlBTWdCQkR3QVVVRVFDQUFJQUFvQXJ3RU5nTElCQXNnQUNnQzJBRUVRQ0FBUWVnRGFpQURJQVFROEFFYUN5QUFJQUVnQWlBRElBUVE3Z01pQmhBaERRRWdBQ0FBS1FPd0FpQUVyWHdpQnpjRHNBSWdBQ0FBS1FPNEFpQUZJQVpxSWdHdGZEY0R1QUpCdUg4Z0FTQUhRZ0Y4SUFBcEE2Z0NJZ2RXR3lBQklBZENBRkliRHdzZ0JTRUdDeUFHQzFzQkFYNGdBQ0FCSUFJZ0F5QUVFUEFESWdNUUlRUkFJQU1QQ3lBQUlBRWdBMm9nQWlBRGF4RHZBeUlCRUNFRVFDQUJEd3NDZnlBQUtRT29BaUlGVUVVRVFFRzRmeUFGSUFBcEE3QUNRZ0Y4VWcwQkdnc2dBU0FEYWdzTGtBRUJBMzhnQUNFQkFrQUNRQ0FBUVFOeFJRMEFJQUF0QUFCRkJFQkJBQThMQTBBZ0FVRUJhaUlCUVFOeFJRMEJJQUV0QUFBTkFBc01BUXNEUUNBQklnSkJCR29oQVNBQ0tBSUFJZ05CZjNNZ0EwSC8vZnQzYW5GQmdJR0NoSGh4UlEwQUN5QURRZjhCY1VVRVFDQUNJQUJyRHdzRFFDQUNMUUFCSVFNZ0FrRUJhaUlCSVFJZ0F3MEFDd3NnQVNBQWF3dmlBUUVJZnlBQUtBSVVJUU1nQUNnQ0VDRUVJQUFvQWdRaUFpQUFLQUlBSWdWcklnRUVRQ0FBS0FJWUlRWWdCU0FDYXlJQ0lBRWdBaUFCU2h0QkEzWWdBVUYvSUFGQmYwb2JJZ0ZCQVNBQlFRRklHMndpQVVFQklBRkJBVXNiSVFkQkFDRUJBMEFnQlNBQlFRTjBhaUlDTHdFR0lRZ2dBU0FFYWlBQ0x3RUVFSUFCT2dBQUlBRWdCbW9nQWlnQ0FCQWtPZ0FBSUFFZ0Eyb2dDQkE4T2dBQUlBRkJBV29pQVNBSFJ3MEFDd3NnQUNnQ0pDSUJRUUZHQkg4Z0JDQUFLQUlvYWtFak9nQUFJQUFvQWlRRklBRUxRUUpHQkVBZ0F5QUFLQUlvYWtFME9nQUFDd3ZKQVFFRGZ3SkFRbjhnQWlBQ1VCc2lBa0tBZ0lDQUFsb0VRQ0FCS0FJQUlRUU1BUXRCQmlFRElBS25JZ1JCd0FCUEJFQWdCRUYvYWhBa1FRRnFJUU1MSUFFb0FnQWlCQ0FEVFEwQUlBRWdBellDQUNBRElRUUxJQUVvQWdnZ0JFRUJhaUlEU3dSQUlBRWdBellDQ0FzZ0JDQUJLQUlFSWdVZ0FTZ0NHQkQwQVNJRFNRUkFJQUVnQkNBRmFpQURhellDQkFzZ0JFRUpUUVJBSUFGQkNqWUNBQXNnQUNBQktRSUFOd0lBSUFBZ0FTZ0NHRFlDR0NBQUlBRXBBaEEzQWhBZ0FDQUJLUUlJTndJSUM5TUJBZ0ovQVg0akFFRkFhaUlESkFBZ0EwSi9JQUlnQWxBYklnVkNnWUFRVkNBRlFvR0FDRlJxSUFWQ2dZQUJWR3BCaEFWc1FSWkJBQ0FCUVFNZ0FSc2dBVUVBU0JzZ0FVRVdTaHRCSEd4cUlnUkJtSVVCYWlnQ0FEWUNPQ0FESUFSQmtJVUJhaWtDQURjRE1DQURJQVJCaUlVQmFpa0NBRGNES0NBRElBUkJnSVVCYWlrQ0FEY0RJQ0FCUVg5TUJFQWdBMEVBSUFGck5nSTBDeUFESUFNb0FqZzJBaGdnQXlBREtRTXdOd01RSUFNZ0F5a0RLRGNEQ0NBRElBTXBBeUEzQXdBZ0FDQURJQUlROUFNZ0EwRkFheVFBQ3lJQkFYOENRQ0FCUlEwQUlBQW9BZ0FnQVVzTkFDQUFLQUlFSUFGUElRSUxJQUlMU3dFRWZ3SkFJQUJGRFFBZ0FFRU1haUlCSUFBUTlnTWhBaUFCSUFBb0FyQWxJZ0VnQUVHMEpXb29BZ0FpQXlBQVFiZ2xhaWdDQUNJRUVLUUJJQUlOQUNBQUlBRWdBeUFFRUdRTEN6UUJBbjhnQUVFQlFRRVFXeUFBRURrZ0FDZ0NEQ0lDSUFBb0FoQkpCSDhnQWlBQUtBSUlheUFBS0FJRVFRQkhhZ1VnQVFzTEpBQWdBQ0FCTmdJTUlBQWdBVFlDQ0NBQVFnQTNBZ0FnQUNBQklBSnFRWHhxTmdJUUMvVUJBUVYvQWtBZ0FVRVJTU0FEUVF4SmNnMEFJQUJCQm1vaUJ5QUJRWHBxSUFJZ0EwRURha0VDZGlJR0lBUVFjU0lGRUNFRVFDQUZEd3NnQlVVTkFDQUFJQVZCLy84RGNSQXZJQVVnQjJvaUJTQUFJQUZxSWdjZ0JXc2dBaUFHYWlJSUlBWWdCQkJ4SWdFUUlRUkFJQUVQQ3lBQlJRMEFJQUJCQW1vZ0FVSC8vd054RUM4Z0FTQUZhaUlGSUFjZ0JXc2dCaUFJYWlJSUlBWWdCQkJ4SWdFUUlRUkFJQUVQQ3lBQlJRMEFJQUJCQkdvZ0FVSC8vd054RUM4Z0FTQUZhaUlGSUFjZ0JXc2dCaUFJYWlJQklBSWdBMm9nQVdzZ0JCQnhJZ0VRSVFSQUlBRVBDeUFCUlEwQUlBRWdCV29nQUdzaENRc2dDUXRHQVFOL0lBSkJBRWdFUUVFQkR3c0RRQ0FFSUFFZ0EwRUNkQ0lGYWlnQ0FFRUFSeUFBSUFWcUxRQUNSWEZ5SVFRZ0FpQURSeUVGSUFOQkFXb2hBeUFGRFFBTElBUkZDeW9CQVg4akFFRVFheUlBSkFBZ0FFRUFOZ0lNUVpUcEFTZ0NBRUcvRWtFQUVMa0JJQUJCRUdva0FBdjRCZ0VIZnlNQVFVQnFJZ2NrQUFKQUlBQWdBVUVEZEdvaUJDMEFCeUlGSUFKTkJFQWdCU0VDREFFTElBUkJCMm9oQmtFQklBVWdBbXNpQ1hRaENFRUFJUVFnQlNFREEwQWdCaUFDT2dBQUlBUWdDR3BCZnlBRklBTnJkR29oQkNBQUlBRkJmMm9pQVVFRGRHb2lBMEVIYWlFR0lBTXRBQWNpQXlBQ1N3MEFDd05BSUFOQi93RnhJQUpIUlFSQUlBQWdBVUYvYWlJQlFRTjBhaTBBQnlFRERBRUxDeUFIUXZEaHc0ZVBucno0Y0RjRE1DQUhRdkRodzRlUG5yejRjRGNES0NBSFF2RGh3NGVQbnJ6NGNEY0RJQ0FIUXZEaHc0ZVBucno0Y0RjREdDQUhRdkRodzRlUG5yejRjRGNERUNBSFF2RGh3NGVQbnJ6NGNEY0RDQ0FIUXZEaHc0ZVBucno0Y0RjREFDQUVJQWwxSVFVQ1FDQUJRWDlNRFFBZ0FpRUdJQUVoQkFOQUlBWWdBMEgvQVhFaUEwc0VRQ0FISUFJZ0EydEJBblJxSUFRMkFnQWdBeUVHQ3lBRVFRRklEUUVnQUNBRVFYOXFJZ1JCQTNScUxRQUhJUU1NQUFzQUN5QUZRUUJLQkVBRFFBSkFBa0FnQlJBa1FRRnFJZ1JCQWtrRVFDQUVJUU1NQVFzZ0J5QUVRUUowYWlnQ0FDRUlBMEFDUUNBSElBUkJmMm9pQmtFQ2RHb29BZ0FoQ1NBSVFmRGh3NGQvUndSQUlBbEI4T0hEaDM5R0RRRWdBQ0FJUVFOMGFpZ0NBQ0FBSUFsQkEzUnFLQUlBUVFGMFRRMEJDMEVCSVFNZ0NTRUlJQVlpQkVFQlN3MEJEQUlMQ3lBRUlnTkJERXNOQVFzRFFBSkFJQWNnQTBFQ2RHb29BZ0JCOE9IRGgzOUhCRUFnQXlFRURBRUxRUTBoQkNBRFFRRnFJZ05CRFVjTkFRc0xJQWNnQkVGL2FpSUdRUUowYWlnQ0FDRUpDeUFISUFSQkFuUnFJZ2dvQWdBaEF5QUpRZkRodzRkL1JnUkFJQWNnQmtFQ2RHb2dBellDQUF0QmZ5QUdkQ0FGYWlFRklBQWdBMEVEZEdvaUJpQUdMUUFIUVFGcU9nQUhJQWdnQXdSL0lBZ2dBMEYvYWlJRE5nSUFJQU5COE9IRGgzOGdBQ0FEUVFOMGFpMEFCeUFDSUFSclJoc0ZRZkRodzRkL0N6WUNBQ0FGUVFCS0RRQUxDeUFGUVg5S0RRQWdCeWdDQkNFRUEwQWdCVUYvSUFWQmYwb2JJUVlnQlNFREEwQWdCRUh3NGNPSGYwWUVRQ0FCSVFRRFFDQUVJZ0ZCZjJvaEJDQUFJQUZCQTNScUxRQUhJQUpHRFFBTElBQWdBVUVCYWlJRVFRTjBhaUlHSUFZdEFBZEJmMm82QUFjZ0EwRUJhaUVGSUFOQmZrb05Bd3dDQ3lBQUlBUkJBV29pQkVFRGRHb2lCU0FGTFFBSFFYOXFPZ0FISUFNZ0JrY2hCU0FEUVFGcUlRTWdCUTBBQ3dzTElBZEJRR3NrQUNBQ0M3NENBUWQvSXdCQmdBSnJJZ1FrQUNBRVFRQkJnQUlRS0NFRkEwQWdCU0FCSUFOQkFuUnFLQUlBUVFGcUVDUkJBM1JxSWdRZ0JDZ0NBRUVCYWpZQ0FDQURRUUZxSWdNZ0FrME5BQXRCSGlFRElBVW9BdkFCSVFRRFFDQUZJQU5CZjJvaUEwRURkR29pQnlBSEtBSUFJQVJxSWdRMkFnQWdBdzBBQzBFQUlRTURRQ0FGSUFOQkEzUnFJZ1FnQkNnQ0FEWUNCQ0FEUVFGcUlnTkJJRWNOQUFzRFFDQUJJQVpCQW5ScUtBSUFJZ2hCQVdvUUpFRURkQ0FGYWlJRUlnTkJER29nQXlnQ0RDSURRUUZxTmdJQUFrQWdBeUFFS0FJSUlnUk5EUUFEUUNBSUlBQWdBMEYvYWlJSFFRTjBhaUlKS0FJQVRRMEJJQUFnQTBFRGRHb2dDU2tDQURjQ0FDQUhJZ01nQkVzTkFBc2dCQ0VEQ3lBQUlBTkJBM1JxSWdNZ0Jqb0FCaUFESUFnMkFnQWdCa0VCYWlJR0lBSk5EUUFMSUFWQmdBSnFKQUFMNHdZQkRIOGpBRUZBYWlJSEpBQkJmeUVGQWtBQ1FBSkFJQVJCQTNFTkFFRlNJUVVnQWtIL0FVc05BQ0FEUVFzZ0F4c2hEQ0FFUVFCQmdDQVFLQ0VJSUFSQkNHb2lCaUFCSUFJUS9nTWdBaUVEQTBBZ0F5SUZRWDlxSVFNZ0JpQUZRUU4wYWlnQ0FDSUJSUTBBQ3lBSUlBRWdCaUFEUVFOMGFpSUJLQUlBYWpZQ2lCQWdBVUdBQWpzQkJDQUdJQVZCQTNScVFZQUNPd0VFSUFWQi93RnFJZ3BCZ0FKTkRRRWdCVUYrYWlFRFFZRUNJUUVEUUNBR0lBRkJBM1JxUVlDQWdJQUVOZ0lBSUFGQkFXb2lBU0FLVFEwQUN5QUlRWUNBZ0lCNE5nSUFRWUFDSVFGQmdRSWhDRUdCQWlFRUEwQWdCaUFJUVFOMGFpQUdJQU1nQmlBRFFRTjBhaWdDQUNJSklBWWdBVUVEZEdvb0FnQWlDMGtpRFdzaUNDQUJJQWtnQzA5cUlna2dCaUFJUVFOMGFpZ0NBQ0lMSUFZZ0NVRURkR29vQWdBaURra2lEeHRCQTNScUloQW9BZ0FnQmlBRElBRWdEUnRCQTNScUlnRW9BZ0JxTmdJQUlCQWdCRHNCQkNBQklBUTdBUVFnQ1NBTElBNVBhaUVCSUFnZ0Qyc2hBeUFLSUFSQkFXb2lCRUgvL3dOeElnaFBEUUFMREFJTElBZEJRR3NrQUNBRkR3c2dDRUdBZ0lDQWVEWUNBQXRCQUNFRElBWWdDa0VEZEdwQkFEb0FCeUFGUWY0QmFpSUJRWUFDVHdSQUEwQWdCaUFCUVFOMGFpSUVJQVlnQkM4QkJFRURkR290QUFkQkFXbzZBQWNnQVVGL2FpSUJRZjhCU3cwQUN3c0RRQ0FHSUFOQkEzUnFJZ0VnQmlBQkx3RUVRUU4wYWkwQUIwRUJham9BQnlBRFFRRnFJZ01nQlUwTkFBc2dCaUFGSUF3US9RTWhCRUVBSVFNZ0IwRUFPd0U0SUFkQ0FEY0RNQ0FIUWdBM0F5Z2dCMElBTndNZ0lBZEJBRHNCR0NBSFFnQTNBeEFnQjBJQU53TUlJQWRDQURjREFFRi9JUUVnQkVFTVRRUkFBMEFnQjBFZ2FpQUdJQU5CQTNScUxRQUhRUUYwYWlJQklBRXZBUUJCQVdvN0FRQWdBMEVCYWlJRElBVk5EUUFMSUFRRVFFRUFJUVVnQkNFREEwQWdCeUFEUVFGMElnRnFJQVU3QVFBZ0IwRWdhaUFCYWk4QkFDQUZha0grL3dOeFFRRjJJUVVnQTBGL2FpSUREUUFMQzBFQUlRVkJBQ0VEQTBBZ0FDQUdJQU5CQTNScUlnRXRBQVpCQW5ScUlBRXRBQWM2QUFJZ0EwRUJhaUlESUFKTkRRQUxBMEFnQnlBQUlBVkJBblJxSWdFdEFBSkJBWFJxSWdNZ0F5OEJBQ0lEUVFGcU93RUFJQUVnQXpzQkFDQUZRUUZxSWdVZ0FrME5BQXNnQkNFQkN5QUhRVUJySkFBZ0FRdmRBZ0VGZnlNQVFaQUNheUlHSkFCQlVpRUZBa0FnQTBIL0FVc05BQ0FHUVFBNkFJTUNRUUVoQlNBRVFRRnFJZ2hCQVVzRVFBTkFJQVpCZ3dKcUlBVnFJQWdnQldzNkFBQWdCQ0FGUmlFSklBVkJBV29oQlNBSlJRMEFDd3NDZnlBREJFQURRQ0FHSUFkcUlBSWdCMEVDZEdvdEFBSWdCa0dEQW1wcUxRQUFPZ0FBSUFkQkFXb2lCeUFEUncwQUN5QUFRUUZxSUFGQmYyb2dCaUFERVBvQkRBRUxJQUJCQVdvZ0FVRi9haUFHUVFBUStnRUxJZ1VRSVEwQUlBVkJBa2tnQlNBRFFRRjJUM0pGQkVBZ0FDQUZPZ0FBSUFWQkFXb2hCUXdCQzBGL0lRVWdBMEdBQVVzTkFFRzZmeUVGSUFOQkFXcEJBWFlpQWlBQlR3MEFJQUpCQVdvaEJTQUFJQU5CL3dCcU9nQUFRUUFoQnlBRElBWnFRUUE2QUFBZ0EwVU5BQU5BSUFkQkFYWWdBR29nQmlBSFFRRnlhaTBBQUNBR0lBZHFMUUFBUVFSMGFqb0FBU0FIUVFKcUlnY2dBMGtOQUFzTElBWkJrQUpxSkFBZ0JRdC9BUVIvSXdCQmtBUnJJZ1FrQUNBRVFmOEJOZ0lJQWtBZ0JFRVFhaUFFUVFocUlBUkJER29nQVNBQ0VHc2lCaEFoQkVBZ0JpRUZEQUVMUVZRaEJTQUVLQUlNSWdkQkJrc05BQ0FESUFSQkVHb2dCQ2dDQ0NBSEVJTUVJZ1VRSVEwQUlBQWdBU0FHYWlBQ0lBWnJJQU1RZ2dRaEJRc2dCRUdRQkdva0FDQUZDKzhGQVFOL0l3QkJNR3NpQkNRQUFrQWdBeThCQWdSQUlBUkJHR29nQVNBQ0VFVWlBUkFoRFFFZ0JFRVFhaUFFUVJocUlBTVFnZ0VnQkVFSWFpQUVRUmhxSUFNUWdnRkJBQ0VCQWtBZ0JFRVlhaEFqQkVCQkFDRUREQUVMQTBBZ0FDQUJhaUlDSUFSQkVHb2dCRUVZYWhCaU9nQUFJQUlnQkVFSWFpQUVRUmhxRUdJNkFBRWdCRUVZYWhBakJFQWdBVUVDY2lFRERBSUxJQUlnQkVFUWFpQUVRUmhxRUdJNkFBSWdBaUFFUVFocUlBUkJHR29RWWpvQUF5QUJRUVJxSVFNZ0JFRVlhaEFqSVFJZ0FVSDNBVXNOQVNBRElRRWdBa1VOQUFzTEFuOERRRUc2ZnlFQklBTkIvUUZMRFFNZ0FDQURhaUlDSUFSQkVHb2dCRUVZYWhCaU9nQUFJQUlpQmtFQmFpRUZJQVJCR0dvUUkwRURSZ1JBUVFJaEF5QUVRUWhxREFJTElBTkIvQUZMRFFNZ0JpQUVRUWhxSUFSQkdHb1FZam9BQVNBRFFRSnFJUU1nQkVFWWFoQWpRUU5IRFFBTElBQWdBMm9oQlVFRElRTWdCRUVRYWdzaEFTQUZJQUVnQkVFWWFoQmlPZ0FBSUFJZ0Eyb2dBR3NoQVF3QkN5QUVRUmhxSUFFZ0FoQkZJZ0VRSVEwQUlBUkJFR29nQkVFWWFpQURFSUlCSUFSQkNHb2dCRUVZYWlBREVJSUJRUUFoQVFKQUlBUkJHR29RSXdSQVFRQWhBd3dCQ3dOQUlBQWdBV29pQWlBRVFSQnFJQVJCR0dvUVlUb0FBQ0FDSUFSQkNHb2dCRUVZYWhCaE9nQUJJQVJCR0dvUUl3UkFJQUZCQW5JaEF3d0NDeUFDSUFSQkVHb2dCRUVZYWhCaE9nQUNJQUlnQkVFSWFpQUVRUmhxRUdFNkFBTWdBVUVFYWlFRElBUkJHR29RSXlFQ0lBRkI5d0ZMRFFFZ0F5RUJJQUpGRFFBTEN3Si9BMEJCdW44aEFTQURRZjBCU3cwQ0lBQWdBMm9pQWlBRVFSQnFJQVJCR0dvUVlUb0FBQ0FDSWdaQkFXb2hCU0FFUVJocUVDTkJBMFlFUUVFQ0lRTWdCRUVJYWd3Q0N5QURRZndCU3cwQ0lBWWdCRUVJYWlBRVFSaHFFR0U2QUFFZ0EwRUNhaUVESUFSQkdHb1FJMEVEUncwQUN5QUFJQU5xSVFWQkF5RURJQVJCRUdvTElRRWdCU0FCSUFSQkdHb1FZVG9BQUNBQ0lBTnFJQUJySVFFTElBUkJNR29rQUNBQkM2OERBUXAvSXdCQmdBUnJJZ2trQUVGU0lRVUNRQ0FDUWY4QlN3MEFJQUJCQkdvaENrR0FnQVFnQTBGL2FuUkJFSFVoQzBFQklBTjBJZ2hCZjJvaURDRUhRUUVoQlFOQUFrQWdBU0FFUVFGMElnMXFMd0VBSWdaQi8vOERSZ1JBSUFvZ0IwRUNkR29nQkRvQUFpQUhRWDlxSVFkQkFTRUdEQUVMSUFWQkFDQUxJQVpCRUhSQkVIVktHeUVGQ3lBSklBMXFJQVk3QVFBZ0FpQUVSeUVHSUFSQkFXb2hCQ0FHRFFBTElBQWdCVHNCQWlBQUlBTTdBUUFnQ0VFRGRpQUlRUUYyYWtFRGFpRUdRUUFoQkVFQUlRVURRQ0FCSUFWQkFYUnFMZ0VBSWdCQkFVNEVRQ0FBUWYvL0EzRWlBRUVCSUFCQkFVc2JJUXRCQUNFQUEwQWdDaUFFUVFKMGFpQUZPZ0FDQTBBZ0JDQUdhaUFNY1NJRUlBZExEUUFMSUFCQkFXb2lBQ0FMUncwQUN3c2dBaUFGUnlFQUlBVkJBV29oQlNBQURRQUxRWDhoQlNBRURRQWdDRUVCSUFoQkFVc2JJUUpCQUNFRlFRQWhCQU5BSUFrZ0NpQUVRUUowYWlJQUxRQUNRUUYwYWlJQklBRXZBUUFpQVVFQmFqc0JBQ0FBSUFNZ0FSQWtheUlIT2dBRElBQWdBU0FIZENBSWF6c0JBQ0FFUVFGcUlnUWdBa2NOQUFzTElBbEJnQVJxSkFBZ0JRc2pBUUYvSUFBZ0FDZ0NCQ0lCUVFGcU5nSUVJQUFnQUNnQ0FFRUJJQUYwY2pZQ0FBdFpBUUYvSUFBZ0FDMEFTaUlCUVg5cUlBRnlPZ0JLSUFBb0FnQWlBVUVJY1FSQUlBQWdBVUVnY2pZQ0FFRi9Ed3NnQUVJQU53SUVJQUFnQUNnQ0xDSUJOZ0ljSUFBZ0FUWUNGQ0FBSUFFZ0FDZ0NNR28yQWhCQkFBdXpBZ0VDZnlNQVFVQnFJZ1lrQUFKQUlBTkJBMGtOQUNBR1FTaHFJQUFnQVJEL0FSQWhEUUFnQWlBRGFrRi9haUlBTFFBQUlRRUNRQ0FEUVFGeEJFQWdCa0VZYWlBRUlBRVFZeUFHUVFocUlBUWdBRUYvYWkwQUFCQmpJQVpCS0dvZ0JrRVlhaUFBUVg1cUlnTXRBQUFRYkNBRkJFQWdCa0VvYWhEK0FRd0NDeUFHUVNocUVEa01BUXNnQmtFSWFpQUVJQUVRWXlBR1FSaHFJQVFnQUVGL2FpSURMUUFBRUdNTElBTWdBa3NFUUFOQUlBWkJLR29nQmtFSWFpQURRWDlxTFFBQUVHd2dCa0VvYWlBR1FSaHFJQU5CZm1vaUF5MEFBQkJzQWtBZ0JRUkFJQVpCS0dvUS9nRU1BUXNnQmtFb2FoQTVDeUFESUFKTERRQUxDeUFHUVNocUlBWW9BZ2dnQmlnQ0ZCQjBJQVpCS0dvZ0JpZ0NHQ0FHS0FJa0VIUWdCa0VvYWhEOUFTRUhDeUFHUVVCckpBQWdCd3NrQUNBQVFRQTJBUVFnQUVFQU93RUFJQUFnQVRzQkFpQUFJQUZCQTNScVFnQTNBZ2dMemdRQ0JuOEVmaUFEUVFOc0lBRkJBV3AySVFnZ0F5QUJkaUVLQTBBQ1FDQUNJQVZCQW5ScUtBSUFJZ1pGQkVBZ0FDQUZRUUYwYWtFQU93RUFEQUVMQWtBQ1FDQUdJQXBOQkVBZ0FDQUZRUUYwYWtILy93TTdBUUFNQVFzZ0FDQUZRUUYwYWlFSklBWWdDRXNOQVNBSlFRRTdBUUFMSUFNZ0Jtc2hBeUFIUVFGcUlRY01BUXNnQ1VIKy93TTdBUUFMSUFWQkFXb2lCU0FFVFEwQUN3SkFBa0JCQVNBQmRDSUpJQWRySWdaRkRRQWdBeUFHYmlBSVN3UkFJQU5CQTJ3Z0JrRUJkRzRoQmtFQUlRVURRQUpBSUFBZ0JVRUJkR29pQ0M4QkFFSCsvd05IRFFBZ0FpQUZRUUowYWlnQ0FDSUtJQVpMRFFBZ0NFRUJPd0VBSUFNZ0Ntc2hBeUFIUVFGcUlRY0xJQVZCQVdvaUJTQUVUUTBBQ3lBSklBZHJJUVlMSUFjZ0JFRUJhaUlIUmdSQVFRQWhCVUVBSVFGQkFDRURBMEFnQWlBRlFRSjBhaWdDQUNJSElBRWdCeUFCU3lJSEd5RUJJQVVnQXlBSEd5RURJQVZCQVdvaUJTQUVUUTBBQ3lBQUlBTkJBWFJxSWdBZ0FDOEJBQ0FHYWpzQkFBd0JDeUFEUlFSQVFRQWhBaUFHUlEwQ1FRQWhCUU5BSUFBZ0JVRUJkR29pQVM0QkFDSURRUUZPQkVBZ0FTQURRUUZxT3dFQUlBWkJmMm9oQmdzZ0JVRUJhaUFIY0NFRklBWU5BQXNNQWdzZ0JxMUJQaUFCYTYwaUM0WkNmeUFMUW45OGhrSi9oU0lNZkNBRHJZQWhEVUVBSVFVRFFDQUFJQVZCQVhScUlnRXZBUUJCL3Y4RFJnUkFJQXdnQzRnaERpQU5JQUlnQlVFQ2RHbzFBZ0IrSUF4OElnd2dDNGluSUE2bmF5SURSUVJBUVg4UEN5QUJJQU03QVFBTElBVkJBV29pQlNBRVRRMEFDd3RCQUNFQ0N5QUNDMFFCQVg5QmZ5RUZJQVJCQTNFRWZ5QUZCU0FCS0FJQVFmNEJUUVJBSUFBZ0FTQUNJQU5CQVNBRUVJTUNEd3NnQVVIL0FUWUNBQ0FBSUFFZ0FpQURJQVFRZ3dFTEMxZ0JBWDhqQUVFUWF5SUVKQUFDZjBFQklBQWdBU0FFUVF4cUVNQUVSUTBBR2tFQ0lBTW9BZ0FnQkNnQ0RFa05BQnBCQVNBQUlBRWdBaENoQkVVTkFCb2dBeUFFS0FJTU5nSUFRUUFMSVFBZ0JFRVFhaVFBSUFBTGlRSUJBMzhDUUFKQUlBQW9BaHdpQXlnQ05DSUVSUVJBUVFFaEJTQURJQUFvQWloQkFTQURLQUlrZEVFQklBQW9BaUFSQVFBaUJEWUNOQ0FFUlEwQkN5QURLQUlvSWdCRkJFQWdBMElBTndJc0lBTkJBU0FES0FJa2RDSUFOZ0lvQ3lBQUlBSk5CRUFnQkNBQklBQnJJQUFRS2hvZ0EwRUFOZ0l3REFJTElBUWdBeWdDTUNJRmFpQUJJQUpySUFJZ0FDQUZheUlBSUFBZ0Frc2JJZ0FRS2hvZ0FpQUFheUlDQkVBZ0F5Z0NOQ0FCSUFKcklBSVFLaG9nQXlBQ05nSXdEQUlMUVFBaEJTQURRUUFnQXlnQ01DQUFhaUlCSUFFZ0F5Z0NLQ0lDUmhzMkFqQWdBeWdDTENJQklBSlBEUUFnQXlBQUlBRnFOZ0lzQ3lBRkR3c2dBeUFES0FJb05nSXNRUUFMc2pjQkhYOGpBRUVRYXlJU0pBQkJmaUVVQWtBZ0FFVU5BQ0FBS0FJY0lnRkZEUUFnQUNnQ0RDSU9SUTBBSUFBb0FnQWlCa1VFUUNBQUtBSUVEUUVMSUFFb0FnQWlBa0VMUmdSQUlBRkJERFlDQUVFTUlRSUxJQUZCMkFCcUlSc2dBVUh3QldvaEZ5QUJRZkFBYWlFWklBRkIxQUJxSVJvZ0FVSHNBR29oR0NBQlFiQUthaUVXSUFFb0Fqd2hCQ0FCS0FJNElRVWdBQ2dDQkNJY0lRY2dBQ2dDRUNJTUlSTUNRQU5BQWtCQmZDRVVRUUVoQXdKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQW44Q1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFJT0h3Z0pDZzBRQXdJQkFCb2JIQndkSGg4Z0lRY2xKZ1kzQlRrbktBUkZMa1l2Q3lBQktBSVFJUU1NR0FzZ0FTZ0NFQ0VEREJZTElBRW9BaEFoQXd3VUN5QUJLQUlRSVFNTUVnc2dBU2dDQ0NFSkRDUUxJQUVvQWtnaENRd3lDeUFCS0FKSUlRa01Md3NnQVNnQ2FDRUpEQndMSUFFb0FnZ2lBMFVOSVNBRVFSQkpCRUFEUUNBSFJRMDhJQWRCZjJvaEJ5QUdMUUFBSUFSMElBVnFJUVVnQkVFSVNTRUNJQVJCQ0dvaEJDQUdRUUZxSVFZZ0FnMEFDd3NnQTBFQ2NVVWdCVUdmbGdKSGNrVUVRRUVBSVFVZ0FVRUFRUUJCQUJBMUlnTTJBaGdnRWtHZmxnSTdBQXdnQXlBU1FReHFRUUlRTlNFRElBRkJBVFlDQUNBQklBTTJBaGhCQUNFRUlBRW9BZ0FoQWd3OEN5QUJRUUEyQWhBZ0FTZ0NJQ0lDQkVBZ0FrRi9OZ0l3Q3dKQUlBTkJBWEVFUUNBRlFRaDBRWUQrQTNFZ0JVRUlkbXBCSDNCRkRRRUxJQUJCbnU4QU5nSVlJQUZCSFRZQ0FDQUJLQUlBSVFJTVBBc2dCVUVQY1VFSVJ3UkFJQUJCdGU4QU5nSVlJQUZCSFRZQ0FDQUJLQUlBSVFJTVBBc2dCVUVFZGlJRFFROXhJZ2hCQ0dvaEFpQUJLQUlrSWdsRkJFQWdBU0FDTmdJa0REb0xJQUlnQ1UwTk9TQUVRWHhxSVFRZ0FFSFE3d0EyQWhnZ0FVRWROZ0lBSUFNaEJTQUJLQUlBSVFJTU93c2dCRUVRU1FSQUEwQWdCMFVOT3lBSFFYOXFJUWNnQmkwQUFDQUVkQ0FGYWlFRklBUkJDRWtoQXlBRVFRaHFJUVFnQmtFQmFpRUdJQU1OQUFzTElBRWdCVFlDRUNBRlFmOEJjVUVJUndSQUlBQkJ0ZThBTmdJWUlBRkJIVFlDQUNBQktBSUFJUUlNT3dzZ0JVR0F3QU54QkVBZ0FFSGs3d0EyQWhnZ0FVRWROZ0lBSUFFb0FnQWhBZ3c3Q3lBQktBSWdJZ01FUUNBRElBVkJDSFpCQVhFMkFnQUxJQVZCZ0FSeEJFQWdFaUFGT3dBTUlBRWdBU2dDR0NBU1FReHFRUUlRTlRZQ0dBc2dBVUVDTmdJQVFRQWhCRUVBSVFVTUFRc2dCRUVmU3cwQkN5QUdJUUlEUUNBSFJRUkFRUUFoQnlBQ0lRWWdEeUVERERzTElBZEJmMm9oQnlBQ0xRQUFJQVIwSUFWcUlRVWdCRUVZU1NFRElBUkJDR29oQkNBQ1FRRnFJZ1loQWlBRERRQUxDeUFCS0FJZ0lnTUVRQ0FESUFVMkFnUUxJQUV0QUJGQkFuRUVRQ0FTSUFVMkFBd2dBU0FCS0FJWUlCSkJER3BCQkJBMU5nSVlDeUFCUVFNMkFnQkJBQ0VFUVFBaEJRd0JDeUFFUVE5TERRRUxJQVloQWdOQUlBZEZCRUJCQUNFSElBSWhCaUFQSVFNTU9Bc2dCMEYvYWlFSElBSXRBQUFnQkhRZ0JXb2hCU0FFUVFoSklRTWdCRUVJYWlFRUlBSkJBV29pQmlFQ0lBTU5BQXNMSUFFb0FpQWlDUVJBSUFrZ0JVRUlkallDRENBSklBVkIvd0Z4TmdJSUN5QUJLQUlRSWdOQmdBUnhCRUFnRWlBRk93QU1JQUVnQVNnQ0dDQVNRUXhxUVFJUU5UWUNHQXNnQVVFRU5nSUFRUUFoQkVFQUlRVkJBQ0lDSUFOQmdBaHhSUTBCR2d3REN5QUJLQUlRSWdOQmdBaHhEUUVnQVNnQ0lDRUpJQVFMSVFRZ0NRUkFJQWxCQURZQ0VBc01Bd3NnQlNFQ0lBUkJEMHNOQVFzRFFDQUhSUVJBUVFBaEJ5QUNJUVVnRHlFRERETUxJQWRCZjJvaEJ5QUdMUUFBSUFSMElBSnFJUUlnQkVFSVNTRUZJQVJCQ0dvaEJDQUdRUUZxSWdnaEJpQUZEUUFMSUFnaEJpQUNJUVVMSUFFZ0JUWUNRQ0FCS0FJZ0lnSUVRQ0FDSUFVMkFoUUxRUUFoQkNBRFFZQUVjUVJBSUJJZ0JUc0FEQ0FCSUFFb0FoZ2dFa0VNYWtFQ0VEVTJBaGdMUVFBaEJRc2dBVUVGTmdJQUN3SkFJQU5CZ0FoeFJRMEFJQWNnQVNnQ1FDSUNJQUlnQjBzYklnZ0VRQUpBSUFFb0FpQWlDVVVOQUNBSktBSVFJZ3BGRFFBZ0NpQUpLQUlVSUFKcklnTnFJQVlnQ1NnQ0dDSUNJQU5ySUFnZ0F5QUlhaUFDU3hzUUtob2dBU2dDRUNFREN5QURRWUFFY1FSQUlBRWdBU2dDR0NBR0lBZ1FOVFlDR0FzZ0FTQUJLQUpBSUFocklnSTJBa0FnQnlBSWF5RUhJQVlnQ0dvaEJnc2dBa1VOQUNBUElRTU1Md3NnQVVFR05nSUFJQUZCQURZQ1FBc0NRQ0FEUVlBUWNRUkFRUUFoQXlBSFJRMHRBMEFnQTBFQmFpRUNJQU1nQm1vdEFBQWhDQUpBSUFFb0FpQWlBMFVOQUNBREtBSWNJZ3BGRFFBZ0FTZ0NRQ0lKSUFNb0FpQlBEUUFnQVNBSlFRRnFOZ0pBSUFrZ0Ntb2dDRG9BQUFzZ0J5QUNTd1JBSUFJaEF5QUlEUUVMQ3lBQktBSVFJZ05CZ0FSeEJFQWdBU0FCS0FJWUlBWWdBaEExTmdJWUN5QUNJQVpxSVFZZ0J5QUNheUVISUFoRkRRRWdEeUVEREM4TElBRW9BaUFpQWtVTkFDQUNRUUEyQWh3TElBRkJCellDQUNBQlFRQTJBa0FMQWtBZ0EwR0FJSEVFUUVFQUlRTWdCMFVOTEFOQUlBTkJBV29oQWlBRElBWnFMUUFBSVFnQ1FDQUJLQUlnSWdORkRRQWdBeWdDSkNJS1JRMEFJQUVvQWtBaUNTQURLQUlvVHcwQUlBRWdDVUVCYWpZQ1FDQUpJQXBxSUFnNkFBQUxJQWNnQWtzRVFDQUNJUU1nQ0EwQkN3c2dBU2dDRUNJRFFZQUVjUVJBSUFFZ0FTZ0NHQ0FHSUFJUU5UWUNHQXNnQWlBR2FpRUdJQWNnQW1zaEJ5QUlSUTBCSUE4aEF3d3VDeUFCS0FJZ0lnSkZEUUFnQWtFQU5nSWtDeUFCUVFnMkFnQUxJQU5CZ0FSeEJFQWdCRUVQVFFSQUEwQWdCMFVOTENBSFFYOXFJUWNnQmkwQUFDQUVkQ0FGYWlFRklBUkJDRWtoQWlBRVFRaHFJUVFnQmtFQmFpRUdJQUlOQUFzTElBVWdBUzhCR0VjTkYwRUFJUVZCQUNFRUN5QUJLQUlnSWdJRVFDQUNRUUUyQWpBZ0FpQURRUWwyUVFGeE5nSXNDeUFCUVFCQkFFRUFFRFVpQXpZQ0dDQUFJQU0yQWpBZ0FVRUxOZ0lBSUFFb0FnQWhBZ3dxQ3lBRVFTQkpCRUFEUUNBSFJRMHFJQWRCZjJvaEJ5QUdMUUFBSUFSMElBVnFJUVVnQkVFWVNTRURJQVJCQ0dvaEJDQUdRUUZxSVFZZ0F3MEFDd3NnQVNBRlFRaDBRWUNBL0FkeElBVkJHSFJ5SUFWQkNIWkJnUDREY1NBRlFSaDJjbklpQXpZQ0dDQUFJQU0yQWpBZ0FVRUtOZ0lBUVFBaEJVRUFJUVFMSUFFb0FneEZCRUFnQUNBTU5nSVFJQUFnRGpZQ0RDQUFJQWMyQWdRZ0FDQUdOZ0lBSUFFZ0JEWUNQQ0FCSUFVMkFqaEJBaUVVRENzTElBRkJBRUVBUVFBUVpTSUROZ0lZSUFBZ0F6WUNNQ0FCUVFzMkFnQUxJQUVvQWdRTkZDQUVRUUpMQkg4Z0JBVWdCMFVOSnlBSFFYOXFJUWNnQmkwQUFDQUVkQ0FGYWlFRklBWkJBV29oQmlBRVFRaHFDeUVESUFFZ0JVRUJjVFlDQkVFTklRUUNRQUpBQWtBQ1FDQUZRUUYyUVFOeFFRRnJEZ01BQVFJREN5QUJRYUR6QURZQ1RDQUJRb21BZ0lEUUFEY0NWQ0FCUWFDREFUWUNVRUVUSVFRTUFndEJFQ0VFREFFTElBQkJrZkFBTmdJWVFSMGhCQXNnQVNBRU5nSUFJQU5CZldvaEJDQUZRUU4ySVFVZ0FTZ0NBQ0VDRENjTElBVWdCRUVIY1hZaEJTQUVRWGh4SWdSQkgwMEVRQU5BSUFkRkRTY2dCMEYvYWlFSElBWXRBQUFnQkhRZ0JXb2hCU0FFUVJoSklRTWdCRUVJYWlFRUlBWkJBV29oQmlBRERRQUxDeUFGUWYvL0EzRWlBeUFGUVg5elFSQjJSd1JBSUFCQnBQQUFOZ0lZSUFGQkhUWUNBQ0FCS0FJQUlRSU1Kd3NnQVVFT05nSUFJQUVnQXpZQ1FFRUFJUVZCQUNFRUN5QUJRUTgyQWdBTElBRW9Ba0FpQXdSQUlBd2dCeUFESUFNZ0Iwc2JJZ01nQXlBTVN4c2lBMFVFUUNBUElRTU1Kd3NnRGlBR0lBTVFLaUVDSUFFZ0FTZ0NRQ0FEYXpZQ1FDQUNJQU5xSVE0Z0RDQURheUVNSUFNZ0Jtb2hCaUFISUFOcklRY2dBU2dDQUNFQ0RDVUxJQUZCQ3pZQ0FDQUJLQUlBSVFJTUpBc2dCRUVPU1FSQUEwQWdCMFVOSkNBSFFYOXFJUWNnQmkwQUFDQUVkQ0FGYWlFRklBUkJCa2toQXlBRVFRaHFJUVFnQmtFQmFpRUdJQU1OQUFzTElBRWdCVUVmY1NJRFFZRUNhallDWUNBQklBVkJCWFpCSDNFaUFrRUJhallDWkNBQklBVkJDblpCRDNGQkJHb2lDRFlDWENBRVFYSnFJUVFnQlVFT2RpRUZJQU5CSFUxQkFDQUNRUjVKRzBVRVFDQUFRY0h3QURZQ0dDQUJRUjAyQWdBZ0FTZ0NBQ0VDRENRTElBRkJFVFlDQUVFQUlRSWdBVUVBTmdKb0RBRUxJQUVvQW1naUFpQUJLQUpjSWdoUERRRUxJQUloQXdOQUlBUkJBazBFUUNBSFJRMGlJQWRCZjJvaEJ5QUdMUUFBSUFSMElBVnFJUVVnQmtFQmFpRUdJQVJCQ0dvaEJBc2dBU0FEUVFGcUlnSTJBbWdnQVNBRFFRRjBRZkR3QUdvdkFRQkJBWFJxSUFWQkIzRTdBWEFnQkVGOWFpRUVJQVZCQTNZaEJTQUNJUU1nQWlBSVNRMEFDd3NnQWtFVFNRUkFBMEFnQVNBQ1FRRjBRZkR3QUdvdkFRQkJBWFJxUVFBN0FYQWdBa0VCYWlJQ1FSTkhEUUFMSUFGQkV6WUNhQXNnQVVFSE5nSlVJQUVnRmpZQ1RDQUJJQlkyQW14QkFDRUpRUUFnR1VFVElCZ2dHaUFYRUt3QklnOEVRQ0FBUVpieEFEWUNHQ0FCUVIwMkFnQWdBU2dDQUNFQ0RDRUxJQUZCRWpZQ0FDQUJRUUEyQW1oQkFDRVBDeUFKSUFFb0FtQWlIU0FCS0FKa2FpSVFTUVJBUVg4Z0FTZ0NWSFJCZjNNaEZTQUJLQUpNSVEwRFFDQUVJUW9nQnlFQ0lBWWhBd0pBSUFRZ0RTQUZJQlZ4SWhGQkFuUnFMUUFCSWd0UEJFQWdCQ0VJREFFTEEwQWdBa1VOQ2lBRExRQUFJQXAwSVFzZ0EwRUJhaUVESUFKQmYyb2hBaUFLUVFocUlnZ2hDaUFJSUEwZ0JTQUxhaUlGSUJWeEloRkJBblJxTFFBQklndEpEUUFMQ3dKQUlBMGdFVUVDZEdvdkFRSWlCRUVQVFFSQUlBRWdDVUVCYWlJR05nSm9JQUVnQ1VFQmRHb2dCRHNCY0NBSUlBdHJJUVFnQlNBTGRpRUZJQVloQ1F3QkN3Si9BbjhDUUFKQUFrQWdCRUZ3YWc0Q0FBRUNDeUFJSUF0QkFtb2lCa2tFUUFOQUlBSkZEU1VnQWtGL2FpRUNJQU10QUFBZ0NIUWdCV29oQlNBRFFRRnFJUU1nQ0VFSWFpSUlJQVpKRFFBTEN5QUlJQXRySVFRZ0JTQUxkaUVJSUFsRkJFQWdBRUd2OFFBMkFoZ2dBVUVkTmdJQUlBTWhCaUFDSVFjZ0NDRUZJQUVvQWdBaEFnd25DeUFFUVg1cUlRUWdDRUVDZGlFRklBaEJBM0ZCQTJvaEJ5QUpRUUYwSUFGcUx3RnVEQU1MSUFnZ0MwRURhaUlHU1FSQUEwQWdBa1VOSkNBQ1FYOXFJUUlnQXkwQUFDQUlkQ0FGYWlFRklBTkJBV29oQXlBSVFRaHFJZ2dnQmtrTkFBc0xJQWdnQzJ0QmZXb2hCQ0FGSUF0MklnWkJBM1loQlNBR1FRZHhRUU5xREFFTElBZ2dDMEVIYWlJR1NRUkFBMEFnQWtVTkl5QUNRWDlxSVFJZ0F5MEFBQ0FJZENBRmFpRUZJQU5CQVdvaEF5QUlRUWhxSWdnZ0Jra05BQXNMSUFnZ0MydEJlV29oQkNBRklBdDJJZ1pCQjNZaEJTQUdRZjhBY1VFTGFnc2hCMEVBQ3lFR0lBY2dDV29nRUVzRVFDQUFRYS94QURZQ0dDQUJRUjAyQWdBZ0F5RUdJQUloQnlBQktBSUFJUUlNSXdzRFFDQUJJQWxCQVhScUlBWTdBWEFnQ1VFQmFpRUpJQWRCZjJvaUJ3MEFDeUFCSUFrMkFtZ0xJQU1oQmlBQ0lRY2dDU0FRU1EwQUN3c2dBUzhCOEFSRkJFQWdBRUhKOFFBMkFoZ2dBVUVkTmdJQUlBRW9BZ0FoQWd3Z0N5QUJRUWsyQWxRZ0FTQVdOZ0pNSUFFZ0ZqWUNiRUVCSUJrZ0hTQVlJQm9nRnhDc0FTSVBCRUFnQUVIdThRQTJBaGdnQVVFZE5nSUFJQUVvQWdBaEFnd2dDeUFCUVFZMkFsZ2dBU0FCS0FKc05nSlFRUUlnQVNBQktBSmdRUUYwYWtId0FHb2dBU2dDWkNBWUlCc2dGeENzQVNJUEJFQWdBRUdLOGdBMkFoZ2dBVUVkTmdJQUlBRW9BZ0FoQWd3Z0N5QUJRUk0yQWdCQkFDRVBDeUFCUVJRMkFnQUxJQXhCZ2dKSklBZEJCa2x5UlFSQUlBQWdERFlDRUNBQUlBNDJBZ3dnQUNBSE5nSUVJQUFnQmpZQ0FDQUJJQVEyQWp3Z0FTQUZOZ0k0SUFBZ0V4Q1JCQ0FCS0FJOElRUWdBU2dDT0NFRklBQW9BZ1FoQnlBQUtBSUFJUVlnQUNnQ0VDRU1JQUFvQWd3aERpQUJLQUlBUVF0SERSWWdBVUYvTmdMRU55QUJLQUlBSVFJTUhnc2dBVUVBTmdMRU55QUVJUWtnQnlFQ0lBWWhBd0pBSUFRZ0FTZ0NUQ0lRSUFWQmZ5QUJLQUpVZEVGL2N5SU5jU0lMUVFKMGFpMEFBU0lLVHdSQUlBUWhDQXdCQ3dOQUlBSkZEUWdnQXkwQUFDQUpkQ0VLSUFOQkFXb2hBeUFDUVg5cUlRSWdDVUVJYWlJSUlRa2dDQ0FRSUFVZ0Ntb2lCU0FOY1NJTFFRSjBhaTBBQVNJS1NRMEFDd3NnQ2lFRUlCQWdDMEVDZEdvaUJpOEJBaUVSSUFZdEFBQWlEVVVnRFVId0FYRnlEUTBnQWlFSElBTWhCZ0pBSUFRZ0VDQUZRWDhnQkNBTmFuUkJmM01pRlhFZ0JIWWdFV29pRFVFQ2RHb3RBQUVpQ21vZ0NDSUpUUVJBSUFnaEN3d0JDd05BSUFkRkRRY2dCaTBBQUNBSmRDRUtJQVpCQVdvaEJpQUhRWDlxSVFjZ0NVRUlhaUlMSVFrZ0JDQVFJQVVnQ21vaUJTQVZjU0FFZGlBUmFpSU5RUUowYWkwQUFTSUthaUFMU3cwQUN3c2dFQ0FOUVFKMGFpSURMUUFBSVEwZ0F5OEJBaUVSSUFFZ0JEWUN4RGNnQ3lBRWF5RUlJQVVnQkhZaEJRd09DeUFNUlEwU0lBNGdBU2dDUURvQUFDQUJRUlEyQWdBZ0RFRi9haUVNSUE1QkFXb2hEaUFCS0FJQUlRSU1IQXNnQVNnQ0NDSUpCRUFnQkVFZlRRUkFBMEFnQjBVTkhTQUhRWDlxSVFjZ0JpMEFBQ0FFZENBRmFpRUZJQVJCR0VraEFpQUVRUWhxSVFRZ0JrRUJhaUVHSUFJTkFBc0xJQUFnRXlBTWF5SUNJQUFvQWhScU5nSVVJQUVnQVNnQ0hDQUNhallDSEFKQUlBSkZCRUFnQVNnQ0VDRUlJQUVvQWhnaEFnd0JDeUFPSUFKcklRb2dBU2dDR0NFVElBRUNmeUFCS0FJUUlnZ0VRQ0FUSUFvZ0FoQTFEQUVMSUJNZ0NpQUNFR1VMSWdJMkFoZ2dBQ0FDTmdJd0N5QUZJQVZCQ0hSQmdJRDhCM0VnQlVFWWRISWdCVUVJZGtHQS9nTnhJQVZCR0haeWNpQUlHeUFDUncwS1FRQWhCU0FNSVJOQkFDRUVDeUFCUVJzMkFnQUxBa0FnQ1VVTkFDQUJLQUlRUlEwQUlBUkJIMDBFUUFOQUlBZEZEUndnQjBGL2FpRUhJQVl0QUFBZ0JIUWdCV29oQlNBRVFSaEpJUUlnQkVFSWFpRUVJQVpCQVdvaEJpQUNEUUFMQ3lBRklBRW9BaHhIRFFwQkFDRUZRUUFoQkFzZ0FVRWNOZ0lBREJzTElBRkJERFlDQUF3UkN5QUdJQWRxSVFZZ0JDQUhRUU4wYWlFRURCY0xJQUlnQTJvaEJpQUlJQUpCQTNScUlRUU1GZ3NnQmlBSGFpRUdJQVFnQjBFRGRHb2hCQXdWQzBGOUlRTU1GZ3RCZmlFVURCWUxJQUJCL2U4QU5nSVlJQUZCSFRZQ0FDQUJLQUlBSVFJTUV3c2dBVUVhTmdJQUlBVWdCRUVIY1hZaEJTQUVRWGh4SVFRZ0FTZ0NBQ0VDREJJTElBQkI4UElBTmdJWUlBRkJIVFlDQUNBTUlSTWdBU2dDQUNFQ0RCRUxJQUJCaGZNQU5nSVlJQUZCSFRZQ0FDQUJLQUlBSVFJTUVBdEJBQ0VFSUFNaEJpQUNJUWNMSUFFZ0VVSC8vd054TmdKQUlBRWdCQ0FLYWpZQ3hEY2dDQ0FLYXlFRUlBVWdDblloQlNBTlJRUkFJQUZCR1RZQ0FDQUJLQUlBSVFJTUR3c2dEVUVnY1FSQUlBRkJDellDQUNBQlFYODJBc1EzSUFFb0FnQWhBZ3dQQ3lBTlFjQUFjUVJBSUFCQm9QSUFOZ0lZSUFGQkhUWUNBQ0FCS0FJQUlRSU1Ed3NnQVVFVk5nSUFJQUVnRFVFUGNTSUpOZ0pJQ3lBR0lRZ2dCeUVLQWtBZ0NVVUVRQ0FCS0FKQUlRTU1BUXNnQ0NFRElBUWlBaUFKU1FSQUEwQWdCMFVORENBSFFYOXFJUWNnQXkwQUFDQUNkQ0FGYWlFRklBTkJBV29pQmlFRElBSkJDR29pQWlBSlNRMEFDd3NnQVNBQktBTEVOeUFKYWpZQ3hEY2dBU0FCS0FKQUlBVkJmeUFKZEVGL2MzRnFJZ00yQWtBZ0FpQUpheUVFSUFVZ0NYWWhCUXNnQVVFV05nSUFJQUVnQXpZQ3lEY0xJQVFoQ1NBSElRSWdCaUVEQWtBZ0JDQUJLQUpRSWhBZ0JVRi9JQUVvQWxoMFFYOXpJZzF4SWd0QkFuUnFMUUFCSWdwUEJFQWdCQ0VJREFFTEEwQWdBa1VOQ1NBRExRQUFJQWwwSVFvZ0EwRUJhaUVESUFKQmYyb2hBaUFKUVFocUlnZ2hDU0FJSUJBZ0JTQUthaUlGSUExeElndEJBblJxTFFBQklncEpEUUFMQ3lBUUlBdEJBblJxSWdZdkFRSWhFUUpBSUFZdEFBQWlEVUh3QVhFRVFDQUJLQUxFTnlFRUlBTWhCaUFDSVFjZ0NpRUpEQUVMSUFJaEJ5QURJUVlDUUNBS0lCQWdCVUYvSUFvZ0RXcDBRWDl6SWhWeElBcDJJQkZxSWcxQkFuUnFMUUFCSWdscUlBZ2lCRTBFUUNBSUlRc01BUXNEUUNBSFJRMEpJQVl0QUFBZ0JIUWhDU0FHUVFGcUlRWWdCMEYvYWlFSElBUkJDR29pQ3lFRUlBb2dFQ0FGSUFscUlnVWdGWEVnQ25ZZ0VXb2lEVUVDZEdvdEFBRWlDV29nQzBzTkFBc0xJQkFnRFVFQ2RHb2lBeTBBQUNFTklBTXZBUUloRVNBQklBRW9Bc1EzSUFwcUlnUTJBc1EzSUFzZ0Ntc2hDQ0FGSUFwMklRVUxJQUVnQkNBSmFqWUN4RGNnQ0NBSmF5RUVJQVVnQ1hZaEJTQU5RY0FBY1FSQUlBQkJ2UElBTmdJWUlBRkJIVFlDQUNBQktBSUFJUUlNRFFzZ0FVRVhOZ0lBSUFFZ0RVRVBjU0lKTmdKSUlBRWdFVUgvL3dOeE5nSkVDeUFHSVFnZ0J5RUtJQWtFUUNBSUlRTWdCQ0lDSUFsSkJFQURRQ0FIUlEwSElBZEJmMm9oQnlBRExRQUFJQUowSUFWcUlRVWdBMEVCYWlJR0lRTWdBa0VJYWlJQ0lBbEpEUUFMQ3lBQklBRW9Bc1EzSUFscU5nTEVOeUFCSUFFb0FrUWdCVUYvSUFsMFFYOXpjV28yQWtRZ0JTQUpkaUVGSUFJZ0NXc2hCQXNnQVVFWU5nSUFDeUFNRFFFTFFRQWhEQ0FQSVFNTUNnc0NRQ0FCS0FKRUlnTWdFeUFNYXlJQ1N3UkFBa0FnQXlBQ2F5SUNJQUVvQWl4TkRRQWdBU2dDd0RkRkRRQWdBRUhTOGdBMkFoZ2dBVUVkTmdJQUlBRW9BZ0FoQWd3TEN3Si9JQUlnQVNnQ01DSURTd1JBSUFFb0FpZ2dBaUFEYXlJQ2F3d0JDeUFESUFKckN5RUlJQUVvQWtBaUZDQUNJQUlnRkVzYklRTWdBU2dDTkNBSWFpRUNEQUVMSUE0Z0Eyc2hBaUFCS0FKQUloUWhBd3NnQVNBVUlBd2dBeUFESUF4TEd5SUlhellDUUNBSUlRTURRQ0FPSUFJdEFBQTZBQUFnRGtFQmFpRU9JQUpCQVdvaEFpQURRWDlxSWdNTkFBc2dEQ0FJYXlFTUlBRW9Ba0FOQUNBQlFSUTJBZ0FnQVNnQ0FDRUNEQWdMSUFFb0FnQWhBZ3dIQ3lBSUlBcHFJUVlnQkNBS1FRTjBhaUVFREFVTElBSWdBMm9oQmlBSUlBSkJBM1JxSVFRTUJBc2dCaUFIYWlFR0lBUWdCMEVEZEdvaEJBd0RDeUFJSUFwcUlRWWdCQ0FLUVFOMGFpRUVEQUlMUVFBaEJ5QURJUVlnQ0NFRUlBOGhBd3dEQ3lBQlFZQUNJQWgwTmdJVVFRQWhCQ0FCUVFCQkFFRUFFR1VpQXpZQ0dDQUFJQU0yQWpBZ0FVRUpRUXNnQlVHQXdBQnhHellDQUVFQUlRVWdBU2dDQUNFQ0RBRUxDMEVBSVFjZ0R5RURDeUFBSUF3MkFoQWdBQ0FPTmdJTUlBQWdCellDQkNBQUlBWTJBZ0FnQVNBRU5nSThJQUVnQlRZQ09BSkFBa0FnQVNnQ0tFVUVRQ0FNSUJOR0RRRWdBU2dDQUVFWlN3MEJDeUFBSUE0Z0V5QU1heENMQkEwQklBQW9BaEFoRENBQUtBSUVJUWNMSUFBZ0FDZ0NDQ0FjSUFkcmFqWUNDQ0FBSUJNZ0RHc2lBaUFBS0FJVWFqWUNGQ0FCSUFFb0Fod2dBbW8yQWh3Q1FDQUNSUTBBSUFFb0FnaEZEUUFnQUNnQ0RDQUNheUVHSUFFb0FoZ2hCQ0FCQW44Z0FTZ0NFQVJBSUFRZ0JpQUNFRFVNQVFzZ0JDQUdJQUlRWlFzaUFqWUNHQ0FBSUFJMkFqQUxJQUFnQVNnQ1BDQUJLQUlFUVFCSFFRWjBhaUFCS0FJQUlnQkJDMFpCQjNScVFZQUNJQUJCRGtaQkNIUWdBRUVUUmh0cU5nSXNJQU5CZXlBREd5RVVEQUVMSUFGQkhqWUNBQXNnRWtFUWFpUUFJQlFMa0FFQkEzOGdBRVVFUUVGK0R3c2dBRUVBTmdJWUlBQW9BaUFpQVVVRVFDQUFRUUEyQWlnZ0FFRWJOZ0lnUVJzaEFRc2dBQ2dDSkVVRVFDQUFRUncyQWlRTElBQW9BaWhCQVVITU55QUJFUUVBSWdKRkJFQkJmQThMSUFBZ0FqWUNIRUVBSVFFZ0FrRUFOZ0kwSUFBUWpnUWlBd1IvSUFBb0FpZ2dBaUFBS0FJa0VRUUFJQUJCQURZQ0hDQURCU0FCQ3d0ZUFRSi9RWDRoQWdKQUlBQkZEUUFnQUNnQ0hDSUJSUTBBQWtBZ0FTZ0NOQ0lDUlEwQUlBRW9BaVJCRDBZTkFDQUFLQUlvSUFJZ0FDZ0NKQkVFQUNBQlFRQTJBalFMSUFGQkR6WUNKQ0FCUVFFMkFnZ2dBQkNQQkNFQ0N5QUNDekVCQW45QmZpRUJBa0FnQUVVTkFDQUFLQUljSWdKRkRRQWdBa0VBTmdJd0lBSkNBRGNDS0NBQUVKQUVJUUVMSUFFTGxRRUJBMzlCZmlFQ0FrQWdBRVVOQUNBQUtBSWNJZ0ZGRFFCQkFDRUNJQUZCQURZQ0hDQUFRUUEyQWdnZ0FFSUFOd0lVSUFFb0FnZ2lBd1JBSUFBZ0EwRUJjVFlDTUFzZ0FVSUFOd0k0SUFGQkFEWUNJQ0FCUVlDQUFqWUNGQ0FCUVFBMkFnd2dBVUlBTndJQUlBRkNnWUNBZ0hBM0FzQTNJQUVnQVVHd0Ntb2lBRFlDYkNBQklBQTJBbEFnQVNBQU5nSk1DeUFDQzlRTEFSVi9JQUFvQWd4QmYyb2lCQ0FBS0FJUUlnTWdBV3RxSVJFZ0FDZ0NIQ0lKS0FJd0lnb2dDU2dDS0NJU2FpRVRJQWtvQWpSQmYyb2hERUYvSUFrb0FsaDBRWDl6SVJSQmZ5QUpLQUpVZEVGL2N5RVZJQU1nQkdwQi8zMXFJUTBnQUNnQ0FFRi9haUlJSUFBb0FnUnFRWHRxSVE0Z0NTZ0NVQ0VQSUFrb0Frd2hFQ0FKS0FJOElRVWdDU2dDT0NFQklBa29BaXdoRmdOQUlBVkJEazBFUUNBSUxRQUJJQVYwSUFGcUlBZ3RBQUlnQlVFSWFuUnFJUUVnQlVFUWFpRUZJQWhCQW1vaENBc2dCU0FRSUFFZ0ZYRkJBblJxSWdNdEFBRWlBbXNoQlNBQklBSjJJUUVnQXk4QkFpRUhBa0FDUUFKQUlBTXRBQUFpQWtVTkFDQUpBbjhDUUFKQUEwQWdBa0gvQVhFaEF5QUNRUkJ4QkVBZ0IwSC8vd054SVFjQ2Z5QURRUTl4SWdaRkJFQWdDQ0VESUFFTUFRc0NmeUFGSUFaUEJFQWdCU0VDSUFnTUFRc2dCVUVJYWlFQ0lBZ3RBQUVnQlhRZ0FXb2hBU0FJUVFGcUN5RURJQUlnQm1zaEJTQUJRWDhnQm5SQmYzTnhJQWRxSVFjZ0FTQUdkZ3NoQWlBRlFRNU5CRUFnQXkwQUFTQUZkQ0FDYWlBRExRQUNJQVZCQ0dwMGFpRUNJQVZCRUdvaEJTQURRUUpxSVFNTElBVWdEeUFDSUJSeFFRSjBhaUlJTFFBQklnRnJJUVVnQWlBQmRpRUJJQWd2QVFJaEJpQUlMUUFBSWdKQkVIRU5BZ05BSUFKQndBQnhSUVJBSUFVZ0R5QUJRWDhnQW5SQmYzTnhJQVpCLy84RGNXcEJBblJxSWdJdEFBRWlCbXNoQlNBQklBWjJJUUVnQWk4QkFpRUdJQUl0QUFBaUFrRVFjVVVOQVF3RUN3dEJ2UElBSVFjZ0F5RUlEQU1MSUFOQndBQnhSUVJBSUFVZ0VDQUJRWDhnQTNSQmYzTnhJQWRCLy84RGNXcEJBblJxSWdNdEFBRWlBbXNoQlNBQklBSjJJUUVnQXk4QkFpRUhJQU10QUFBaUFrVU5CUXdCQ3d0Qm9QSUFJUWRCQ3lBRFFTQnhEUUlhREFFTElBWkIvLzhEY1NFTEFuOGdCU0FDUVE5eElnSlBCRUFnQlNFR0lBTU1BUXNnQXkwQUFTQUZkQ0FCYWlFQklBTkJBV29nQlVFSWFpSUdJQUpQRFFBYUlBTXRBQUlnQm5RZ0FXb2hBU0FGUVJCcUlRWWdBMEVDYWdzaENDQUJRWDhnQW5SQmYzTnhJUU1nQmlBQ2F5RUZJQUVnQW5ZaEFRSkFJQU1nQzJvaUN5QUVJQkZySWdOTEJFQUNRQ0FMSUFOcklnTWdGazBOQUNBSktBTEFOMFVOQUVIUzhnQWhCd3dEQ3dKQUFrQWdDa1VFUUNBTUlCSWdBMnRxSVFJZ0F5RUdJQWNnQTAwTkFnTkFJQVFnQWkwQUFUb0FBU0FFUVFGcUlRUWdBa0VCYWlFQ0lBWkJmMm9pQmcwQUN3d0JDeUFLSUFOSkJFQWdEQ0FUSUFOcmFpRUNJQU1nQ21zaUF5RUdJQWNnQTAwTkFnTkFJQVFnQWkwQUFUb0FBU0FFUVFGcUlRUWdBa0VCYWlFQ0lBWkJmMm9pQmcwQUN5QU1JUUlnQnlBRGF5SUhJQW9pQmswRVFBd0RDd05BSUFRZ0FpMEFBVG9BQVNBRVFRRnFJUVFnQWtFQmFpRUNJQVpCZjJvaUJnMEFDeUFFSUF0cklRSWdCeUFLYXlFSERBSUxJQXdnQ2lBRGEyb2hBaUFESVFZZ0J5QURUUTBCQTBBZ0JDQUNMUUFCT2dBQklBUkJBV29oQkNBQ1FRRnFJUUlnQmtGL2FpSUdEUUFMQ3lBRUlBdHJJUUlnQnlBRGF5RUhDeUFIUVFOUEJFQURRQ0FFSUFJdEFBRTZBQUVnQkNBQ0xRQUNPZ0FDSUFRZ0FpMEFBem9BQXlBRVFRTnFJUVFnQWtFRGFpRUNJQWRCZldvaUIwRUNTdzBBQ3dzZ0IwVU5CU0FFSUFJdEFBRTZBQUVnQjBFQlJ3MEJJQVJCQVdvaEJBd0ZDeUFFSUF0cklRTURRQ0FFSWdJZ0F5SUdMUUFCT2dBQklBSWdBeTBBQWpvQUFpQUNJQU10QUFNNkFBTWdBa0VEYWlFRUlBTkJBMm9oQXlBSFFYMXFJZ2RCQWtzTkFBc2dCMFVOQkNBQ0lBWXRBQVE2QUFRZ0IwRUJSZ1JBSUFKQkJHb2hCQXdGQ3lBQ0lBWXRBQVU2QUFVZ0FrRUZhaUVFREFRTElBUWdBaTBBQWpvQUFpQUVRUUpxSVFRTUF3c2dBQ0FITmdJWVFSMExOZ0lBREFJTElBUWdCem9BQVNBRVFRRnFJUVFMSUFRZ0RVOE5BQ0FJSUE1SkRRRUxDeUFBSUFSQkFXbzJBZ3dnQUNBTklBUnJRWUVDYWpZQ0VDQUFJQWdnQlVFRGRtc2lBMEVCYWpZQ0FDQUFJQTRnQTJ0QkJXbzJBZ1FnQ1NBRlFRZHhJZ0EyQWp3Z0NTQUJRWDhnQUhSQmYzTnhOZ0k0Q3pnQkEzOERRQ0FDSUFCQkFYRnlJZ05CQVhRaEFpQUJRUUZLSVFRZ0FFRUJkaUVBSUFGQmYyb2hBU0FFRFFBTElBTkIvLy8vL3dkeEM2b0RBUVIvSXdCQklHc2lCQ1FBSUFRZ0FpOEJBRUVCZENJRE93RUNJQVFnQWk4QkFpQURRZjcvQTNGcVFRRjBJZ003QVFRZ0JDQUNMd0VFSUFOQi92OERjV3BCQVhRaUF6c0JCaUFFSUFJdkFRWWdBMEgrL3dOeGFrRUJkQ0lET3dFSUlBUWdBaThCQ0NBRFFmNy9BM0ZxUVFGMElnTTdBUW9nQkNBQ0x3RUtJQU5CL3Y4RGNXcEJBWFFpQXpzQkRDQUVJQUl2QVF3Z0EwSCsvd054YWtFQmRDSURPd0VPSUFRZ0FpOEJEaUFEUWY3L0EzRnFRUUYwSWdNN0FSQWdCQ0FDTHdFUUlBTkIvdjhEY1dwQkFYUWlBenNCRWlBRUlBSXZBUklnQTBIKy93Tnhha0VCZENJRE93RVVJQVFnQWk4QkZDQURRZjcvQTNGcVFRRjBJZ003QVJZZ0JDQUNMd0VXSUFOQi92OERjV3BCQVhRaUF6c0JHQ0FFSUFNZ0FpOEJHR3BCQVhRaUF6c0JHaUFFSUFJdkFSb2dBMnBCQVhRaUF6c0JIQ0FFSUFJdkFSd2dBMnBCQVhRN0FSNUJBQ0VDSUFGQkFFNEVRQU5BSUFBZ0FrRUNkR29pQmk4QkFpSURCRUFnQkNBRFFRRjBhaUlGSUFVdkFRQWlCVUVCYWpzQkFDQUdJQVVnQXhDU0JEc0JBQXNnQVNBQ1J5RURJQUpCQVdvaEFpQUREUUFMQ3lBRVFTQnFKQUFMN2dRQkMzOGdBeWdDRUNFR0lBTW9BZ2doQ0NBREtBSUVJUXdnQXlnQ0FDRUpJQUJCMUJacVFnQTNBUUFnQUVITUZtcENBRGNCQUNBQVFjUVdha0lBTndFQUlBQkJ2QlpxUWdBM0FRQWdBU0FBSUFBb0F0UW9RUUowYWtIY0Ztb29BZ0JCQW5ScVFRQTdBUUlDUUNBQUtBTFVLQ0lEUWJzRVNnMEFJQU5CQVdvaEF3TkFJQUVnQUNBRFFRSjBha0hjRm1vb0FnQWlCVUVDZENJTmFpSUtJQUVnQ2k4QkFrRUNkR292QVFJaUJFRUJhaUFHSUFZZ0JFb2JJZ3M3QVFJZ0JpQUVUQ0VPQWtBZ0JTQUNTZzBBSUFBZ0MwRUJkR3BCdkJacUlnUWdCQzhCQUVFQmFqc0JBRUVBSVFRZ0JTQUlUZ1JBSUF3Z0JTQUlhMEVDZEdvb0FnQWhCQXNnQUNBQUtBS29MU0FLTHdFQUlnVWdCQ0FMYW14cU5nS29MU0FKUlEwQUlBQWdBQ2dDckMwZ0JDQUpJQTFxTHdFQ2FpQUZiR28yQXF3dEN5QUhJQTVxSVFjZ0EwRUJhaUlEUWIwRVJ3MEFDeUFIUlEwQUlBQWdCa0VCZEdwQnZCWnFJUVFEUUNBR0lRTURRQ0FBSUFNaUJVRi9haUlEUVFGMGFrRzhGbW9pQ0M4QkFDSUpSUTBBQ3lBSUlBbEJmMm83QVFBZ0FDQUZRUUYwYWtHOEZtb2lBeUFETHdFQVFRSnFPd0VBSUFRZ0JDOEJBRUYvYWlJRE93RUFJQWRCQWtvaEJTQUhRWDVxSVFjZ0JRMEFDeUFHUlEwQVFiMEVJUVVEUUNBRFFmLy9BM0VoQnlBRklRTURRQ0FIQkVBZ0FDQURRWDlxSWdOQkFuUnFRZHdXYWlnQ0FDSUVJQUpLRFFFZ0FTQUVRUUowYWlJRkx3RUNJZ1FnQmtjRVFDQUFJQUFvQXFndElBVXZBUUFnQmlBRWEyeHFOZ0tvTFNBRklBWTdBUUlMSUFkQmYyb2hCeUFESVFVTUFRc0xJQVpCZjJvaUJrVU5BU0FBSUFaQkFYUnFRYndXYWk4QkFDRUREQUFMQUFzTFV3RUJmeU1BUVNCcklnUWtBQ0FFSUFFMkFoZ2dCQ0FBTmdJVUlBUkJ2QWcyQWhBZ0JFR0FDVFlDQ0NBRUlBSTJBZ3dnQkVFUWFpQUVRUWhxRUtvRUlBTWdCQ2dDRENBQ2F6WUNBQ0FFUVNCcUpBQUxrd1VCQlg4Z0FDOEJ1QzBnQVVILy9RTnFRZi8vQTNFaUJpQUFLQUs4TFNJRWRISWhCUUpBSUFSQkRFNEVRQ0FBSUFVN0FiZ3RJQUFnQUNnQ0ZDSUVRUUZxTmdJVUlBUWdBQ2dDQ0dvZ0JUb0FBQ0FBSUFBb0FoUWlCRUVCYWpZQ0ZDQUVJQUFvQWdocUlBQkJ1UzFxTFFBQU9nQUFJQUFvQXJ3dElnVkJkV29oQkNBR1FSQWdCV3QySVFVTUFRc2dCRUVGYWlFRUN5QUFJQVEyQXJ3dElBSkJmMnBCLy84RGNTSUhJQVIwSVFZQ2Z5QUVRUXhPQkVBZ0FDQUZJQVp5SWdRN0FiZ3RJQUFnQUNnQ0ZDSUZRUUZxTmdJVUlBVWdBQ2dDQ0dvZ0JEb0FBQ0FBSUFBb0FoUWlCRUVCYWpZQ0ZDQUVJQUFvQWdocUlBQkJ1UzFxTFFBQU9nQUFJQUFvQXJ3dElnVkJkV29oQkNBSFFSQWdCV3QyREFFTElBUkJCV29oQkNBRklBWnlDeUVGSUFBZ0JEWUN2QzBnQUNBRklBTkIvUDhEYWtILy93TnhJZ1lnQkhSeUlnVTdBYmd0QWtBZ0JFRU5UZ1JBSUFBZ0FDZ0NGQ0lFUVFGcU5nSVVJQVFnQUNnQ0NHb2dCVG9BQUNBQUlBQW9BaFFpQkVFQmFqWUNGQ0FFSUFBb0FnaHFJQUJCdVMxcUxRQUFPZ0FBSUFBb0Fyd3RJZ1ZCZEdvaEJDQUdRUkFnQld0MklRVU1BUXNnQkVFRWFpRUVDeUFBSUFRMkFyd3RRUUFoQmlBQVFia3RhaUVIQTBBZ0FDQUZJQUFnQmtHQTVRQnFMUUFBUVFKMGFrSCtGR292QVFBaUNDQUVkSElpQlRzQnVDMGdBQUovSUFSQkRrNEVRQ0FBSUFBb0FoUWlCRUVCYWpZQ0ZDQUVJQUFvQWdocUlBVTZBQUFnQUNBQUtBSVVJZ1JCQVdvMkFoUWdCQ0FBS0FJSWFpQUhMUUFBT2dBQUlBQWdDRUVRSUFBb0Fyd3RJZ1JyZGlJRk93RzRMU0FFUVhOcURBRUxJQVJCQTJvTElnUTJBcnd0SUFaQkFXb2lCaUFEUncwQUN5QUFJQUJCbEFGcUlBRkJmMm9RaVFJZ0FDQUFRWWdUYWlBQ1FYOXFFSWtDQzY4Q0FDQUFJQUJCbEFGcUlBQkJuQlpxS0FJQUVJb0NJQUFnQUVHSUUyb2dBRUdvRm1vb0FnQVFpZ0lnQUNBQVFiQVdhaEN1QVNBQUlBQW9BcWd0QW45QkVpQUFRYm9WYWk4QkFBMEFHa0VSSUFCQmdoVnFMd0VBRFFBYVFSQWdBRUcyRldvdkFRQU5BQnBCRHlBQVFZWVZhaThCQUEwQUdrRU9JQUJCc2hWcUx3RUFEUUFhUVEwZ0FFR0tGV292QVFBTkFCcEJEQ0FBUWE0VmFpOEJBQTBBR2tFTElBQkJqaFZxTHdFQURRQWFRUW9nQUVHcUZXb3ZBUUFOQUJwQkNTQUFRWklWYWk4QkFBMEFHa0VJSUFCQnBoVnFMd0VBRFFBYVFRY2dBRUdXRldvdkFRQU5BQnBCQmlBQVFhSVZhaThCQUEwQUdrRUZJQUJCbWhWcUx3RUFEUUFhUVFRZ0FFR2VGV292QVFBTkFCcEJBMEVDSUFCQi9oUnFMd0VBR3dzaUFFRURiR3BCRVdvMkFxZ3RJQUFMamdFQkFuOUIvNEQvbjM4aEFRTkFBa0FnQVVFQmNVVU5BQ0FBSUFKQkFuUnFMd0dVQVVVTkFFRUFEd3NnQVVFQmRpRUJJQUpCQVdvaUFrRWdSdzBBQzBFQklRRUNRQ0FBTHdHNEFRMEFJQUF2QWJ3QkRRQWdBQzhCeUFFTkFFRWdJUUlEUUNBQUlBSkJBblJxTHdHVUFVVUVRRUVBSVFFZ0FrRUJhaUlDUVlBQ1J3MEJEQUlMQzBFQklRRUxJQUVMckFFQkFYOENRQ0FBQW44Z0FDZ0N2QzBpQVVFUVJnUkFJQUFnQUNnQ0ZDSUJRUUZxTmdJVUlBRWdBQ2dDQ0dvZ0FDMEF1QzA2QUFBZ0FDQUFLQUlVSWdGQkFXbzJBaFFnQVNBQUtBSUlhaUFBUWJrdGFpMEFBRG9BQUNBQVFRQTdBYmd0UVFBTUFRc2dBVUVJU0EwQklBQWdBQ2dDRkNJQlFRRnFOZ0lVSUFFZ0FDZ0NDR29nQUMwQXVDMDZBQUFnQUNBQVFia3RhaTBBQURzQnVDMGdBQ2dDdkMxQmVHb0xOZ0s4TFFzTHZ3RUJBbjhnQUJDTUFpQUFJQUFvQWhRaUEwRUJhallDRkNBRElBQW9BZ2hxSUFJNkFBQWdBQ0FBS0FJVUlnTkJBV28yQWhRZ0F5QUFLQUlJYWlBQ1FRaDJPZ0FBSUFBZ0FDZ0NGQ0lEUVFGcU5nSVVJQU1nQUNnQ0NHb2dBa0YvY3lJRE9nQUFJQUFnQUNnQ0ZDSUVRUUZxTmdJVUlBUWdBQ2dDQ0dvZ0EwRUlkam9BQUNBQ0JFQURRQ0FCTFFBQUlRTWdBQ0FBS0FJVUlnUkJBV28yQWhRZ0JDQUFLQUlJYWlBRE9nQUFJQUZCQVdvaEFTQUNRWDlxSWdJTkFBc0xDLzBHQVF0L0l3QkJFR3NpQ2lRQUFrQWdBQ2dDQ0NBQUtBSUVJZ05yUVFSTUJFQWdBQkN4QVVVTkFTQUFLQUlFSVFNTEEwQWdBMEVCYWlFSUlBTXRBQUFpQjBFRGNVVUVRQ0FIUVFKMklnWkJBV29oQkNBQUtBSUlJZ3NnQ0dzaUJVRVZTU0FIUVQ5TGNpQUJLQUlJSWd3Z0FTZ0NCQ0lDYXlJSlFSQkpja1VFUUNBQ0lBTW9BQUUyQUFBZ0FpQURLQUFGTmdBRUlBSWdBeWdBQ1RZQUNDQUNJQU1vQUEwMkFBd2dBU0FDSUFScU5nSUVJQVFnQ0dvaEF3d0NDd0pBSUFkQjhBRkpCRUFnQ0NFR0RBRUxJQXNnQ0NBR1FVVnFJZ2RxSWdacklRVWdCMEVDZEVIQURXb29BZ0FnQ0NnQUFIRkJBV29oQkFzQ1FDQUVJQVZORFFBZ0RDQUNheUFGU1EwREEwQWdBU0FDSUFZZ0JSQXFJQVZxTmdJRUlBQW9BZ0FpQWlBQUtBSU1JQUlvQWdBb0FoQVJCQUFnQUNnQ0FDSUNJQXBCREdvZ0FpZ0NBQ2dDREJFREFDRUdJQUFnQ2lnQ0RDSUhOZ0lNSUFkRkRRUWdBQ0FHSUFkcU5nSUlJQUVvQWdnZ0FTZ0NCQ0lDYXlFSklBUWdCV3NpQkNBSFRRMEJJQWtnQnlJRlR3MEFDd3dEQ3lBSklBUkpEUUlnQVNBQ0lBWWdCQkFxSUFScU5nSUVJQUFvQWdnZ0JDQUdhaUlEYTBFRVNnMEJJQUFnQXpZQ0JDQUFFTEVCUlEwQ0lBQW9BZ1FoQXd3QkN5QUJLQUlFSWdZZ0FTZ0NBR3NnQjBFQmRFSEFDV292QVFBaUJVRUxkaUlKUVFKMFFjQU5haWdDQUNBSUtBQUFjU0FGUVlBT2NXb2lCRUYvYWswTkFRSkFJQVJCQ0VrZ0JVSC9BWEVpQjBFUVMzSWdBU2dDQ0NBR2F5SUNRUkJKY2tVRVFDQUdJQVlnQkdzaUFpZ0FBRFlBQUNBR0lBSW9BQVEyQUFRZ0JpQUNLQUFJTmdBSUlBWWdBaWdBRERZQURBd0JDd0pBQWtBZ0FpQUhRUXBxVHdSQUlBWWdCR3NoQlNBR0lRTWdCeUVDSUFSQkIwd05BUXdDQ3lBQ0lBZEpEUVFnQmlBRWF5RURJQVloQlNBSElRSURRQ0FGSUFNdEFBQTZBQUFnQlVFQmFpRUZJQU5CQVdvaEF5QUNRUUZLSVFRZ0FrRi9haUVDSUFRTkFBc01BZ3NEUUNBRElBVW9BQUEyQUFBZ0F5QUZLQUFFTmdBRUlBSWdCR3NoQWlBRElBUnFJZ01nQldzaUJFRUlTQTBBQ3dzZ0FrRUFUQTBBQTBBZ0F5QUZLQUFBTmdBQUlBTWdCU2dBQkRZQUJDQURRUWhxSVFNZ0JVRUlhaUVGSUFKQkNFb2hCQ0FDUVhocUlRSWdCQTBBQ3dzZ0FTQUdJQWRxTmdJRUlBQW9BZ2dnQ0NBSmFpSURhMEVFU2cwQUlBQWdBellDQkNBQUVMRUJSUTBCSUFBb0FnUWhBd3dBQ3dBTElBcEJFR29rQUF1b0JnRUpmd05BQWtBQ1FBSkFJQUFvQW5RaUJrR0RBazhFUUNBQVFRQTJBbUFNQVFzZ0FCQjJJQUFvQW5RaUJrR0RBazlCQkhKRkJFQkJBQThMSUFZRVFDQUFRUUEyQW1BZ0JrRUNTdzBCSUFBb0Ftd2hCd3dDQ3lBQVFRQTJBclF0SUFBZ0FDZ0NYQ0lCUVFCT0JIOGdBQ2dDT0NBQmFnVkJBQXNnQUNnQ2JDQUJhMEVCRUVRZ0FDQUFLQUpzTmdKY0lBQW9BZ0FRTmtFRFFRSWdBQ2dDQUNnQ0VCc1BDeUFBS0FKc0lnZEZCRUJCQUNFSERBRUxJQUFvQWpnZ0Iyb2lDRUYvYWlJQkxRQUFJZ01nQ0MwQUFFY05BQ0FESUFFdEFBSkhEUUFnQXlBQkxRQURSdzBBSUFoQmdnSnFJUWxCZnlFQkEwQUNRQ0FCSUFocUlnSXRBQVFnQTBjRVFDQUNRUVJxSVFVTUFRc2dBaTBBQlNBRFJ3UkFJQUpCQldvaEJRd0JDeUFDTFFBR0lBTkhCRUFnQWtFR2FpRUZEQUVMSUFJdEFBY2dBMGNFUUNBQ1FRZHFJUVVNQVFzZ0F5QUlJQUZCQ0dvaUJHb2lCUzBBQUVjTkFDQUNMUUFKSUFOSEJFQWdBa0VKYWlFRkRBRUxJQUl0QUFvZ0EwY0VRQ0FDUVFwcUlRVU1BUXNnQWtFTGFpRUZJQUZCOWdGS0RRQWdCQ0VCSUFNZ0JTMEFBRVlOQVFzTElBQWdCaUFGSUFsclFZSUNhaUlCSUFFZ0Jrc2JJZ0UyQW1BZ0FVRURTUTBBSUFBb0FxUXRJQUFvQXFBdElnUkJBWFJxUVFFN0FRQWdBQ0FFUVFGcU5nS2dMU0FFSUFBb0FwZ3RhaUFCUVgxcUlnRTZBQUFnQVVIL0FYRkJvT1VBYWkwQUFFRUNkRUdBQ0hJZ0FHb2lBU0FCTHdHWUFVRUJhanNCbUFFZ0FDZ0NZQ0VCSUFCQkFEWUNZQ0FBSUFBdkFZZ1RRUUZxT3dHSUV5QUFJQUFvQW5RZ0FXczJBblFnQUNBQklBQW9BbXhxSWdZMkFtd01BUXNnQUNnQ09DQUhhaTBBQUNFQklBQW9BcVF0SUFBb0FxQXRJZ1JCQVhScVFRQTdBUUFnQUNBRVFRRnFOZ0tnTFNBRUlBQW9BcGd0YWlBQk9nQUFJQUFnQVVFQ2RHb2lBU0FCTHdHVUFVRUJhanNCbEFFZ0FDQUFLQUowUVg5cU5nSjBJQUFnQUNnQ2JFRUJhaUlHTmdKc0N5QUFLQUtnTFNBQUtBS2NMVUYvYWtjTkFFRUFJUUVnQUNBQUtBSmNJZ1JCQUU0RWZ5QUFLQUk0SUFScUJVRUFDeUFHSUFSclFRQVFSQ0FBSUFBb0FtdzJBbHdnQUNnQ0FCQTJJQUFvQWdBb0FoQU5BQXNnQVF1L0FnRURmd0pBQTBBQ1FBSkFJQUFvQW5RTkFDQUFFSFlnQUNnQ2RBMEFEQUVMSUFCQkFEWUNZQ0FBS0FJNElBQW9BbXhxTFFBQUlRRWdBQ2dDcEMwZ0FDZ0NvQzBpQWtFQmRHcEJBRHNCQUNBQUlBSkJBV28yQXFBdElBSWdBQ2dDbUMxcUlBRTZBQUFnQUNBQlFRSjBhaUlCSUFFdkFaUUJRUUZxT3dHVUFTQUFJQUFvQW5SQmYybzJBblFnQUNBQUtBSnNRUUZxSWdJMkFtd2dBQ2dDb0MwZ0FDZ0NuQzFCZjJwSERRRWdBQ0FBS0FKY0lnRkJBRTRFZnlBQUtBSTRJQUZxQlVFQUN5QUNJQUZyUVFBUVJDQUFJQUFvQW13MkFsd2dBQ2dDQUJBMklBQW9BZ0FvQWhBTkFRd0NDd3NnQUVFQU5nSzBMU0FBSUFBb0Fsd2lBVUVBVGdSL0lBQW9BamdnQVdvRlFRQUxJQUFvQW13Z0FXdEJBUkJFSUFBZ0FDZ0NiRFlDWENBQUtBSUFFRFpCQTBFQ0lBQW9BZ0FvQWhBYkR3c2dBd3VHQVFFQmZ5QUNJQUFvQWdRaUF5QURJQUpMR3lJQ0JFQWdBQ0FESUFKck5nSUVJQUVnQUNnQ0FDQUNFQ29oQVFKQUFrQUNRQ0FBS0FJY0tBSVlRWDlxRGdJQUFRSUxJQUFnQUNnQ01DQUJJQUlRWlRZQ01Bd0JDeUFBSUFBb0FqQWdBU0FDRURVMkFqQUxJQUFnQUNnQ0FDQUNhallDQUNBQUlBQW9BZ2dnQW1vMkFnZ0xJQUlMMmdvQkIzOENRQU5BQWtBQ1FBSkFJQUFvQW5SQmhRSkxEUUFnQUJCMklBRWdBQ2dDZENJQ1FZWUNUM0pGQkVCQkFBOExJQUpGRFFJZ0FrRUNTdzBBSUFBZ0FDZ0NZQ0lDTmdKNElBQWdBQ2dDY0RZQ1pFRUNJUVFnQUVFQ05nSmdEQUVMUVFJaEJDQUFJQUFvQWxRZ0FDZ0NiQ0lESUFBb0FqaHFMUUFDSUFBb0FrZ2dBQ2dDV0hSemNTSUNOZ0pJSUFBb0FrQWdBeUFBS0FJMGNVRUJkR29nQUNnQ1JDQUNRUUYwYWlJQ0x3RUFJZ1U3QVFBZ0FpQURPd0VBSUFBZ0FDZ0NZQ0lDTmdKNElBQWdBQ2dDY0RZQ1pDQUFRUUkyQW1BZ0JVVU5BQUpBSUFJZ0FDZ0NnQUZQRFFBZ0F5QUZheUFBS0FJc1FmcDlha3NOQUNBQUlBQWdCUkNQQWlJRU5nSmdJQVJCQlVzTkFDQUFLQUtJQVVFQlJ3UkFJQVJCQTBjTkFVRURJUVFnQUNnQ2JDQUFLQUp3YTBHQklFa05BUXRCQWlFRUlBQkJBallDWUFzZ0FDZ0NlQ0VDQ3lBQ1FRTkpJQVFnQWt0eVJRUkFJQUFvQW5RaEJTQUFLQUtrTFNBQUtBS2dMU0lEUVFGMGFpQUFLQUpzSWdZZ0FDZ0NaRUYvYzJvaUJEc0JBQ0FBSUFOQkFXbzJBcUF0SUFNZ0FDZ0NtQzFxSUFKQmZXb2lBam9BQUNBQ1FmOEJjVUdnNVFCcUxRQUFRUUowUVlBSWNpQUFhaUlDUVpnQmFpQUNMd0dZQVVFQmFqc0JBQ0FBSUFSQmYycEIvLzhEY1NJQ0lBSkJCM1pCZ0FKcUlBSkJnQUpKRzBHZzZBQnFMUUFBUVFKMGFrR0lFMm9pQWlBQ0x3RUFRUUZxT3dFQUlBQWdBQ2dDZUNJQ1FYNXFJZ1EyQW5nZ0FDQUFLQUowSUFKclFRRnFOZ0owSUFVZ0JtcEJmV29oQlNBQUtBSnNJUUlnQUNnQ25DMGhCaUFBS0FLZ0xTRUlBMEFnQUNBQ0lnTkJBV29pQWpZQ2JDQUNJQVZOQkVBZ0FDQUFLQUpVSUFNZ0FDZ0NPR290QUFNZ0FDZ0NTQ0FBS0FKWWRITnhJZ2MyQWtnZ0FDZ0NRQ0FBS0FJMElBSnhRUUYwYWlBQUtBSkVJQWRCQVhScUlnY3ZBUUE3QVFBZ0J5QUNPd0VBQ3lBQUlBUkJmMm9pQkRZQ2VDQUVEUUFMSUFCQkFqWUNZQ0FBUVFBMkFtZ2dBQ0FEUVFKcUlnVTJBbXdnQ0NBR1FYOXFSdzBDUVFBaEFrRUFJUVFnQUNBQUtBSmNJZ05CQUU0RWZ5QUFLQUk0SUFOcUJTQUVDeUFGSUFOclFRQVFSQ0FBSUFBb0FtdzJBbHdnQUNnQ0FCQTJJQUFvQWdBb0FoQU5BZ3dEQ3lBQUtBSm9CRUFnQUNnQ2JDQUFLQUk0YWtGL2FpMEFBQ0VDSUFBb0FxUXRJQUFvQXFBdElnTkJBWFJxUVFBN0FRQWdBQ0FEUVFGcU5nS2dMU0FESUFBb0FwZ3RhaUFDT2dBQUlBQWdBa0VDZEdvaUFrR1VBV29nQWk4QmxBRkJBV283QVFBZ0FDZ0NvQzBnQUNnQ25DMUJmMnBHQkVCQkFDRUNJQUFnQUNnQ1hDSURRUUJPQkg4Z0FDZ0NPQ0FEYWdVZ0Fnc2dBQ2dDYkNBRGEwRUFFRVFnQUNBQUtBSnNOZ0pjSUFBb0FnQVFOZ3NnQUNBQUtBSnNRUUZxTmdKc0lBQWdBQ2dDZEVGL2FqWUNkQ0FBS0FJQUtBSVFEUUpCQUE4RklBQkJBVFlDYUNBQUlBQW9BbXhCQVdvMkFtd2dBQ0FBS0FKMFFYOXFOZ0owREFJTEFBc0xJQUFvQW1nRVFDQUFLQUpzSUFBb0FqaHFRWDlxTFFBQUlRSWdBQ2dDcEMwZ0FDZ0NvQzBpQTBFQmRHcEJBRHNCQUNBQUlBTkJBV28yQXFBdElBTWdBQ2dDbUMxcUlBSTZBQUFnQUNBQ1FRSjBhaUlDUVpRQmFpQUNMd0dVQVVFQmFqc0JBQ0FBUVFBMkFtZ0xJQUFnQUNnQ2JDSURRUUlnQTBFQ1NSczJBclF0SUFGQkJFWUVRRUVBSVFRZ0FDQUFLQUpjSWdGQkFFNEVmeUFBS0FJNElBRnFCU0FFQ3lBRElBRnJRUUVRUkNBQUlBQW9BbXcyQWx3Z0FDZ0NBQkEyUVFOQkFpQUFLQUlBS0FJUUd3OExJQUFvQXFBdEJFQkJBQ0VDUVFBaEJDQUFJQUFvQWx3aUFVRUFUZ1IvSUFBb0FqZ2dBV29GSUFRTElBTWdBV3RCQUJCRUlBQWdBQ2dDYkRZQ1hDQUFLQUlBRURZZ0FDZ0NBQ2dDRUVVTkFRdEJBU0VDQ3lBQ0M3d0lBUTEvQWtBRFFBSkFBa0FDUUNBQUtBSjBRWVVDVFFSQUlBQVFkaUFCSUFBb0FuUWlBa0dHQWs5eVJRUkFRUUFQQ3lBQ1JRMERJQUpCQTBrTkFRc2dBQ0FBS0FKVUlBQW9BbXdpQkNBQUtBSTRhaTBBQWlBQUtBSklJQUFvQWxoMGMzRWlBallDU0NBQUtBSkFJQVFnQUNnQ05IRkJBWFJxSUFBb0FrUWdBa0VCZEdvaUFpOEJBQ0lET3dFQUlBSWdCRHNCQUNBRFJRMEFJQVFnQTJzZ0FDZ0NMRUg2ZldwTERRQWdBQ0FBSUFNUWp3SWlBellDWUF3QkN5QUFLQUpnSVFNTEFrQWdBMEVEVHdSQUlBQW9BcVF0SUFBb0FxQXRJZ0pCQVhScUlBQW9BbXdnQUNnQ2NHc2lCRHNCQUNBQUlBSkJBV28yQXFBdElBSWdBQ2dDbUMxcUlBTkJmV29pQWpvQUFDQUNRZjhCY1VHZzVRQnFMUUFBUVFKMFFZQUljaUFBYWlJQ1FaZ0JhaUFDTHdHWUFVRUJhanNCQUNBQUlBUkJmMnBCLy84RGNTSUNJQUpCQjNaQmdBSnFJQUpCZ0FKSkcwR2c2QUJxTFFBQVFRSjBha0dJRTJvaUFpQUNMd0VBUVFGcU93RUFJQUFnQUNnQ2RDQUFLQUpnSWdOcklnSTJBblFnQUNnQ25DMUJmMm9oQnlBQUtBS2dMU0VJQWtBZ0FrRURTUTBBSUFNZ0FDZ0NnQUZMRFFBZ0FDQURRWDlxSWdVMkFtQWdBQ2dDU0NFR0lBQW9BbXdoQXlBQUtBSTBJUWtnQUNnQ1FDRUtJQUFvQWtRaEN5QUFLQUpVSVF3Z0FDZ0NPQ0VOSUFBb0FsZ2hEZ05BSUFBZ0F5SUNRUUZxSWdNMkFtd2dBQ0FDSUExcUxRQURJQVlnRG5SeklBeHhJZ1kyQWtnZ0NpQURJQWx4UVFGMGFpQUxJQVpCQVhScUlnUXZBUUE3QVFBZ0JDQURPd0VBSUFBZ0JVRi9haUlGTmdKZ0lBVU5BQXNnQUNBQ1FRSnFJZ00yQW13Z0J5QUlSdzBFREFJTElBQkJBRFlDWUNBQUlBQW9BbXdnQTJvaUF6WUNiQ0FBSUFBb0FqZ2dBMm9pQkMwQUFDSUNOZ0pJSUFBZ0FDZ0NWQ0FFTFFBQklBSWdBQ2dDV0hSemNUWUNTQ0FISUFoSERRTU1BUXNnQUNnQ09DQUFLQUpzYWkwQUFDRURJQUFvQXFRdElBQW9BcUF0SWdKQkFYUnFRUUE3QVFBZ0FDQUNRUUZxTmdLZ0xTQUNJQUFvQXBndGFpQURPZ0FBSUFBZ0EwRUNkR29pQWtHVUFXb2dBaThCbEFGQkFXbzdBUUFnQUNBQUtBSjBRWDlxTmdKMElBQWdBQ2dDYkVFQmFpSUROZ0pzSUFBb0FxQXRJQUFvQXB3dFFYOXFSdzBDQzBFQUlRUkJBQ0VHSUFBZ0FDZ0NYQ0lDUVFCT0JIOGdBQ2dDT0NBQ2FnVWdCZ3NnQXlBQ2EwRUFFRVFnQUNBQUtBSnNOZ0pjSUFBb0FnQVFOaUFBS0FJQUtBSVFEUUVNQWdzTElBQWdBQ2dDYkNJQ1FRSWdBa0VDU1JzMkFyUXRJQUZCQkVZRVFFRUFJUVVnQUNBQUtBSmNJZ0ZCQUU0RWZ5QUFLQUk0SUFGcUJTQUZDeUFDSUFGclFRRVFSQ0FBSUFBb0FtdzJBbHdnQUNnQ0FCQTJRUU5CQWlBQUtBSUFLQUlRR3c4TElBQW9BcUF0QkVCQkFDRUVRUUFoQlNBQUlBQW9BbHdpQVVFQVRnUi9JQUFvQWpnZ0FXb0ZJQVVMSUFJZ0FXdEJBQkJFSUFBZ0FDZ0NiRFlDWENBQUtBSUFFRFlnQUNnQ0FDZ0NFRVVOQVF0QkFTRUVDeUFFQzdZQkFRRi9Jd0JCUUdvaUF5UUFJQU1nQVRZQ0VDQURJQUEyQWd3Z0EwRzhDRFlDQ0NBRElBSTJBaHdnQXlBQ05nSVlJQU5DQURjQU1TQURRZ0EzQWl3Z0F5QURRUWhxTmdJb1FRQWhBQ0FEUVFBMkFpUUNRQ0FEUVNocUlBTkJKR29RclFSRkRRQWdBeUFDSUFNb0FpUnFOZ0lnSUFOQktHb2dBMEVZYWhDYkJDQURMUUE0UlEwQUlBTW9BaHdnQXlnQ0lFWWhBQXNnQXlnQ0tDSUJJQU1vQWpRZ0FTZ0NBQ2dDRUJFRUFDQURRVUJySkFBZ0FBdllBd0VGZnlBQUtBSU1RWHRxSWdKQi8vOERJQUpCLy84RFNSc2hCUUpBQTBBQ1FDQUFLQUowSWdKQkFVMEVRQ0FBRUhZZ0FDZ0NkQ0lDSUFGeVJRUkFRUUFQQ3lBQ1JRMEJDeUFBUVFBMkFuUWdBQ0FBS0FKc0lBSnFJZ0kyQW13Z0FrRUFJQUlnQUNnQ1hDSURJQVZxSWdSSkd3Ui9JQUlGSUFBZ0JEWUNiQ0FBSUFJZ0JHczJBblJCQUNFRVFRQWhBaUFBSUFOQkFFNEVmeUFBS0FJNElBTnFCU0FDQ3lBRlFRQVFSQ0FBSUFBb0FtdzJBbHdnQUNnQ0FCQTJJQUFvQWdBb0FoQkZEUU1nQUNnQ1hDRURJQUFvQW13TElBTnJJZ1lnQUNnQ0xFSDZmV3BKRFFGQkFDRUVRUUFoQWlBQUlBTkJBRTRFZnlBQUtBSTRJQU5xQlNBQ0N5QUdRUUFRUkNBQUlBQW9BbXcyQWx3Z0FDZ0NBQkEySUFBb0FnQW9BaEFOQVF3Q0N3dEJBQ0VDSUFCQkFEWUN0QzBnQVVFRVJnUkFJQUFnQUNnQ1hDSUJRUUJPQkg4Z0FDZ0NPQ0FCYWdVZ0Fnc2dBQ2dDYkNBQmEwRUJFRVFnQUNBQUtBSnNOZ0pjSUFBb0FnQVFOa0VEUVFJZ0FDZ0NBQ2dDRUJzUEN5QUFLQUpzSWdNZ0FDZ0NYQ0lCU2dSQVFRQWhCQ0FBSUFGQkFFNEVmeUFBS0FJNElBRnFCU0FDQ3lBRElBRnJRUUFRUkNBQUlBQW9BbXcyQWx3Z0FDZ0NBQkEySUFBb0FnQW9BaEJGRFFFTFFRRWhCQXNnQkF0aUFDQUFRUUEyQXJ3dElBQkJBRHNCdUMwZ0FFRzRGbXBCd09rQk5nSUFJQUFnQUVIOEZHbzJBckFXSUFCQnJCWnFRYXpwQVRZQ0FDQUFJQUJCaUJOcU5nS2tGaUFBUWFBV2FrR1k2UUUyQWdBZ0FDQUFRWlFCYWpZQ21CWWdBQkNOQWd1b0FRRUNmeUFBSUFBb0FpeEJBWFEyQWp3Z0FDZ0NSQ0lCSUFBb0FreEJBWFJCZm1vaUFtcEJBRHNCQUNBQlFRQWdBaEFvR2lBQVFRQTJBclF0SUFCQ2dJQ0FnQ0EzQW5RZ0FFSUFOd0pvSUFCQ2dJQ0FnQ0EzQWx3Z0FFRUFOZ0pJSUFBZ0FDZ0NoQUZCREd3aUFVRzAxd0JxTHdFQU5nS1FBU0FBSUFGQnNOY0FhaThCQURZQ2pBRWdBQ0FCUWJMWEFHb3ZBUUEyQW9BQklBQWdBVUcyMXdCcUx3RUFOZ0o4QzZvQkFRSi9RWDRoQWdKQUlBQkZEUUFnQUNnQ0hDSUJSUTBBSUFBb0FpQkZEUUFnQUNnQ0pFVU5BQ0FBUVFJMkFpd2dBRUVBTmdJSUlBQkNBRGNDRkNBQlFRQTJBaFFnQVNBQktBSUlOZ0lRSUFFb0FoZ2lBa0YvVEFSQUlBRkJBQ0FDYXlJQ05nSVlDeUFCUVNwQjhRQWdBaHMyQWdRZ0FBSi9JQUpCQWtZRVFFRUFRUUJCQUJBMURBRUxRUUJCQUVFQUVHVUxOZ0l3UVFBaEFpQUJRUUEyQWlnZ0FSQ2pCQXNnQWdzR0FDQUJFRGdMQ1FBZ0FTQUNiQkJNQzlBREFRTi9RWG9oQWdKQVFhQ0VBUzBBQUVFeFJ3MEFRWDRoQWlBQVJRMEFJQUJCQURZQ0dDQUFLQUlnSWdORkJFQWdBRUVBTmdJb0lBQkJHellDSUVFYklRTUxJQUFvQWlSRkJFQWdBRUVjTmdJa0MwRUdJQUVnQVVGL1Joc2lCRUVKU3cwQVFYd2hBaUFBS0FJb1FRRkJ4QzBnQXhFQkFDSUJSUTBBSUFBZ0FUWUNIQ0FCUWdFM0FoZ2dBU0FBTmdJQUlBRkIvLzhCTmdJMElBRkNnSUNDZ1BBQk53SXNJQUZDLy8rQmdOQUFOd0pVSUFGQ2dJQ0NnUEFCTndKTUlBRWdBQ2dDS0VHQWdBSkJBaUFBS0FJZ0VRRUFOZ0k0SUFFZ0FDZ0NLQ0FCS0FJc1FRSWdBQ2dDSUJFQkFEWUNRQ0FBS0FJb0lBRW9Ba3hCQWlBQUtBSWdFUUVBSVFJZ0FVRUFOZ0xBTFNBQklBSTJBa1FnQVVHQWdBRTJBcHd0SUFFZ0FDZ0NLRUdBZ0FGQkJDQUFLQUlnRVFFQUlnSTJBZ2dnQVNBQktBS2NMU0lEUVFKME5nSU1Ba0FDUUNBQktBSTRSUTBBSUFFb0FrQkZJQUpGY2cwQUlBRW9Ba1FOQVFzZ0FVR2FCVFlDQkNBQVFiT0VBVFlDR0NBQUVLOEJHa0Y4RHdzZ0FVRUFOZ0tJQVNBQklBUTJBb1FCSUFGQkNEb0FKQ0FCSUFJZ0EwRURiR28yQXBndElBRWdBaUFEUVg1eGFqWUNwQzBnQUJDbEJDSUJSUVJBSUFBb0Fod1FwQVFMSUFFaEFnc2dBZ3ZoQmdBZ0FFRi9jeUVBQWtBZ0FrVWdBVUVEY1VWeURRQURRQ0FCTFFBQUlBQkIvd0Z4YzBFQ2RFR3dGMm9vQWdBZ0FFRUlkbk1oQUNBQlFRRnFJUUVnQWtGL2FpSUNSUTBCSUFGQkEzRU5BQXNMSUFKQkgwc0VRQU5BSUFFb0Fod2dBU2dDR0NBQktBSVVJQUVvQWhBZ0FTZ0NEQ0FCS0FJSUlBRW9BZ1FnQVNnQ0FDQUFjeUlBUVFaMlFmd0hjVUd3SjJvb0FnQWdBRUgvQVhGQkFuUkJzQzlxS0FJQWN5QUFRUTUyUWZ3SGNVR3dIMm9vQWdCeklBQkJGblpCL0FkeFFiQVhhaWdDQUhOeklnQkJCblpCL0FkeFFiQW5haWdDQUNBQVFmOEJjVUVDZEVHd0wyb29BZ0J6SUFCQkRuWkIvQWR4UWJBZmFpZ0NBSE1nQUVFV2RrSDhCM0ZCc0JkcUtBSUFjM01pQUVFR2RrSDhCM0ZCc0NkcUtBSUFJQUJCL3dGeFFRSjBRYkF2YWlnQ0FITWdBRUVPZGtIOEIzRkJzQjlxS0FJQWN5QUFRUloyUWZ3SGNVR3dGMm9vQWdCemN5SUFRUVoyUWZ3SGNVR3dKMm9vQWdBZ0FFSC9BWEZCQW5SQnNDOXFLQUlBY3lBQVFRNTJRZndIY1VHd0gyb29BZ0J6SUFCQkZuWkIvQWR4UWJBWGFpZ0NBSE56SWdCQkJuWkIvQWR4UWJBbmFpZ0NBQ0FBUWY4QmNVRUNkRUd3TDJvb0FnQnpJQUJCRG5aQi9BZHhRYkFmYWlnQ0FITWdBRUVXZGtIOEIzRkJzQmRxS0FJQWMzTWlBRUVHZGtIOEIzRkJzQ2RxS0FJQUlBQkIvd0Z4UVFKMFFiQXZhaWdDQUhNZ0FFRU9ka0g4QjNGQnNCOXFLQUlBY3lBQVFSWjJRZndIY1VHd0Yyb29BZ0J6Y3lJQVFRWjJRZndIY1VHd0oyb29BZ0FnQUVIL0FYRkJBblJCc0M5cUtBSUFjeUFBUVE1MlFmd0hjVUd3SDJvb0FnQnpJQUJCRm5aQi9BZHhRYkFYYWlnQ0FITnpJZ0JCQm5aQi9BZHhRYkFuYWlnQ0FDQUFRZjhCY1VFQ2RFR3dMMm9vQWdCeklBQkJEblpCL0FkeFFiQWZhaWdDQUhNZ0FFRVdka0g4QjNGQnNCZHFLQUlBY3lFQUlBRkJJR29oQVNBQ1FXQnFJZ0pCSDBzTkFBc0xJQUpCQTBzRVFBTkFJQUVvQWdBZ0FITWlBRUVHZGtIOEIzRkJzQ2RxS0FJQUlBQkIvd0Z4UVFKMFFiQXZhaWdDQUhNZ0FFRU9ka0g4QjNGQnNCOXFLQUlBY3lBQVFSWjJRZndIY1VHd0Yyb29BZ0J6SVFBZ0FVRUVhaUVCSUFKQmZHb2lBa0VEU3cwQUN3c2dBZ1JBQTBBZ0FTMEFBQ0FBUWY4QmNYTkJBblJCc0JkcUtBSUFJQUJCQ0haeklRQWdBVUVCYWlFQklBSkJmMm9pQWcwQUN3c2dBRUYvY3d2VEJRRUxmeU1BUWFBUWF5SUNKQUFnQVNBQ1Fac1FhZ0ovSUFBZ0FDZ0NBQ2dDQ0JFQUFDSURRZjhBVFFSQUlBSWdBem9BbXhBZ0FrR2NFR29NQVFzZ0EwSC8vd0JOQkVBZ0FpQURRUWQyT2dDY0VDQUNJQU5CZ0FGeU9nQ2JFQ0FDUVowUWFnd0JDeUFEUWYvLy93Qk5CRUFnQWlBRFFRNTJPZ0NkRUNBQ0lBTkJnQUZ5T2dDYkVDQUNJQU5CQjNaQmdBRnlPZ0NjRUNBQ1FaNFFhZ3dCQ3lBQ0lBTkJnQUZ5T2dDYkVDQUNJQU5CRG5aQmdBRnlPZ0NkRUNBQ0lBTkJCM1pCZ0FGeU9nQ2NFQ0FEUVJWMklRUWdBMEgvLy8vL0FFMEVRQ0FDSUFRNkFKNFFJQUpCbnhCcURBRUxJQUlnQTBFY2Rqb0FueEFnQWlBRVFZQUJjam9BbmhBZ0FrR2dFR29MSUFKQm14QnFheUlMSUFFb0FnQW9BZ2dSQmdBZ0FrRUFOZ0tRRUFKQUlBTkZEUUFEUUNBQUlBSkJER29nQUNnQ0FDZ0NEQkVEQUNFSUFuOGdBaWdDRENJRUlBTkJnSUFFSUFOQmdJQUVTUnNpQms4RVFDQUdEQUVMQW44Z0NVVUVRQ0FHRUcwaENRc2dDUXNnQ0NBRUVDb2hDQ0FBSUFRZ0FDZ0NBQ2dDRUJFRUFBTkFJQVFnQ0dvZ0FDQUNRUXhxSUFBb0FnQW9BZ3dSQXdBZ0JpQUVheUlGSUFJb0Fnd2lCeUFGSUFkSkd5SUZFQ29hSUFBZ0JTQUFLQUlBS0FJUUVRUUFJQVlnQkNBRmFpSUVTdzBBQzBFQUN5RU1JQUlnQmpZQ0RFR0FBaUVGQTBBQ1FDQUZJZ1JCQVhRaEJTQUVRZi8vQUVzTkFDQUVJQVpKRFFFTEN5QUNRUkJxSVFjQ1FDQUVRWUVJU1EwQUlBSW9BcEFRSWdjTkFDQUNRWUNBQWhCdElnYzJBcEFRQ3lBSFFRQWdCUkFvSVFjZ0FTQUJJQVlnQmtFR2JtcEJJR29pQlFKL0lBcEZCRUFnQlJCdElRb0xJQW9MSUFFb0FnQW9BZ3dSQVFBaUJTQUlJQUlvQWd3Z0JTQUhJQVFRdFFRZ0JXc2lCQ0FCS0FJQUtBSUlFUVlBSUFBZ0RDQUFLQUlBS0FJUUVRUUFJQVFnQzJvaEN5QURJQVpySWdNTkFBc2dDUVJBSUFrUU9Bc2dDaEE0SUFJb0FwQVFJZ0JGRFFBZ0FCQTRDeUFDUWFBUWFpUUFDOHdXQVFoL1FYNGhBZ0pBQWtBQ1FDQUFSUTBBSUFBb0Fod2lBVVVOQUFKQUFrQWdBQ2dDREVVTkFDQUFLQUlBUlFSQUlBQW9BZ1FOQVFzZ0FTZ0NCQ0lDUVpvRlIwRUJjZzBCQ3lBQVFhYUVBVFlDR0VGK0R3c2dBQ2dDRUVVTkFTQUJJQUEyQWdBZ0FTZ0NLQm9nQVVFRU5nSW9Ba0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBQ1FTcEdCRUFnQVNnQ0dFRUNSZ1JBSUFCQkFFRUFRUUFRTlRZQ01DQUJJQUVvQWhRaUFrRUJhallDRkNBQ0lBRW9BZ2hxUVI4NkFBQWdBU0FCS0FJVUlnSkJBV28yQWhRZ0FpQUJLQUlJYWtHTEFUb0FBQ0FCSUFFb0FoUWlBa0VCYWpZQ0ZDQUNJQUVvQWdocVFRZzZBQUFnQVNnQ0hDSUNSUVJBSUFFZ0FTZ0NGQ0lDUVFGcU5nSVVJQUlnQVNnQ0NHcEJBRG9BQUNBQklBRW9BaFFpQWtFQmFqWUNGQ0FDSUFFb0FnaHFRUUE2QUFBZ0FTQUJLQUlVSWdKQkFXbzJBaFFnQWlBQktBSUlha0VBT2dBQUlBRWdBU2dDRkNJQ1FRRnFOZ0lVSUFJZ0FTZ0NDR3BCQURvQUFDQUJJQUVvQWhRaUFrRUJhallDRkNBQ0lBRW9BZ2hxUVFBNkFBQkJBaUVDSUFFb0FvUUJJZ05CQ1VjRVFFRUVJQUVvQW9nQlFRRktRUUowSUFOQkFrZ2JJUUlMSUFFZ0FTZ0NGQ0lEUVFGcU5nSVVJQU1nQVNnQ0NHb2dBam9BQUNBQklBRW9BaFFpQWtFQmFqWUNGQ0FDSUFFb0FnaHFRUU02QUFBZ0FVSHhBRFlDQkF3TkN5QUNLQUlrSVFNZ0FpZ0NIQ0VFSUFJb0FoQWhCU0FDS0FJc0lRWWdBaWdDQUNFSElBRWdBU2dDRkNJSVFRRnFOZ0lVUVFJaEFpQUlJQUVvQWdocUlBWkJBRWRCQVhRZ0IwRUFSM0lnQlVFQVIwRUNkSElnQkVFQVIwRURkSElnQTBFQVIwRUVkSEk2QUFBZ0FTZ0NIQ2dDQkNFRElBRWdBU2dDRkNJRVFRRnFOZ0lVSUFRZ0FTZ0NDR29nQXpvQUFDQUJLQUljS0FJRUlRTWdBU0FCS0FJVUlnUkJBV28yQWhRZ0JDQUJLQUlJYWlBRFFRaDJPZ0FBSUFFb0Fod3ZBUVloQXlBQklBRW9BaFFpQkVFQmFqWUNGQ0FFSUFFb0FnaHFJQU02QUFBZ0FTZ0NIQzBBQnlFRElBRWdBU2dDRkNJRVFRRnFOZ0lVSUFRZ0FTZ0NDR29nQXpvQUFDQUJLQUtFQVNJRFFRbEhCRUJCQkNBQktBS0lBVUVCU2tFQ2RDQURRUUpJR3lFQ0N5QUJJQUVvQWhRaUEwRUJhallDRkNBRElBRW9BZ2hxSUFJNkFBQWdBU2dDSENnQ0RDRUNJQUVnQVNnQ0ZDSURRUUZxTmdJVUlBTWdBU2dDQ0dvZ0Fqb0FBQUovSUFFb0Fod2lCQ2dDRUFSQUlBUW9BaFFoQWlBQklBRW9BaFFpQTBFQmFqWUNGQ0FESUFFb0FnaHFJQUk2QUFBZ0FTZ0NIQ2dDRkNFQ0lBRWdBU2dDRkNJRFFRRnFOZ0lVSUFNZ0FTZ0NDR29nQWtFSWRqb0FBQ0FCS0FJY0lRUUxJQVFvQWl3TEJFQWdBQ0FBS0FJd0lBRW9BZ2dnQVNnQ0ZCQTFOZ0l3Q3lBQlFjVUFOZ0lFSUFGQkFEWUNJQXdDQ3lBQktBSXdRUXgwUVlDUWZtb2hCRUVBSVFJQ1FDQUJLQUtJQVVFQlNnMEFJQUVvQW9RQklnTkJBa2dOQUVIQUFDRUNJQU5CQmtnTkFFR0FBVUhBQVNBRFFRWkdHeUVDQ3lBQlFmRUFOZ0lFSUFFZ0FpQUVjaUlDUVNCeUlBSWdBU2dDYkJzaUFrRWZjQ0FDY2tFZmN4QjFJQUVvQW13RVFDQUJJQUF2QVRJUWRTQUJJQUF2QVRBUWRRc2dBRUVBUVFCQkFCQmxOZ0l3SUFFb0FnUWhBZ3NnQWtIRkFFY05BU0FCS0FJY0lRUUxBa0FnQkNnQ0VBUkFJQUVvQWhRaEFpQUJLQUlnSWdVZ0JDOEJGRThOQVNBQ0lRTURRQ0FCS0FJTUlBSkdCRUFDUUNBQ0lBTk5EUUFnQkNnQ0xFVU5BQ0FBSUFBb0FqQWdBU2dDQ0NBRGFpQUNJQU5yRURVMkFqQUxJQUFRTmlBQktBSWNJUVFnQVNnQ0ZDSUNJQUVvQWd4R0RRTWdBU2dDSUNFRklBSWhBd3NnQkNnQ0VDQUZhaTBBQUNFRUlBRWdBa0VCYWpZQ0ZDQUJLQUlJSUFKcUlBUTZBQUFnQVNBQktBSWdRUUZxSWdVMkFpQWdCU0FCS0FJY0lnUXZBUlJQQkVBZ0F5RUNEQU1GSUFFb0FoUWhBZ3dCQ3dBTEFBc2dBVUhKQURZQ0JBd0NDd0pBSUFRb0FpeEZEUUFnQVNnQ0ZDSURJQUpORFFBZ0FDQUFLQUl3SUFFb0FnZ2dBbW9nQXlBQ2F4QTFOZ0l3Q3lBQktBSWdJQVFvQWhSR0JFQWdBVUhKQURZQ0JDQUJRUUEyQWlBTUFnc2dBU2dDQkNFQ0N5QUNRY2tBUncwQklBRW9BaHdoQkFzZ0JDZ0NIRVVOQWlBQktBSVVJZ0loQXdKQUEwQUNRQ0FCS0FJTUlBSkdCRUFDUUNBQ0lBTk5EUUFnQVNnQ0hDZ0NMRVVOQUNBQUlBQW9BakFnQVNnQ0NDQURhaUFDSUFOckVEVTJBakFMSUFBUU5pQUJLQUlVSWdJZ0FTZ0NERVlOQVNBQ0lRTUxRUUVoQlNBQktBSWNLQUljSVFRZ0FTQUJLQUlnSWdaQkFXbzJBaUFnQkNBR2FpMEFBQ0VFSUFFZ0FrRUJhallDRkNBQktBSUlJQUpxSUFRNkFBQWdCQVJBSUFFb0FoUWhBZ3dDQlNBRElRSU1Bd3NBQ3d0QkFDRUZDd0pBSUFFb0Fod2lCQ2dDTEVVTkFDQUJLQUlVSWdNZ0FrME5BQ0FBSUFBb0FqQWdBU2dDQ0NBQ2FpQURJQUpyRURVMkFqQUxJQVVOQVNBQktBSUVJUUlMSUFKQjJ3QkhEUU1nQVNnQ0hDRUVEQUlMSUFGQkFEWUNJQXNnQVVIYkFEWUNCQXNnQkNnQ0pFVU5BU0FCS0FJVUlnSWhBd0pBQTBBQ1FDQUJLQUlNSUFKR0JFQUNRQ0FDSUFOTkRRQWdBU2dDSENnQ0xFVU5BQ0FBSUFBb0FqQWdBU2dDQ0NBRGFpQUNJQU5yRURVMkFqQUxJQUFRTmlBQktBSVVJZ0lnQVNnQ0RFWU5BU0FDSVFNTFFRRWhCU0FCS0FJY0tBSWtJUVFnQVNBQktBSWdJZ1pCQVdvMkFpQWdCQ0FHYWkwQUFDRUVJQUVnQWtFQmFqWUNGQ0FCS0FJSUlBSnFJQVE2QUFBZ0JBUkFJQUVvQWhRaEFnd0NCU0FESVFJTUF3c0FDd3RCQUNFRkN3SkFJQUVvQWh3aUJDZ0NMRVVOQUNBQktBSVVJZ01nQWswTkFDQUFJQUFvQWpBZ0FTZ0NDQ0FDYWlBRElBSnJFRFUyQWpBTElBVU5BU0FCS0FJRUlRSUxJQUpCNXdCSERRSWdBU2dDSENFRURBRUxJQUZCNXdBMkFnUUxJQVFvQWl3RVFDQUJLQUlVSWdWQkFtb2lBaUFCS0FJTUlnUkxCSDhnQUJBMklBRW9BZ3doQkNBQktBSVVJZ1ZCQW1vRklBSUxJQVJMRFFFZ0FDZ0NNQ0VDSUFFZ0JVRUJhallDRkNBQktBSUlJQVZxSUFJNkFBQWdBQ2dDTUNFQ0lBRWdBU2dDRkNJRFFRRnFOZ0lVSUFNZ0FTZ0NDR29nQWtFSWRqb0FBQ0FBUVFCQkFFRUFFRFUyQWpBZ0FVSHhBRFlDQkF3QkN5QUJRZkVBTmdJRUN3SkFJQUVvQWhRRVFDQUFFRFlnQUNnQ0VBUkFJQUFvQWdRaEFnd0NDd3dFQ3lBQUtBSUVJZ0lOQUVFQUlRSUxBa0FDUUFKQUlBRW9BZ1FpQTBHYUJVWUVRQ0FDUlEwQkRBVUxJQUlOQVFzZ0EwR2FCVWNOQUNBQktBSjBSUTBCQ3dKL0FrQUNRQUpBSUFFb0FvZ0JRWDVxRGdJQUFRSUxJQUVRblFRTUFnc2dBUkNjQkF3QkN5QUJRUVFnQVNnQ2hBRkJER3hCdU5jQWFpZ0NBQkVEQUFzaUFrRitjVUVDUmdSQUlBRkJtZ1UyQWdRTElBSkJmWEZGQkVCQkFDRUNJQUFvQWhBTkFnd0VDeUFDUVFGSERRQWdBVUVBUVFCQkFCQ09BaUFBRURZZ0FDZ0NFQTBBREFNTFFRRWhBaUFCS0FJWUlnTkJBVWdOQUNBQUtBSXdJUUlDUUNBRFFRSkdCRUFnQVNBQktBSVVJZ05CQVdvMkFoUWdBeUFCS0FJSWFpQUNPZ0FBSUFBb0FqQWhBaUFCSUFFb0FoUWlBMEVCYWpZQ0ZDQURJQUVvQWdocUlBSkJDSFk2QUFBZ0FDOEJNaUVDSUFFZ0FTZ0NGQ0lEUVFGcU5nSVVJQU1nQVNnQ0NHb2dBam9BQUNBQUxRQXpJUUlnQVNBQktBSVVJZ05CQVdvMkFoUWdBeUFCS0FJSWFpQUNPZ0FBSUFBb0FnZ2hBaUFCSUFFb0FoUWlBMEVCYWpZQ0ZDQURJQUVvQWdocUlBSTZBQUFnQUNnQ0NDRUNJQUVnQVNnQ0ZDSURRUUZxTmdJVUlBTWdBU2dDQ0dvZ0FrRUlkam9BQUNBQUx3RUtJUUlnQVNBQktBSVVJZ05CQVdvMkFoUWdBeUFCS0FJSWFpQUNPZ0FBSUFBdEFBc2hBaUFCSUFFb0FoUWlBMEVCYWpZQ0ZDQURJQUVvQWdocUlBSTZBQUFNQVFzZ0FTQUNRUkIyRUhVZ0FTQUFMd0V3RUhVTElBQVFOaUFCS0FJWUlnQkJBVTRFUUNBQlFRQWdBR3MyQWhnTElBRW9BaFJGSVFJTElBSVBDeUFBUWNlRUFUWUNHRUY3RHdzZ0FVRi9OZ0lvUVFBTDNRRUJCbjhDUUNBQUtBS0FnQkFpQlNBQUtBS0VnQkFpQXlBQUtBS01nQkFpQkdwQkJHcEpEUUFnQUNnQ2xJQVFJZ0lnQlNBRGEwRjlhaUlHVHcwQUEwQWdBQ0FDUWYvL0EzRkJBWFJxUVlDQUNHb2dBaUFBSUFJZ0Eyb1FPa0VDZEdvaUJDZ0NBR3NpQjBILy93TWdCMEgvL3dOSkd6c0JBQ0FFSUFJMkFnQWdBa0VCYWlJQ0lBWkpEUUFMSUFBb0FveUFFQ0VFQ3lBQUlBUTJBcENBRUNBQUlBTTJBb2lBRUNBQVFRQTJBcHlBRUNBQUlBRTJBb0NBRUNBQUlBVWdBMnNpQWpZQ2pJQVFJQUFnQWpZQ2xJQVFJQUFnQVNBQ2F6WUNoSUFRQzlrREFRUi9Jd0JCRUdzaUF5UUFJQUZCQURZQ0FDQUFLQUlBSWdJZ0EwRU1haUFDS0FJQUtBSU1FUU1BSVFJQ1FDQURLQUlNUlEwQUlBSXNBQUFoQWlBQUtBSUFJZ1JCQVNBRUtBSUFLQUlRRVFRQUlBRWdBU2dDQUNBQ1FmOEFjWEkyQWdBQ1FDQUNRWDlLRFFBZ0FDZ0NBQ0lDSUFOQkRHb2dBaWdDQUNnQ0RCRURBQ0VDSUFNb0FneEZEUUVnQWl3QUFDRUNJQUFvQWdBaUJFRUJJQVFvQWdBb0FoQVJCQUFnQVNBQktBSUFJQUpCL3dCeFFRZDBjallDQUNBQ1FYOUtEUUFnQUNnQ0FDSUNJQU5CREdvZ0FpZ0NBQ2dDREJFREFDRUNJQU1vQWd4RkRRRWdBaXdBQUNFQ0lBQW9BZ0FpQkVFQklBUW9BZ0FvQWhBUkJBQWdBU0FCS0FJQUlBSkIvd0J4UVE1MGNqWUNBQ0FDUVg5S0RRQWdBQ2dDQUNJQ0lBTkJER29nQWlnQ0FDZ0NEQkVEQUNFQ0lBTW9BZ3hGRFFFZ0Fpd0FBQ0VDSUFBb0FnQWlCRUVCSUFRb0FnQW9BaEFSQkFBZ0FTQUJLQUlBSUFKQi93QnhRUlYwY2pZQ0FDQUNRWDlLRFFBZ0FDZ0NBQ0lDSUFOQkRHb2dBaWdDQUNnQ0RCRURBQ0VDSUFNb0FneEZEUUVnQWl3QUFDRUZJQUFvQWdBaUFFRUJJQUFvQWdBb0FoQVJCQUFnQVNBQktBSUFJQVZCSEhSeU5nSUFJQVZCZjBvTkFFRUFJUVVNQVF0QkFTRUZDeUFEUVJCcUpBQWdCUXZoU1FFM2Z3SkFJQUFvQW9DQUVDSUpJQUFvQW9TQUVDSUxheUFBS0FLUWdCQnJJZ2hCZ0lBRVR3UkFJQUJCQURZQ25JQVFEQUVMQWtBZ0NBMEFJQU1vQWdCQmdTQklEUUFnQUNBQUtBS2NnQkJCb0lBUUVDb2lBQ0FCRUt3RUlBQWdCVHNCbUlBUURBRUxBa0FnQkVFQVRFRUFJQVpCQWtZYkRRQWdBeWdDQUNJSVFZQ0FnUEFIU3cwQUlBQWdDQ0FKYWpZQ2dJQVFRUWtnQlNBRlFRRklHeUlGUVF3Z0JVRU1TQnNpRzBFTWJDSUpRWlFXYWlnQ0FDRXVBa0FDZnlBYlFRbE5CRUFnQTBFQU5nSUFJQUlnQkdvaU9rRjdhaUE2SUFaQkFrWWlPeHNoS1NBQklBaHFJVE1nQVNFb0lBSWhDUUpBSUFoQkRVZ05BQ0F6UVhScUlqSWdBVWtOQUVHQU5DQWJka0VCY1NFMElETkJlMm9pR0VGL2FpRXZJQmhCZldvaElrRUFJUnNEUUNBQUtBS1VnQkFoQkNBQUtBS0lnQkFoRXlBQUtBS2NnQkFoRkNBb0lRd0RRQ0FBS0FLUWdCQWlCU0FNSUF0ckloOUJnWUI4YWlBRlFZQ0FCR29nSDBzYklSVWdBQ2dDaklBUUlSQWdEQ2dBQUNFT0lBUWdIMGtFUUFOQUlBQWdCRUgvL3dOeFFRRjBha0dBZ0FocUlBUWdBQ0FFSUF0cUVEcEJBblJxSWdVb0FnQnJJZ2hCLy84RElBaEIvLzhEU1JzN0FRQWdCU0FFTmdJQUlBUkJBV29pQkNBZlNRMEFDd3NnQUNBZk5nS1VnQkFnREVFSWFpRWhJQXhCQkdvaEVrRURJUWdDUUNBQUlBd1FPa0VDZENJamFpZ0NBQ0lISUJWSkJFQWdMaUVOREFFTElBNUIvLzhEY1NBT1FSQjJSaUFPUWY4QmNTQU9RUmgyUm5FaEpDQVFJQk5xSVE4Z0N5QVFhaUlkUVFScUlSRWdERUYvYWlFbVFRQWhKU0F1SVExQkFDRWNBMEFDUUFKQUFuOENRQUpBSUJBZ0IwMEVRQ0FJSUNacUx3QUFJQWNnQzJvaUNpQUlha0YvYWk4QUFFY05CU0FPSUFvb0FBQkhEUVVnQ2tFRWFpRUVJQ0lnRWswRWZ5QVNCU0FFS0FBQUlCSW9BQUJ6SWdVTkFpQUVRUVJxSVFRZ0lRc2lCU0FpU1FSQUEwQWdCQ2dBQUNBRktBQUFjeUlXQkVBZ0ZoQWxJQVZxSUJKcklRUU1Cd3NnQkVFRWFpRUVJQVZCQkdvaUJTQWlTUTBBQ3dzQ1FDQUZJQzlQRFFBZ0JDOEFBQ0FGTHdBQVJ3MEFJQVJCQW1vaEJDQUZRUUpxSVFVTElBVWdHRWtFZnlBRlFRRnFJQVVnQkMwQUFDQUZMUUFBUmhzRklBVUxJQkpySVFRTUJBc2dEaUFISUJOcUlnUW9BQUJIRFFRZ0JFRUVhaUVFQW44Z0VpQVlJQXdnRUNBSGEyb2lJQ0FnSUJoTEd5SVdRWDFxSWdvZ0VrME5BQm9nQkNnQUFDQVNLQUFBY3lJRkRRSWdCRUVFYWlFRUlDRUxJZ1VnQ2trRVFBTkFJQVFvQUFBZ0JTZ0FBSE1pSndSQUlDY1FKU0FGYWlBU2F3d0ZDeUFFUVFScUlRUWdCVUVFYWlJRklBcEpEUUFMQ3dKQUlBVWdGa0YvYWs4TkFDQUVMd0FBSUFVdkFBQkhEUUFnQkVFQ2FpRUVJQVZCQW1vaEJRc2dCU0FXU1FSL0lBVkJBV29nQlNBRUxRQUFJQVV0QUFCR0d3VWdCUXNnRW1zTUFnc2dCUkFsSVFRTUFnc2dCUkFsQ3lFRUlBY2dDMm9nSGdKL0lBUkJCR29pQ2lBTWFpQVdSeUFnSUJoUGNrVUVRQ0FkSVFVQ2Z3SkFBbjhnSWlBV0lnUkxCRUFnSFNnQUFDQVdLQUFBY3lJRURRSWdFU0VGSUJaQkJHb2hCQXNnQkNBaVNRc0VRQU5BSUFVb0FBQWdCQ2dBQUhNaUhnUkFJQjRRSlNBRWFpQVdhd3dFQ3lBRlFRUnFJUVVnQkVFRWFpSUVJQ0pKRFFBTEN3SkFJQVFnTDA4TkFDQUZMd0FBSUFRdkFBQkhEUUFnQlVFQ2FpRUZJQVJCQW1vaEJBc2dCQ0FZU1FSL0lBUkJBV29nQkNBRkxRQUFJQVF0QUFCR0d3VWdCQXNnRm1zTUFRc2dCQkFsQ3lBS2FpRUtDeUFLSUFoS0lnUUxHeUVlSUFvZ0NDQUVHeUVJREFFTElBUkJCR29pQkNBSUlBUWdDRW9pQkJzaENDQUtJQjRnQkJzaEhnc2dEVUYvYWlFTkFrQUNRQ0EwUlNBQUlBZEIvLzhEY1VFQmRHcEJnSUFJYWk4QkFDSUVRUUZIY2cwQUlDVkZCRUJCQVNFbElDUkZEUUZCQWlFbElCSWdHQ0FPRUROQkJHb2hIQXNnSlVFQ1J5QUhRWDlxSWdVZ0ZVbHlEUUJCQWlFbElCQWdCUkF5UlEwQUlBNGdFeUFMSUFVZ0VFa2lGaHNnQldvaUNpZ0FBRWNOQUNBS1FRUnFJQThnR0NBV0d5SUhJQTRRTTBFRWFpRUVJQk1nQUNnQ2tJQVFJaUJxSVJZQ1FDQUZJQkJKQkVBZ0J5QUVJQXBxUmdSQUlCMGdHQ0FFSUE0UVBSQXpJQVJxSVFRTElBb2dGaUFPRURFaEJ3d0JDeUFLSUFvZ0hTQU9FREVpQjJzZ0hVY2dJQ0FRVDNJTkFDQVBJQlpCQUNBSGF5QU9FRDBRTVNBSGFpRUhDeUFGSUFVZ0Iyc2lDaUFWSUFvZ0ZVc2JJZ3BySUFScUloWWdIRWtnQkNBY1MzSkZCRUFnQkNBRklCeHJhaUlFSUJBZ0VDQUVFREliSVFjTUFnc2dFQ0FLRURKRkJFQWdFQ0VIREFJTEFrQWdDQ0FXSUJ3Z0ZpQWNTUnNpQkU4RVFDQWVJUVVnQ0NFRURBRUxJQXdnQ2lBTGFpSUZhMEgvL3dOS0RRUUxJQW9nQUNBS1FmLy9BM0ZCQVhScVFZQ0FDR292QVFBaUNFa0VRQ0FGSVI0Z0JDRUlEQVFMSUFvZ0NHc2hCeUFGSVI0Z0JDRUlEQUVMSUFjZ0JHc2hCd3NnRFVVTkFTQUhJQlZQRFFBTEN3SkFJQTFGSUI4Z0ZXdEIvdjhEUzNJTkFDQWZJQlFnSTJvb0FnQWlDaUFWYWlBVUtBS0FnQkFnRkNnQ2hJQVFJaDFySWhGcklnOXJRZi8vQTBzTkFBTkFJQTFGRFFFZ0RpQUtJQjFxSWdRb0FBQkdCRUFnQkVFRWFpRUVBbjhDUUFKL0lCSWdHQ0FNSUJFZ0NtdHFJZ1VnQlNBWVN4c2lFRUY5YWlJV0lCSk5EUUFhSUFRb0FBQWdFaWdBQUhNaUJRMEJJQVJCQkdvaEJDQWhDeUlGSUJaSkJFQURRQ0FFS0FBQUlBVW9BQUJ6SWdjRVFDQUhFQ1VnQldvZ0Vtc01CQXNnQkVFRWFpRUVJQVZCQkdvaUJTQVdTUTBBQ3dzQ1FDQUZJQkJCZjJwUERRQWdCQzhBQUNBRkx3QUFSdzBBSUFSQkFtb2hCQ0FGUVFKcUlRVUxJQVVnRUVrRWZ5QUZRUUZxSUFVZ0JDMEFBQ0FGTFFBQVJoc0ZJQVVMSUJKckRBRUxJQVVRSlF0QkJHb2lCQ0FJSUFRZ0NFb2lCQnNoQ0NBTElBOXFJQjRnQkJzaEhnc2dEVUYvYWlFTklBb2dGQ0FLUWYvL0EzRkJBWFJxUVlDQUNHb3ZBUUFpQkdzaENpQWZJQThnQkdzaUQydEJnSUFFU1EwQUN3c2dDRUVEU2dSQUlDZ2hIeUFKSVE0Z0RDRWRJQjRpQ1NFV0lBZ2hFZ0ovQW44Q1FBSkFBa0FEUUNBSklSNENRQ0FNSUFnaURXb2lLQ0F5VFFSQUlBQW9BcENBRUNJRUlDaEJmbW9pRVNBQUtBS0VnQkFpSVdzaUlFR0JnSHhxSUFSQmdJQUVhaUFnU3hzaEl5QUFLQUtNZ0JBaEZDQUFLQUtJZ0JBaEppQUFLQUtjZ0JBaEp5QVJLQUFBSVJNZ0FDZ0NsSUFRSWdRZ0lFa0VRQU5BSUFBZ0JFSC8vd054UVFGMGFrR0FnQWhxSUFRZ0FDQUVJQ0ZxRURwQkFuUnFJZ1VvQWdCcklnaEIvLzhESUFoQi8vOERTUnM3QVFBZ0JTQUVOZ0lBSUFSQkFXb2lCQ0FnU1EwQUN3c2dFU0FNYXlFcUlBQWdJRFlDbElBUUlCRkJDR29oTUNBUlFRUnFJUlVnRENBUmF5RWtBa0FnQUNBUkVEcEJBblFpTEdvb0FnQWlCeUFqU1FSQUlDNGhFQ0FOSVFnTUFRc2dFMEgvL3dOeElCTkJFSFpHSUJOQi93RnhJQk5CR0haR2NTRTFJQlFnSm1vaE1TQVVJQ0ZxSWh4QkJHb2hKVUVBSVMxQkFDQXFheUUySUF4QmYyb2hOeUFOSVFnZ0xpRVFRUUFoQ1FOQUFrQUNRQUovQWtBQ1FDQVVJQWROQkVBZ0NDQTNhaThBQUNBSElDRnFJZ3NnTm1vZ0NHcEJmMm92QUFCSERRVWdFeUFMS0FBQVJ3MEZBa0FnS2tVRVFFRUFJUW9NQVFzZ0pDQWNJQXRySWdRZ0pDQUVTaHNpRDBFZmRTQVBjU0VGUVFBaEJBTkFJQVFpQ2lBUFRBUkFJQVVoQ2d3Q0N5QVJJQXBCZjJvaUJHb3RBQUFnQkNBTGFpMEFBRVlOQUFzTElBdEJCR29oQkNBaUlCVk5CSDhnRlFVZ0JDZ0FBQ0FWS0FBQWN5SUZEUUlnQkVFRWFpRUVJREFMSWdVZ0lra0VRQU5BSUFRb0FBQWdCU2dBQUhNaUR3UkFJQThRSlNBRmFpQVZheUVFREFjTElBUkJCR29oQkNBRlFRUnFJZ1VnSWtrTkFBc0xBa0FnQlNBdlR3MEFJQVF2QUFBZ0JTOEFBRWNOQUNBRVFRSnFJUVFnQlVFQ2FpRUZDeUFGSUJoSkJIOGdCVUVCYWlBRklBUXRBQUFnQlMwQUFFWWJCU0FGQ3lBVmF5RUVEQVFMSUJNZ0J5QW1haUlLS0FBQVJ3MEVJQXBCQkdvaEJDQUFLQUtRZ0JBaE9BSi9JQlVnR0NBUklCUWdCMnRxSWlzZ0t5QVlTeHNpQzBGOWFpSVBJQlZORFFBYUlBUW9BQUFnRlNnQUFITWlCUTBDSUFSQkJHb2hCQ0F3Q3lJRklBOUpCRUFEUUNBRUtBQUFJQVVvQUFCeklqa0VRQ0E1RUNVZ0JXb2dGV3NNQlFzZ0JFRUVhaUVFSUFWQkJHb2lCU0FQU1EwQUN3c0NRQ0FGSUF0QmYycFBEUUFnQkM4QUFDQUZMd0FBUncwQUlBUkJBbW9oQkNBRlFRSnFJUVVMSUFVZ0Mwa0VmeUFGUVFGcUlBVWdCQzBBQUNBRkxRQUFSaHNGSUFVTElCVnJEQUlMSUFVUUpTRUVEQUlMSUFVUUpRc2hCQ0FSSUFSQkJHb2lEMm9nQzBjZ0t5QVlUM0pGQkVBZ0hDRUZBbjhDUUFKL0lDSWdDeUlFU3dSQUlCd29BQUFnQ3lnQUFITWlCQTBDSUNVaEJTQUxRUVJxSVFRTElBUWdJa2tMQkVBRFFDQUZLQUFBSUFRb0FBQnpJaXNFUUNBckVDVWdCR29nQzJzTUJBc2dCVUVFYWlFRklBUkJCR29pQkNBaVNRMEFDd3NDUUNBRUlDOVBEUUFnQlM4QUFDQUVMd0FBUncwQUlBVkJBbW9oQlNBRVFRSnFJUVFMSUFRZ0dFa0VmeUFFUVFGcUlBUWdCUzBBQUNBRUxRQUFSaHNGSUFRTElBdHJEQUVMSUFRUUpRc2dEMm9oRHdzQ1FDQXFSUVJBUVFBaEJRd0JDeUFrSUNZZ09Hb2dDbXNpQkNBa0lBUktHeUlyUVI5MUlDdHhJUXRCQUNFRUEwQWdCQ0lGSUN0TUJFQWdDeUVGREFJTElCRWdCVUYvYWlJRWFpMEFBQ0FFSUFwcUxRQUFSZzBBQ3dzZ0R5QUZheUlFSUFoTURRRWdCU0FSYWlFWklBY2dJV29nQldvaEd5QUVJUWdNQVFzZ0JDQUthMEVFYWlJRUlBaE1EUUFnQ2lBUmFpRVpJQW9nQzJvaEd5QUVJUWdMSUJCQmYyb2hFQUpBQWtBZ05FVWdBQ0FIUWYvL0EzRkJBWFJxUVlDQUNHb3ZBUUFpQkVFQlIzSU5BQ0F0UlFSQVFRRWhMU0ExUlEwQlFRSWhMU0FWSUJnZ0V4QXpRUVJxSVFrTElDMUJBa2NnQjBGL2FpSUZJQ05KY2cwQVFRSWhMU0FVSUFVUU1rVU5BQ0FUSUNZZ0lTQUZJQlJKSWdvYklBVnFJZ3NvQUFCSERRQWdDMEVFYWlBeElCZ2dDaHNpQnlBVEVETkJCR29oQkNBbUlBQW9BcENBRUNJUGFpRUtBa0FnQlNBVVNRUkFJQWNnQkNBTGFrWUVRQ0FjSUJnZ0JDQVRFRDBRTXlBRWFpRUVDeUFMSUFvZ0V4QXhJUWNNQVFzZ0N5QUxJQndnRXhBeElnZHJJQnhISUE4Z0ZFOXlEUUFnTVNBS1FRQWdCMnNnRXhBOUVERWdCMm9oQndzZ0JTQUZJQWRySWdzZ0l5QUxJQ05MR3lJS2F5QUVhaUlMSUFsSklBUWdDVXR5UlFSQUlBUWdCU0FKYTJvaUJDQVVJQlFnQkJBeUd5RUhEQUlMSUFvZ0ZDQVVJQW9RTWlJRUd5RUhJQ29nQkVWeURRRUNRQ0FJSUFzZ0NTQUxJQWxKR3lJRVR3UkFJQmtoQlNBYklRc2dDQ0VFREFFTElCRWlCU0FLSUNGcUlndHJRZi8vQTBvTkJBc2dDaUFBSUFwQi8vOERjVUVCZEdwQmdJQUlhaThCQUNJSVNRUkFJQVVoR1NBTElSc2dCQ0VJREFRTElBb2dDR3NoQnlBRklSa2dDeUViSUFRaENBd0JDeUFISUFScklRY0xJQkJGRFFFZ0J5QWpUdzBBQ3dzQ1FDQWdJQ05yUWY3L0Ewc0VRQ0FiSVFrTUFRc2dFRVVFUUNBYklRa01BUXNnSUNBbklDeHFLQUlBSWc4Z0kyb2dKeWdDZ0lBUUlDY29Bb1NBRUNJSGF5SWxheUlMYTBILy93TkxCRUFnR3lFSkRBRUxJQnNoQ1FOQUlCQkZEUUVDUUNBVElBY2dEMm9pQ2lnQUFFY05BQ0FLUVFScUlRUUNmd0pBQW44Z0ZTQVlJQkVnSlNBUGEyb2lCU0FGSUJoTEd5SWJRWDFxSWh3Z0ZVME5BQm9nQkNnQUFDQVZLQUFBY3lJRkRRRWdCRUVFYWlFRUlEQUxJZ1VnSEVrRVFBTkFJQVFvQUFBZ0JTZ0FBSE1pRkFSQUlCUVFKU0FGYWlBVmF3d0VDeUFFUVFScUlRUWdCVUVFYWlJRklCeEpEUUFMQ3dKQUlBVWdHMEYvYWs4TkFDQUVMd0FBSUFVdkFBQkhEUUFnQkVFQ2FpRUVJQVZCQW1vaEJRc2dCU0FiU1FSL0lBVkJBV29nQlNBRUxRQUFJQVV0QUFCR0d3VWdCUXNnRldzTUFRc2dCUkFsQzBFRWFpRVVBa0FnS2tVRVFFRUFJUVVNQVFzZ0pDQUhJQ2NvQW95QUVHb2dDbXNpQkNBa0lBUktHeUljUVI5MUlCeHhJUnRCQUNFRUEwQWdCQ0lGSUJ4TUJFQWdHeUVGREFJTElCRWdCVUYvYWlJRWFpMEFBQ0FFSUFwcUxRQUFSZzBBQ3dzZ0ZDQUZheUlFSUFoTURRQWdCU0FSYWlFWklBc2dJV29nQldvaENTQUVJUWdMSUJCQmYyb2hFQ0FQSUNjZ0QwSC8vd054UVFGMGFrR0FnQWhxTHdFQUlnUnJJUThnSUNBTElBUnJJZ3RyUVlDQUJFa05BQXNMSUFnZ0RVY05BU0FKSVJzTElBd2dIMnNoQkNBR0JFQWdEaUFFUWY4QmJtb2dCR3BCQ1dvZ0tVc05CUXNnRGtFQmFpRUZBa0FnQkVFUFR3UkFJQTVCOEFFNkFBQWdCRUZ4YWlJSFFmOEJUd1JBSUFWQi93RWdCRUh5ZldvaUNFSC9BVzRpQlVFQmFoQW9HaUFGUVlGK2JDQUlhaUVISUFVZ0RtcEJBbW9oQlFzZ0JTQUhPZ0FBSUFWQkFXb2hCUXdCQ3lBT0lBUkJCSFE2QUFBTElBVWdIeUFFSUFWcUlna1FPeUFKSUF3Z0htdEIvLzhEY1JBdklBMUJmR29oQ0NBSlFRSnFJUWtnQmdSQUlBa2dDRUgvQVc1cVFRWnFJQ2xMRFFVTElBNHRBQUFoRENBSVFROVBCRUFnRGlBTVFROXFPZ0FBSUExQmJXb2lCMEgrQTA4RVFDQUpRZjhCSUExQjczdHFJZ2hCL2dOdUlnbEJBWFFpREVFQ2FoQW9HaUFKUVlKOGJDQUlhaUVISUFVZ0JDQU1hbXBCQkdvaENRc2dCMEgvQVU4RVFDQUpRZjhCT2dBQUlBZEJnWDVxSVFjZ0NVRUJhaUVKQ3lBSklBYzZBQUFnQ1VFQmFpRUpEQVFMSUE0Z0NDQU1ham9BQUF3REN5QWRJQXdnSFNBTVNTQVpJQXdnRW1wSmNTSUVHeUVSSUFraEd5QVpJZ3dnRVd0QkEwZ05BQ0FTSUEwZ0JCc2hGU0FXSUI0Z0JCc2hIaUFmSVJZRFFDQVJJQlZxSWg5QkEyb2hOU0FSSUJWQkVpQVZRUkpJR3lJd2FpRXhBa0FDUUFOQUFuOENRQ0FNSUJGcklnUkJFVW9OQUNBUklBeHJJQVFnQ0dwQmZHb2dNQ0F4SUFnZ0RHcEJmR3BMRzJvaUJFRUJTQTBBSUFnZ0JHc2hFaUFFSUF4cUlSa2dCQ0FKYWd3QkN5QU1JUmtnQ0NFU0lBa0xJUnNDUUNBU0lCbHFJaWdnTWswRVFDQUFLQUtRZ0JBaUJDQW9RWDFxSWcwZ0FDZ0NoSUFRSWlGcklpQkJnWUI4YWlBRVFZQ0FCR29nSUVzYklTTWdBQ2dDaklBUUlSUWdBQ2dDaUlBUUlTWWdBQ2dDbklBUUlTY2dEU2dBQUNFVElBQW9BcFNBRUNJRUlDQkpCRUFEUUNBQUlBUkIvLzhEY1VFQmRHcEJnSUFJYWlBRUlBQWdCQ0FoYWhBNlFRSjBhaUlGS0FJQWF5SUlRZi8vQXlBSVFmLy9BMGtiT3dFQUlBVWdCRFlDQUNBRVFRRnFJZ1FnSUVrTkFBc0xJQTBnR1dzaEtpQUFJQ0EyQXBTQUVDQU5RUWhxSVMwZ0RVRUVhaUVkSUJrZ0RXc2hKQUpBSUFBZ0RSQTZRUUowSWpacUtBSUFJZ2NnSTBrRVFDQXVJUkFnRWlFSURBRUxJQk5CLy84RGNTQVRRUkIyUmlBVFFmOEJjU0FUUVJoMlJuRWhOeUFVSUNacUlTc2dGQ0FoYWlJY1FRUnFJU1ZCQUNFTVFRQWdLbXNoT0NBWlFYOXFJVGtnRWlFSUlDNGhFRUVBSVFrRFFBSkFBa0FDZndKQUFrQWdGQ0FIVFFSQUlBZ2dPV292QUFBZ0J5QWhhaUlMSURocUlBaHFRWDlxTHdBQVJ3MEZJQk1nQ3lnQUFFY05CUUpBSUNwRkJFQkJBQ0VLREFFTElDUWdIQ0FMYXlJRUlDUWdCRW9iSWc5QkgzVWdEM0VoQlVFQUlRUURRQ0FFSWdvZ0Qwd0VRQ0FGSVFvTUFnc2dEU0FLUVg5cUlnUnFMUUFBSUFRZ0Myb3RBQUJHRFFBTEN5QUxRUVJxSVFRZ0lpQWRUUVIvSUIwRklBUW9BQUFnSFNnQUFITWlCUTBDSUFSQkJHb2hCQ0F0Q3lJRklDSkpCRUFEUUNBRUtBQUFJQVVvQUFCeklnOEVRQ0FQRUNVZ0JXb2dIV3NoQkF3SEN5QUVRUVJxSVFRZ0JVRUVhaUlGSUNKSkRRQUxDd0pBSUFVZ0wwOE5BQ0FFTHdBQUlBVXZBQUJIRFFBZ0JFRUNhaUVFSUFWQkFtb2hCUXNnQlNBWVNRUi9JQVZCQVdvZ0JTQUVMUUFBSUFVdEFBQkdHd1VnQlFzZ0hXc2hCQXdFQ3lBVElBY2dKbW9pQ2lnQUFFY05CQ0FLUVFScUlRUWdBQ2dDa0lBUUlUd0NmeUFkSUJnZ0RTQVVJQWRyYWlJc0lDd2dHRXNiSWd0QmZXb2lEeUFkVFEwQUdpQUVLQUFBSUIwb0FBQnpJZ1VOQWlBRVFRUnFJUVFnTFFzaUJTQVBTUVJBQTBBZ0JDZ0FBQ0FGS0FBQWN5STlCRUFnUFJBbElBVnFJQjFyREFVTElBUkJCR29oQkNBRlFRUnFJZ1VnRDBrTkFBc0xBa0FnQlNBTFFYOXFUdzBBSUFRdkFBQWdCUzhBQUVjTkFDQUVRUUpxSVFRZ0JVRUNhaUVGQ3lBRklBdEpCSDhnQlVFQmFpQUZJQVF0QUFBZ0JTMEFBRVliQlNBRkN5QWRhd3dDQ3lBRkVDVWhCQXdDQ3lBRkVDVUxJUVFnRFNBRVFRUnFJZzlxSUF0SElDd2dHRTl5UlFSQUlCd2hCUUovQWtBQ2Z5QWlJQXNpQkVzRVFDQWNLQUFBSUFzb0FBQnpJZ1FOQWlBbElRVWdDMEVFYWlFRUN5QUVJQ0pKQ3dSQUEwQWdCU2dBQUNBRUtBQUFjeUlzQkVBZ0xCQWxJQVJxSUF0ckRBUUxJQVZCQkdvaEJTQUVRUVJxSWdRZ0lra05BQXNMQWtBZ0JDQXZUdzBBSUFVdkFBQWdCQzhBQUVjTkFDQUZRUUpxSVFVZ0JFRUNhaUVFQ3lBRUlCaEpCSDhnQkVFQmFpQUVJQVV0QUFBZ0JDMEFBRVliQlNBRUN5QUxhd3dCQ3lBRUVDVUxJQTlxSVE4TEFrQWdLa1VFUUVFQUlRVU1BUXNnSkNBbUlEeHFJQXBySWdRZ0pDQUVTaHNpTEVFZmRTQXNjU0VMUVFBaEJBTkFJQVFpQlNBc1RBUkFJQXNoQlF3Q0N5QU5JQVZCZjJvaUJHb3RBQUFnQkNBS2FpMEFBRVlOQUFzTElBOGdCV3NpQkNBSVRBMEJJQVVnRFdvaEZ5QUhJQ0ZxSUFWcUlSb2dCQ0VJREFFTElBUWdDbXRCQkdvaUJDQUlUQTBBSUFvZ0RXb2hGeUFLSUF0cUlSb2dCQ0VJQ3lBUVFYOXFJUkFDUUFKQUlEUkZJQUFnQjBILy93TnhRUUYwYWtHQWdBaHFMd0VBSWdSQkFVZHlEUUFnREVVRVFFRUJJUXdnTjBVTkFVRUNJUXdnSFNBWUlCTVFNMEVFYWlFSkN5QU1RUUpISUFkQmYyb2lCU0FqU1hJTkFFRUNJUXdnRkNBRkVESkZEUUFnRXlBbUlDRWdCU0FVU1NJS0d5QUZhaUlMS0FBQVJ3MEFJQXRCQkdvZ0t5QVlJQW9iSWdvZ0V4QXpRUVJxSVFRZ0ppQUFLQUtRZ0JBaUQyb2hEQUpBSUFVZ0ZFa0VRQ0FLSUFRZ0MycEdCRUFnSENBWUlBUWdFeEE5RURNZ0JHb2hCQXNnQ3lBTUlCTVFNU0VIREFFTElBc2dDeUFjSUJNUU1TSUhheUFjUnlBUElCUlBjZzBBSUNzZ0RFRUFJQWRySUJNUVBSQXhJQWRxSVFjTElBVWdCU0FIYXlJTUlDTWdEQ0FqU3hzaUNtc2dCR29pQ3lBSlNTQUVJQWxMY2tVRVFDQUVJQVVnQ1d0cUlnUWdGQ0FVSUFRUU1oc2hCMEVDSVF3TUFnc2dDaUFVSUJRZ0NoQXlJZ1FiSVFkQkFpRU1JQ29nQkVWeURRRUNRQ0FJSUFzZ0NTQUxJQWxKR3lJRVR3UkFJQmNoQlNBYUlRc2dDQ0VFREFFTElBMGlCU0FLSUNGcUlndHJRZi8vQTBvTkJBc2dDaUFBSUFwQi8vOERjVUVCZEdwQmdJQUlhaThCQUNJSVNRUkFJQVVoRnlBTElSb2dCQ0VJREFRTElBb2dDR3NoQnlBRklSY2dDeUVhSUFRaENBd0JDeUFISUFScklRY0xJQkJGRFFFZ0J5QWpUdzBBQ3dzQ1FBSkFJQkJGSUNBZ0kydEIvdjhEUzNJTkFDQWdJQ2NnTm1vb0FnQWlEeUFqYWlBbktBS0FnQkFnSnlnQ2hJQVFJZ3BySWh4cklndHJRZi8vQTBzTkFDQVhJUXdnR2lFSkEwQWdFRVVOQWdKQUlCTWdDaUFQYWlJYUtBQUFSdzBBSUJwQkJHb2hCQUovQWtBQ2Z5QWRJQmdnRFNBY0lBOXJhaUlGSUFVZ0dFc2JJaGRCZldvaUJ5QWRUUTBBR2lBRUtBQUFJQjBvQUFCeklnVU5BU0FFUVFScUlRUWdMUXNpQlNBSFNRUkFBMEFnQkNnQUFDQUZLQUFBY3lJbEJFQWdKUkFsSUFWcUlCMXJEQVFMSUFSQkJHb2hCQ0FGUVFScUlnVWdCMGtOQUFzTEFrQWdCU0FYUVg5cVR3MEFJQVF2QUFBZ0JTOEFBRWNOQUNBRVFRSnFJUVFnQlVFQ2FpRUZDeUFGSUJkSkJIOGdCVUVCYWlBRklBUXRBQUFnQlMwQUFFWWJCU0FGQ3lBZGF3d0JDeUFGRUNVTFFRUnFJU1VDUUNBcVJRUkFRUUFoQlF3QkN5QWtJQW9nSnlnQ2pJQVFhaUFhYXlJRUlDUWdCRW9iSWdkQkgzVWdCM0VoRjBFQUlRUURRQ0FFSWdVZ0Iwd0VRQ0FYSVFVTUFnc2dEU0FGUVg5cUlnUnFMUUFBSUFRZ0dtb3RBQUJHRFFBTEN5QWxJQVZySWdRZ0NFd05BQ0FGSUExcUlRd2dDeUFoYWlBRmFpRUpJQVFoQ0FzZ0VFRi9haUVRSUE4Z0p5QVBRZi8vQTNGQkFYUnFRWUNBQ0dvdkFRQWlCR3NoRHlBZ0lBc2dCR3NpQzJ0QmdJQUVTUTBBQ3d3QkN5QVhJUXdnR2lFSkN5QUlJQkpIRFFFZ0NTRWFJQXdoRndzZ0VTQVdheUVGSUFZRVFDQU9JQVZCL3dGdWFpQUZha0VKYWlBcFN3MEVDeUFaSUJGcklCVWdHU0FmU1JzaENTQU9RUUZxSVFjQ1FDQUZRUTlQQkVBZ0RrSHdBVG9BQUNBRlFYRnFJZ1JCL3dGUEJFQWdCMEgvQVNBRlFmSjlhaUlJUWY4QmJpSUVRUUZxRUNnYUlBUWdEbXBCQW1vaEJ5QUVRWUYrYkNBSWFpRUVDeUFISUFRNkFBQWdCMEVCYWlFSERBRUxJQTRnQlVFRWREb0FBQXNnQnlBV0lBVWdCMm9pQkJBN0lBUWdFU0FlYTBILy93TnhFQzhnQ1VGOGFpRUlJQVJCQW1vaEJDQUdCRUFnQkNBSVFmOEJibXBCQm1vZ0tVc05CQXNnRGkwQUFDRU1Ba0FnQ0VFUFR3UkFJQTRnREVFUGFqb0FBQ0FKUVcxcUlnaEIvZ05QQkVBZ0JFSC9BU0FKUWU5N2FpSUVRZjREYmlJSVFRRjBJZ3hCQW1vUUtCb2dDRUdDZkd3Z0JHb2hDQ0FISUFVZ0RHcHFRUVJxSVFRTElBaEIvd0ZQQkVBZ0JFSC9BVG9BQUNBSVFZRithaUVJSUFSQkFXb2hCQXNnQkNBSU9nQUFJQVJCQVdvaEJBd0JDeUFPSUFnZ0RHbzZBQUFMSUJrZ0NTQVJhaUlGYXlFSUlBWUVRQ0FFSUFoQi93RnVhaUFJYWtFSmFpQXBTdzBIQ3lBRVFRRnFJUWNDUUNBSVFROVBCRUFnQkVId0FUb0FBQ0FJUVhGcUlnMUIvd0ZQQkVBZ0IwSC9BU0FJUWZKOWFpSU1RZjhCYmlJSlFRRnFFQ2dhSUFRZ0NXcEJBbW9oQnlBSlFZRitiQ0FNYWlFTkN5QUhJQTA2QUFBZ0IwRUJhaUVIREFFTElBUWdDRUVFZERvQUFBc2dCeUFGSUFjZ0NHb2lDUkE3SUFrZ0dTQWJhMEgvL3dOeEVDOGdFa0Y4YWlFSUlBbEJBbW9oQ1NBR0JFQWdDU0FJUWY4QmJtcEJCbW9nS1VzTkJ3c2dCQzBBQUNFTUlBaEJEMDhFUUNBRUlBeEJEMm82QUFBQ2Z5QVNRVzFxSWdSQi9nTlBCRUFnQ1VIL0FTQVNRZTk3YWlJRVFmNERiaUlJUVFGMElnbEJBbW9RS0JvZ0J5QUpJQmxxSUFWcmFrRUVhaUVKSUFoQmdueHNJQVJxSVFRTElBUkIvd0ZQQ3dSQUlBbEIvd0U2QUFBZ0NVRUJhaUVKSUFSQmdYNXFJUVFMSUFrZ0JEb0FBQ0FKUVFGcUlRa01DQXNnQkNBSUlBeHFPZ0FBREFjTElBd2dOVThOQVNBTUlSY2dDU0VhSUF3Z0gwa05BQXNDUUNBWklCOVBEUUFnRWlBZklCbHJJZ1JySWhKQkEwb0VRQ0FFSUJ0cUlSc2dIeUVaREFFTElBd2hHU0FKSVJzZ0NDRVNDeUFSSUJacklRUWdCZ1JBSUE0Z0JFSC9BVzVxSUFScVFRbHFJQ2xMRFFJTElBNUJBV29oQlFKQUlBUkJEMDhFUUNBT1FmQUJPZ0FBSUFSQmNXb2lCMEgvQVU4RVFDQUZRZjhCSUFSQjhuMXFJaGRCL3dGdUlnVkJBV29RS0JvZ0JVR0JmbXdnRjJvaEJ5QUZJQTVxUVFKcUlRVUxJQVVnQnpvQUFDQUZRUUZxSVFVTUFRc2dEaUFFUVFSME9nQUFDeUFGSUJZZ0JDQUZhaUlhRURzZ0dpQVJJQjVyUWYvL0EzRVFMeUFWUVh4cUlSY2dHa0VDYWlFSElBWUVRQ0FISUJkQi93RnVha0VHYWlBcFN3MENDeUFPTFFBQUlSb0NmeUFYUVE5UEJFQWdEaUFhUVE5cU9nQUFBbjhnRlVGdGFpSU5RZjREVHdSQUlBZEIvd0VnRlVIdmUyb2lGMEgrQTI0aUdrRUJkQ0llUVFKcUVDZ2FJQVVnQkNBZWFtcEJCR29oQnlBYVFZSjhiQ0FYYWlFTkN5QU5RZjhCVHdzRVFDQUhRZjhCT2dBQUlBZEJBV29oQnlBTlFZRithaUVOQ3lBSElBMDZBQUFnQjBFQmFnd0JDeUFPSUJjZ0dtbzZBQUFnQndzaERpQU1JUmNnQ1NFYUlCa2hIU0FiSVJZTUF3c0NmeUFaSUI5UEJFQWdGU0VOSUJJTUFRc2dFaUFaSUJGcklnMUJFVW9OQUJvZ0VpQU5JQkpxUVh4cUlEQWdNU0FTSUJscVFYeHFTeHNpRFNBUklCbHJhaUlFUVFGSURRQWFJQVFnRzJvaEd5QUVJQmxxSVJrZ0VpQUVhd3NoRlNBUklCWnJJUVFnQmdSQUlBNGdCRUgvQVc1cUlBUnFRUWxxSUNsTERRRUxJQTVCQVdvaEJRSkFJQVJCRDA4RVFDQU9RZkFCT2dBQUlBUkJjV29pQjBIL0FVOEVRQ0FGUWY4QklBUkI4bjFxSWhkQi93RnVJZ1ZCQVdvUUtCb2dCVUdCZm13Z0Yyb2hCeUFGSUE1cVFRSnFJUVVMSUFVZ0J6b0FBQ0FGUVFGcUlRVU1BUXNnRGlBRVFRUjBPZ0FBQ3lBRklCWWdCQ0FGYWlJYUVEc2dHaUFSSUI1clFmLy9BM0VRTHlBTlFYeHFJUmNnR2tFQ2FpRUhJQVlFUUNBSElCZEIvd0Z1YWtFR2FpQXBTdzBCQ3lBT0xRQUFJUm9DZnlBWFFROVBCRUFnRGlBYVFROXFPZ0FBQW44Z0RVRnRhaUlRUWY0RFR3UkFJQWRCL3dFZ0RVSHZlMm9pRjBIK0EyNGlHa0VCZENJZVFRSnFFQ2dhSUFVZ0JDQWVhbXBCQkdvaEJ5QWFRWUo4YkNBWGFpRVFDeUFRUWY4QlR3c0VRQ0FIUWY4Qk9nQUFJQWRCQVdvaEJ5QVFRWUYrYWlFUUN5QUhJQkE2QUFBZ0RTQVJhaUVXSUJraEVTQUhRUUZxREFFTElBNGdGeUFhYWpvQUFDQU5JQkZxSVJZZ0dTRVJJQWNMSVE0Z0d5RWVJQXdoRnlBSklSb01BUXNMQ3lBV0RBTUxJQVVoS0NBRURBTUxJQ2dnTWtzTkJpQUFLQUtFZ0JBaEN3d0ZDeUFmQ3lFb0lBNExJUWxCQUNFSElBWkJBa1lOQXd3R0N5QWZJUVFnREVFQmFpSU1JREpORFFBTEN3c2dNeUFvYXlJRVFmQUJha0gvQVc0aEJRSkFJQVpGRFFBZ0JDQUZhaUFKYWtFQmFpQXBRUVZxSURvZ094c2lCVTBOQUVFQUlRY2dCa0VCUmcwRElBbEJmM01nQldvaUJDQUVRZkFCYWtIL0FXNXJJUVFMSUFRZ0tHb2hCZ0pBSUFSQkQwOEVRQ0FKUWZBQk9nQUFJQWxCQVdvaEJTQUVRWEZxSWdoQi93RkpCRUFnQlNJSklBZzZBQUFNQWdzZ0JVSC9BU0FFUWZKOWFpSUlRZjhCYmlJRlFRRnFFQ2dhSUFVZ0NXcEJBbW9pQ1NBRlFZRitiQ0FJYWpvQUFBd0JDeUFKSUFSQkJIUTZBQUFMSUFsQkFXb2dLQ0FFRUNvaEJTQURJQVlnQVdzMkFnQWdCQ0FGYWlBQ2F3d0JDeUFBSUFFZ0FpQURJQVFnTGlBSlFaZ1dhaWdDQUNBR0lBVkJDMHBCQVNBQUxRQ2FnQkJCQUVjUWtBSUxJZ2RCQUVvTkFRc2dBRUVCT2dDYmdCQUxJQWNQQ3lBQUlBRWdBaUFESUFRZ0JTQUdFSkVDQ3pBQUlBQW9BcHlBRUVVRVFDQUFJQUVnQWlBRElBUWdCU0FHRUpFQ0R3c2dBQ0FCSUFJZ0F5QUVJQVVnQmhDdUJBdCtBUUYvSUFBb0FvQ0FFQ0FBS0FLRWdCQnJJZ0pCZ1lDQWdBUlBCRUFnQUVFQVFZQ0FDQkFvUVlDQUNHcEIvd0ZCZ0lBSUVDZ2FRUUFoQWdzZ0FDQUJOZ0tBZ0JBZ0FDQUNRWUNBQkdvaUFqWUNsSUFRSUFBZ0FqWUNrSUFRSUFBZ0FqWUNqSUFRSUFBZ0FTQUNheUlCTmdLRWdCQWdBQ0FCTmdLSWdCQUxUd0VCZnlBQUxRQ2JnQkFFUUNBQUVKSUNHaUFBSUFFUXNBRVBDeUFBUVFBMkFweUFFQ0FBS0FLRWdCQWhBaUFBUVFBMkFvU0FFQ0FBSUFBb0FvQ0FFQ0FDYXpZQ2dJQVFJQUFnQVJDd0FRdFFBUUovSXdCQkVHc2lCaVFBSUFZZ0F6WUNEQ0FBUVFOeFJRUkFJQUFnQlJDeEJDQUFJQUVRc0FRZ0FDQUJJQUlnQmtFTWFpQUVJQVVnQXhDVEFpQUVTaEN2QkNFSEN5QUdRUkJxSkFBZ0J3dnlLQUVUZnlBRlFRRWdCVUVCU2hzaEJpQUFJZ1ZGSUFCQkIzRnlCSDlCQUFVZ0JVRUFRYUNBQVJBb0N5RUlBa0FDUUFKQUFrQWdBeENUQWlBRVRBUkFJQU5CaW9BRVNnMEJJQU5CZ0lDQThBZExEUUlnQVNBRGFpRU1JQWdvQW9DQUFTRUFJQWhCQXpzQmhvQUJJQWdnQUNBRGFqWUNnSUFCSUFnZ0NDZ0NrSUFCSUFOcU5nS1FnQUVDUUNBRFFRMUlCRUFnQWlFRElBRWhBQXdCQ3lBTVFYVnFJUkFnREVGMGFpRVVJQUVnQVNnQUFFRURFREFnQ0VFRElBRWdBR3NpQ3hCSklBeEJlMm9pRVVGL2FpRVRJQkZCZldvaER5QUdRUVowSWdWQkFYSWhFaUFCUVFGcUlnUW9BQUJCQXhBd0lRb2dBU0VKSUFJaEJnTkFJQVJCQVdvaERTQUtJQWhCQXhCSUlRY2dCU0VPSUJJaEF3SkFBMEFnRFNnQUFFRURFREFoQUNBRUlBdHJJQW9nQ0VFREVGd2dCeUFMYWlJS0tBQUFJQVFvQUFCR0RRRWdEa0VHZFNFVklBQWdDRUVERUVnaEJ5QURJUTRnQTBFQmFpRURJQUFoQ2lBVklBMGlCR29pRFNBUVRRMEFDeUFHSVFNZ0NTRUFEQUlMQTBBZ0NpSU5JQUZOSUFRaUFDQUpUWEpGQkVBZ0FFRi9haUlFTFFBQUlBMUJmMm9pQ2kwQUFFWU5BUXNMSUFaQkFXb2hBd0pBSUFBZ0NXc2lCRUVQVHdSQUlBWkI4QUU2QUFBZ0JFRnhhaUlLUWY4QlRnUkFJQU5CL3dFZ0FFSHZBV29pQXlBS1FmMERJQXBCL1FOSUd5SUhJQWxxYTBIL0FXNUJBV29RS0JvZ0JpQURJQWxySUFkclFmOEJiaUlIYWtFQ2FpRURJQVFnQjBHQmZteHFRZko5YWlFS0N5QURJQW82QUFBZ0EwRUJhaUVEREFFTElBWWdCRUVFZERvQUFBc2dBeUFKSUFNZ0JHb2lDaEE3QTBBZ0NpQUFJQTFyUWYvL0EzRVFMeUFOUVFScUlRTUNmd0pBQW44Z0R5QUFRUVJxSWdsTkJFQWdDUXdCQ3lBREtBQUFJQWtvQUFCeklnTU5BU0FOUVFocUlRTWdBRUVJYWdzaUJDQVBTUVJBQTBBZ0F5Z0FBQ0FFS0FBQWN5SUhCRUFnQnhBbElBUnFJQWxyREFRTElBTkJCR29oQXlBRVFRUnFJZ1FnRDBrTkFBc0xBa0FnQkNBVFR3MEFJQU12QUFBZ0JDOEFBRWNOQUNBRFFRSnFJUU1nQkVFQ2FpRUVDeUFFSUJGSkJIOGdCRUVCYWlBRUlBTXRBQUFnQkMwQUFFWWJCU0FFQ3lBSmF3d0JDeUFERUNVTElRUWdDa0VDYWlFRElBQWdCR3BCQkdvaEFDQUdMUUFBSVFrQ1FDQUVRUTlQQkVBZ0JpQUpRUTlxT2dBQUlBTkJmeEEwSUFSQmNXb2lCRUg4QjA4RVFBTkFJQU5CQkdvaUEwRi9FRFFnQkVHRWVHb2lCRUg3QjBzTkFBc0xJQU1nQkVILy93TnhRZjhCYmlJR2FpSURJQVpCZ1g1c0lBUnFPZ0FBSUFOQkFXb2hBd3dCQ3lBR0lBUWdDV282QUFBTElBQWdFRThOQWlBQVFYNXFJZ1FnQkNnQUFFRURFREFnQ0VFRElBc1FTU0FBS0FBQVFRTVFNQ0lFSUFoQkF4QklJUVlnQUNBTGF5QUVJQWhCQXhCY0lBWWdDMm9pRFNnQUFDQUFLQUFBUmdSQUlBTkJBRG9BQUNBRFFRRnFJUW9nQXlFR0RBRUxDeUFBUVFGcUlnUW9BQUJCQXhBd0lRb2dBQ0VKSUFNaEJpQUVJQlJORFFBTEN3SkFJQXdnQUdzaUJFRVBUd1JBSUFOQjhBRTZBQUFnQTBFQmFpRUJJQVJCY1dvaUJVSC9BVWtFUUNBQklnTWdCVG9BQUF3Q0N5QUJRZjhCSUFSQjhuMXFJZ0ZCL3dGdVFRRnFFQ2dhSUFGQi93RnVJZ1VnQTJwQkFtb2lBeUFGUVlGK2JDQUJham9BQUF3QkN5QURJQVJCQkhRNkFBQUxEQVFMSUFOQmlvQUVUQVJBSUFOQmdJQ0E4QWRMRFFJZ0FpQUVhaUVQSUFFZ0Eyb2hEQ0FJS0FLQWdBRWhBQ0FJUVFNN0FZYUFBU0FJSUFBZ0EybzJBb0NBQVNBSUlBZ29BcENBQVNBRGFqWUNrSUFCQWtBZ0EwRU5TQVJBSUFJaEF5QUJJUUFNQVFzZ0RFRjFhaUVSSUF4QmRHb2hGU0FCSUFFb0FBQkJBeEF3SUFoQkF5QUJJQUJySWdzUVNTQU1RWHRxSWhSQmYyb2hGeUFVUVgxcUlSQWdCa0VHZENJSlFRRnlJUklnQVVFQmFpSUVLQUFBUVFNUU1DRUtJQUVoQlNBQ0lRWURRQ0FFUVFGcUlRMGdDaUFJUVFNUVNDRUhJQWtoRGlBU0lRTUNRQU5BSUEwb0FBQkJBeEF3SVFBZ0JDQUxheUFLSUFoQkF4QmNJQWNnQzJvaUNpZ0FBQ0FFS0FBQVJnMEJJQTVCQm5VaEZpQUFJQWhCQXhCSUlRY2dBeUVPSUFOQkFXb2hBeUFBSVFvZ0ZpQU5JZ1JxSWcwZ0VVME5BQXNnQmlFRElBVWhBQXdDQ3dOQUlBb2lEU0FCVFNBRUlnQWdCVTF5UlFSQUlBQkJmMm9pQkMwQUFDQU5RWDlxSWdvdEFBQkdEUUVMQ3lBR0lBQWdCV3NpQTJvZ0EwSC9BVzVxUVFscUlBOUxCRUJCQUE4TElBWkJBV29oQkFKQUlBTkJEMDhFUUNBR1FmQUJPZ0FBSUFOQmNXb2lDa0gvQVU0RVFDQUVRZjhCSUFCQjd3RnFJZ1FnQ2tIOUF5QUtRZjBEU0JzaUJ5QUZhbXRCL3dGdVFRRnFFQ2dhSUFZZ0JDQUZheUFIYTBIL0FXNGlCMnBCQW1vaEJDQURJQWRCZ1g1c2FrSHlmV29oQ2dzZ0JDQUtPZ0FBSUFSQkFXb2hCQXdCQ3lBR0lBTkJCSFE2QUFBTElBUWdCU0FESUFScUlnb1FPd05BSUFvZ0FDQU5hMEgvL3dOeEVDOGdEVUVFYWlFRElBb0Nmd0pBQW44Z0VDQUFRUVJxSWdWTkJFQWdCUXdCQ3lBREtBQUFJQVVvQUFCeklnTU5BU0FOUVFocUlRTWdBRUVJYWdzaUJDQVFTUVJBQTBBZ0F5Z0FBQ0FFS0FBQWN5SUhCRUFnQnhBbElBUnFJQVZyREFRTElBTkJCR29oQXlBRVFRUnFJZ1FnRUVrTkFBc0xBa0FnQkNBWFR3MEFJQU12QUFBZ0JDOEFBRWNOQUNBRFFRSnFJUU1nQkVFQ2FpRUVDeUFFSUJSSkJIOGdCRUVCYWlBRUlBTXRBQUFnQkMwQUFFWWJCU0FFQ3lBRmF3d0JDeUFERUNVTElnUkI4QUZxUWY4QmJtcEJDR29nRDBzRVFFRUFEd3NnQ2tFQ2FpRURJQUFnQkdwQkJHb2hBQ0FHTFFBQUlRVUNRQ0FFUVE5UEJFQWdCaUFGUVE5cU9nQUFJQU5CZnhBMElBUkJjV29pQkVIOEIwOEVRQU5BSUFOQkJHb2lBMEYvRURRZ0JFR0VlR29pQkVIN0Iwc05BQXNMSUFNZ0JFSC8vd054UWY4QmJpSUZhaUlESUFWQmdYNXNJQVJxT2dBQUlBTkJBV29oQXd3QkN5QUdJQVFnQldvNkFBQUxJQUFnRVU4TkFpQUFRWDVxSWdRZ0JDZ0FBRUVERURBZ0NFRURJQXNRU1NBQUtBQUFRUU1RTUNJRUlBaEJBeEJJSVFVZ0FDQUxheUFFSUFoQkF4QmNJQVVnQzJvaURTZ0FBQ0FBS0FBQVJnUkFJQU5CQURvQUFDQURRUUZxSVFvZ0F5RUdEQUVMQ3lBQVFRRnFJZ1FvQUFCQkF4QXdJUW9nQUNFRklBTWhCaUFFSUJWTkRRQUxDeUFESUF3Z0FHc2lCR29nQkVId0FXcEIvd0Z1YWtFQmFpQVBTdzBDQWtBZ0JFRVBUd1JBSUFOQjhBRTZBQUFnQTBFQmFpRUJJQVJCY1dvaUJVSC9BVWtFUUNBQklnTWdCVG9BQUF3Q0N5QUJRZjhCSUFSQjhuMXFJZ0ZCL3dGdVFRRnFFQ2dhSUFGQi93RnVJZ1VnQTJwQkFtb2lBeUFGUVlGK2JDQUJham9BQUF3QkN5QURJQVJCQkhRNkFBQUxEQVFMSUFOQmdJQ0E4QWRMRFFFZ0FpQUVhaUVQSUFFZ0Eyb2lFRUYxYWlFUklCQkJkR29oRlNBSUtBS0FnQUVoQUNBSVFRRkJBaUFCUWYvL0Ewc2JJZ3M3QVlhQUFTQUlJQUFnQTJvMkFvQ0FBU0FJSUFnb0FwQ0FBU0FEYWpZQ2tJQUJJQUVnQVNnQUFDQUxFREFnQ0NBTElBRWdBR3NpREJCSklCQkJlMm9pRjBGL2FpRVlJQmRCZldvaEZDQUdRUVowSWdwQkFYSWhEU0FCUVFGcUlnTW9BQUFnQ3hBd0lRUWdBVUdBZ0FSSklSWWdBaUVGSUFFaEJnTkFBa0FDUUNBV1JRUkFJQU1nRlVzTkFpQURRUUZxSVE0Z0NpRUpJQTBoQndOQUlBUWdDQkNGQVNFQUlBNG9BQUJCQVJBd0lSSWdBeUFFSUFoQkFTQU1FRWtnQUVILy93TnFJQU5QQkVBZ0FDZ0FBQ0FES0FBQVJnMERDeUFKUVFaMUlRQWdCeUVKSUFkQkFXb2hCeUFTSVFRZ0FDQU9JZ05xSWc0Z0VVME5BQXNNQWdzZ0F5QVZTdzBCSUFOQkFXb2hEaUFFSUFnZ0N4QklJUUFnQ2lFSklBMGhCd05BSUE0b0FBQWdDeEF3SVJJZ0F5QU1heUlUSUFRZ0NDQUxFRndnQUVILy93TnFJQk5QQkVBZ0FDQU1haUlBS0FBQUlBTW9BQUJHRFFJTElBbEJCblVoRXlBU0lBZ2dDeEJJSVFBZ0J5RUpJQWRCQVdvaEJ5QVNJUVFnRXlBT0lnTnFJZzRnRVUwTkFBc01BUXNEUUNBQUlnUWdBVTBnQXlJSklBWk5ja1VFUUNBSlFYOXFJZ010QUFBZ0JFRi9haUlBTFFBQVJnMEJDd3RCQUNFVElBVWdDU0FHYXlJRGFpQURRZjhCYm1wQkNXb2dEMHNOQXlBRlFRRnFJUUFDUUNBRFFROVBCRUFnQlVId0FUb0FBQ0FEUVhGcUlnZEIvd0ZPQkVBZ0FFSC9BU0FKUWU4QmFpSUFJQWRCL1FNZ0IwSDlBMGdiSWdjZ0JtcHJRZjhCYmtFQmFoQW9HaUFGSUFBZ0Jtc2dCMnRCL3dGdUlnZHFRUUpxSVFBZ0F5QUhRWUYrYkdwQjhuMXFJUWNMSUFBZ0J6b0FBQ0FBUVFGcUlRQU1BUXNnQlNBRFFRUjBPZ0FBQ3lBQUlBWWdBQ0FEYWlJSEVEc2dDU0VHQTBBZ0J5QUdJQVJyUWYvL0EzRVFMeUFFUVFScUlRTWdCd0ovQWtBQ2Z5QVVJQVpCQkdvaUFFMEVRQ0FBREFFTElBTW9BQUFnQUNnQUFITWlBdzBCSUFSQkNHb2hBeUFHUVFocUN5SUVJQlJKQkVBRFFDQURLQUFBSUFRb0FBQnpJZ2tFUUNBSkVDVWdCR29nQUdzTUJBc2dBMEVFYWlFRElBUkJCR29pQkNBVVNRMEFDd3NDUUNBRUlCaFBEUUFnQXk4QUFDQUVMd0FBUncwQUlBTkJBbW9oQXlBRVFRSnFJUVFMSUFRZ0Ywa0VmeUFFUVFGcUlBUWdBeTBBQUNBRUxRQUFSaHNGSUFRTElBQnJEQUVMSUFNUUpRc2lBRUh3QVdwQi93RnVha0VJYWlBUFN3MEVJQWRCQW1vaEF5QUFJQVpxUVFScUlRWWdCUzBBQUNFRUFuOGdBRUVQVHdSQUlBVWdCRUVQYWpvQUFDQURRWDhRTkNBQVFYRnFJZ1JCL0FkUEJFQURRQ0FEUVFScUlnTkJmeEEwSUFSQmhIaHFJZ1JCK3dkTERRQUxDeUFESUFSQi8vOERjVUgvQVc0aUFHb2lBeUFBUVlGK2JDQUVham9BQUNBRFFRRnFEQUVMSUFVZ0FDQUVham9BQUNBREN5RUZJQVlnRVU4TkFTQUdRWDVxSWdBZ0FDZ0FBQ0FMRURBZ0NDQUxJQXdRU1NBR0tBQUFJUUFDUUFKQUlCWkZCRUFnQUVFQkVEQWlBQ0FJRUlVQklRUWdCaUFBSUFoQkFTQU1FRWtnQkVILy93TnFJQVpKRFFFZ0JDZ0FBQ0FHS0FBQVJ3MEJEQUlMSUFBZ0N4QXdJZ01nQ0NBTEVFZ2hBQ0FHSUF4cklnUWdBeUFJSUFzUVhDQUFRZi8vQTJvZ0JFa05BQ0FBSUF4cUlnUW9BQUFnQmlnQUFFWU5BUXNnQmtFQmFpSURLQUFBSUFzUU1DRUVEQU1MSUFWQkFEb0FBQ0FGUVFGcUlRY01BQXNBQ3d0QkFDRVRJQVVnRUNBR2F5SUJhaUFCUWZBQmFrSC9BVzVxUVFGcUlBOUxEUUVDUUNBQlFROVBCRUFnQlVId0FUb0FBQ0FGUVFGcUlRQWdBVUZ4YWlJRFFmOEJTUVJBSUFBaUJTQURPZ0FBREFJTElBQkIvd0VnQVVIeWZXb2lBRUgvQVc1QkFXb1FLQm9nQUVIL0FXNGlBeUFGYWtFQ2FpSUZJQU5CZ1g1c0lBQnFPZ0FBREFFTElBVWdBVUVFZERvQUFBc2dCVUVCYWlBR0lBRVFLaUFCYWlBQ2F5RVREQUVMSUFOQmdJQ0E4QWRMRFFBZ0FTQURhaUlQUVhWcUlSQWdEMEYwYWlFVUlBZ29Bb0NBQVNFQUlBaEJBVUVDSUFGQi8vOERTeHNpQ3pzQmhvQUJJQWdnQUNBRGFqWUNnSUFCSUFnZ0NDZ0NrSUFCSUFOcU5nS1FnQUVnQVNBQktBQUFJQXNRTUNBSUlBc2dBU0FBYXlJTUVFa2dEMEY3YWlJVFFYOXFJUmNnRTBGOWFpRVJJQVpCQm5RaUNrRUJjaUVOSUFGQkFXb2lBeWdBQUNBTEVEQWhCQ0FCUVlDQUJFa2hGU0FDSVFVZ0FTRUdBMEFDUUNBVlJRUkFJQU1nRkVzTkJDQURRUUZxSVE0Z0NpRUpJQTBoQndOQUlBUWdDQkNGQVNFQUlBNG9BQUJCQVJBd0lSSWdBeUFFSUFoQkFTQU1FRWtnQUVILy93TnFJQU5QQkVBZ0FDZ0FBQ0FES0FBQVJnMERDeUFKUVFaMUlRQWdCeUVKSUFkQkFXb2hCeUFTSVFRZ0FDQU9JZ05xSWc0Z0VFME5BQXNNQkFzZ0F5QVVTdzBESUFOQkFXb2hEaUFFSUFnZ0N4QklJUUFnQ2lFSklBMGhCd05BSUE0b0FBQWdDeEF3SVJJZ0F5QU1heUlXSUFRZ0NDQUxFRndnQUVILy93TnFJQlpQQkVBZ0FDQU1haUlBS0FBQUlBTW9BQUJHRFFJTElBbEJCblVoRmlBU0lBZ2dDeEJJSVFBZ0J5RUpJQWRCQVdvaEJ5QVNJUVFnRmlBT0lnTnFJZzRnRUUwTkFBc01Bd3NEUUNBQUlnUWdBVTBnQXlJSklBWk5ja1VFUUNBSlFYOXFJZ010QUFBZ0JFRi9haUlBTFFBQVJnMEJDd3NnQlVFQmFpRURBa0FnQ1NBR2F5SUFRUTlQQkVBZ0JVSHdBVG9BQUNBQVFYRnFJZ2RCL3dGT0JFQWdBMEgvQVNBSlFlOEJhaUlESUFkQi9RTWdCMEg5QTBnYklnY2dCbXByUWY4QmJrRUJhaEFvR2lBRklBTWdCbXNnQjJ0Qi93RnVJZ2RxUVFKcUlRTWdBQ0FIUVlGK2JHcEI4bjFxSVFjTElBTWdCem9BQUNBRFFRRnFJUU1NQVFzZ0JTQUFRUVIwT2dBQUN5QURJQVlnQUNBRGFpSUhFRHNnQ1NFR0EwQWdCeUFHSUFSclFmLy9BM0VRTHlBRVFRUnFJUU1DZndKQUFuOGdFU0FHUVFScUlnQk5CRUFnQUF3QkN5QURLQUFBSUFBb0FBQnpJZ01OQVNBRVFRaHFJUU1nQmtFSWFnc2lCQ0FSU1FSQUEwQWdBeWdBQUNBRUtBQUFjeUlKQkVBZ0NSQWxJQVJxSUFCckRBUUxJQU5CQkdvaEF5QUVRUVJxSWdRZ0VVa05BQXNMQWtBZ0JDQVhUdzBBSUFNdkFBQWdCQzhBQUVjTkFDQURRUUpxSVFNZ0JFRUNhaUVFQ3lBRUlCTkpCSDhnQkVFQmFpQUVJQU10QUFBZ0JDMEFBRVliQlNBRUN5QUFhd3dCQ3lBREVDVUxJUUFnQjBFQ2FpRURJQUFnQm1wQkJHb2hCaUFGTFFBQUlRUUNmeUFBUVE5UEJFQWdCU0FFUVE5cU9nQUFJQU5CZnhBMElBQkJjV29pQkVIOEIwOEVRQU5BSUFOQkJHb2lBMEYvRURRZ0JFR0VlR29pQkVIN0Iwc05BQXNMSUFNZ0JFSC8vd054UWY4QmJpSUFhaUlESUFCQmdYNXNJQVJxT2dBQUlBTkJBV29NQVFzZ0JTQUFJQVJxT2dBQUlBTUxJUVVnQmlBUVR3MERJQVpCZm1vaUFDQUFLQUFBSUFzUU1DQUlJQXNnREJCSklBWW9BQUFoQUFKQUFrQWdGVVVFUUNBQVFRRVFNQ0lBSUFnUWhRRWhCQ0FHSUFBZ0NFRUJJQXdRU1NBRVFmLy9BMm9nQmtrTkFTQUVLQUFBSUFZb0FBQkhEUUVNQWdzZ0FDQUxFREFpQXlBSUlBc1FTQ0VBSUFZZ0RHc2lCQ0FESUFnZ0N4QmNJQUJCLy84RGFpQUVTUTBBSUFBZ0RHb2lCQ2dBQUNBR0tBQUFSZzBCQ3lBR1FRRnFJZ01vQUFBZ0N4QXdJUVFNQWdzZ0JVRUFPZ0FBSUFWQkFXb2hCd3dBQ3dBTEFBc2dFdzhMQWtBZ0R5QUdheUlCUVE5UEJFQWdCVUh3QVRvQUFDQUZRUUZxSVFBZ0FVRnhhaUlEUWY4QlNRUkFJQUFpQlNBRE9nQUFEQUlMSUFCQi93RWdBVUh5ZldvaUFFSC9BVzVCQVdvUUtCb2dBRUgvQVc0aUF5QUZha0VDYWlJRklBTkJnWDVzSUFCcU9nQUFEQUVMSUFVZ0FVRUVkRG9BQUFzZ0JVRUJhaUFHSUFFUUtpQUJhaUFDYXc4TElBTkJBV29nQUNBRUVDb2dCR29nQW1zTEpnQWdBRUVYTmdJUUlBQkJHRFlDRENBQVFSazJBZ2dnQUVFYU5nSUVJQUJCd0JVMkFnQUwxUWdCQ1g4Z0JBUi9RUkJCSUNBRVFSQjJJZ1ViUVhoQkFDQUZJQVFnQlJzaUJVRUlkaUlFRzJwQmZFRUFJQVFnQlNBRUd5SUZRUVIySWdRYmFrRitRUUFnQkNBRklBUWJJZ1ZCQW5ZaUJCdHFJQVFnQlNBRUcwRUJTMnNGUVNFTElRc2dBQ0FCYWlFSkFrQWdBVUVQU1EwQUlBbEJmR29oRENBSlFYRnFJUTBnQUNJR1FRRnFJZ0VoQkFOQUlBRW9BQUFoQjBFZ0lRRURRQ0FFSWdVZ0FVRUZkbW9pQkNBTlN3UkFJQVloQUF3REN5QURJQWRCdmMvVzhRRnNJQXQyUVFGMGFpSUlMd0VBSVFvZ0JDZ0FBQ0VISUFnZ0JTQUFhenNCQUNBQlFRRnFJUUVnQlNnQUFDQUFJQXBxSWdvb0FBQkhEUUFMSUFVZ0Jtc2lDRUYvYWlFQkFrQUNRQ0FJUVQxT0JFQWdBa0VCYWlFRVFRQWhCd05BSUFRZ0FUb0FBQ0FFUVFGcUlRUWdCMEVCYWlFSElBRkJDSFlpQVEwQUN5QUNJQWRCQW5SQmJHbzZBQUFNQVFzZ0FpQUJRUUowT2dBQUlBSkJBV29oQkNBSVFSQktEUUFnQWlBR0tBQUFOZ0FCSUFJZ0JpZ0FCRFlBQlNBQ0lBWW9BQWcyQUFrZ0FpQUdLQUFNTmdBTkRBRUxJQVFnQmlBSUVDb2FDeUFFSUFocUlRSURRQ0FLUVFScUlRZEJBQ0VFQWtBQ1FDQU1JQVZCQkdvaUFVa05BQU5BSUFFb0FBQWlCaUFFSUFkcUtBQUFJZ2hHQkVBZ0JFRUVhaUVFSUFGQkJHb2lBU0FNVFEwQkRBSUxDeUFFUVhoQkFDQUdJQWh6SWdSQkVIUWlBU0FFSUFFYklnWkJDSFFpQkJ0QkQwRWZJQUViYWtGOFFRQWdCQ0FHSUFRYklnUkJCSFFpQVJ0cVFYNUJBQ0FCSUFRZ0FSc2lCRUVDZENJQkcyb2dBU0FFSUFFYlFmLy8vLzhIY1VFQVIydEJBM1ZxSVFRTUFRc2dBU0FKVHcwQUlBa2dCQ0FCYTJvaEJnTkFJQVFnQjJvdEFBQWdBUzBBQUVjTkFTQUVRUUZxSVFRZ0FVRUJhaUlCSUFsSERRQUxJQVloQkFzZ0JTQUtheUVHSUFSQkJHb2hBUUpBSUFSQndBQklCRUFnQVNFSERBRUxJQUVoQkFOQUlBSWdCanNBQVNBQ1FmNEJPZ0FBSUFKQkEyb2hBaUFFUVlNQlNpRUlJQVJCUUdvaUJ5RUVJQWdOQUFzTElBZEJ3UUJPQkVBZ0FpQUdPd0FCSUFKQjdnRTZBQUFnQjBGRWFpRUhJQUpCQTJvaEFnc2dBU0FGYWlFRkFuOGdCMEVMU2lBR1FmOFBTM0pGQkVBZ0FpQUdPZ0FCSUFJZ0JrRURka0hnQVhFZ0IwRUNkR3BCOFFGcU9nQUFJQUpCQW1vTUFRc2dBaUFHT3dBQklBSWdCMEVDZEVGK2Fqb0FBQ0FDUVFOcUN5RUNJQVVnRFU4RVFDQUZJUUFNQXdzZ0F5QUZRWDlxSWdFb0FBQkJ2Yy9XOFFGc0lBdDJRUUYwYWlBRklBQnJJZ1JCZjJvN0FRQWdBQ0FESUFVb0FBQkJ2Yy9XOFFGc0lBdDJRUUYwYWlJR0x3RUFhaUlLS0FBQUlRY2dCaUFFT3dFQUlBY2dCU2dBQUVZTkFBc2dCVUVCYWlFRUlBRkJBbW9oQVNBRklRWU1BQXNBQ3lBQUlBbEpCSDhnQ1NBQWF5SURRWDlxSVFFZ0FnSi9JQU5CUFU0RVFDQUNRUUZxSVFSQkFDRUhBMEFnQkNBQk9nQUFJQVJCQVdvaEJDQUhRUUZxSVFjZ0FVRUlkaUlCRFFBTElBZEJBblJCYkdvTUFRc2dBa0VCYWlFRUlBRkJBblFMT2dBQUlBUWdBQ0FERUNvZ0Eyb0ZJQUlMQytzQ0FoVi9BWDVDc0g4aEdTQUNRUWR4Qkg0Z0dRVWdBd1JBSUFKQkEzWWhCU0FEUVFOMElRa0RRQ0FGQkVBZ0NFRURkQ0lHSUFWc0lRb2dCa0VIY2lJTElBVnNJUXdnQmtFR2NpSU5JQVZzSVE0Z0JrRUZjaUlQSUFWc0lSQWdCa0VFY2lJUklBVnNJUklnQmtFRGNpSVRJQVZzSVJRZ0JrRUNjaUlWSUFWc0lSWWdCa0VCY2lJWElBVnNJUmhCQUNFRUEwQWdBU0FHSUFRZ0NXd2lCMnBxSUFBZ0JDQUthbW90QUFBNkFBQWdBU0FISUJkcWFpQUFJQVFnR0dwcUxRQUFPZ0FBSUFFZ0J5QVZhbW9nQUNBRUlCWnFhaTBBQURvQUFDQUJJQWNnRTJwcUlBQWdCQ0FVYW1vdEFBQTZBQUFnQVNBSElCRnFhaUFBSUFRZ0VtcHFMUUFBT2dBQUlBRWdCeUFQYW1vZ0FDQUVJQkJxYWkwQUFEb0FBQ0FCSUFjZ0RXcHFJQUFnQkNBT2Ftb3RBQUE2QUFBZ0FTQUhJQXRxYWlBQUlBUWdER3BxTFFBQU9nQUFJQVJCQVdvaUJDQUZSdzBBQ3dzZ0NFRUJhaUlJSUFOSERRQUxDeUFDSUFOc3JRc0xOQUVCZmtLd2Z5RUZBa0FnQWtFSGNRMEFJQUFnQkNBQ0lBTVF0Z1FpQlVJQVV3MEFJQVFnQVNBQ0lBTVF1QVFoQlFzZ0JRdjJBZ0lOZndKK1FyQi9JUkVnQWtFSGNRUitJQkVGSUFJZ0Eyd2hCeUFEUVFOMElnVUVRQ0FEUVFkc0lRa2dBMEVHYkNFS0lBTkJCV3doQ3lBRFFRSjBJUXdnQTBFRGJDRU5JQU5CQVhRaERpQUZRWDlxSUFkUElROERRQ0FQUlFSQUlBWkJBM1loRUVFQUlRZ2dCU0VDQTBBZ0FTQUlJQkJxSWdScUlBQWdCaUFJYW1vcEF3QWlFVUlIaUNBUmhVS3FnYWlGb0pXQTFRQ0RJaElnRVlVZ0VrSUhob1VpRVVJT2lDQVJoVUxNbVlPQXdKa3pneUlTSUJHRklCSkNEb2FGSWhGQ0hJZ2dFWVZDOE9IRGh3K0RJaElnRVlVaUVUd0FBQ0FCSUFNZ0JHcHFJQkZDQ0lnOEFBQWdBU0FFSUE1cWFpQVJRaENJUEFBQUlBRWdCQ0FOYW1vZ0VVSVlpRHdBQUNBQklBUWdER3BxSUJFZ0VrSWNob1VpRVVJZ2lEd0FBQ0FCSUFRZ0MycHFJQkZDS0lnOEFBQWdBU0FFSUFwcWFpQVJRakNJUEFBQUlBRWdCQ0FKYW1vZ0VVSTRpRHdBQUNBQ0lnZ2dCV29pQWtGL2FpQUhTUTBBQ3dzZ0JrRUlhaUlHSUFWSkRRQUxDeUFIclFzTFZRRUJma0t3ZnlFRkFrQWdBa0VIY1EwQUlBQWdBU0FDSUFNUXZBUWlCVUlBVXcwQUlBRWdCQ0FDSUFNUXV3UWlCVUlBVXcwQUlBSkJCM0VFZmtLd2Z3VWdCQ0FCSUFNZ0FrRURkaEM2QkFzaEJRc2dCUXRaQVFOL0EwQWdBZ1JBSUFJZ0JHd2hCa0VBSVFVRFFDQUJJQVZCQTNRZ0JHb2dBMnhxSUFBZ0JTQUdhaUFEYkdvZ0F4QXFHaUFGUVFGcUlnVWdBa2NOQUFzTElBUkJBV29pQkVFSVJ3MEFDeUFDSUFOc1FRTjByUXZBQWdJSGZ3SitRckIvSVFzZ0FpQURiQ0lFUVFkeEJINGdDd1VnQkVFRGRpSUNCRUFnQWtFSGJDRUZJQUpCQm13aEJpQUNRUVZzSVFjZ0FrRUNkQ0VJSUFKQkEyd2hDU0FDUVFGMElRcEJBQ0VEQTBBZ0FTQURhaUFBSUFOQkEzUnFLUU1BSWd0Q0I0Z2dDNFZDcW9Hb2hhQ1ZnTlVBZ3lJTUlBdUZJQXhDQjRhRklndENEb2dnQzRWQ3pKbURnTUNaTTRNaURDQUxoU0FNUWc2R2hTSUxRaHlJSUF1RlF2RGh3NGNQZ3lJTUlBdUZJZ3M4QUFBZ0FTQUNJQU5xYWlBTFFnaUlQQUFBSUFFZ0F5QUthbW9nQzBJUWlEd0FBQ0FCSUFNZ0NXcHFJQXRDR0lnOEFBQWdBU0FESUFocWFpQUxJQXhDSElhRklndENJSWc4QUFBZ0FTQURJQWRxYWlBTFFpaUlQQUFBSUFFZ0F5QUdhbW9nQzBJd2lEd0FBQ0FCSUFNZ0JXcHFJQXRDT0lnOEFBQWdBMEVCYWlJRElBSkhEUUFMQ3lBRXJRc0xyUU1CRW44Q1FDQUNSUTBBSUFKQkNFOEVRQU5BSUFNRVFDQURJQVZzSVFjZ0JVRUhjaUlJSUFOc0lRa2dCVUVHY2lJS0lBTnNJUXNnQlVFRmNpSU1JQU5zSVEwZ0JVRUVjaUlPSUFOc0lROGdCVUVEY2lJUUlBTnNJUkVnQlVFQ2NpSVNJQU5zSVJNZ0JVRUJjaUlVSUFOc0lSVkJBQ0VFQTBBZ0FTQUZJQUlnQkd3aUJtcHFJQUFnQkNBSGFtb3RBQUE2QUFBZ0FTQUdJQlJxYWlBQUlBUWdGV3BxTFFBQU9nQUFJQUVnQmlBU2Ftb2dBQ0FFSUJOcWFpMEFBRG9BQUNBQklBWWdFR3BxSUFBZ0JDQVJhbW90QUFBNkFBQWdBU0FHSUE1cWFpQUFJQVFnRDJwcUxRQUFPZ0FBSUFFZ0JpQU1hbW9nQUNBRUlBMXFhaTBBQURvQUFDQUJJQVlnQ21wcUlBQWdCQ0FMYW1vdEFBQTZBQUFnQVNBR0lBaHFhaUFBSUFRZ0NXcHFMUUFBT2dBQUlBUkJBV29pQkNBRFJ3MEFDd3NnQlVFUGFpRUVJQVZCQ0dvaEJTQUVJQUpKRFFBTEN5QUNRWGh4SWdVZ0FrOE5BQU5BSUFNRVFDQURJQVZzSVFaQkFDRUVBMEFnQVNBQ0lBUnNJQVZxYWlBQUlBUWdCbXBxTFFBQU9nQUFJQVJCQVdvaUJDQURSdzBBQ3dzZ0JVRUJhaUlGSUFKSERRQUxDeUFDSUFOc3JRdUNBUUVHZnlBQklBRWdBRzRpQmlBQWJHc2hCeUFBSUFGTkJFQWdCa0VCSUFaQkFVc2JJUWdEUUNBQUJFQWdBQ0FFYkNFSlFRQWhCUU5BSUFNZ0JTQUphbW9nQWlBRklBWnNJQVJxYWkwQUFEb0FBQ0FGUVFGcUlnVWdBRWNOQUFzTElBUkJBV29pQkNBSVJ3MEFDd3NnQXlBQklBZHJJZ0JxSUFBZ0Ftb2dCeEFxR2dzTkFDQUFJQUVnQWlBREVMMEVDNElCQVFaL0lBRWdBU0FBYmlJR0lBQnNheUVISUFBRVFDQUdRUUVnQmtFQlN4c2hDQU5BSUFBZ0FVMEVRQ0FFSUFac0lRbEJBQ0VGQTBBZ0F5QUZJQWxxYWlBQ0lBQWdCV3dnQkdwcUxRQUFPZ0FBSUFWQkFXb2lCU0FJUncwQUN3c2dCRUVCYWlJRUlBQkhEUUFMQ3lBRElBRWdCMnNpQUdvZ0FDQUNhaUFIRUNvYUM3Z0JBUU4vQWtBZ0FVRUJTQTBBSUFBc0FBQWlCRUgvQUhFaEF3SkFJQVJCZjBvTkFDQUJRUUpJRFFFZ0FDd0FBU0lFUVFkMFFZRC9BSEVnQTNJaEF5QUVRWDlLRFFBZ0FVRURTQTBCSUFBc0FBSWlCRUVPZEVHQWdQOEFjU0FEY2lFRElBUkJmMG9OQUNBQlFRUklEUUVnQUN3QUF5SUVRUlYwUVlDQWdQOEFjU0FEY2lFRElBUkJmMG9OQUNBQlFRVklEUUVnQUMwQUJDSUFRUTlMRFFFZ0FFRWNkQ0FEY2lFREN5QUNJQU0yQWdCQkFTRUZDeUFGQ3cwQUlBQWdBU0FDSUFNUXZ3UUxsQUlCQTM4Z0FDQUJFRGNhSUFKQkEzWWlCRUg0Ly8vL0FYRWhBeUFCSUFKQkIzRWlCV29oQWlBQUlBVnFJUUFDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQVJCQjNGQmYyb09Cd1lGQkFNQ0FRQUhDeUFBSUFJUU55RUFJQUpCQ0dvaEFnc2dBQ0FDRURjaEFDQUNRUWhxSVFJTElBQWdBaEEzSVFBZ0FrRUlhaUVDQ3lBQUlBSVFOeUVBSUFKQkNHb2hBZ3NnQUNBQ0VEY2hBQ0FDUVFocUlRSUxJQUFnQWhBM0lRQWdBa0VJYWlFQ0N5QUFJQUlRTnlFQUlBSkJDR29oQWdzZ0F3UkFBMEFnQUNBQ0VEY2dBa0VJYWhBM0lBSkJFR29RTnlBQ1FSaHFFRGNnQWtFZ2FoQTNJQUpCS0dvUU55QUNRVEJxRURjZ0FrRTRhaEEzSVFBZ0FrRkFheUVDSUFOQmVHb2lBdzBBQ3dzZ0FBc3RBQ0FDQkVBRFFDQUFJQUV0QUFBNkFBQWdBRUVCYWlFQUlBRkJBV29oQVNBQ1FYOXFJZ0lOQUFzTElBQUx2UVVCQTM4Z0FDQUJheUlEUVFsUEJFQWdBQ0FCSUFJUVVBOExBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFOQmZtcEJIM2NPRUFBQkRBSU1EQXdEQkFVR0J3Z0pDZ3NNQ3lBQ1FRRk5EUXdEUUNBQUlBRVFlQ0VBSUFKQmZtb2lBa0VCU3cwQUN3d01DeUFDUVFOTkRRc0RRQ0FBSUFFUWR5RUFJQUpCZkdvaUFrRURTdzBBQ3d3TEN5QUNRUWRORFFvRFFDQUFJQUVRTnlFQUlBSkJlR29pQWtFSFN3MEFDd3dLQ3lBQ1FROU5EUWtEUUNBQUlBRVFWaUVBSUFKQmNHb2lBa0VQU3cwQUN3d0pDeUFDUVJKSkRRZ2dBVUVRYWlFREEwQWdBQ0FCRUZZZ0F4QjRJUUFnQWtGdWFpSUNRUkZMRFFBTERBZ0xJQUpCRkVrTkJ5QUJRUkJxSVFNRFFDQUFJQUVRVmlBREVIY2hBQ0FDUVd4cUlnSkJFMHNOQUFzTUJ3c2dBa0VXU1EwR0lBRkJGR29oQXlBQlFSQnFJUVFEUUNBQUlBRVFWaUFFRUhjZ0F4QjRJUUFnQWtGcWFpSUNRUlZMRFFBTERBWUxJQUpCR0VrTkJTQUJRUkJxSVFNRFFDQUFJQUVRVmlBREVEY2hBQ0FDUVdocUlnSkJGMHNOQUFzTUJRc2dBa0VhU1EwRUlBRkJHR29oQXlBQlFSQnFJUVFEUUNBQUlBRVFWaUFFRURjZ0F4QjRJUUFnQWtGbWFpSUNRUmxMRFFBTERBUUxJQUpCSEVrTkF5QUJRUmhxSVFNZ0FVRVFhaUVFQTBBZ0FDQUJFRllnQkJBM0lBTVFkeUVBSUFKQlpHb2lBa0ViU3cwQUN3d0RDeUFDUVI1SkRRSWdBVUVjYWlFRElBRkJHR29oQkNBQlFSQnFJUVVEUUNBQUlBRVFWaUFGRURjZ0JCQjNJQU1RZUNFQUlBSkJZbW9pQWtFZFN3MEFDd3dDQ3lBQ1FSOU5EUUVEUUNBQUlBRVFsQUloQUNBQ1FXQnFJZ0pCSDBzTkFBc01BUXNnQWtVTkFRTkFJQUFnQVMwQUFEb0FBQ0FBUVFGcUlRQWdBVUVCYWlFQklBSkJmMm9pQWcwQUN3d0JDeUFDUlEwQUEwQWdBQ0FCTFFBQU9nQUFJQUJCQVdvaEFDQUJRUUZxSVFFZ0FrRi9haUlDRFFBTEN5QUFDN0VCQWdKL0FuNGdBRUYvYWkwQUFDRURBa0FDUUNBQlFYaHFJZ1FnQUUwTkFDQURyVUwvQVlOQ2dZS0VpSkNnd0lBQmZpRUZBMEFnQWlrQUFDSUdJQVZSQkVBZ0FrRUlhaUVDSUFCQkNHb2lBQ0FFU1EwQkRBSUxDeUFHcDBIL0FYRWdBMGNOQVFOQUlBQkJBV29oQUNBQ0xRQUJJUUVnQWtFQmFpRUNJQUVnQTBZTkFBc01BUXNnQUNBQlR3MEFBMEFnQWkwQUFDQURSdzBCSUFKQkFXb2hBaUFBUVFGcUlnQWdBVWtOQUFzTElBQUxKZ0VCZjBFQ0lRUWdBeWdDQUNBQkVKVUNUd1IvSUFBZ0FTQUNJQU1RbFFSQkFBVWdCQXNMQzh6Y0FUZ0FRWUFJQzRNR1RqWnpibUZ3Y0hrMFUybHVhMFVBQUJoMEFBQUFCQUFBVGpaemJtRndjSGsyVTI5MWNtTmxSUUFBQUFBWWRBQUFHQVFBQUFBQUFBQnNCQUFBQVFBQUFBSUFBQUFEQUFBQUJBQUFBQVVBQUFCT05uTnVZWEJ3ZVRFMVFubDBaVUZ5Y21GNVUyOTFjbU5sUlFBQWpISUFBRkFFQUFBc0JBQUFBQUFBQUxRRUFBQUdBQUFBQndBQUFBZ0FBQUFKQUFBQVRqWnpibUZ3Y0hreU1sVnVZMmhsWTJ0bFpFSjVkR1ZCY25KaGVWTnBibXRGQUFBQWpISUFBSkFFQUFBUUJBQUFBUUFFQ0FFUUFTQUNBQVVJQWhBQ0lBTUFCZ2dERUFNZ0JBQUhDQVFRQkNBRkFBZ0lCUkFGSUFZQUNRZ0dFQVlnQndBS0NBY1FCeUFJQUFzSUNCQUlJQWtBQkFrSkVBa2dDZ0FGQ1FvUUNpQUxBQVlKQ3hBTElBd0FCd2tNRUF3Z0RRQUlDUTBRRFNBT0FBa0pEaEFPSUE4QUNna1BFQThnRUFBTENSQVFFQ0FSQUFRS0VSQVJJQklBQlFvU0VCSWdFd0FHQ2hNUUV5QVVBQWNLRkJBVUlCVUFDQW9WRUJVZ0ZnQUpDaFlRRmlBWEFBb0tGeEFYSUJnQUN3b1lFQmdnR1FBRUN4a1FHU0FhQUFVTEdoQWFJQnNBQmdzYkVCc2dIQUFIQ3h3UUhDQWRBQWdMSFJBZElCNEFDUXNlRUI0Z0h3QUtDeDhRSHlBZ0FBc0xJQkFnSUNFQUJBd2hFQ0VnSWdBRkRDSVFJaUFqQUFZTUl4QWpJQ1FBQnd3a0VDUWdKUUFJRENVUUpTQW1BQWtNSmhBbUlDY0FDZ3duRUNjZ0tBQUxEQ2dRS0NBcEFBUU5LUkFwSUNvQUJRMHFFQ29nS3dBR0RTc1FLeUFzQUFjTkxCQXNJQzBBQ0EwdEVDMGdMZ0FKRFM0UUxpQXZBQW9OTHhBdklEQUFDdzB3RURBZ01RQUVEakVRTVNBeUFBVU9NaEF5SURNQUJnNHpFRE1nTkFBSERqUVFOQ0ExQUFnT05SQTFJRFlBQ1E0MkVEWWdOd0FLRGpjUU55QTRBQXNPT0JBNElEa0FCQTg1RURrZ09nQUZEem9RT2lBN0FBWVBPeEE3SUR3QUJ3ODhFRHdnQVFnSUR6MFFQU0FCRUFrUFBoQStJQUVZQ2c4L0VEOGdBU0FMRDBBUVFDQUFBQUFBL3dBQUFQLy9BQUQvLy84QS8vLy8vMlJsWTI5dGNISmxjM01BWTI5dGNISmxjM01BWm5KbFpWOXlaWE4xYkhRQWRta0FBSGh6QUFCcGFXbHBhV2xwQUVHUURndlVCaWdIQUFBd0J3QUFNQWNBQU14ekFBRE1jd0FBekhNQUFCaDBBQUMyQndBQVFIUUFBRWdIQUFBQUFBQUFBUUFBQUlnSEFBQUFBQUFBVGxOME0xOWZNakV5WW1GemFXTmZjM1J5YVc1blNXTk9VMTh4TVdOb1lYSmZkSEpoYVhSelNXTkZSVTVUWHpsaGJHeHZZMkYwYjNKSlkwVkZSVVVBQUJoMEFBQ1FCd0FBVGxOME0xOWZNakl4WDE5aVlYTnBZMTl6ZEhKcGJtZGZZMjl0Ylc5dVNVeGlNVVZGUlFCT01UQmxiWE5qY21sd2RHVnVNM1poYkVVQUFBQUFHSFFBQU5RSEFBQk9NVEJsYlhOamNtbHdkR1Z1TVRGdFpXMXZjbmxmZG1sbGQwbG9SVVVBYVdscEFBQW9Cd0FBTUFjQUFCZ0lBQUFnQ0FBQUpBZ0FBQ29JQUFBeENBQUFOZ2dBQUdKc2IzTmpiSG9BYkhvMEFHeDZOR2hqQUhOdVlYQndlUUI2YkdsaUFIcHpkR1FBUlhKeWIzSXVJQ0J1ZEdoeVpXRmtjeUJqWVc1dWIzUWdZbVVnYkdGeVoyVnlJSFJvWVc0Z1FreFBVME5mVFVGWVgxUklVa1ZCUkZNZ0tDVmtLUUJGY25KdmNpNGdJRzUwYUhKbFlXUnpJRzExYzNRZ1ltVWdZU0J3YjNOcGRHbDJaU0JwYm5SbFoyVnlBRVZTVWs5U095QnlaWFIxY200Z1kyOWtaU0JtY205dElIQjBhSEpsWVdSZlkzSmxZWFJsS0NrZ2FYTWdKV1FLQUFsRmNuSnZjaUJrWlhSaGFXdzZJQ1Z6Q2dCQ2JHOXpZeUJvWVhNZ2JtOTBJR0psWlc0Z1kyOXRjR2xzWldRZ2QybDBhQ0FuSlhNbklBQmpiMjF3Y21WemMybHZiaUJ6ZFhCd2IzSjBMaUFnVUd4bFlYTmxJSFZ6WlNCdmJtVWdhR0YyYVc1bklHbDBMZ0JGY25KdmNpQmhiR3h2WTJGMGFXNW5JRzFsYlc5eWVTRUFSVkpTVDFJN0lISmxkSFZ5YmlCamIyUmxJR1p5YjIwZ2NIUm9jbVZoWkY5cWIybHVLQ2tnYVhNZ0pXUUtBRWx1Y0hWMElHSjFabVpsY2lCemFYcGxJR05oYm01dmRDQmxlR05sWldRZ0pXUWdZbmwwWlhNS0FFOTFkSEIxZENCaWRXWm1aWElnYzJsNlpTQnphRzkxYkdRZ1ltVWdiR0Z5WjJWeUlIUm9ZVzRnSldRZ1lubDBaWE1LQUdCamJHVjJaV3hnSUhCaGNtRnRaWFJsY2lCdGRYTjBJR0psSUdKbGRIZGxaVzRnTUNCaGJtUWdPU0VLQUdCemFIVm1abXhsWUNCd1lYSmhiV1YwWlhJZ2JYVnpkQ0JpWlNCbGFYUm9aWElnTUN3Z01TQnZjaUF5SVFvQUFBQUFBUUFBZ0FBQUFBQUJBQUFBQVFBQUNnb0xEQTBPRGc0Ty93QUlDQkFnSUNBZ1FBQkI5aFFMVWZDL21wbVptWm1adVQrYW1abVptWm5KUHpNek16TXpNOU0vbXBtWm1abVoyVDh6TXpNek16UGpQODNNek16TXpPdy9abVptWm1abTdqOEFBQUFBQUFEd1B3QUFBQUFBQVBBL1oyVnVaWEpwWXdCQjFCVUxHUUVBQUFBQ0FBQUFBUUFBQUFBQUFBQUVBQUFBQkFBQUFBUUFRZndWQzY0Qi8vLy8vL3ovLy84QkFBQUFBZ0FBQUFNQUFBQUFBQUFBQWdBQUFCQUFBQUFBQUFBQUFnQUFBQkFBQUFBQUFBQUFBZ0FBQUJBQUFBQUFBQUFBQkFBQUFCQUFBQUFBQUFBQUNBQUFBQkFBQUFBQUFBQUFFQUFBQUJBQUFBQUFBQUFBSUFBQUFCQUFBQUFBQUFBQVFBQUFBQkFBQUFBQUFBQUFnQUFBQUJBQUFBQUFBQUFBQUFFQUFCQUFBQUFCQUFBQVlBQUFBRUFBQUFBQkFBQUFBQUlBQUlBQUFBQUJBQUFBQUVBQUFBQVFBRUcwRnd2eFFKWXdCM2NzWVE3dXVsRUptUm5FYlFlUDlHcHdOYVZqNmFPVlpKNHlpTnNPcExqY2VSN3AxZUNJMmRLWEsweTJDYjE4c1g0SExiam5rUjIva0dRUXR4M3lJTEJxU0hHNTg5NUJ2b1I5MU5vYTYrVGRiVkcxMVBUSGhkT0RWcGhzRThDb2EyUjYrV0w5N01sbGlrOWNBUlRaYkFaall6MFArdlVOQ0kzSUlHNDdYaEJwVE9SQllOVnljV2VpMGVRRFBFZlVCRXY5aFEzU2E3VUtwZnFvdFRWc21MSkMxc203MjBENXZLempiTmd5ZFZ6ZlJjOE4xdHhaUGRHcnJERFpKam9BM2xHQVVkZklGbUhRdjdYMHRDRWp4TE5XbVpXNnp3K2x2YmlldUFJb0NJZ0ZYN0xaRE1ZazZRdXhoM3h2THhGTWFGaXJIV0hCUFMxbXRwQkIzSFlHY2RzQnZDRFNtQ29RMWUrSmhiRnhIN1cyQnFYa3Y1OHoxTGpvb3NrSGVEVDVBQStPcUFtV0dKZ080YnNOYW44dFBXMElsMnhra1FGY1krYjBVV3RyWW1Gc0hOZ3daWVZPQUdMeTdaVUdiSHVsQVJ2QjlBaUNWOFFQOWNiWnNHVlE2YmNTNnJpK2kzeUl1ZnpmSGQxaVNTM2FGZk44MDR4bFROVDdXR0d5VGM1UnRUcDBBTHlqNGpDNzFFR2wzMHJYbGRnOWJjVFJwUHYwMXROcTZXbEQvTmx1TkVhSVo2M1F1R0RhY3kwRVJPVWRBek5mVEFxcXlYd04zVHh4QlZDcVFRSW5FQkFMdm9ZZ0RNa2x0V2hYczRWdklBblVacm1mNUdIT0R2bmVYcGpKMlNraW1OQ3d0S2pYeHhjOXMxbUJEYlF1TzF5OXQ2MXN1c0FnZzdqdHRyTy9tZ3ppdGdPYTByRjBPVWZWNnE5MzBwMFZKdHNFZ3hiY2N4SUxZK09FTzJTVVBtcHREYWhhYW5vTHp3N2tuZjhKa3lldUFBcXhuZ2Q5UkpNUDhOS2pDSWRvOGdFZS9zSUdhVjFYWXZmTFoyV0FjVFpzR2VjR2EyNTJHOVQrNEN2VGlWcDYyaERNU3QxbmI5KzUrZm52dm81RHZyY1gxWTZ3WU9pajF0WitrOUdoeE1MWU9GTHkzMC94Wjd2UloxZThwdDBHdFQ5TE5ySkkyaXNOMkV3YkNxLzJTZ00yWUhvRVFjUHZZTjlWMzJlbzc0NXVNWG0rYVVhTXMySExHb05tdktEU2J5VTI0bWhTbFhjTXpBTkhDN3U1RmdJaUx5WUZWYjQ3dXNVb0M3MnlrbHEwS3dScXMxeW4vOWZDTWMvUXRZdWUyU3dkcnQ1YnNNSmtteWJ5WSt5Y28ycDFDcE50QXFrR0Nady9OZzdyaFdjSGNoTlhBQVdDU3IrVkZIcTQ0cTRyc1hzNEc3WU1tNDdTa2cyKzFlVzM3OXg4SWQvYkM5VFMwNFpDNHRUeCtMUGRhRzZEMmgvTkZyNkJXeWE1OXVGM3NHOTNSN2NZNWxvSWlIQnFELy9LT3dabVhBc0JFZitlWlk5cHJtTDQwLzlyWVVYUGJCWjQ0Z3FnN3RJTjExU0RCRTdDc3dNNVlTWm5wL2NXWU5CTlIybEoyM2R1UGtwcTBhN2NXdGJaWmd2ZlFQQTcyRGRUcnJ5cHhaNjczbi9Qc2tmcC83VXdIUEs5dllyQ3Vzb3drN05UcHFPMEpBVTIwTHFUQnRmTktWZmVWTDluMlNNdWVtYXp1RXBoeEFJYmFGMlVLMjhxTjc0THRLR09ETU1iM3dWYWplOENMUUFBQUFCQk1Sc1pnbUkyTXNOVExTc0V4V3hrUmZSM2ZZYW5XbGJIbGtGUENJclp5RW03d3RHSzZPLzZ5OW4wNHd4UHRheE5mcTYxamkyRG5zOGNtSWRSRXNKS0VDUFpVOU53OUhpU1FlOWhWZGV1TGhUbXRUZlh0WmdjbG9TREJWbVlHNElZcVFDYjIvb3RzSnJMTnFsZFhYZm1IR3hzLzk4L1FkU2VEbHJOb2lTRWxlTVZuNHdnUnJLbllYZXB2cWJoNlBIbjBQUG9KSVBldzJXeXhkcXFybDFkNjU5R1JDak1hMjlwL1hCMnJtc3hPZTlhS2lBc0NRY0xiVGdjRXZNMlJ0K3lCMTNHY1ZSdzdUQmxhL1QzOHlxN3RzSXhvbldSSElrMG9BZVErN3lmRjdxTmhBNTUzcWtsT08reVBQOTU4M08rU09ocWZSdkZRVHdxM2xnRlQzbndSSDVpNlljdFQ4TEdIRlRiQVlvVmxFQzdEbzJENkNPbXd0azR2dzNGb0RoTTlMc2hqNmVXQ3M2V2pSTUpBTXhjU0RIWFJZdGkrbTdLVStGM1ZGMjd1aFZzb0tQV1A0MklsdzZXa1ZDWTE5NFJxY3pIMHZyaDdKUEwrdlZjMTJKeUhlWjVhOTYxVkVDZmhFOVpXQklPRmhrakZRL2FjRGdrbTBFalBhZHIvV1htV3VaOEpRbkxWMlE0MEU2anJwRUI0cCtLR0NITXB6TmcvYndxcitFa3JlN1FQN1F0Z3hLZmJMSUpocXNrU01ucUZWUFFLVVorKzJoM1plTDJlVDh2dDBna05uUWJDUjAxS2hJRThyeFRTN09OU0ZKdzNtVjVNZTkrWVA3ejV1ZS93djMrZkpIUTFUMmd5OHo2Tm9xRHV3ZVJtbmhVdkxFNVphZW9TNWlET3dxcG1DTEorclVKaU11dUVFOWQ3MThPYlBSR3pUL1piWXdPd25SREVscnpBaU5CNnNGd2JNR0FRWGZZUjljMmx3Ym1MWTdGdFFDbGhJUWJ2QnFLUVhGYnUxcG9tT2gzUTluWmJGb2VUeTBWWDM0MkRKd3RHeWZkSEFBK0VnQ1l1Vk14ZzZDUVlxNkwwVk8xa2hiRjlOMVg5Ty9FbEtmQzc5V1cyZmJwdkFldXFJMGN0MnZlTVp3cTd5cUY3WGxyeXF4SWNOTnZHMTM0TGlwRzRlRTIzbWFnQjhWL1kxVG9WQ0psODAzbDg3SUNwTUtwRzJlUmhEQW1vSjhwdUs3RjVQbWYzdjA2elBQV2UvM296N3hycVlEOVdyS1pQZ21mc244NGhLdXdKQndzOFJVSE5USkdLaDV6ZHpFSHRPRndTUFhRYTFFMmcwWjZkN0pkWTA3WCtzc1A1dUhTekxYTStZMkUxK0JLRXBhdkN5T050c2h3b0oySlFidUVSbDBqQXdkc09CckVQeFV4aFE0T0tFS1lUMmNEcVZSK3dQcDVWWUhMWWt3ZnhUaUJYdlFqbUoybkRyUGNsaFdxR3dCVTVWb3hUL3laWW1MWDJGTjV6aGRQNFVsV2Z2cFFsUzNYZTlRY3pHSVRpbzB0VXJ1V05KSG91eC9RMmFBRzdQTitYcTNDWlVkdWtVaHNMNkJUZGVnMkVqcXBCd2tqYWxRa0NDdGxQeEhrZWFlV3BVaThqMllia2FRbktvcTk0THpMOHFHTjBPdGkzdjNBSSsvbTJiM2h2QlQ4MEtjTlA0T0tKbjZ5a1QrNUpOQncrQlhMYVR0RzVrSjZkLzFidFd0bDNQUmFmc1UzQ1ZQdWRqaEk5N0d1Q2Jqd254S2hNOHcvaW5MOUpKTUFBQUFBTjJyQ0FXN1VoQU5admtZQzNLZ0pCK3ZDeXdheWZJMEVoUlpQQmJoUkV3NlBPOUVQMW9XWERlSHZWUXhrK1JvSlU1UFlDQW90bmdvOVIxd0xjS01tSEVmSjVCMGVkNklmS1IxZ0hxd0xMeHViWWUwYXd0K3JHUFcxYVJuSThqVVMvNWozRTZZbXNSR1JUSE1RRkZvOEZTTXcvaFI2anJnV1RlUjZGK0JHVFRqWExJODVqcExKTzduNEN6bzg3a1EvQzRTR1BsSTZ3RHhsVUFJOVdCZGVObTk5bkRjMnc5bzFBYWtZTklTL1Z6R3oxWlV3Nm12VE10MEJFVE9RNVdza3A0K3BKZjR4N3lmSld5MG1URTFpSTNzbm9DSWltZVlnRmZNa0lTaTBlQ29mM3JvclJtRDhLWEVLUGlqMEhIRXR3M2F6TEpySTlTNnRvamN2d0kyYWNQZm5XSEd1V1I1em1UUGNjaHdsazNjclQxRjJjdkVYZEVXYjFYVjQzSWwrVDdaTGZ4WUlEWDBoWXM5OHBIU0FlWk1lUW5qS29BUjYvY3JHZTdBdXZHeUhSSDV0M3ZvNGIrbVErbTVzaHJWclcreDNhZ0pTTVdnMU9QTnBDSCt2WWo4VmJXTm1xeXRoVWNIcFlOVFhwbVhqdldSa3VnTWlabzFwNEdjZ3k5ZElGNkVWU1U0ZlUwdDVkWkZLL0dQZVQ4c0pIRTZTdDFwTXBkMllUWmlheEVhdjhBWkg5azVBUmNFa2drUkVNczFCYzFnUFFDcm1TVUlkakl0RFVHanhWR2NDTTFVK3ZIVlhDZGEzVm96QStGTzdxanBTNGhSOFVOVit2bEhvT2VKYTMxTWdXNGJ0WmxteGg2UllOSkhyWFFQN0tWeGFSVzllYlMrdFg0QWJOZUczY2ZmZzdzK3g0dG1sYytOY3N6em1hOW4rNXpKbnVPVUZEWHJrT0VvbTd3OGc1TzVXbnFMc1lmUmc3ZVRpTCtqVGlPM3BpamFyNjcxY2Flcnd1QlA5eDlMUi9KNXNsLzZwQmxYL0xCQWEraHQ2MlB0Q3hKNzVkYTVjK0VqcEFQTi9nOEx5SmoyRThCRlhSdkdVUVFuMG95dkw5ZnFWamZmTi8wLzJZRjE0MlZjM3V0Z09pZnphT2VNKzI3ejFjZDZMbjdQZjBpSDEzZVZMTjl6WURHdlg3MmFwMXJiWTc5U0JzaTNWQktSaTBEUE9vTkZxY09iVFhSb2swaEQrWHNVbmxKekVmaXJheGtsQUdNZk1WbGZDK3p5Vnc2S0MwOEdWNkJIQXFLOU55NS9GajhyR2U4bkk4UkVMeVhRSFJNeERiWWJOR3RQQXp5MjVBczVBbHErUmQveHRrQzVDSzVJWktPbVRuRDZtbHF0VVpKZnk2aUtWeFlEZ2xQakh2Si9Qclg2ZWxoTTRuS0Y1K3Awa2I3V1lFd1YzbVVxN01adDkwZk9hTURXSmpRZGZTNHhlNFEyT2FZdlBqK3lkZ0lyYjkwS0xna2tFaWJVanhvaUlaSnFEdnc1WWd1YXdIb0RSMnR5QlZNeVRoR09tVVlVNkdCZUhEWExWaHFEUTRxbVh1aUNvemdSbXF2bHVwS3Q4ZU91dVN4SXByeEtzYjYwbHhxMnNHSUh4cHkvck02WjJWWFdrUVQrM3BjUXArS0R6UXpxaHF2MThvNTJYdnFMUWM4UzE1eGtHdEw2blFMYUp6WUszRE52TnNqdXhEN05pRDBteFZXV0xzR2dpMTd0ZlNCVzZCdlpUdURHY2tibTBpdDY4ZytBY3ZkcGVXci90TkppK0FBQUFBR1ZudkxpTHlBbXE3cSsxRWxlWFlvOHk4TjQzM0Y5ckpiazQxNTN2S0xURmlrOElmV1Rndlc4Qmh3SFh1TC9XU3QzWWF2SXpkOS9nVmhCaldKOVhHVkQ2TUtYb0ZKOFErbkg0ckVMSXdIdmZyYWZIWjBNSWNuVW1iODdOY0grdGxSVVlFUzM3dDZRL250QVloeWZvenhwQ2ozT2lyQ0RHc01sSGVnZytyektnVzhpT0dMVm5Pd3JRQUlleWFUaFFMd3hmN0pmaThGbUZoNWZsUGRHSGhtVzA0RHJkV2srUHp6OG9NM2VHRU9UcTQzZFlVZzNZN1VCb3YxSDRvZmdyOE1TZmwwZ3FNQ0phVDFlZTR2WnZTWCtUQ1BYSGZhZEExUmpBL0cxTzBKODFLN2NqamNVWWxwK2dmeW9uR1VmOXVud2dRUUtTai9RUTkraElxRDFZRkp0WVA2Z2p0cEFkTWRQM29ZbHF6M1lVRDZqS3JPRUhmNzZFWU1NRzBuQ2dYcmNYSE9aWnVLbjBQTjhWVElYbnd0SGdnSDVwRGkvTGUydElkOE9pRHczTHgyaXhjeW5IQkdGTW9Malo5Wmh2UkpELzAveCtVR2J1R3pmYVZrMG51UTRvUUFXMnh1K3dwS09JREJ3YXNOdUJmOWRuT1pGNDBpdjBIMjZUQS9jbU8yYVFtb09JUHkrUjdWaVRLVlJnUkxReEIvZ00zNmhOSHJyUDhhYnMzNUwraWJndVJtY1htMVFDY0Nmc3UwandjZDR2VE1rd2dQbmJWZWRGWTV5Z1AydjV4NFBURjJnMndYSVBpbm5MTjEza3JsRGhYRUQvVkU0bG1PajJjNGlMcmhidk54YjRRSUlFblNjK3ZDUWY2U0ZCZUZXWnI5ZmdpOHF3WERNN3RsbnRYdEhsVmJCK1VFZlZHZXovYkNFN1lnbEdoOXJuNlRMSWdvNk9jTlNlN1NpeCtWR1FYMWJrZ2pveFdEcURDWStuNW00ekh3akJoZzF0cGpxMXBPRkF2Y0dHL0FVdktVa1hTazcxci9OMklqS1dFWjZLZUw0cm1CM1pseUJMeWZSNExxNUl3TUFCL2RLbFprRnFIRjZXOTNrNUtrK1hscDlkOHZFajVRVVphMDFnZnRmMWp0Rmk1K3UyM2w5U2pnbkNOK20xZXRsR0FHaThJYnpRNmpIZmlJOVdZekJoK2RZaUJKNXFtcjJtdlFmWXdRRy9ObTYwclZNSkNCV2FUbklkL3luT3BSR0dlN2QwNGNjUHpka1FrcWkrckNwR0VSazRJM2FsZ0hWbXh0Z1FBWHBnL3E3UGNwdkpjOG9pOGFSWFI1WVk3Nms1cmYzTVhoRkZCdTVOZG1PSjhjNk5Ka1RjNkVINFpGRjVML2swSHBOQjJyRW1VNy9XbXV2cHh2bXpqS0ZGQzJJTzhCa0hhVXlodmxHYlBOczJKNFExbVpLV1VQNHVMcG01VkNiODN1aWVFbkZkakhjVzRUVE9MamFwcTBtS0VVWG1Qd01nZ1lPN2RwSGc0eFAyWEZ2OVdlbEptRDVWOFNFR2dteEVZVDdVcXM2THhzK3BOMzQ0UVgvV1hTYkRick9KZG56VzdzckViOVlkV1FxeG9lSGtIaFR6Z1htb1M5ZHB5eE95RG5lclhLSEN1VG5HZmdHQS9xbWM1WmtWSkFzMm9EWnVVUnlPcHhabWhzSngyajRzM204c1NiblRsUENCQkFtVjVyaXhlMGtOb3g0dXNSdElQdEpETFZsdSs4UDIyK21ta1dkUkg2bXd6SHJPREhTVVlibG04UVlGM2dBQUFBQjNCekNXN2c1aExKa0pVYm9IYmNRWmNHcjBqK2xqcFRXZVpKV2pEdHVJTW5uY3VLVGcxZWtlbDlMWmlBbTJUQ3Qrc1h5OTU3Z3RCNUMvSFpFZHR4QmthckFnOHZPNWNVaUV2a0hlR3RyVWZXM2Q1T3YwMUxWUmc5T0Z4eE5zbUZaa2E2akEvV0w1ZW9wbHlld1VBVnhQWXdaczJmb1BQV09OQ0EzMU8yNGd5RXhwRUY3VllFSGtvbWR4Y2p3RDVORkxCTlJIMGcyRi9hVUt0V3MxdGFqNlFyS1liTnU3eWRhc3ZQbEFNdGhzNDBYZlhIWGMxZzNQcTlFOVdTYlpNS3hSM2dBNnlOZFJnTC9RWVJZaHRQUzFWclBFSTgrNmxabTR2YVVQS0FLNG5sOEZpQWpHRE5teXNRdnBKQzl2ZklkWWFFd1J3V0VkcTdabUxUMTIzRUdRQWR0eEJwalNJTHp2MVJBcWNiR0ZpUWEydFIrZnYrU2w2TGpVTTNnSHlhSVBBUGswbGdtb2p1RU9tQmgvYWcyN0NHMDlMWkZrYkpmbVkxd0JhMnRSOUJ4c1lXS0ZaVERZOG1JQVRtd0dsZTBiQWFWN2dnajB3ZlVQeEZkbHNObkdFcmZwVUl1K3VPcjh1WWg4WXQwZDN4WGFMVW1NMDN6eis5Uk1aVTJ5WVZnNnRWSE9vN3dBZE5TN01PSkszNlZCUGRpVjE2VFJ4RzNUMXZUN1EybnBhalJ1MmZ5dFo0aEcybUM0MEVRRUxYTXpBeDNscWdwTVg5ME5mTWxRQlhFOEp3SkJxcjRMRUJESkRDQ0dWMmkxSlNCdmhiTzVadFFKem1Ia24xN2UrUTRwMmNtWXNOQ1lJc2ZYcUxSWnN6MFhMclFOZ2JlOVhEdkF1bXl0N2JpRElKcS9zN1lEdHVJTWRMSFNtdXJWUnptZDBuZXZCTnNtRlhQY0ZvUGpZd3NTbEdRN2hBMXRhajU2YWxxbzVBN1BDNU1KLzUwS0FLNG5mUWVlc2ZBUGswU0hDS1BTSGdIeWFHa0d3djczWWxkZGdHVm55eGxzTm5GdWF3Ym4vdFFiZG9uVEsrQVEybnBhWjkxS3pQbTUzMitPdnUvNUY3ZStRMkN3anRYVzFxUG9vZEdUZmpqWXdzUlAzL0pTMGJ0bjhhYThWMmMvdFFiZFNMSTJTOWdOSzlxdkNodE1OZ05LOWtFRWVtRGZZTy9EcUdmZlZURnVqdTlHYWI1NXkyR3pqTHhtZ3hvbGI5S2dVbWppTnN3TWQ1VzdDMGNESWdJV3VWVUZKaS9GdWp1K3NyMExLQ3UwV3BKY3Myb0V3dGYvcDdYUXp6RXMyWjZMVzk2dUhadGt3ckRzWS9JbWRXcWpuQUp0a3dxY0NRYXA2dzQyUDNJSFo0VUZBRmNUbGI5S2d1SzRlaFI3c1N1dURMWWJPSkxTanB2bDFiNE5mTnp2dHd2YjN5R0cwOUxVOGRUaVFtamRzL2dmMm9OdWdiNFd6ZmE1Smx0dnNIZmhHTGRIZDRnSVd1Yi9EMnB3WmdZN3loRUJDMXlQWlo3LytHS3VhV0ZyLzlNV2JNOUZvQXJpZU5jTjB1NU9CSU5VT1FPendxZG5KbUhRWUJiM1NXbEhUVDV1ZDl1dTBXcEsyZFphM0VEZkMyWTMyRHZ3cWJ5dVU5Njduc1ZIc3M5L01MWC82YjI5OGh6S3VzS0tVN09UTUNTMG82YTYwRFlGemRjR2sxVGVWeWtqMldlL3MyWjZMc1JoU3JoZGFCc0NLbThybExRTHZqZkRESTZoV2dYZkd5MEM3NDBBQUFBQUdSc3hRVEkyWW9JckxWUERaR3pGQkgxMzlFVldXcWVHVDBHV3g4alppZ2pSd3J0Sit1L29pdVAwMmN1c3RVOE10YTUrVFo2RExZNkhtQnpQU3NJU1VWUFpJeEI0OUhEVFllOUJraTZ1MTFVM3RlWVVISmkxMXdXRGhKYUNHNWhabXdDcEdMQXQrdHVwTnN1YTVuZGRYZjlzYkJ6VVFUL2Z6Vm9PbnBXRUpLS01ueFhqcDdKR0lMNnBkMkh4Nk9HbTZQUFE1OFBlZ3lUYXhiSmxYVjJ1cWtSR24rdHZhOHdvZG5EOWFUa3hhNjRnS2xydkN3Y0pMQkljT0czZlJqYnp4bDBIc3Uxd1ZISDBhMlV3dXlyejk2SXh3cmFKSEpGMWtBZWdOQmVmdlBzT2hJMjZKYW5lZVR5eTd6aHo4M24vYXVoSXZrSEZHMzFZM2lvODhIbFBCZWxpZmtUQ1R5MkgyMVFjeHBRVmlnR05EcnRBcGlQb2c3ODQyY0k0b01VTklidjBUQXFXcDQ4VGpaYk9YTXdBQ1VYWE1VaHUrbUtMZCtGVHlycTdYVlNqb0d3VmlJMC8xcEdXRHBmZTE1aFF4OHlwRWV6aCt0TDErc3VUY21MWFhHdDU1aDFBVkxYZVdVK0VueFlPRWxnUEZTTVpKRGh3MmowalFadGwvV3VuZk9aYTVsZkxDU1ZPMERoa0FaR3VveGlLbitJenA4d2hLcno5WUswazRhKzBQOUR1bnhLRExZWUpzbXpKU0NTcjBGTVY2dnQrUmluaVpYZG9Mejk1OWpZa1NMY2RDUnQwQkJJcU5VdFR2UEpTU0kyemVXWGVjR0IrN3pIbjV2UCsvdjNDdjlYUWtYek15NkE5ZzRvMitwcVJCN3V4dkZSNHFLZGxPVHVEbUVzaW1La0tDYlg2eVJDdXk0aGY3MTFQUnZSc0RtM1pQODEwd2c2TTgxb1NRK3BCSXdMQmJIREIySGRCZ0pjMjEwZU9MZVlHcFFDMXhid2JoSVJ4UVlvYWFGcTdXME4zNkpoYWJOblpGUzFQSGd3MmZsOG5HeTJjUGdBYzNibVlBQktnZ3pGVGk2NWlrSksxVTlIZDlNVVd4Ty8wVisvQ3A1VDIyWmJWcmdlODZiY2NqYWljTWQ1cmhTcnZLc3ByZWUzVGNFaXMrRjBiYitGR0tpNW0zamJoZjhVSG9GVG9WR05OODJVaUFyTHo1UnVwd3FRd2hKRm5LWitnSnVURnJyajkzcC81MXZQTU9zL28vWHVBcVd1OG1iSmEvYktmQ1Q2cmhEaC9MQndrc0RVSEZmRWVLa1l5QnpGM2MwaHc0YlJSYTlEMWVrYURObU5kc25mTCt0ZE8wdUhtRC9uTXRjemcxNFNOcjVZU1NyYU5Jd3Vkb0hESWhMdEJpUU1qWFVZYU9Hd0hNUlUveENnT0RvVm5UNWhDZmxTcEExVjUrc0JNWXN1QmdUakZINWdqOUY2ekRxZWRxaFdXM09WVUFCdjhUekZhMTJKaW1jNTVVOWhKNFU4WFVQcCtWbnZYTFpWaXpCelVMWTJLRXpTV3UxSWZ1K2lSQnFEWjBGNSs4K3hIWmNLdGJFaVJiblZUb0M4NkVqYm9Jd2tIcVFna1ZHb1JQMlVybHFkNTVJKzhTS1dra1J0bXZZb3FKL0xMdk9EcjBJMmh3UDNlWXRubTd5TVV2T0c5RGFmUS9DYUtnejgva2JKK2NOQWt1V25MRmZoQzVrWTdXLzEzZXR4bGE3WEZmbHIwN2xNSk4vZElPSGE0Q2E2eG9SS2Y4SW8vekRPVEpQMXlBQUFBQUFIQ2FqY0RoTlJ1QWthK1dRY0pxTndHeThMckJJMThzZ1ZQRm9VT0UxRzREOUU3ancyWGhkWU1WZS9oQ1JyNVpBallrMU1LbmkwS0MxeEhQUndtbzNBZDVNbEhINkozSGg1Z0hTa2JMd3VzR3UxaG14aXIzOElaYWJYMUVqWHl5QlAzbVA4UnNTYW1FSE5Na1JVOFdoUVUvakFqRnJpT2VoZDY1RTA0VFViZ09ZOHMxenZKa280NkMvaTVQMFR1UEQ2R2hBczh3RHBTUFFKUVpUWmVGMWczbkgxdk5kckROalFZcVFFeFY3K0VNSlhWc3pMVGErb3pFUUhkSkd2bGtDV3BqNmNuN3pIK0ppMWJ5U05pVFV3aW9DZDdJT2FaSWlFazh4VXFlTFFvSzdyZUh5bjhZRVlvUGdweExYRWM5Q3l6ZHNNdTljaWFMemVpclhDYWpjQnhXT2YzY3g1WnJuTGNNNWwza3lVY2RsRlBLM1FYOFhKMTFadEZmb25jZUg5THRrOTlEUWdXZk05aUlYbUFkS1I0UWg2VGVnU2d5bnZHeXYxc3ZDNndiWDVFaDI4NCt0NXUrcERwYTdXR2JHcDM3RnRvTVZJQ2FmTTROV0t2ZndoamJSVS9ZU3VyWm1EcHdWRmxwdGZVWkdTOTQyWWlBN3BuNEdtTlNOZkxJRWtWb1JkTFV4OU9TcEYxZVUvZVkveE9IQW5MVEZxM2trMlkzYVZHeEpxWVJ3YndyMFZBVHZaRWdpVEJRYzB5UkVBUFdITkNTZVlxUTR1TUhWVHhhRkJWTXdKblYzVzhQbGEzMWdsVCtNQ01VanFxdTFCOEZPSlJ2bjdWV3VJNTZGc2dVOTlaWnUyR1dLU0hzVjNya1RSY0tmc0RYbTlGV2wrdEwyM2hOUnVBNFBkeHQrS3h6KzdqYzZYWjVqeXpYT2YrMld2bHVHY3k1SG9OQmU4bVNqanU1Q0FQN0tLZVZ1MWc5R0hvTCtMazZlMkkwK3VyTm9ycWFWeTkvUk80OFB6UjBzZitsMnllLzFVR3Fmb2FFQ3o3MkhvYitaN0VRdmhjcm5YekFPbEk4c0tEZi9DRVBTYnhSbGNSOUFsQmxQWExLNlAzalpYNjlrLy96ZGw0WFdEWXVqZFgydnlKRHRzKzR6bmVjZlc4MzdPZmk5MzFJZExjTjB2bDEyc00yTmFwWnUvVTc5aTIxUzJ5Z2RCaXBBVFJvTTR6MCtad2F0SWtHbDNGWHY0UXhKeVVKOGJhS243SEdFQkp3bGRXek1PVlBQdkIwNEtpd0JIb2xjdE5yNmpLajhXZnlNbDd4c2tMRWZITVJBZDB6WVp0UTgvQTB4ck9Bcmt0a2ErV1FKQnQvSGVTSzBJdWsra29HWmFtUHB5WFpGU3JsU0xxOHBUZ2dNV2Z2TWY0bm42dHo1dzRFNWFkK25taG1MVnZKSmwzQlJPYk1idEttdlBSZlkySk5UQ01TMThIamczaFhvL1BpMm1LZ0ozc2kwTDMyNGtFU1lLSXhpTzFnNXBraUlKWURyK0FIckRtZ2R6YTBZU1R6RlNGVWFaamh4Y1lPb2JWY2cycDR0Q2dxQ0M2bDZwbUJNNnJwRzc1cnV0NGZLOHBFa3V0YjZ3U3JLM0dKYWZ4Z1JpbU0rc3ZwSFZWZHFXM1AwR2crQ25Fb1RwRDg2TjgvYXFpdnBlZHRjUnowTFFHR2VlMlFLZSt0NExOaWJMTjJ3eXpEN0U3c1VrUFlyQ0xaVlc3MXlKb3VoVklYN2hUOWdhNWtad3h2TjZLdEwwYzRJTy9XbDdhdnBnMDdRQUFBQUM0dkdkbHFnbklpeEsxcis2UFlwZFhOOTd3TWlWclg5eWQxemk1eGJRbzczMElUNHB2dmVCazF3R0hBVXJXdjdqeWF0amQ0TjkzTTFoakVGWlFHVmVmNktVdyt2b1FueFJDclBoeDMzdkF5R2ZIcDYxMWNnaER6YzV2SnBXdGYzQXRFUmdWUDZTMys0Y1kwSjRheitnbm9uT1BRckRHSUt3SWVrZkpvREt2UGhpT3lGc0tPMmUxc29jQTBDOVFPR21YN0Y4TWhWbnc0ajNsbDRkbGhvZlIzVHJndE0rUFQxcDNNeWcvNnVRUWhsSllkK05BN2RnTitGRy9hUEFyK0tGSWw1L0VXaUl3S3VLZVYwOS9TVy8yeC9VSWs5VkFwMzF0L01BWU5aL1FUbzBqdHl1ZmxoakZKeXAvb0xyOVJ4a0NRU0I4RVBTUGtxaEk2UGViRkZnOUk2Zy9XREVka0xhSm9mZlRGSGJQYXF6S3FBKytmd2ZoQnNOZ2hGNmdjTkxtSEJlMzlLbTRXVXdWM3p6Und1ZUZhWDZBNEh2TEx3N0RkMGhyeXcwUG9uT3hhTWRoQk1jcDJiaWdURVJ2bVBYODAvK1E3bVpRZmxiYU54c091U2ROdGdWQUtLU3c3OFljRElpamdkdXdHamxuMTM4cjBuaVJrMjRmOURzbTl3T0RtcEJta1M4L2lDbVRXTzIwUkdCVURQZ0hNUjVOcU4rbThjKzYvcExmN0VZdXVJbFVteGRuN0Nkd0FuSHdTTHZKVEMvZTIvbUFNR05GNTFWclA2Q2MwNFBIK2NFMmFCZDVpZzl5NUYwM3kxemhVSzVPVlA5QTl1aVlKYTZMaUhNV04rOFdCSUpBK0x3K0o1MGg2UjhrbVZWNFFZdmcxNjh6WExESzdWbTJPMVhsMFY1SFVINncvK3daMVdJN0lXemFoMFlKeURMcDUzQ09qb0lvN1o3VWtGSDVzWUxrVmw4NldERTZwNDhKZ3g4emJ1WU5oc0VJdFRxbWJiMUE0YVFGL0liQkYwa3BMNi8xVGtveUluYnppcDRSbHBncnZuZ2dsOWtkZVBUSlM4QklyaTdTL1FIQWFrRm1wZmVXWGh4UEtqbDVYWitXbCtVajhmSk5heGtGOWRkK1lPZGkwWTVmM3JicndnbU9VbnExNlRkb0FFYlowTHdodklqZk1lb3dZMWFQSXRiNVlacHFuZ1FIdmFhOXZ3SEIySzIwYmpZVkNBbFRIWEpPbXFYT0tmKzNlNFlSRDhmaGRKSVEyYzBxckw2b09Ca1JSb0NsZGlQWXhtWjFZSG9CRUhMUHJ2N0tjOG1iVjZUeEl1OFlsa2Y5clRtcFJSRmV6SFpON2diTzhZbGozRVFtaldUNFFlajVMM2xSUVpNZU5GTW1zZHJybXRhL3Mvbkc2UXRGb1l3WjhBNWlvVXhwQnp5YlViNkVKemJibHBLWk5TNHUvbEFtVkxtWm51amUvSXhkY1JJMDRSWjNxVFl1emhHS1Nhc0RQK1pGdTRPQklPUGdrWFpiWFBZVFNlbFovZkZWUHBoc2dnWWgxRDVoUk1hTHpxcCtONm5QMW45Qk9HN0RKbDE4ZG9tenhNcnUxbGtkMW0vaG9iRUs4eFFlNUV1b2VZRVR5Mm5YcTNjT3NybkNvVndCZnNZNW5LbitnQ1FWbWVVMm9EWUxqaHhSYm9abUZxYysybkhDTEcvZUxKVFR1VWtKQklId3Niam1sYU1OU1hzYnNTNGVROUkrU1B0dVdTM3AyL2JEVVdlUnBzeXdxUjkwRE01NlpybGhsTjRGQnZFQUFBQUFBQUFBQUIwQUFBQUVBQVFBQ0FBRUFCNEFBQUFFQUFVQUVBQUlBQjRBQUFBRUFBWUFJQUFnQUI0QUFBQUVBQVFBRUFBUUFCOEFBQUFJQUJBQUlBQWdBQjhBQUFBSUFCQUFnQUNBQUI4QUFBQUlBQ0FBZ0FBQUFSOEFBQUFnQUlBQUFnRUFCQjhBQUFBZ0FBSUJBZ0VBRUI4QVFmRFlBQXNKQWdBQUFBTUFBQUFIQUVHQzJRQUxkUVVBRUFBRkFBZ0FCUUFZQUFVQUJBQUZBQlFBQlFBTUFBVUFIQUFGQUFJQUJRQVNBQVVBQ2dBRkFCb0FCUUFHQUFVQUZnQUZBQTRBQlFBZUFBVUFBUUFGQUJFQUJRQUpBQVVBR1FBRkFBVUFCUUFWQUFVQURRQUZBQjBBQlFBREFBVUFFd0FGQUFzQUJRQWJBQVVBQndBRkFCY0FCUUJCa05vQUMyVUJBQUFBQVFBQUFBSUFBQUFDQUFBQUF3QUFBQU1BQUFBRUFBQUFCQUFBQUFVQUFBQUZBQUFBQmdBQUFBWUFBQUFIQUFBQUJ3QUFBQWdBQUFBSUFBQUFDUUFBQUFrQUFBQUtBQUFBQ2dBQUFBc0FBQUFMQUFBQURBQUFBQXdBQUFBTkFBQUFEUUJCZ05zQUMvOElEQUFJQUl3QUNBQk1BQWdBekFBSUFDd0FDQUNzQUFnQWJBQUlBT3dBQ0FBY0FBZ0FuQUFJQUZ3QUNBRGNBQWdBUEFBSUFMd0FDQUI4QUFnQS9BQUlBQUlBQ0FDQ0FBZ0FRZ0FJQU1JQUNBQWlBQWdBb2dBSUFHSUFDQURpQUFnQUVnQUlBSklBQ0FCU0FBZ0EwZ0FJQURJQUNBQ3lBQWdBY2dBSUFQSUFDQUFLQUFnQWlnQUlBRW9BQ0FES0FBZ0FLZ0FJQUtvQUNBQnFBQWdBNmdBSUFCb0FDQUNhQUFnQVdnQUlBTm9BQ0FBNkFBZ0F1Z0FJQUhvQUNBRDZBQWdBQmdBSUFJWUFDQUJHQUFnQXhnQUlBQ1lBQ0FDbUFBZ0FaZ0FJQU9ZQUNBQVdBQWdBbGdBSUFGWUFDQURXQUFnQU5nQUlBTFlBQ0FCMkFBZ0E5Z0FJQUE0QUNBQ09BQWdBVGdBSUFNNEFDQUF1QUFnQXJnQUlBRzRBQ0FEdUFBZ0FIZ0FJQUo0QUNBQmVBQWdBM2dBSUFENEFDQUMrQUFnQWZnQUlBUDRBQ0FBQkFBZ0FnUUFJQUVFQUNBREJBQWdBSVFBSUFLRUFDQUJoQUFnQTRRQUlBQkVBQ0FDUkFBZ0FVUUFJQU5FQUNBQXhBQWdBc1FBSUFIRUFDQUR4QUFnQUNRQUlBSWtBQ0FCSkFBZ0F5UUFJQUNrQUNBQ3BBQWdBYVFBSUFPa0FDQUFaQUFnQW1RQUlBRmtBQ0FEWkFBZ0FPUUFJQUxrQUNBQjVBQWdBK1FBSUFBVUFDQUNGQUFnQVJRQUlBTVVBQ0FBbEFBZ0FwUUFJQUdVQUNBRGxBQWdBRlFBSUFKVUFDQUJWQUFnQTFRQUlBRFVBQ0FDMUFBZ0FkUUFJQVBVQUNBQU5BQWdBalFBSUFFMEFDQUROQUFnQUxRQUlBSzBBQ0FCdEFBZ0E3UUFJQUIwQUNBQ2RBQWdBWFFBSUFOMEFDQUE5QUFnQXZRQUlBSDBBQ0FEOUFBZ0FFd0FKQUJNQkNRQ1RBQWtBa3dFSkFGTUFDUUJUQVFrQTB3QUpBTk1CQ1FBekFBa0FNd0VKQUxNQUNRQ3pBUWtBY3dBSkFITUJDUUR6QUFrQTh3RUpBQXNBQ1FBTEFRa0Fpd0FKQUlzQkNRQkxBQWtBU3dFSkFNc0FDUURMQVFrQUt3QUpBQ3NCQ1FDckFBa0Fxd0VKQUdzQUNRQnJBUWtBNndBSkFPc0JDUUFiQUFrQUd3RUpBSnNBQ1FDYkFRa0FXd0FKQUZzQkNRRGJBQWtBMndFSkFEc0FDUUE3QVFrQXV3QUpBTHNCQ1FCN0FBa0Fld0VKQVBzQUNRRDdBUWtBQndBSkFBY0JDUUNIQUFrQWh3RUpBRWNBQ1FCSEFRa0F4d0FKQU1jQkNRQW5BQWtBSndFSkFLY0FDUUNuQVFrQVp3QUpBR2NCQ1FEbkFBa0E1d0VKQUJjQUNRQVhBUWtBbHdBSkFKY0JDUUJYQUFrQVZ3RUpBTmNBQ1FEWEFRa0FOd0FKQURjQkNRQzNBQWtBdHdFSkFIY0FDUUIzQVFrQTl3QUpBUGNCQ1FBUEFBa0FEd0VKQUk4QUNRQ1BBUWtBVHdBSkFFOEJDUURQQUFrQXp3RUpBQzhBQ1FBdkFRa0Fyd0FKQUs4QkNRQnZBQWtBYndFSkFPOEFDUUR2QVFrQUh3QUpBQjhCQ1FDZkFBa0Fud0VKQUY4QUNRQmZBUWtBM3dBSkFOOEJDUUEvQUFrQVB3RUpBTDhBQ1FDL0FRa0Fmd0FKQUg4QkNRRC9BQWtBL3dFSkFBQUFCd0JBQUFjQUlBQUhBR0FBQndBUUFBY0FVQUFIQURBQUJ3QndBQWNBQ0FBSEFFZ0FCd0FvQUFjQWFBQUhBQmdBQndCWUFBY0FPQUFIQUhnQUJ3QUVBQWNBUkFBSEFDUUFCd0JrQUFjQUZBQUhBRlFBQndBMEFBY0FkQUFIQUFNQUNBQ0RBQWdBUXdBSUFNTUFDQUFqQUFnQW93QUlBR01BQ0FEakFBZ0FRYURrQUF0TkFRQUFBQUVBQUFBQkFBQUFBUUFBQUFJQUFBQUNBQUFBQWdBQUFBSUFBQUFEQUFBQUF3QUFBQU1BQUFBREFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBVUFBQUFGQUFBQUJRQUFBQVVBUVlEbEFBc1RFQkVTQUFnSENRWUtCUXNFREFNTkFnNEJEd0JCb2VVQUMrd0NBUUlEQkFVR0J3Z0lDUWtLQ2dzTERBd01EQTBORFEwT0RnNE9EdzhQRHhBUUVCQVFFQkFRRVJFUkVSRVJFUkVTRWhJU0VoSVNFaE1URXhNVEV4TVRGQlFVRkJRVUZCUVVGQlFVRkJRVUZCVVZGUlVWRlJVVkZSVVZGUlVWRlJVV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRnhjWEZ4Y1hGeGNYRnhjWEZ4Y1hGeGdZR0JnWUdCZ1lHQmdZR0JnWUdCZ1lHQmdZR0JnWUdCZ1lHQmdZR0JnWUdSa1pHUmtaR1JrWkdSa1pHUmtaR1JrWkdSa1pHUmtaR1JrWkdSa1pHUmthR2hvYUdob2FHaG9hR2hvYUdob2FHaG9hR2hvYUdob2FHaG9hR2hvYUdoc2JHeHNiR3hzYkd4c2JHeHNiR3hzYkd4c2JHeHNiR3hzYkd4c2JHeHNjQUFBQUFBRUFBQUFDQUFBQUF3QUFBQVFBQUFBRkFBQUFCZ0FBQUFjQUFBQUlBQUFBQ2dBQUFBd0FBQUFPQUFBQUVBQUFBQlFBQUFBWUFBQUFIQUFBQUNBQUFBQW9BQUFBTUFBQUFEZ0FBQUJBQUFBQVVBQUFBR0FBQUFCd0FBQUFnQUFBQUtBQUFBREFBQUFBNEFCQm9lZ0FDL1VFQVFJREJBUUZCUVlHQmdZSEJ3Y0hDQWdJQ0FnSUNBZ0pDUWtKQ1FrSkNRb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvTEN3c0xDd3NMQ3dzTEN3c0xDd3NMREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd05EUTBORFEwTkRRME5EUTBORFEwTkRRME5EUTBORFEwTkRRME5EUTBORFE0T0RnNE9EZzRPRGc0T0RnNE9EZzRPRGc0T0RnNE9EZzRPRGc0T0RnNE9EZzRPRGc0T0RnNE9EZzRPRGc0T0RnNE9EZzRPRGc0T0RnNE9EZzRPRGc0UER3OFBEdzhQRHc4UER3OFBEdzhQRHc4UER3OFBEdzhQRHc4UER3OFBEdzhQRHc4UER3OFBEdzhQRHc4UER3OFBEdzhQRHc4UER3OFBEdzhQRHc4UEFBQVFFUklTRXhNVUZCUVVGUlVWRlJZV0ZoWVdGaFlXRnhjWEZ4Y1hGeGNZR0JnWUdCZ1lHQmdZR0JnWUdCZ1lHUmtaR1JrWkdSa1pHUmtaR1JrWkdSb2FHaG9hR2hvYUdob2FHaG9hR2hvYUdob2FHaG9hR2hvYUdob2FHaG9hR3hzYkd4c2JHeHNiR3hzYkd4c2JHeHNiR3hzYkd4c2JHeHNiR3hzYkd4c2NIQndjSEJ3Y0hCd2NIQndjSEJ3Y0hCd2NIQndjSEJ3Y0hCd2NIQndjSEJ3Y0hCd2NIQndjSEJ3Y0hCd2NIQndjSEJ3Y0hCd2NIQndjSEJ3Y0hCd2NIUjBkSFIwZEhSMGRIUjBkSFIwZEhSMGRIUjBkSFIwZEhSMGRIUjBkSFIwZEhSMGRIUjBkSFIwZEhSMGRIUjBkSFIwZEhSMGRIUjBkSFIwZEhSMGRIUUFBQUFBQkFBQUFBZ0FBQUFNQUFBQUVBQUFBQmdBQUFBZ0FBQUFNQUFBQUVBQUFBQmdBQUFBZ0FBQUFNQUFBQUVBQUFBQmdBQUFBZ0FBQUFNQUFBQUFBQVFBQWdBRUFBQUFDQUFBQUF3QUFBQVFBQUFBR0FBQUFDQUFBQUF3QUFBQVFBQUFBR0FBQUFDQUFBQUF3QUFBQVFBQUFBR0FBUWFEdEFBdkVBd0VBQWdBREFBUUFCUUFIQUFrQURRQVJBQmtBSVFBeEFFRUFZUUNCQU1FQUFRR0JBUUVDQVFNQkJBRUdBUWdCREFFUUFSZ0JJQUV3QVVBQllBQUFBQUFEQUFRQUJRQUdBQWNBQ0FBSkFBb0FDd0FOQUE4QUVRQVRBQmNBR3dBZkFDTUFLd0F6QURzQVF3QlRBR01BY3dDREFLTUF3d0RqQUFJQkFBQUFBQUFBRUFBUUFCQUFFQUFSQUJFQUVnQVNBQk1BRXdBVUFCUUFGUUFWQUJZQUZnQVhBQmNBR0FBWUFCa0FHUUFhQUJvQUd3QWJBQndBSEFBZEFCMEFRQUJBQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFSQUJFQUVRQVJBQklBRWdBU0FCSUFFd0FUQUJNQUV3QVVBQlFBRkFBVUFCVUFGUUFWQUJVQUVBQklBRTRBYVc1amIzSnlaV04wSUdobFlXUmxjaUJqYUdWamF3QjFibXR1YjNkdUlHTnZiWEJ5WlhOemFXOXVJRzFsZEdodlpBQnBiblpoYkdsa0lIZHBibVJ2ZHlCemFYcGxBSFZ1YTI1dmQyNGdhR1ZoWkdWeUlHWnNZV2R6SUhObGRBQm9aV0ZrWlhJZ1kzSmpJRzFwYzIxaGRHTm9BR2x1ZG1Gc2FXUWdZbXh2WTJzZ2RIbHdaUUJwYm5aaGJHbGtJSE4wYjNKbFpDQmliRzlqYXlCc1pXNW5kR2h6QUhSdmJ5QnRZVzU1SUd4bGJtZDBhQ0J2Y2lCa2FYTjBZVzVqWlNCemVXMWliMnh6QUVIdzhBQUw0eE1RQUJFQUVnQUFBQWdBQndBSkFBWUFDZ0FGQUFzQUJBQU1BQU1BRFFBQ0FBNEFBUUFQQUdsdWRtRnNhV1FnWTI5a1pTQnNaVzVuZEdoeklITmxkQUJwYm5aaGJHbGtJR0pwZENCc1pXNW5kR2dnY21Wd1pXRjBBR2x1ZG1Gc2FXUWdZMjlrWlNBdExTQnRhWE56YVc1bklHVnVaQzF2WmkxaWJHOWphd0JwYm5aaGJHbGtJR3hwZEdWeVlXd3ZiR1Z1WjNSb2N5QnpaWFFBYVc1MllXeHBaQ0JrYVhOMFlXNWpaWE1nYzJWMEFHbHVkbUZzYVdRZ2JHbDBaWEpoYkM5c1pXNW5kR2dnWTI5a1pRQnBiblpoYkdsa0lHUnBjM1JoYm1ObElHTnZaR1VBYVc1MllXeHBaQ0JrYVhOMFlXNWpaU0IwYjI4Z1ptRnlJR0poWTJzQWFXNWpiM0p5WldOMElHUmhkR0VnWTJobFkyc0FhVzVqYjNKeVpXTjBJR3hsYm1kMGFDQmphR1ZqYXdBQUFBQUFZQWNBQUFBSVVBQUFDQkFBRkFoekFCSUhId0FBQ0hBQUFBZ3dBQUFKd0FBUUJ3b0FBQWhnQUFBSUlBQUFDYUFBQUFnQUFBQUlnQUFBQ0VBQUFBbmdBQkFIQmdBQUNGZ0FBQWdZQUFBSmtBQVRCenNBQUFoNEFBQUlPQUFBQ2RBQUVRY1JBQUFJYUFBQUNDZ0FBQW13QUFBSUNBQUFDSWdBQUFoSUFBQUo4QUFRQndRQUFBaFVBQUFJRkFBVkNPTUFFd2NyQUFBSWRBQUFDRFFBQUFuSUFCRUhEUUFBQ0dRQUFBZ2tBQUFKcUFBQUNBUUFBQWlFQUFBSVJBQUFDZWdBRUFjSUFBQUlYQUFBQ0J3QUFBbVlBQlFIVXdBQUNId0FBQWc4QUFBSjJBQVNCeGNBQUFoc0FBQUlMQUFBQ2JnQUFBZ01BQUFJakFBQUNFd0FBQW40QUJBSEF3QUFDRklBQUFnU0FCVUlvd0FUQnlNQUFBaHlBQUFJTWdBQUNjUUFFUWNMQUFBSVlnQUFDQ0lBQUFta0FBQUlBZ0FBQ0lJQUFBaENBQUFKNUFBUUJ3Y0FBQWhhQUFBSUdnQUFDWlFBRkFkREFBQUllZ0FBQ0RvQUFBblVBQklIRXdBQUNHb0FBQWdxQUFBSnRBQUFDQW9BQUFpS0FBQUlTZ0FBQ2ZRQUVBY0ZBQUFJVmdBQUNCWUFRQWdBQUJNSE13QUFDSFlBQUFnMkFBQUp6QUFSQnc4QUFBaG1BQUFJSmdBQUNhd0FBQWdHQUFBSWhnQUFDRVlBQUFuc0FCQUhDUUFBQ0Y0QUFBZ2VBQUFKbkFBVUIyTUFBQWgrQUFBSVBnQUFDZHdBRWdjYkFBQUliZ0FBQ0M0QUFBbThBQUFJRGdBQUNJNEFBQWhPQUFBSi9BQmdCd0FBQUFoUkFBQUlFUUFWQ0lNQUVnY2ZBQUFJY1FBQUNERUFBQW5DQUJBSENnQUFDR0VBQUFnaEFBQUpvZ0FBQ0FFQUFBaUJBQUFJUVFBQUNlSUFFQWNHQUFBSVdRQUFDQmtBQUFtU0FCTUhPd0FBQ0hrQUFBZzVBQUFKMGdBUkJ4RUFBQWhwQUFBSUtRQUFDYklBQUFnSkFBQUlpUUFBQ0VrQUFBbnlBQkFIQkFBQUNGVUFBQWdWQUJBSUFnRVRCeXNBQUFoMUFBQUlOUUFBQ2NvQUVRY05BQUFJWlFBQUNDVUFBQW1xQUFBSUJRQUFDSVVBQUFoRkFBQUo2Z0FRQndnQUFBaGRBQUFJSFFBQUNab0FGQWRUQUFBSWZRQUFDRDBBQUFuYUFCSUhGd0FBQ0cwQUFBZ3RBQUFKdWdBQUNBMEFBQWlOQUFBSVRRQUFDZm9BRUFjREFBQUlVd0FBQ0JNQUZRakRBQk1ISXdBQUNITUFBQWd6QUFBSnhnQVJCd3NBQUFoakFBQUlJd0FBQ2FZQUFBZ0RBQUFJZ3dBQUNFTUFBQW5tQUJBSEJ3QUFDRnNBQUFnYkFBQUpsZ0FVQjBNQUFBaDdBQUFJT3dBQUNkWUFFZ2NUQUFBSWF3QUFDQ3NBQUFtMkFBQUlDd0FBQ0lzQUFBaExBQUFKOWdBUUJ3VUFBQWhYQUFBSUZ3QkFDQUFBRXdjekFBQUlkd0FBQ0RjQUFBbk9BQkVIRHdBQUNHY0FBQWduQUFBSnJnQUFDQWNBQUFpSEFBQUlSd0FBQ2U0QUVBY0pBQUFJWHdBQUNCOEFBQW1lQUJRSFl3QUFDSDhBQUFnL0FBQUozZ0FTQnhzQUFBaHZBQUFJTHdBQUNiNEFBQWdQQUFBSWp3QUFDRThBQUFuK0FHQUhBQUFBQ0ZBQUFBZ1FBQlFJY3dBU0J4OEFBQWh3QUFBSU1BQUFDY0VBRUFjS0FBQUlZQUFBQ0NBQUFBbWhBQUFJQUFBQUNJQUFBQWhBQUFBSjRRQVFCd1lBQUFoWUFBQUlHQUFBQ1pFQUV3YzdBQUFJZUFBQUNEZ0FBQW5SQUJFSEVRQUFDR2dBQUFnb0FBQUpzUUFBQ0FnQUFBaUlBQUFJU0FBQUNmRUFFQWNFQUFBSVZBQUFDQlFBRlFqakFCTUhLd0FBQ0hRQUFBZzBBQUFKeVFBUkJ3MEFBQWhrQUFBSUpBQUFDYWtBQUFnRUFBQUloQUFBQ0VRQUFBbnBBQkFIQ0FBQUNGd0FBQWdjQUFBSm1RQVVCMU1BQUFoOEFBQUlQQUFBQ2RrQUVnY1hBQUFJYkFBQUNDd0FBQW01QUFBSURBQUFDSXdBQUFoTUFBQUorUUFRQndNQUFBaFNBQUFJRWdBVkNLTUFFd2NqQUFBSWNnQUFDRElBQUFuRkFCRUhDd0FBQ0dJQUFBZ2lBQUFKcFFBQUNBSUFBQWlDQUFBSVFnQUFDZVVBRUFjSEFBQUlXZ0FBQ0JvQUFBbVZBQlFIUXdBQUNIb0FBQWc2QUFBSjFRQVNCeE1BQUFocUFBQUlLZ0FBQ2JVQUFBZ0tBQUFJaWdBQUNFb0FBQW4xQUJBSEJRQUFDRllBQUFnV0FFQUlBQUFUQnpNQUFBaDJBQUFJTmdBQUNjMEFFUWNQQUFBSVpnQUFDQ1lBQUFtdEFBQUlCZ0FBQ0lZQUFBaEdBQUFKN1FBUUJ3a0FBQWhlQUFBSUhnQUFDWjBBRkFkakFBQUlmZ0FBQ0Q0QUFBbmRBQklIR3dBQUNHNEFBQWd1QUFBSnZRQUFDQTRBQUFpT0FBQUlUZ0FBQ2YwQVlBY0FBQUFJVVFBQUNCRUFGUWlEQUJJSEh3QUFDSEVBQUFneEFBQUp3d0FRQndvQUFBaGhBQUFJSVFBQUNhTUFBQWdCQUFBSWdRQUFDRUVBQUFuakFCQUhCZ0FBQ0ZrQUFBZ1pBQUFKa3dBVEJ6c0FBQWg1QUFBSU9RQUFDZE1BRVFjUkFBQUlhUUFBQ0NrQUFBbXpBQUFJQ1FBQUNJa0FBQWhKQUFBSjh3QVFCd1FBQUFoVkFBQUlGUUFRQ0FJQkV3Y3JBQUFJZFFBQUNEVUFBQW5MQUJFSERRQUFDR1VBQUFnbEFBQUpxd0FBQ0FVQUFBaUZBQUFJUlFBQUNlc0FFQWNJQUFBSVhRQUFDQjBBQUFtYkFCUUhVd0FBQ0gwQUFBZzlBQUFKMndBU0J4Y0FBQWh0QUFBSUxRQUFDYnNBQUFnTkFBQUlqUUFBQ0UwQUFBbjdBQkFIQXdBQUNGTUFBQWdUQUJVSXd3QVRCeU1BQUFoekFBQUlNd0FBQ2NjQUVRY0xBQUFJWXdBQUNDTUFBQW1uQUFBSUF3QUFDSU1BQUFoREFBQUo1d0FRQndjQUFBaGJBQUFJR3dBQUNaY0FGQWREQUFBSWV3QUFDRHNBQUFuWEFCSUhFd0FBQ0dzQUFBZ3JBQUFKdHdBQUNBc0FBQWlMQUFBSVN3QUFDZmNBRUFjRkFBQUlWd0FBQ0JjQVFBZ0FBQk1ITXdBQUNIY0FBQWczQUFBSnp3QVJCdzhBQUFobkFBQUlKd0FBQ2E4QUFBZ0hBQUFJaHdBQUNFY0FBQW52QUJBSENRQUFDRjhBQUFnZkFBQUpud0FVQjJNQUFBaC9BQUFJUHdBQUNkOEFFZ2NiQUFBSWJ3QUFDQzhBQUFtL0FBQUlEd0FBQ0k4QUFBaFBBQUFKL3dBUUJRRUFGd1VCQVJNRkVRQWJCUUVRRVFVRkFCa0ZBUVFWQlVFQUhRVUJRQkFGQXdBWUJRRUNGQVVoQUJ3RkFTQVNCUWtBR2dVQkNCWUZnUUJBQlFBQUVBVUNBQmNGZ1FFVEJSa0FHd1VCR0JFRkJ3QVpCUUVHRlFWaEFCMEZBV0FRQlFRQUdBVUJBeFFGTVFBY0JRRXdFZ1VOQUJvRkFRd1dCY0VBUUFVQUFERXVNaTQ0QUhOMGNtVmhiU0JsY25KdmNnQnBibk4xWm1acFkybGxiblFnYldWdGIzSjVBR0oxWm1abGNpQmxjbkp2Y2dCQjVJUUJDNkVWYXpnSEFBMnlCd0NjOGdjQWNHUUlBR0N1Q2dDd2NRc0FNS29NQUJNQUFBQU1BQUFBRFFBQUFBRUFBQUFHQUFBQUFRQUFBQUVBQUFBVEFBQUFEUUFBQUE0QUFBQUJBQUFBQndBQUFBQUFBQUFCQUFBQUZBQUFBQThBQUFBUUFBQUFBUUFBQUFZQUFBQUFBQUFBQVFBQUFCVUFBQUFRQUFBQUVRQUFBQUVBQUFBRkFBQUFBQUFBQUFJQUFBQVZBQUFBRWdBQUFCSUFBQUFCQUFBQUJRQUFBQUFBQUFBQ0FBQUFGUUFBQUJJQUFBQVRBQUFBQWdBQUFBVUFBQUFDQUFBQUF3QUFBQlVBQUFBVEFBQUFFd0FBQUFNQUFBQUZBQUFBQkFBQUFBTUFBQUFWQUFBQUV3QUFBQk1BQUFBREFBQUFCUUFBQUFnQUFBQUVBQUFBRlFBQUFCTUFBQUFUQUFBQUF3QUFBQVVBQUFBUUFBQUFCUUFBQUJVQUFBQVRBQUFBRkFBQUFBUUFBQUFGQUFBQUVBQUFBQVVBQUFBV0FBQUFGQUFBQUJVQUFBQUVBQUFBQlFBQUFCQUFBQUFGQUFBQUZnQUFBQlVBQUFBV0FBQUFCQUFBQUFVQUFBQVFBQUFBQlFBQUFCWUFBQUFWQUFBQUZnQUFBQVVBQUFBRkFBQUFFQUFBQUFVQUFBQVdBQUFBRlFBQUFCWUFBQUFGQUFBQUJRQUFBQ0FBQUFBR0FBQUFGZ0FBQUJZQUFBQVhBQUFBQlFBQUFBVUFBQUFnQUFBQUJnQUFBQllBQUFBWEFBQUFGd0FBQUFZQUFBQUZBQUFBSUFBQUFBWUFBQUFXQUFBQUZnQUFBQllBQUFBRkFBQUFCUUFBQURBQUFBQUhBQUFBRndBQUFCY0FBQUFXQUFBQUJRQUFBQVFBQUFCQUFBQUFCd0FBQUJjQUFBQVhBQUFBRmdBQUFBWUFBQUFEQUFBQVFBQUFBQWdBQUFBWEFBQUFHQUFBQUJZQUFBQUhBQUFBQXdBQUFBQUJBQUFKQUFBQUdRQUFBQmtBQUFBWEFBQUFCd0FBQUFNQUFBQUFBUUFBQ1FBQUFCb0FBQUFhQUFBQUdBQUFBQWNBQUFBREFBQUFBQUlBQUFrQUFBQWJBQUFBR3dBQUFCa0FBQUFKQUFBQUF3QUFBT2NEQUFBSkFBQUFFZ0FBQUF3QUFBQU5BQUFBQVFBQUFBVUFBQUFCQUFBQUFRQUFBQklBQUFBTkFBQUFEZ0FBQUFFQUFBQUdBQUFBQUFBQUFBRUFBQUFTQUFBQURnQUFBQTRBQUFBQkFBQUFCUUFBQUFBQUFBQUNBQUFBRWdBQUFCQUFBQUFRQUFBQUFRQUFBQVFBQUFBQUFBQUFBZ0FBQUJJQUFBQVFBQUFBRVFBQUFBSUFBQUFGQUFBQUFnQUFBQU1BQUFBU0FBQUFFZ0FBQUJJQUFBQURBQUFBQlFBQUFBSUFBQUFEQUFBQUVnQUFBQklBQUFBVEFBQUFBd0FBQUFVQUFBQUVBQUFBQkFBQUFCSUFBQUFTQUFBQUV3QUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQVNBQUFBRWdBQUFCTUFBQUFFQUFBQUJBQUFBQWdBQUFBRkFBQUFFZ0FBQUJJQUFBQVRBQUFBQlFBQUFBUUFBQUFJQUFBQUJRQUFBQklBQUFBU0FBQUFFd0FBQUFZQUFBQUVBQUFBQ0FBQUFBVUFBQUFTQUFBQUVnQUFBQk1BQUFBRkFBQUFCQUFBQUF3QUFBQUdBQUFBRWdBQUFCTUFBQUFUQUFBQUJ3QUFBQVFBQUFBTUFBQUFCZ0FBQUJJQUFBQVNBQUFBRXdBQUFBUUFBQUFFQUFBQUVBQUFBQWNBQUFBU0FBQUFFZ0FBQUJNQUFBQUVBQUFBQXdBQUFDQUFBQUFIQUFBQUVnQUFBQklBQUFBVEFBQUFCZ0FBQUFNQUFBQ0FBQUFBQndBQUFCSUFBQUFUQUFBQUV3QUFBQVlBQUFBREFBQUFnQUFBQUFnQUFBQVNBQUFBRXdBQUFCTUFBQUFJQUFBQUF3QUFBQUFCQUFBSUFBQUFFZ0FBQUJNQUFBQVRBQUFBQmdBQUFBTUFBQUNBQUFBQUNRQUFBQklBQUFBVEFBQUFFd0FBQUFnQUFBQURBQUFBQUFFQUFBa0FBQUFTQUFBQUV3QUFBQk1BQUFBS0FBQUFBd0FBQUFBQ0FBQUpBQUFBRWdBQUFCTUFBQUFUQUFBQURBQUFBQU1BQUFBQUFnQUFDUUFBQUJJQUFBQVRBQUFBRXdBQUFBMEFBQUFEQUFBQTV3TUFBQWtBQUFBUkFBQUFEQUFBQUF3QUFBQUJBQUFBQlFBQUFBRUFBQUFCQUFBQUVRQUFBQXdBQUFBTkFBQUFBUUFBQUFZQUFBQUFBQUFBQVFBQUFCRUFBQUFOQUFBQUR3QUFBQUVBQUFBRkFBQUFBQUFBQUFFQUFBQVJBQUFBRHdBQUFCQUFBQUFDQUFBQUJRQUFBQUFBQUFBQ0FBQUFFUUFBQUJFQUFBQVJBQUFBQWdBQUFBUUFBQUFBQUFBQUFnQUFBQkVBQUFBUUFBQUFFUUFBQUFNQUFBQUVBQUFBQWdBQUFBTUFBQUFSQUFBQUVRQUFBQkVBQUFBREFBQUFCQUFBQUFRQUFBQUVBQUFBRVFBQUFCRUFBQUFSQUFBQUF3QUFBQVFBQUFBSUFBQUFCUUFBQUJFQUFBQVJBQUFBRVFBQUFBUUFBQUFFQUFBQUNBQUFBQVVBQUFBUkFBQUFFUUFBQUJFQUFBQUZBQUFBQkFBQUFBZ0FBQUFGQUFBQUVRQUFBQkVBQUFBUkFBQUFCZ0FBQUFRQUFBQUlBQUFBQlFBQUFCRUFBQUFSQUFBQUVRQUFBQVVBQUFBRUFBQUFDQUFBQUFZQUFBQVJBQUFBRWdBQUFCRUFBQUFIQUFBQUJBQUFBQXdBQUFBR0FBQUFFUUFBQUJJQUFBQVJBQUFBQXdBQUFBUUFBQUFNQUFBQUJ3QUFBQkVBQUFBU0FBQUFFUUFBQUFRQUFBQURBQUFBSUFBQUFBY0FBQUFSQUFBQUVnQUFBQkVBQUFBR0FBQUFBd0FBQUFBQkFBQUhBQUFBRVFBQUFCSUFBQUFSQUFBQUJnQUFBQU1BQUFDQUFBQUFDQUFBQUJFQUFBQVNBQUFBRVFBQUFBZ0FBQUFEQUFBQUFBRUFBQWdBQUFBUkFBQUFFZ0FBQUJFQUFBQUtBQUFBQXdBQUFBQUNBQUFJQUFBQUVRQUFBQklBQUFBUkFBQUFCUUFBQUFNQUFBQUFBUUFBQ1FBQUFCRUFBQUFTQUFBQUVRQUFBQWNBQUFBREFBQUFBQUlBQUFrQUFBQVJBQUFBRWdBQUFCRUFBQUFKQUFBQUF3QUFBQUFDQUFBSkFBQUFFUUFBQUJJQUFBQVJBQUFBQ3dBQUFBTUFBQURuQXdBQUNRQUFBQTRBQUFBTUFBQUFEUUFBQUFFQUFBQUZBQUFBQVFBQUFBRUFBQUFPQUFBQURnQUFBQThBQUFBQkFBQUFCUUFBQUFBQUFBQUJBQUFBRGdBQUFBNEFBQUFQQUFBQUFRQUFBQVFBQUFBQUFBQUFBUUFBQUE0QUFBQU9BQUFBRHdBQUFBSUFBQUFFQUFBQUFBQUFBQUlBQUFBT0FBQUFEZ0FBQUE0QUFBQUVBQUFBQkFBQUFBSUFBQUFEQUFBQURnQUFBQTRBQUFBT0FBQUFBd0FBQUFRQUFBQUVBQUFBQkFBQUFBNEFBQUFPQUFBQURnQUFBQVFBQUFBRUFBQUFDQUFBQUFVQUFBQU9BQUFBRGdBQUFBNEFBQUFHQUFBQUJBQUFBQWdBQUFBRkFBQUFEZ0FBQUE0QUFBQU9BQUFBQ0FBQUFBUUFBQUFJQUFBQUJRQUFBQTRBQUFBUEFBQUFEZ0FBQUFVQUFBQUVBQUFBQ0FBQUFBWUFBQUFPQUFBQUR3QUFBQTRBQUFBSkFBQUFCQUFBQUFnQUFBQUdBQUFBRGdBQUFBOEFBQUFPQUFBQUF3QUFBQVFBQUFBTUFBQUFCd0FBQUE0QUFBQVBBQUFBRGdBQUFBUUFBQUFEQUFBQUdBQUFBQWNBQUFBT0FBQUFEd0FBQUE0QUFBQUZBQUFBQXdBQUFDQUFBQUFJQUFBQURnQUFBQThBQUFBUEFBQUFCZ0FBQUFNQUFBQkFBQUFBQ0FBQUFBNEFBQUFQQUFBQUR3QUFBQWNBQUFBREFBQUFBQUVBQUFnQUFBQU9BQUFBRHdBQUFBOEFBQUFGQUFBQUF3QUFBREFBQUFBSkFBQUFEZ0FBQUE4QUFBQVBBQUFBQmdBQUFBTUFBQUNBQUFBQUNRQUFBQTRBQUFBUEFBQUFEd0FBQUFjQUFBQURBQUFBQUFFQUFBa0FBQUFPQUFBQUR3QUFBQThBQUFBSUFBQUFBd0FBQUFBQkFBQUpBQUFBRGdBQUFBOEFBQUFQQUFBQUNBQUFBQU1BQUFBQUFnQUFDUUFBQUE0QUFBQVBBQUFBRHdBQUFBa0FBQUFEQUFBQUFBSUFBQWtBQUFBT0FBQUFEd0FBQUE4QUFBQUtBQUFBQXdBQUFPY0RBQUFKQUFBQUlBQUFBQ0FBQUFBaEFBQUFJZ0FBQUNNQUFBQWtBQUFBSlFBQUFDWUFBQUFuQUFBQUtBQUFBQ2tBQUFBcEFBQUFLZ0FBQUNzQUFBQXNBQUFBTFFBQUFDNEFBQUF2QUFBQU1BQUFBREFBQUFBeEFBQUFNUUFBQURJQUFBQXpBQUFBTkFBQUFEVUFBQUEyQUFBQU53QUFBRGdBQUFBNEFFR1FtZ0VMK2dFRUFBTUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFFQUFRQUJBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQU1BQWdBQkFBRUFBUUFCQUFFQS8vLy8vLy8vLy84QUFBQUFBQUFBQUFFQUFRQUJBQUVBQVFBQkFBSUFBZ0FDQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFQLy8vLy8vLy8vLy8vOEFBQUFBQUFBQkFBUUFBd0FDQUFJQUFnQUNBQUlBQWdBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFQLy8vLy8vLy8vLy8vLy8vLy8vQUVHVm5BRUwrQWNJQUFBQUJ3QUFhZ1lBQUFBR0FBQ3RCUUFBYWdVQUFERUZBQUFBQlFBQTFBUUFBSzBFQUFDS0JBQUFhZ1FBQUV3RUFBQXhCQUFBRndRQUFBQUVBQURwQXdBQTFBTUFBTUFEQUFDdEF3QUFtd01BQUlvREFBQjVBd0FBYWdNQUFGc0RBQUJNQXdBQVBnTUFBREVEQUFBa0F3QUFGd01BQUFzREFBQUFBd0FBOUFJQUFPa0NBQURlQWdBQTFBSUFBTW9DQUFEQUFnQUF0Z0lBQUswQ0FBQ2tBZ0FBbXdJQUFKSUNBQUNLQWdBQWdnSUFBSGtDQUFCeUFnQUFhZ0lBQUdJQ0FBQmJBZ0FBVXdJQUFFd0NBQUJGQWdBQVBnSUFBRGNDQUFBeEFnQUFLZ0lBQUNRQ0FBQWVBZ0FBRndJQUFCRUNBQUFMQWdBQUJRSUFBQUFDQUFENkFRQUE5QUVBQU84QkFBRHBBUUFBNUFFQUFONEJBQURaQVFBQTFBRUFBTThCQUFES0FRQUF4UUVBQU1BQkFBQzdBUUFBdGdFQUFMSUJBQUN0QVFBQXFBRUFBS1FCQUFDZkFRQUFtd0VBQUpjQkFBQ1NBUUFBamdFQUFJb0JBQUNHQVFBQWdnRUFBSDRCQUFCNUFRQUFkUUVBQUhJQkFBQnVBUUFBYWdFQUFHWUJBQUJpQVFBQVhnRUFBRnNCQUFCWEFRQUFVd0VBQUZBQkFBQk1BUUFBU1FFQUFFVUJBQUJDQVFBQVBnRUFBRHNCQUFBM0FRQUFOQUVBQURFQkFBQXVBUUFBS2dFQUFDY0JBQUFrQVFBQUlRRUFBQjRCQUFBYUFRQUFGd0VBQUJRQkFBQVJBUUFBRGdFQUFBc0JBQUFJQVFBQUJRRUFBQUlCQUFBQUFRQUEvUUFBQVBvQUFBRDNBQUFBOUFBQUFQRUFBQUR2QUFBQTdBQUFBT2tBQUFEbUFBQUE1QUFBQU9FQUFBRGVBQUFBM0FBQUFOa0FBQURYQUFBQTFBQUFBTkVBQUFEUEFBQUF6QUFBQU1vQUFBREhBQUFBeFFBQUFNSUFBQURBQUFBQXZnQUFBTHNBQUFDNUFBQUF0Z0FBQUxRQUFBQ3lBQUFBcndBQUFLMEFBQUNyQUFBQXFBQUFBS1lBQUFDa0FBQUFvZ0FBQUo4QUFBQ2RBQUFBbXdBQUFKa0FBQUNYQUFBQWxRQUFBSklBQUFDUUFBQUFqZ0FBQUl3QUFBQ0tBQUFBaUFBQUFJWUFBQUNFQUFBQWdnQUFBSUFBQUFCK0FBQUFld0FBQUhrQUFBQjNBQUFBZFFBQUFITUFBQUJ5QUFBQWNBQUFBRzRBQUFCc0FBQUFhZ0FBQUdnQUFBQm1BQUFBWkFBQUFHSUFBQUJnQUFBQVhnQUFBRjBBQUFCYkFBQUFXUUFBQUZjQUFBQlZBQUFBVXdBQUFGSUFBQUJRQUFBQVRnQUFBRXdBQUFCS0FBQUFTUUFBQUVjQUFBQkZBQUFBUXdBQUFFSUFBQUJBQUFBQVBnQUFBRDBBQUFBN0FBQUFPUUFBQURjQUFBQTJBQUFBTkFBQUFESUFBQUF4QUFBQUx3QUFBQzRBQUFBc0FBQUFLZ0FBQUNrQUFBQW5BQUFBSlFBQUFDUUFBQUFpQUFBQUlRQUFBQjhBQUFBZUFBQUFIQUFBQUJvQUFBQVpBQUFBRndBQUFCWUFBQUFVQUFBQUV3QUFBQkVBQUFBUUFBQUFEZ0FBQUEwQUFBQUxBQUFBQ2dBQUFBZ0FBQUFIQUFBQUJRQUFBQVFBQUFBQ0FBQUFBUUJCa0tVQkMxRUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFnQUFBQUlBQUFBREFBQUFBd0FBQUFRQUFBQUVBQUFBQlFBQUFBY0FBQUFJQUFBQUNRQUFBQW9BQUFBTEFBQUFEQUFBQUEwQUFBQU9BQUFBRHdBQUFCQUFRZkdsQVF1L0FRRUNBd1FGQmdjSUNRb0xEQTBPRHhBUUVSRVNFaE1URkJRVUZCVVZGUlVXRmhZV0ZoWVdGaGNYRnhjWEZ4Y1hHQmdZR0JnWUdCZ1lHQmdZR0JnWUdBQUJBZ01FQlFZSENBa0tDd3dORGc4UUVSSVRGQlVXRnhnWkdoc2NIUjRmSUNBaElTSWlJeU1rSkNRa0pTVWxKU1ltSmlZbUppWW1KeWNuSnljbkp5Y29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tTa3BLU2twS1NrcEtTa3BLU2twS1NvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FBRUh3cHdFTFRRRUFBQUFCQUFBQUFRQUFBQUVBQUFBQ0FBQUFBZ0FBQUFNQUFBQURBQUFBQkFBQUFBWUFBQUFIQUFBQUNBQUFBQWtBQUFBS0FBQUFDd0FBQUF3QUFBQU5BQUFBRGdBQUFBOEFBQUFRQUVISXFBRUxEUUVBQUFBQkFBQUFBZ0FBQUFJQVFlQ29BUXZUQmdFQUFBQUJBQUFBQWdBQUFBSUFBQUFtQUFBQWdnQUFBQ0VGQUFCS0FBQUFad2dBQUNZQUFBREFBUUFBZ0FBQUFFa0ZBQUJLQUFBQXZnZ0FBQ2tBQUFBc0FnQUFnQUFBQUVrRkFBQktBQUFBdmdnQUFDOEFBQURLQWdBQWdBQUFBSW9GQUFCS0FBQUFoQWtBQURVQUFBQnpBd0FBZ0FBQUFKMEZBQUJLQUFBQW9Ba0FBRDBBQUFDQkF3QUFnQUFBQU9zRkFBQkxBQUFBUGdvQUFFUUFBQUNlQXdBQWdBQUFBRTBHQUFCTEFBQUFxZ29BQUVzQUFBQ3pBd0FBZ0FBQUFNRUdBQUJOQUFBQUh3MEFBRTBBQUFCVEJBQUFnQUFBQUNNSUFBQlJBQUFBcGc4QUFGUUFBQUNaQkFBQWdBQUFBRXNKQUFCWEFBQUFzUklBQUZnQUFBRGFCQUFBZ0FBQUFHOEpBQUJkQUFBQUl4UUFBRlFBQUFCRkJRQUFnQUFBQUZRS0FBQnFBQUFBakJRQUFHb0FBQUN2QlFBQWdBQUFBSFlKQUFCOEFBQUFUaEFBQUh3QUFBRFNBZ0FBZ0FBQUFHTUhBQUNSQUFBQWtBY0FBSklBQUFBQUFBQUFBUUFBQUFJQUFBQUVBQUFBQUFBQUFBSUFBQUFFQUFBQUNBQUFBQUFBQUFBQkFBQUFBUUFBQUFVQUFBQU5BQUFBSFFBQUFEMEFBQUI5QUFBQS9RQUFBUDBCQUFEOUF3QUEvUWNBQVAwUEFBRDlId0FBL1Q4QUFQMS9BQUQ5L3dBQS9mOEJBUDMvQXdEOS93Y0EvZjhQQVAzL0h3RDkvejhBL2Y5L0FQMy8vd0Q5Ly84Qi9mLy9BLzMvL3dmOS8vOFAvZi8vSC8zLy96LzkvLzkvQUFBQUFBRUFBQUFDQUFBQUF3QUFBQVFBQUFBRkFBQUFCZ0FBQUFjQUFBQUlBQUFBQ1FBQUFBb0FBQUFMQUFBQURBQUFBQTBBQUFBT0FBQUFEd0FBQUJBQUFBQVJBQUFBRWdBQUFCTUFBQUFVQUFBQUZRQUFBQllBQUFBWEFBQUFHQUFBQUJrQUFBQWFBQUFBR3dBQUFCd0FBQUFkQUFBQUhnQUFBQjhBQUFBREFBQUFCQUFBQUFVQUFBQUdBQUFBQndBQUFBZ0FBQUFKQUFBQUNnQUFBQXNBQUFBTUFBQUFEUUFBQUE0QUFBQVBBQUFBRUFBQUFCRUFBQUFTQUFBQUV3QUFBQlFBQUFBVkFBQUFGZ0FBQUJjQUFBQVlBQUFBR1FBQUFCb0FBQUFiQUFBQUhBQUFBQjBBQUFBZUFBQUFId0FBQUNBQUFBQWhBQUFBSWdBQUFDTUFBQUFsQUFBQUp3QUFBQ2tBQUFBckFBQUFMd0FBQURNQUFBQTdBQUFBUXdBQUFGTUFBQUJqQUFBQWd3QUFBQU1CQUFBREFnQUFBd1FBQUFNSUFBQURFQUFBQXlBQUFBTkFBQUFEZ0FBQUF3QUJBRUhFcndFTGxRRUJBQUFBQWdBQUFBTUFBQUFFQUFBQUJRQUFBQVlBQUFBSEFBQUFDQUFBQUFrQUFBQUtBQUFBQ3dBQUFBd0FBQUFOQUFBQURnQUFBQThBQUFBUUFBQUFFZ0FBQUJRQUFBQVdBQUFBR0FBQUFCd0FBQUFnQUFBQUtBQUFBREFBQUFCQUFBQUFnQUFBQUFBQkFBQUFBZ0FBQUFRQUFBQUlBQUFBRUFBQUFDQUFBQUJBQUFBQWdBQUFBQUFCQUFFQUFBQUVBQUFBQ0FCQjVMQUJDNHNCQVFBQUFBSUFBQUFEQUFBQUJBQUFBQVVBQUFBR0FBQUFCd0FBQUFnQUFBQUpBQUFBQ2dBQUFBc0FBQUFNQUFBQURRQUFBQTRBQUFBUEFBQUFFQUFBQUJJQUFBQVVBQUFBRmdBQUFCZ0FBQUFjQUFBQUlBQUFBQ2dBQUFBd0FBQUFRQUFBQUlBQUFBQUFBUUFBQUFJQUFBQUVBQUFBQ0FBQUFCQUFBQUFnQUFBQVFBQUFBSUFBQUFBQUFRQkJzTElCQzlZRUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFJQUFBQUNBQUFBQXdBQUFBTUFBQUFFQUFBQUJnQUFBQWNBQUFBSUFBQUFDUUFBQUFvQUFBQUxBQUFBREFBQUFBMEFBQUFPQUFBQUR3QUFBQkFBQUFBQkFBRUJCZ0FBQUFBQUFBUUFBQUFBRUFBQUJBQUFBQUFnQUFBRkFRQUFBQUFBQUFVREFBQUFBQUFBQlFRQUFBQUFBQUFGQmdBQUFBQUFBQVVIQUFBQUFBQUFCUWtBQUFBQUFBQUZDZ0FBQUFBQUFBVU1BQUFBQUFBQUJnNEFBQUFBQUFFRkVBQUFBQUFBQVFVVUFBQUFBQUFCQlJZQUFBQUFBQUlGSEFBQUFBQUFBd1VnQUFBQUFBQUVCVEFBQUFBZ0FBWUZRQUFBQUFBQUJ3V0FBQUFBQUFBSUJnQUJBQUFBQUFvR0FBUUFBQUFBREFZQUVBQUFJQUFBQkFBQUFBQUFBQUFFQVFBQUFBQUFBQVVDQUFBQUlBQUFCUVFBQUFBQUFBQUZCUUFBQUNBQUFBVUhBQUFBQUFBQUJRZ0FBQUFnQUFBRkNnQUFBQUFBQUFVTEFBQUFBQUFBQmcwQUFBQWdBQUVGRUFBQUFBQUFBUVVTQUFBQUlBQUJCUllBQUFBQUFBSUZHQUFBQUNBQUF3VWdBQUFBQUFBREJTZ0FBQUFBQUFZRVFBQUFBQkFBQmdSQUFBQUFJQUFIQllBQUFBQUFBQWtHQUFJQUFBQUFDd1lBQ0FBQU1BQUFCQUFBQUFBUUFBQUVBUUFBQUNBQUFBVUNBQUFBSUFBQUJRTUFBQUFnQUFBRkJRQUFBQ0FBQUFVR0FBQUFJQUFBQlFnQUFBQWdBQUFGQ1FBQUFDQUFBQVVMQUFBQUlBQUFCUXdBQUFBQUFBQUdEd0FBQUNBQUFRVVNBQUFBSUFBQkJSUUFBQUFnQUFJRkdBQUFBQ0FBQWdVY0FBQUFJQUFEQlNnQUFBQWdBQVFGTUFBQUFBQUFFQVlBQUFFQUFBQVBCZ0NBQUFBQUFBNEdBRUFBQUFBQURRWUFJQUJCbExjQkM0TUVBUUFBQUFFQUFBQUZBQUFBRFFBQUFCMEFBQUE5QUFBQWZRQUFBUDBBQUFEOUFRQUEvUU1BQVAwSEFBRDlEd0FBL1I4QUFQMC9BQUQ5ZndBQS9mOEFBUDMvQVFEOS93TUEvZjhIQVAzL0R3RDkveDhBL2Y4L0FQMy9md0Q5Ly84QS9mLy9BZjMvL3dQOS8vOEgvZi8vRC8zLy94LzkvLzgvL2YvL2Z3QUFBQUFCQUFBQUFnQUFBQU1BQUFBRUFBQUFCUUFBQUFZQUFBQUhBQUFBQ0FBQUFBa0FBQUFLQUFBQUN3QUFBQXdBQUFBTkFBQUFEZ0FBQUE4QUFBQVFBQUFBRVFBQUFCSUFBQUFUQUFBQUZBQUFBQlVBQUFBV0FBQUFGd0FBQUJnQUFBQVpBQUFBR2dBQUFCc0FBQUFjQUFBQUhRQUFBQjRBQUFBZkFBQUFBUUFCQVFVQUFBQUFBQUFGQUFBQUFBQUFCZ1E5QUFBQUFBQUpCZjBCQUFBQUFBOEYvWDhBQUFBQUZRWDkveDhBQUFBREJRVUFBQUFBQUFjRWZRQUFBQUFBREFYOUR3QUFBQUFTQmYzL0F3QUFBQmNGL2Y5L0FBQUFCUVVkQUFBQUFBQUlCUDBBQUFBQUFBNEYvVDhBQUFBQUZBWDkvdzhBQUFBQ0JRRUFBQUFRQUFjRWZRQUFBQUFBQ3dYOUJ3QUFBQUFSQmYzL0FRQUFBQllGL2Y4L0FBQUFCQVVOQUFBQUVBQUlCUDBBQUFBQUFBMEYvUjhBQUFBQUV3WDkvd2NBQUFBQkJRRUFBQUFRQUFZRVBRQUFBQUFBQ2dYOUF3QUFBQUFRQmYzL0FBQUFBQndGL2YvL0R3QUFHd1g5Ly84SEFBQWFCZjMvL3dNQUFCa0YvZi8vQVFBQUdBWDkvLzhBUWFDN0FRdlRBUU1BQUFBRUFBQUFCUUFBQUFZQUFBQUhBQUFBQ0FBQUFBa0FBQUFLQUFBQUN3QUFBQXdBQUFBTkFBQUFEZ0FBQUE4QUFBQVFBQUFBRVFBQUFCSUFBQUFUQUFBQUZBQUFBQlVBQUFBV0FBQUFGd0FBQUJnQUFBQVpBQUFBR2dBQUFCc0FBQUFjQUFBQUhRQUFBQjRBQUFBZkFBQUFJQUFBQUNFQUFBQWlBQUFBSXdBQUFDVUFBQUFuQUFBQUtRQUFBQ3NBQUFBdkFBQUFNd0FBQURzQUFBQkRBQUFBVXdBQUFHTUFBQUNEQUFBQUF3RUFBQU1DQUFBREJBQUFBd2dBQUFNUUFBQURJQUFBQTBBQUFBT0FBQUFEQUFFQVFZQytBUXRSQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUlBQUFBQ0FBQUFBd0FBQUFNQUFBQUVBQUFBQkFBQUFBVUFBQUFIQUFBQUNBQUFBQWtBQUFBS0FBQUFDd0FBQUF3QUFBQU5BQUFBRGdBQUFBOEFBQUFRQUVIZ3ZnRUxoZ1FCQUFFQkJnQUFBQUFBQUFZREFBQUFBQUFBQkFRQUFBQWdBQUFGQlFBQUFBQUFBQVVHQUFBQUFBQUFCUWdBQUFBQUFBQUZDUUFBQUFBQUFBVUxBQUFBQUFBQUJnMEFBQUFBQUFBR0VBQUFBQUFBQUFZVEFBQUFBQUFBQmhZQUFBQUFBQUFHR1FBQUFBQUFBQVljQUFBQUFBQUFCaDhBQUFBQUFBQUdJZ0FBQUFBQUFRWWxBQUFBQUFBQkJpa0FBQUFBQUFJR0x3QUFBQUFBQXdZN0FBQUFBQUFFQmxNQUFBQUFBQWNHZ3dBQUFBQUFDUVlEQWdBQUVBQUFCQVFBQUFBQUFBQUVCUUFBQUNBQUFBVUdBQUFBQUFBQUJRY0FBQUFnQUFBRkNRQUFBQUFBQUFVS0FBQUFBQUFBQmd3QUFBQUFBQUFHRHdBQUFBQUFBQVlTQUFBQUFBQUFCaFVBQUFBQUFBQUdHQUFBQUFBQUFBWWJBQUFBQUFBQUJoNEFBQUFBQUFBR0lRQUFBQUFBQVFZakFBQUFBQUFCQmljQUFBQUFBQUlHS3dBQUFBQUFBd1l6QUFBQUFBQUVCa01BQUFBQUFBVUdZd0FBQUFBQUNBWURBUUFBSUFBQUJBUUFBQUF3QUFBRUJBQUFBQkFBQUFRRkFBQUFJQUFBQlFjQUFBQWdBQUFGQ0FBQUFDQUFBQVVLQUFBQUlBQUFCUXNBQUFBQUFBQUdEZ0FBQUFBQUFBWVJBQUFBQUFBQUJoUUFBQUFBQUFBR0Z3QUFBQUFBQUFZYUFBQUFBQUFBQmgwQUFBQUFBQUFHSUFBQUFBQUFFQVlEQUFFQUFBQVBCZ09BQUFBQUFBNEdBMEFBQUFBQURRWURJQUFBQUFBTUJnTVFBQUFBQUFzR0F3Z0FBQUFBQ2dZREJBQkI4TUlCQzVFT0NBQUFBQWdBQUFBSUFBQUFCd0FBQUFnQUFBQUpBQUFBQ2dBQUFBc0FBQUFBQUFBQUFRQUFBQUlBQUFBQkFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBQUFBQUFCQUFBQUF3QUFBQWNBQUFBUEFBQUFId0FBQUQ4QUFBQi9BQUFBL3dBQUFQOEJBQUQvQXdBQS93Y0FBUDhQQUFEL0h3QUEvejhBQVA5L0FBRC8vd0FBLy84QkFQLy9Bd0QvL3djQS8vOFBBUC8vSHdELy96OEEvLzkvQVAvLy93RC8vLzhCLy8vL0EvLy8vd2YvLy84UC8vLy9ILy8vL3ovLy8vOS9kbTlwWkFCaWIyOXNBR05vWVhJQWMybG5ibVZrSUdOb1lYSUFkVzV6YVdkdVpXUWdZMmhoY2dCemFHOXlkQUIxYm5OcFoyNWxaQ0J6YUc5eWRBQnBiblFBZFc1emFXZHVaV1FnYVc1MEFHeHZibWNBZFc1emFXZHVaV1FnYkc5dVp3Qm1iRzloZEFCa2IzVmliR1VBYzNSa09qcHpkSEpwYm1jQWMzUmtPanBpWVhOcFkxOXpkSEpwYm1jOGRXNXphV2R1WldRZ1kyaGhjajRBYzNSa09qcDNjM1J5YVc1bkFITjBaRG82ZFRFMmMzUnlhVzVuQUhOMFpEbzZkVE15YzNSeWFXNW5BR1Z0YzJOeWFYQjBaVzQ2T25aaGJBQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4amFHRnlQZ0JsYlhOamNtbHdkR1Z1T2pwdFpXMXZjbmxmZG1sbGR6eHphV2R1WldRZ1kyaGhjajRBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhkVzV6YVdkdVpXUWdZMmhoY2o0QVpXMXpZM0pwY0hSbGJqbzZiV1Z0YjNKNVgzWnBaWGM4YzJodmNuUStBR1Z0YzJOeWFYQjBaVzQ2T20xbGJXOXllVjkyYVdWM1BIVnVjMmxuYm1Wa0lITm9iM0owUGdCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkenhwYm5RK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEhWdWMybG5ibVZrSUdsdWRENEFaVzF6WTNKcGNIUmxiam82YldWdGIzSjVYM1pwWlhjOGJHOXVaejRBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhkVzV6YVdkdVpXUWdiRzl1Wno0QVpXMXpZM0pwY0hSbGJqbzZiV1Z0YjNKNVgzWnBaWGM4YVc1ME9GOTBQZ0JsYlhOamNtbHdkR1Z1T2pwdFpXMXZjbmxmZG1sbGR6eDFhVzUwT0Y5MFBnQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4cGJuUXhObDkwUGdCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkengxYVc1ME1UWmZkRDRBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhhVzUwTXpKZmRENEFaVzF6WTNKcGNIUmxiam82YldWdGIzSjVYM1pwWlhjOGRXbHVkRE15WDNRK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEdac2IyRjBQZ0JsYlhOamNtbHdkR1Z1T2pwdFpXMXZjbmxmZG1sbGR6eGtiM1ZpYkdVK0FBQUFHSFFBQUZCbEFBQk9NVEJsYlhOamNtbHdkR1Z1TVRGdFpXMXZjbmxmZG1sbGQwbGtSVVVBQUJoMEFBQjRaUUFBVGpFd1pXMXpZM0pwY0hSbGJqRXhiV1Z0YjNKNVgzWnBaWGRKWmtWRkFBQVlkQUFBb0dVQUFFNHhNR1Z0YzJOeWFYQjBaVzR4TVcxbGJXOXllVjkyYVdWM1NXMUZSUUFBR0hRQUFNaGxBQUJPTVRCbGJYTmpjbWx3ZEdWdU1URnRaVzF2Y25sZmRtbGxkMGxzUlVVQUFCaDBBQUR3WlFBQVRqRXdaVzF6WTNKcGNIUmxiakV4YldWdGIzSjVYM1pwWlhkSmFrVkZBQUFZZEFBQUdHWUFBRTR4TUdWdGMyTnlhWEIwWlc0eE1XMWxiVzl5ZVY5MmFXVjNTV2xGUlFBQUdIUUFBRUJtQUFCT01UQmxiWE5qY21sd2RHVnVNVEZ0WlcxdmNubGZkbWxsZDBsMFJVVUFBQmgwQUFCb1pnQUFUakV3WlcxelkzSnBjSFJsYmpFeGJXVnRiM0o1WDNacFpYZEpjMFZGQUFBWWRBQUFrR1lBQUU0eE1HVnRjMk55YVhCMFpXNHhNVzFsYlc5eWVWOTJhV1YzU1dGRlJRQUFHSFFBQUxobUFBQk9NVEJsYlhOamNtbHdkR1Z1TVRGdFpXMXZjbmxmZG1sbGQwbGpSVVVBQUVCMEFBRHdaZ0FBQUFBQUFBRUFBQUNJQndBQUFBQUFBRTVUZEROZlh6SXhNbUpoYzJsalgzTjBjbWx1WjBsRWFVNVRYekV4WTJoaGNsOTBjbUZwZEhOSlJHbEZSVTVUWHpsaGJHeHZZMkYwYjNKSlJHbEZSVVZGQUFBQVFIUUFBRXhuQUFBQUFBQUFBUUFBQUlnSEFBQUFBQUFBVGxOME0xOWZNakV5WW1GemFXTmZjM1J5YVc1blNVUnpUbE5mTVRGamFHRnlYM1J5WVdsMGMwbEVjMFZGVGxOZk9XRnNiRzlqWVhSdmNrbEVjMFZGUlVVQUFBQkFkQUFBcUdjQUFBQUFBQUFCQUFBQWlBY0FBQUFBQUFCT1UzUXpYMTh5TVRKaVlYTnBZMTl6ZEhKcGJtZEpkMDVUWHpFeFkyaGhjbDkwY21GcGRITkpkMFZGVGxOZk9XRnNiRzlqWVhSdmNrbDNSVVZGUlFBQVFIUUFBQUJvQUFBQUFBQUFBUUFBQUlnSEFBQUFBQUFBVGxOME0xOWZNakV5WW1GemFXTmZjM1J5YVc1blNXaE9VMTh4TVdOb1lYSmZkSEpoYVhSelNXaEZSVTVUWHpsaGJHeHZZMkYwYjNKSmFFVkZSVVVBQUJFQUNnQVJFUkVBQUFBQUJRQUFBQUFBQUFrQUFBQUFDd0FBQUFBQUFBQUFFUUFQQ2hFUkVRTUtCd0FCQUFrTEN3QUFDUVlMQUFBTEFBWVJBQUFBRVJFUkFFR1IwUUVMSVFzQUFBQUFBQUFBQUJFQUNnb1JFUkVBQ2dBQUFnQUpDd0FBQUFrQUN3QUFDd0JCeTlFQkN3RU1BRUhYMFFFTEZRd0FBQUFBREFBQUFBQUpEQUFBQUFBQURBQUFEQUJCaGRJQkN3RU9BRUdSMGdFTEZRMEFBQUFFRFFBQUFBQUpEZ0FBQUFBQURnQUFEZ0JCdjlJQkN3RVFBRUhMMGdFTEhnOEFBQUFBRHdBQUFBQUpFQUFBQUFBQUVBQUFFQUFBRWdBQUFCSVNFZ0JCZ3RNQkN3NFNBQUFBRWhJU0FBQUFBQUFBQ1FCQnM5TUJDd0VMQUVHLzB3RUxGUW9BQUFBQUNnQUFBQUFKQ3dBQUFBQUFDd0FBQ3dCQjdkTUJDd0VNQUVINTB3RUxKd3dBQUFBQURBQUFBQUFKREFBQUFBQUFEQUFBREFBQUxTc2dJQ0F3V0RCNEFDaHVkV3hzS1FCQnNOUUJDMmN3TVRJek5EVTJOemc1UVVKRFJFVkdHUkpFT3dJL0xFY1VQVE13Q2hzR1JrdEZOdzlKRG80WEEwQWRQR2tyTmg5S0xSd0JJQ1VwSVFnTUZSWWlMaEE0UGdzME1SaGtkSFYyTDBFSmZ6a1JJME15UW9tS2l3VUVKaWduRFNvZU5Zd0hHa2lURTVTVkFFR2cxUUVMOWhOSmJHeGxaMkZzSUdKNWRHVWdjMlZ4ZFdWdVkyVUFSRzl0WVdsdUlHVnljbTl5QUZKbGMzVnNkQ0J1YjNRZ2NtVndjbVZ6Wlc1MFlXSnNaUUJPYjNRZ1lTQjBkSGtBVUdWeWJXbHpjMmx2YmlCa1pXNXBaV1FBVDNCbGNtRjBhVzl1SUc1dmRDQndaWEp0YVhSMFpXUUFUbThnYzNWamFDQm1hV3hsSUc5eUlHUnBjbVZqZEc5eWVRQk9ieUJ6ZFdOb0lIQnliMk5sYzNNQVJtbHNaU0JsZUdsemRITUFWbUZzZFdVZ2RHOXZJR3hoY21kbElHWnZjaUJrWVhSaElIUjVjR1VBVG04Z2MzQmhZMlVnYkdWbWRDQnZiaUJrWlhacFkyVUFUM1YwSUc5bUlHMWxiVzl5ZVFCU1pYTnZkWEpqWlNCaWRYTjVBRWx1ZEdWeWNuVndkR1ZrSUhONWMzUmxiU0JqWVd4c0FGSmxjMjkxY21ObElIUmxiWEJ2Y21GeWFXeDVJSFZ1WVhaaGFXeGhZbXhsQUVsdWRtRnNhV1FnYzJWbGF3QkRjbTl6Y3kxa1pYWnBZMlVnYkdsdWF3QlNaV0ZrTFc5dWJIa2dabWxzWlNCemVYTjBaVzBBUkdseVpXTjBiM0o1SUc1dmRDQmxiWEIwZVFCRGIyNXVaV04wYVc5dUlISmxjMlYwSUdKNUlIQmxaWElBVDNCbGNtRjBhVzl1SUhScGJXVmtJRzkxZEFCRGIyNXVaV04wYVc5dUlISmxablZ6WldRQVNHOXpkQ0JwY3lCa2IzZHVBRWh2YzNRZ2FYTWdkVzV5WldGamFHRmliR1VBUVdSa2NtVnpjeUJwYmlCMWMyVUFRbkp2YTJWdUlIQnBjR1VBU1M5UElHVnljbTl5QUU1dklITjFZMmdnWkdWMmFXTmxJRzl5SUdGa1pISmxjM01BUW14dlkyc2daR1YyYVdObElISmxjWFZwY21Wa0FFNXZJSE4xWTJnZ1pHVjJhV05sQUU1dmRDQmhJR1JwY21WamRHOXllUUJKY3lCaElHUnBjbVZqZEc5eWVRQlVaWGgwSUdacGJHVWdZblZ6ZVFCRmVHVmpJR1p2Y20xaGRDQmxjbkp2Y2dCSmJuWmhiR2xrSUdGeVozVnRaVzUwQUVGeVozVnRaVzUwSUd4cGMzUWdkRzl2SUd4dmJtY0FVM2x0WW05c2FXTWdiR2x1YXlCc2IyOXdBRVpwYkdWdVlXMWxJSFJ2YnlCc2IyNW5BRlJ2YnlCdFlXNTVJRzl3Wlc0Z1ptbHNaWE1nYVc0Z2MzbHpkR1Z0QUU1dklHWnBiR1VnWkdWelkzSnBjSFJ2Y25NZ1lYWmhhV3hoWW14bEFFSmhaQ0JtYVd4bElHUmxjMk55YVhCMGIzSUFUbThnWTJocGJHUWdjSEp2WTJWemN3QkNZV1FnWVdSa2NtVnpjd0JHYVd4bElIUnZieUJzWVhKblpRQlViMjhnYldGdWVTQnNhVzVyY3dCT2J5QnNiMk5yY3lCaGRtRnBiR0ZpYkdVQVVtVnpiM1Z5WTJVZ1pHVmhaR3h2WTJzZ2QyOTFiR1FnYjJOamRYSUFVM1JoZEdVZ2JtOTBJSEpsWTI5MlpYSmhZbXhsQUZCeVpYWnBiM1Z6SUc5M2JtVnlJR1JwWldRQVQzQmxjbUYwYVc5dUlHTmhibU5sYkdWa0FFWjFibU4wYVc5dUlHNXZkQ0JwYlhCc1pXMWxiblJsWkFCT2J5QnRaWE56WVdkbElHOW1JR1JsYzJseVpXUWdkSGx3WlFCSlpHVnVkR2xtYVdWeUlISmxiVzkyWldRQVJHVjJhV05sSUc1dmRDQmhJSE4wY21WaGJRQk9ieUJrWVhSaElHRjJZV2xzWVdKc1pRQkVaWFpwWTJVZ2RHbHRaVzkxZEFCUGRYUWdiMllnYzNSeVpXRnRjeUJ5WlhOdmRYSmpaWE1BVEdsdWF5Qm9ZWE1nWW1WbGJpQnpaWFpsY21Wa0FGQnliM1J2WTI5c0lHVnljbTl5QUVKaFpDQnRaWE56WVdkbEFFWnBiR1VnWkdWelkzSnBjSFJ2Y2lCcGJpQmlZV1FnYzNSaGRHVUFUbTkwSUdFZ2MyOWphMlYwQUVSbGMzUnBibUYwYVc5dUlHRmtaSEpsYzNNZ2NtVnhkV2x5WldRQVRXVnpjMkZuWlNCMGIyOGdiR0Z5WjJVQVVISnZkRzlqYjJ3Z2QzSnZibWNnZEhsd1pTQm1iM0lnYzI5amEyVjBBRkJ5YjNSdlkyOXNJRzV2ZENCaGRtRnBiR0ZpYkdVQVVISnZkRzlqYjJ3Z2JtOTBJSE4xY0hCdmNuUmxaQUJUYjJOclpYUWdkSGx3WlNCdWIzUWdjM1Z3Y0c5eWRHVmtBRTV2ZENCemRYQndiM0owWldRQVVISnZkRzlqYjJ3Z1ptRnRhV3g1SUc1dmRDQnpkWEJ3YjNKMFpXUUFRV1JrY21WemN5Qm1ZVzFwYkhrZ2JtOTBJSE4xY0hCdmNuUmxaQ0JpZVNCd2NtOTBiMk52YkFCQlpHUnlaWE56SUc1dmRDQmhkbUZwYkdGaWJHVUFUbVYwZDI5eWF5QnBjeUJrYjNkdUFFNWxkSGR2Y21zZ2RXNXlaV0ZqYUdGaWJHVUFRMjl1Ym1WamRHbHZiaUJ5WlhObGRDQmllU0J1WlhSM2IzSnJBRU52Ym01bFkzUnBiMjRnWVdKdmNuUmxaQUJPYnlCaWRXWm1aWElnYzNCaFkyVWdZWFpoYVd4aFlteGxBRk52WTJ0bGRDQnBjeUJqYjI1dVpXTjBaV1FBVTI5amEyVjBJRzV2ZENCamIyNXVaV04wWldRQVEyRnVibTkwSUhObGJtUWdZV1owWlhJZ2MyOWphMlYwSUhOb2RYUmtiM2R1QUU5d1pYSmhkR2x2YmlCaGJISmxZV1I1SUdsdUlIQnliMmR5WlhOekFFOXdaWEpoZEdsdmJpQnBiaUJ3Y205bmNtVnpjd0JUZEdGc1pTQm1hV3hsSUdoaGJtUnNaUUJTWlcxdmRHVWdTUzlQSUdWeWNtOXlBRkYxYjNSaElHVjRZMlZsWkdWa0FFNXZJRzFsWkdsMWJTQm1iM1Z1WkFCWGNtOXVaeUJ0WldScGRXMGdkSGx3WlFCT2J5Qmxjbkp2Y2lCcGJtWnZjbTFoZEdsdmJnQUFZbUZ6YVdOZmMzUnlhVzVuQUhOMFpEbzZaWGhqWlhCMGFXOXVBQUFBQUFEY2NRQUFQQUFBQUQwQUFBQStBQUFBR0hRQUFPUnhBQUJUZERsbGVHTmxjSFJwYjI0QUFBQUFBQUFBQUFoeUFBQVFBQUFBUHdBQUFFQUFBQUNNY2dBQUZISUFBTnh4QUFCVGRERXhiRzluYVdOZlpYSnliM0lBQUFBQUFEaHlBQUFRQUFBQVFRQUFBRUFBQUFDTWNnQUFSSElBQUFoeUFBQlRkREV5YkdWdVozUm9YMlZ5Y205eUFGTjBPWFI1Y0dWZmFXNW1id0FBQUJoMEFBQlZjZ0FBakhJQUFBRnpBQUJrY2dBQWpISUFBS3h5QUFCc2NnQUFBQUFBQU5CeUFBQkNBQUFBUXdBQUFFUUFBQUJGQUFBQVJnQUFBRWNBQUFCSUFBQUFTUUFBQUU0eE1GOWZZM2g0WVdKcGRqRXhOMTlmWTJ4aGMzTmZkSGx3WlY5cGJtWnZSUUFBQUl4eUFBRGNjZ0FBZUhJQUFFNHhNRjlmWTNoNFlXSnBkakV5TUY5ZmMybGZZMnhoYzNOZmRIbHdaVjlwYm1adlJRQk9NVEJmWDJONGVHRmlhWFl4TVRaZlgzTm9hVzFmZEhsd1pWOXBibVp2UlFBQUFBQUFBQUJBY3dBQVFnQUFBRW9BQUFCRUFBQUFSUUFBQUVzQUFBQ01jZ0FBVEhNQUFHeHlBQUJPTVRCZlgyTjRlR0ZpYVhZeE1qTmZYMloxYm1SaGJXVnVkR0ZzWDNSNWNHVmZhVzVtYjBVQWRnQUFBQ3h6QUFCMGN3QUFZZ0FBQUN4ekFBQ0Fjd0FBWXdBQUFDeHpBQUNNY3dBQWFBQUFBQ3h6QUFDWWN3QUFZUUFBQUN4ekFBQ2tjd0FBY3dBQUFDeHpBQUN3Y3dBQWRBQUFBQ3h6QUFDOGN3QUFhUUFBQUN4ekFBREljd0FBYWdBQUFDeHpBQURVY3dBQWJBQUFBQ3h6QUFEZ2N3QUFiUUFBQUN4ekFBRHNjd0FBWmdBQUFDeHpBQUQ0Y3dBQVpBQUFBQ3h6QUFBRWRBQUFBQUFBQUhoeUFBQkNBQUFBVEFBQUFFUUFBQUJGQUFBQVJnQUFBRTBBQUFCT0FBQUFUd0FBQUFBQUFBQmdkQUFBUWdBQUFGQUFBQUJFQUFBQVJRQUFBRVlBQUFCUkFBQUFVZ0FBQUZNQUFBQ01jZ0FBYkhRQUFIaHlBQUJPTVRCZlgyTjRlR0ZpYVhZeE1qRmZYM1p0YVY5amJHRnpjMTkwZVhCbFgybHVabTlGQUFBQWNIVUFRWmpwQVF0QmdDMEFBQUF5QUFBQkFRQUFIZ0VBQUE4QUFBQ0FMQUFBQUMwQUFBQUFBQUFlQUFBQUR3QUFBQUFBQUFBd0xBQUFBQUFBQUJNQUFBQUhBQUFBQUFBQUFBVUFRZVRwQVFzQk9RQkIvT2tCQ3dvNkFBQUFPd0FBQUMxMkFFR1U2Z0VMQVFJQVFhUHFBUXNGLy8vLy8vOEFRZWpxQVFzSm9INVFBQUFBQUFBRkFFSDg2Z0VMQVZRQVFaVHJBUXNPT2dBQUFGVUFBQUNZZWdBQUFBUUFRYXpyQVFzQkFRQkJ1K3NCQ3dVSy8vLy8vdz09XCIpO1xuXG52YXIgX2E7XG52YXIgQmxvc2NTaHVmZmxlO1xuKGZ1bmN0aW9uKEJsb3NjU2h1ZmZsZTIpIHtcbiAgQmxvc2NTaHVmZmxlMltCbG9zY1NodWZmbGUyW1wiTk9TSFVGRkxFXCJdID0gMF0gPSBcIk5PU0hVRkZMRVwiO1xuICBCbG9zY1NodWZmbGUyW0Jsb3NjU2h1ZmZsZTJbXCJTSFVGRkxFXCJdID0gMV0gPSBcIlNIVUZGTEVcIjtcbiAgQmxvc2NTaHVmZmxlMltCbG9zY1NodWZmbGUyW1wiQklUU0hVRkZMRVwiXSA9IDJdID0gXCJCSVRTSFVGRkxFXCI7XG4gIEJsb3NjU2h1ZmZsZTJbQmxvc2NTaHVmZmxlMltcIkFVVE9TSFVGRkxFXCJdID0gLTFdID0gXCJBVVRPU0hVRkZMRVwiO1xufSkoQmxvc2NTaHVmZmxlIHx8IChCbG9zY1NodWZmbGUgPSB7fSkpO1xuY29uc3QgQ09NUFJFU1NPUlMgPSBuZXcgU2V0KFtcImJsb3NjbHpcIiwgXCJsejRcIiwgXCJsejRoY1wiLCBcInNuYXBweVwiLCBcInpsaWJcIiwgXCJ6c3RkXCJdKTtcbmxldCBlbXNjcmlwdGVuTW9kdWxlO1xuY29uc3QgaW5pdCA9ICgpID0+IGJsb3NjX2NvZGVjKHsgbm9Jbml0aWFsUnVuOiB0cnVlLCB3YXNtQmluYXJ5IH0pO1xuY29uc3QgQmxvc2MgPSAoX2EgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsZXZlbCA9IDUsIGNuYW1lID0gXCJsejRcIiwgc2h1ZmZsZSA9IDEsIGJsb2Nrc2l6ZSA9IDApIHtcbiAgICBpZiAoY2xldmVsIDwgMCB8fCBjbGV2ZWwgPiA5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29tcHJlc3Npb24gbGV2ZWw6ICcke2NsZXZlbH0nLiBJdCBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCA5YCk7XG4gICAgfVxuICAgIGlmICghQ09NUFJFU1NPUlMuaGFzKGNuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbXByZXNzb3IgJyR7Y25hbWV9Jy4gVmFsaWQgY29tcHJlc3NvcnMgaW5jbHVkZVxuICAgICAgICAnYmxvc2NseicsICdsejQnLCAnbHo0aGMnLCdzbmFwcHknLCAnemxpYicsICd6c3RkJy5gKTtcbiAgICB9XG4gICAgaWYgKHNodWZmbGUgPCAtMSB8fCBzaHVmZmxlID4gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNodWZmbGUgJHtzaHVmZmxlfS4gTXVzdCBiZSBvbmUgb2YgMCAoTk9TSFVGRkxFKSxcbiAgICAgICAgMSAoU0hVRkZMRSksIDIgKEJJVFNIVUZGTEUpLCAtMSAoQVVUT1NIVUZGTEUpLmApO1xuICAgIH1cbiAgICB0aGlzLmJsb2Nrc2l6ZSA9IGJsb2Nrc2l6ZTtcbiAgICB0aGlzLmNsZXZlbCA9IGNsZXZlbDtcbiAgICB0aGlzLmNuYW1lID0gY25hbWU7XG4gICAgdGhpcy5zaHVmZmxlID0gc2h1ZmZsZTtcbiAgfVxuICBzdGF0aWMgZnJvbUNvbmZpZyh7IGJsb2Nrc2l6ZSwgY2xldmVsLCBjbmFtZSwgc2h1ZmZsZSB9KSB7XG4gICAgcmV0dXJuIG5ldyBfYShjbGV2ZWwsIGNuYW1lLCBzaHVmZmxlLCBibG9ja3NpemUpO1xuICB9XG4gIGFzeW5jIGVuY29kZShkYXRhKSB7XG4gICAgaWYgKCFlbXNjcmlwdGVuTW9kdWxlKSB7XG4gICAgICBlbXNjcmlwdGVuTW9kdWxlID0gaW5pdCgpO1xuICAgIH1cbiAgICBjb25zdCBtb2R1bGUgPSBhd2FpdCBlbXNjcmlwdGVuTW9kdWxlO1xuICAgIGNvbnN0IHZpZXcgPSBtb2R1bGUuY29tcHJlc3MoZGF0YSwgdGhpcy5jbmFtZSwgdGhpcy5jbGV2ZWwsIHRoaXMuc2h1ZmZsZSwgdGhpcy5ibG9ja3NpemUpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHZpZXcpO1xuICAgIG1vZHVsZS5mcmVlX3Jlc3VsdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgZGVjb2RlKGRhdGEsIG91dCkge1xuICAgIGlmICghZW1zY3JpcHRlbk1vZHVsZSkge1xuICAgICAgZW1zY3JpcHRlbk1vZHVsZSA9IGluaXQoKTtcbiAgICB9XG4gICAgY29uc3QgbW9kdWxlID0gYXdhaXQgZW1zY3JpcHRlbk1vZHVsZTtcbiAgICBjb25zdCB2aWV3ID0gbW9kdWxlLmRlY29tcHJlc3MoZGF0YSk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkodmlldyk7XG4gICAgbW9kdWxlLmZyZWVfcmVzdWx0KCk7XG4gICAgaWYgKG91dCAhPT0gdm9pZCAwKSB7XG4gICAgICBvdXQuc2V0KHJlc3VsdCk7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59LCBfYS5jb2RlY0lkID0gXCJibG9zY1wiLCBfYS5DT01QUkVTU09SUyA9IFsuLi5DT01QUkVTU09SU10sIF9hLk5PU0hVRkZMRSA9IDAsIF9hLlNIVUZGTEUgPSAxLCBfYS5CSVRTSFVGRkxFID0gMiwgX2EuQVVUT1NIVUZGTEUgPSAtMSwgX2EpO1xuXG52YXIgQmxvc2MkMSA9IEJsb3NjO1xuXG5hZGRDb2RlYyhabGliJDEuY29kZWNJZCwgKCkgPT4gWmxpYiQxKTtcclxuYWRkQ29kZWMoR1ppcCQxLmNvZGVjSWQsICgpID0+IEdaaXAkMSk7XHJcbmFkZENvZGVjKEJsb3NjJDEuY29kZWNJZCwgKCkgPT4gQmxvc2MkMSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD16YXJyLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zarr/zarr.mjs\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./node_modules/@aics/volume-viewer/es/workers/FetchZarrWorker.js");
/******/ 	
/******/ })()
;